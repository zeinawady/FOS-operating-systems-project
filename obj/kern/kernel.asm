
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 30 18 00 	lgdtl  0x183018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 30 18 f0       	mov    $0xf0183000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 90 5d 74 f0 01 	movl   $0x1,0xf0745d90
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 e4 5c 74 f0 01 	movl   $0x1,0xf0745ce4
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba b0 8a 76 f0       	mov    $0xf0768ab0,%edx
f010006a:	b8 b8 ca 71 f0       	mov    $0xf071cab8,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 b8 ca 71 f0       	push   $0xf071cab8
f010007e:	e8 a6 20 02 00       	call   f0122129 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 40 40 12 f0       	push   $0xf0124040
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 87 40 12 f0       	push   $0xf0124087
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 9b 40 12 f0       	push   $0xf012409b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 af 40 12 f0       	push   $0xf01240af
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 17 77 00 00       	call   f01077f1 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 bb 40 12 f0       	push   $0xf01240bb
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 c3 40 12 f0       	push   $0xf01240c3
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 5d 80 00 00       	call   f010815f <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 fd 7b 00 00       	call   f0107d04 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 a3 83 00 00       	call   f01084af <initialize_paging>
		sharing_init();
f010010c:	e8 3b 90 00 00       	call   f010914c <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 41 99 00 00       	call   f0109a69 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		setPageReplacmentAlgorithmNchanceCLOCK();
f010012b:	e8 2c fb 00 00       	call   f010fc5c <setPageReplacmentAlgorithmNchanceCLOCK>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		//setPageReplacmentAlgorithmFIFO();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 e5 fb 00 00       	call   f010fd29 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 c0 fb 00 00       	call   f010fd11 <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 e0 fb 00 00       	call   f010fd41 <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 17 25 02 00       	call   f0122680 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 d1 40 12 f0       	push   $0xf01240d1
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 ad b1 00 00       	call   f010b32b <env_init>
		ts_init();
f010017e:	e8 1f d3 00 00       	call   f010d4a2 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 bb 40 12 f0       	push   $0xf01240bb
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 e4 40 12 f0       	push   $0xf01240e4
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 35 73 00 00       	call   f01074dd <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 0d 41 12 f0       	push   $0xf012410d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 0d 75 00 00       	call   f01076cf <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 23 41 12 f0       	push   $0xf0124123
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 f0 74 00 00       	call   f01076cf <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 40 41 12 f0       	push   $0xf0124140
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 d3 74 00 00       	call   f01076cf <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 5f 41 12 f0       	push   $0xf012415f
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 7c 41 12 f0       	push   $0xf012417c
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 e7 4b 00 00       	call   f0104e0b <kclock_init>
		sched_init() ;
f0100224:	e8 bb 68 00 00       	call   f0106ae4 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 a0 41 12 f0       	push   $0xf01241a0
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 30 18 f0       	mov    $0xf0183000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 c0 41 12 f0       	push   $0xf01241c0
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 e4 41 12 f0       	push   $0xf01241e4
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 c0 5f 74 f0 00 	movl   $0x0,0xf0745fc0
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 2c 42 12 f0       	push   $0xf012422c
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 58 42 12 f0       	push   $0xf0124258
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 7d 42 12 f0       	push   $0xf012427d
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 84 42 12 f0       	push   $0xf0124284
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 cc 42 12 f0       	push   $0xf01242cc
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 14 43 12 f0       	push   $0xf0124314
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 cc 42 12 f0       	push   $0xf01242cc
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 84 42 12 f0       	push   $0xf0124284
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 59 43 12 f0       	push   $0xf0124359
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 00 bc 00 00       	call   f010bf44 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 c0 ca 71 f0       	mov    %eax,0xf071cac0

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 60 43 12 f0       	push   $0xf0124360
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 85 43 12 f0       	push   $0xf0124385
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 5c bb 00 00       	call   f010bf02 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 87 43 12 f0       	push   $0xf0124387
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 c0 ca 71 f0       	mov    %eax,0xf071cac0

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 91 43 12 f0       	push   $0xf0124391
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 85 43 12 f0       	push   $0xf0124385
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 8d 74 00 00       	call   f01078aa <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 c5 73 00 00       	call   f01077e7 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 c6 74 00 00       	call   f01078fc <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 24 63 00 00       	call   f0106765 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 fe ba 00 00       	call   f010bf44 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 a3 ba 00 00       	call   f010bf02 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 c0 ca 71 f0       	mov    %eax,0xf071cac0

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 91 43 12 f0       	push   $0xf0124391
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 85 43 12 f0       	push   $0xf0124385
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 8c ba 00 00       	call   f010bf44 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 31 ba 00 00       	call   f010bf02 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 aa 43 12 f0       	push   $0xf01243aa
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 85 43 12 f0       	push   $0xf0124385
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 e4 ca 71 f0       	mov    0xf071cae4,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 c8 43 12 f0       	push   $0xf01243c8
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 e4 ca 71 f0       	mov    %eax,0xf071cae4
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 31 e1 00 00       	call   f010e7a6 <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 e8 ca 71 f0 b4 	movl   $0x3b4,0xf071cae8
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 e8 ca 71 f0 d4 	movl   $0x3d4,0xf071cae8
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 ec ca 71 f0       	mov    %eax,0xf071caec
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 ec ca 71 f0    	mov    0xf071caec,%edx
f010087a:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
		text_length = 0;
f01008a6:	c7 05 e0 ca 71 f0 00 	movl   $0x0,0xf071cae0
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d f0 ca 71 f0 	mov    0xf071caf0,%cx
f01008b7:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d ec ca 71 f0    	mov    0xf071caec,%ecx
f0100972:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 f0 ca 71 f0 	mov    %dx,0xf071caf0
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 e0 ca 71 f0    	mov    0xf071cae0,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 e0 ca 71 f0       	mov    0xf071cae0,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 e0 ca 71 f0       	mov    %eax,0xf071cae0
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 ec ca 71 f0       	mov    0xf071caec,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 ec ca 71 f0       	mov    0xf071caec,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 6e 17 02 00       	call   f0122159 <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 ec ca 71 f0    	mov    0xf071caec,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 f0 ca 71 f0    	mov    %ax,0xf071caf0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 e8 ca 71 f0    	mov    0xf071cae8,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 e8 ca 71 f0       	mov    0xf071cae8,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 e8 ca 71 f0    	mov    0xf071cae8,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 08 cd 71 f0       	mov    %eax,0xf071cd08
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 30 18 f0    	mov    -0xfe7cfe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 08 cd 71 f0       	mov    %eax,0xf071cd08
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 08 cd 71 f0       	mov    %eax,0xf071cd08
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 30 18 f0    	mov    -0xfe7cfe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 08 cd 71 f0       	mov    %eax,0xf071cd08
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 31 18 f0    	mov    -0xfe7cee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 08 cd 71 f0       	mov    %eax,0xf071cd08

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 35 18 f0 	mov    -0xfe7cae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 e0 ca 71 f0       	mov    0xf071cae0,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 e0 ca 71 f0    	mov    0xf071cae0,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 e0 ca 71 f0       	mov    0xf071cae0,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 e0 ca 71 f0       	mov    %eax,0xf071cae0
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 f0 ca 71 f0    	mov    0xf071caf0,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 ec ca 71 f0    	mov    0xf071caec,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 ec ca 71 f0       	mov    0xf071caec,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 e0 ca 71 f0       	mov    0xf071cae0,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 08 cd 71 f0       	mov    0xf071cd08,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 db 43 12 f0       	push   $0xf01243db
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 91 da 00 00       	call   f010e7a6 <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 04 cd 71 f0       	mov    0xf071cd04,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 04 cd 71 f0    	mov    %edx,0xf071cd04
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 00 cb 71 f0    	mov    %dl,-0xf8e3500(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 04 cd 71 f0       	mov    0xf071cd04,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 04 cd 71 f0 00 	movl   $0x0,0xf071cd04
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 00 cd 71 f0    	mov    0xf071cd00,%edx
f0100d7f:	a1 04 cd 71 f0       	mov    0xf071cd04,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 00 cd 71 f0       	mov    0xf071cd00,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 00 cd 71 f0    	mov    %edx,0xf071cd00
f0100d96:	8a 80 00 cb 71 f0    	mov    -0xf8e3500(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 00 cd 71 f0       	mov    0xf071cd00,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 00 cd 71 f0 00 	movl   $0x0,0xf071cd00
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 00 cd 71 f0    	mov    0xf071cd00,%edx
f0100dd0:	a1 04 cd 71 f0       	mov    0xf071cd04,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 00 cd 71 f0       	mov    0xf071cd00,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 00 cd 71 f0    	mov    %edx,0xf071cd00
f0100de7:	8a 80 00 cb 71 f0    	mov    -0xf8e3500(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 00 cd 71 f0       	mov    0xf071cd00,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 00 cd 71 f0 00 	movl   $0x0,0xf071cd00
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 e4 ca 71 f0       	mov    0xf071cae4,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 e7 43 12 f0       	push   $0xf01243e7
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 12 40 00 00       	call   f0104ecd <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 83 b0 00 00       	call   f010bf44 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 04 44 12 f0       	push   $0xf0124404
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 2b 44 12 f0       	push   $0xf012442b
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 cb 3f 00 00       	call   f0104ecd <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 3c b0 00 00       	call   f010bf44 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 40 44 12 f0       	push   $0xf0124440
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 2b 44 12 f0       	push   $0xf012442b
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 f6 08 02 00       	call   f0121879 <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 14 69 00 00       	call   f01078aa <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 46 69 00 00       	call   f01078fc <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 43 0f 02 00       	call   f0121f3b <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 a0 40 76 f0       	push   $0xf07640a0
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 46 11 02 00       	call   f0122159 <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 81 0e 02 00       	call   f0121f3b <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 a0 40 76 f0       	push   $0xf07640a0
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 84 10 02 00       	call   f0122159 <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 80 60 74 f0       	add    $0xf0746080,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 c1 0f 02 00       	call   f0122129 <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 6c 44 12 f0       	push   $0xf012446c
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 6f 44 12 f0       	push   $0xf012446f
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 80 60 74 f0       	push   $0xf0746080
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 66 0c 02 00       	call   f0121f3b <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 7b 0c 02 00       	call   f0121f8a <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 1e 0c 02 00       	call   f0121f3b <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 7f 44 12 f0       	push   $0xf012447f
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 f9 11 02 00       	call   f0122550 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 84 44 12 f0       	push   $0xf0124484
f010137e:	50                   	push   %eax
f010137f:	e8 c3 0c 02 00       	call   f0122047 <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 88 44 12 f0       	push   $0xf0124488
f0101399:	50                   	push   %eax
f010139a:	e8 a8 0c 02 00       	call   f0122047 <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 8d 44 12 f0       	push   $0xf012448d
f01013b4:	50                   	push   %eax
f01013b5:	e8 8d 0c 02 00       	call   f0122047 <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 8d 44 12 f0       	push   $0xf012448d
f01013d5:	50                   	push   %eax
f01013d6:	e8 6c 0c 02 00       	call   f0122047 <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 14 0b 02 00       	call   f0121f3b <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 16 0b 02 00       	call   f0121f8a <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 f5 0a 02 00       	call   f0121f8a <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 72 0a 02 00       	call   f0121f3b <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 8d 0b 02 00       	call   f012207f <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 35 18 f0       	add    $0xf0183540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 35 18 f0       	add    $0xf0183540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 c2 09 02 00       	call   f0121f3b <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 80 60 74 f0       	add    $0xf0746080,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 8d 0b 02 00       	call   f0122129 <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 80 60 74 f0    	add    $0xf0746080,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 f8 09 02 00       	call   f0121fb8 <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 90 39 18 f0       	mov    0xf0183990,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 38 09 02 00       	call   f0121f3b <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d 68 3d 18 f0    	mov    0xf0183d68,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 50 0a 02 00       	call   f012207f <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 9b 08 02 00       	call   f0121f3b <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d 68 3d 18 f0    	mov    0xf0183d68,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d 68 3d 18 f0    	mov    0xf0183d68,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 3b 08 02 00       	call   f0121f3b <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 80 60 74 f0       	add    $0xf0746080,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 06 0a 02 00       	call   f0122129 <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 80 60 74 f0    	add    $0xf0746080,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 71 08 02 00       	call   f0121fb8 <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 b3 07 02 00       	call   f0121f3b <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 80 3d 18 f0       	add    $0xf0183d80,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 ce 08 02 00       	call   f012207f <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 19 07 02 00       	call   f0121f3b <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 80 3d 18 f0       	add    $0xf0183d80,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 80 3d 18 f0       	add    $0xf0183d80,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 bf 06 02 00       	call   f0121f3b <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 80 60 74 f0       	add    $0xf0746080,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 8a 08 02 00       	call   f0122129 <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 80 60 74 f0    	add    $0xf0746080,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 f5 06 02 00       	call   f0121fb8 <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 34 3e 18 f0       	mov    0xf0183e34,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 80 60 74 f0       	add    $0xf0746080,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 80 60 74 f0       	push   $0xf0746080
f0101929:	e8 0d 06 02 00       	call   f0121f3b <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 b4 05 02 00       	call   f0121f3b <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 a1 05 02 00       	call   f0121f3b <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 80 60 74 f0    	lea    -0xf8b9f80(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 80 60 74 f0       	add    $0xf0746080,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 46 05 02 00       	call   f0121f3b <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 80 f0 75 f0    	lea    -0xf8a0f80(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 3b 05 02 00       	call   f0122159 <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 80 3c 76 f0       	push   $0xf0763c80
f0101c3a:	e8 1a 05 02 00       	call   f0122159 <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 ea 03 02 00       	call   f0122047 <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 35 18 f0       	mov    %eax,0xf0183530
f0101c6f:	a1 30 35 18 f0       	mov    0xf0183530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 80 f0 75 f0       	add    $0xf075f080,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 cc 04 02 00       	call   f0122159 <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 c0 5f 74 f0       	mov    0xf0745fc0,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 97 44 12 f0       	mov    $0xf0124497,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 97 48 12 f0       	mov    $0xf0124897,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 97 4c 12 f0       	mov    $0xf0124c97,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 c0 5f 74 f0 00 	movl   $0x0,0xf0745fc0
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 4c 5f 74 f0 00 	movl   $0x0,0xf0745f4c
f0101d59:	00 00 00 
f0101d5c:	c7 05 50 5f 74 f0 00 	movl   $0x0,0xf0745f50
f0101d63:	00 00 00 
f0101d66:	c7 05 58 5f 74 f0 00 	movl   $0x0,0xf0745f58
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 a3 03 02 00       	call   f0122129 <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 91 44 12 f0       	push   $0xf0124491
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 eb a3 00 00       	call   f010c1ca <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 03 5a 00 00       	call   f01077e7 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 60 60 74 f0       	mov    %eax,0xf0746060
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 80 40 76 f0       	mov    %eax,0xf0764080
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 60 60 74 f0       	mov    0xf0746060,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 60 60 74 f0    	mov    %edx,0xf0746060
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 80 40 76 f0       	mov    0xf0764080,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 80 40 76 f0       	mov    %eax,0xf0764080
f0101e98:	a1 80 40 76 f0       	mov    0xf0764080,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 60 60 74 f0       	mov    %eax,0xf0746060
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 80 40 76 f0       	mov    %eax,0xf0764080
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 60 60 74 f0       	mov    0xf0746060,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 60 60 74 f0    	mov    %edx,0xf0746060
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 80 40 76 f0       	mov    0xf0764080,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 80 40 76 f0       	mov    %eax,0xf0764080
f0101ed4:	a1 80 40 76 f0       	mov    0xf0764080,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 7f 44 12 f0       	push   $0xf012447f
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 3a 06 02 00       	call   f0122550 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 97 50 12 f0       	push   $0xf0125097
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 58 5f 74 f0       	mov    0xf0745f58,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 b0 50 12 f0       	push   $0xf01250b0
f0101f7b:	68 8b 01 00 00       	push   $0x18b
f0101f80:	68 01 51 12 f0       	push   $0xf0125101
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 1c 51 12 f0       	push   $0xf012511c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 58 5f 74 f0       	mov    0xf0745f58,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 4c 51 12 f0       	push   $0xf012514c
f0101fdb:	68 96 01 00 00       	push   $0x196
f0101fe0:	68 01 51 12 f0       	push   $0xf0125101
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 76 51 12 f0       	push   $0xf0125176
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 54 5f 74 f0       	mov    %eax,0xf0745f54
f010203b:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 80 51 12 f0       	push   $0xf0125180
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 e3 51 12 f0       	push   $0xf01251e3
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 ec 51 12 f0       	push   $0xf01251ec
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 54 5f 74 f0       	mov    %eax,0xf0745f54
f010218b:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 35 18 f0       	add    $0xf0183548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	//make the foundCommands list empty
	LIST_INIT(&foundCommands);
f01021d6:	c7 05 4c 5f 74 f0 00 	movl   $0x0,0xf0745f4c
f01021dd:	00 00 00 
f01021e0:	c7 05 50 5f 74 f0 00 	movl   $0x0,0xf0745f50
f01021e7:	00 00 00 
f01021ea:	c7 05 58 5f 74 f0 00 	movl   $0x0,0xf0745f58
f01021f1:	00 00 00 

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01021fb:	e9 11 01 00 00       	jmp    f0102311 <process_command+0x141>
	{
		//when commands names are equal
	    if (strcmp(arguments[0], commands[i].name) == 0)
f0102200:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102203:	89 d0                	mov    %edx,%eax
f0102205:	01 c0                	add    %eax,%eax
f0102207:	01 d0                	add    %edx,%eax
f0102209:	c1 e0 03             	shl    $0x3,%eax
f010220c:	05 40 35 18 f0       	add    $0xf0183540,%eax
f0102211:	8b 10                	mov    (%eax),%edx
f0102213:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102216:	8b 00                	mov    (%eax),%eax
f0102218:	83 ec 08             	sub    $0x8,%esp
f010221b:	52                   	push   %edx
f010221c:	50                   	push   %eax
f010221d:	e8 25 fe 01 00       	call   f0122047 <strcmp>
f0102222:	83 c4 10             	add    $0x10,%esp
f0102225:	85 c0                	test   %eax,%eax
f0102227:	0f 85 e1 00 00 00    	jne    f010230e <process_command+0x13e>
	    {
	        if (commands[i].num_of_args == -1 || (number_of_arguments - 1) == commands[i].num_of_args) {
f010222d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102230:	89 d0                	mov    %edx,%eax
f0102232:	01 c0                	add    %eax,%eax
f0102234:	01 d0                	add    %edx,%eax
f0102236:	c1 e0 03             	shl    $0x3,%eax
f0102239:	05 4c 35 18 f0       	add    $0xf018354c,%eax
f010223e:	8b 00                	mov    (%eax),%eax
f0102240:	83 f8 ff             	cmp    $0xffffffff,%eax
f0102243:	74 1d                	je     f0102262 <process_command+0x92>
f0102245:	8b 45 08             	mov    0x8(%ebp),%eax
f0102248:	8d 48 ff             	lea    -0x1(%eax),%ecx
f010224b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010224e:	89 d0                	mov    %edx,%eax
f0102250:	01 c0                	add    %eax,%eax
f0102252:	01 d0                	add    %edx,%eax
f0102254:	c1 e0 03             	shl    $0x3,%eax
f0102257:	05 4c 35 18 f0       	add    $0xf018354c,%eax
f010225c:	8b 00                	mov    (%eax),%eax
f010225e:	39 c1                	cmp    %eax,%ecx
f0102260:	75 08                	jne    f010226a <process_command+0x9a>
	            return i;
f0102262:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102265:	e9 bd 01 00 00       	jmp    f0102427 <process_command+0x257>
	        } else {
	            LIST_INSERT_HEAD(&foundCommands, &commands[i]);
f010226a:	8b 15 4c 5f 74 f0    	mov    0xf0745f4c,%edx
f0102270:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102273:	89 c8                	mov    %ecx,%eax
f0102275:	01 c0                	add    %eax,%eax
f0102277:	01 c8                	add    %ecx,%eax
f0102279:	c1 e0 03             	shl    $0x3,%eax
f010227c:	05 50 35 18 f0       	add    $0xf0183550,%eax
f0102281:	89 10                	mov    %edx,(%eax)
f0102283:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102286:	89 d0                	mov    %edx,%eax
f0102288:	01 c0                	add    %eax,%eax
f010228a:	01 d0                	add    %edx,%eax
f010228c:	c1 e0 03             	shl    $0x3,%eax
f010228f:	05 50 35 18 f0       	add    $0xf0183550,%eax
f0102294:	8b 00                	mov    (%eax),%eax
f0102296:	85 c0                	test   %eax,%eax
f0102298:	74 1c                	je     f01022b6 <process_command+0xe6>
f010229a:	8b 15 4c 5f 74 f0    	mov    0xf0745f4c,%edx
f01022a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01022a3:	89 c8                	mov    %ecx,%eax
f01022a5:	01 c0                	add    %eax,%eax
f01022a7:	01 c8                	add    %ecx,%eax
f01022a9:	c1 e0 03             	shl    $0x3,%eax
f01022ac:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01022b1:	89 42 14             	mov    %eax,0x14(%edx)
f01022b4:	eb 16                	jmp    f01022cc <process_command+0xfc>
f01022b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01022b9:	89 d0                	mov    %edx,%eax
f01022bb:	01 c0                	add    %eax,%eax
f01022bd:	01 d0                	add    %edx,%eax
f01022bf:	c1 e0 03             	shl    $0x3,%eax
f01022c2:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01022c7:	a3 50 5f 74 f0       	mov    %eax,0xf0745f50
f01022cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01022cf:	89 d0                	mov    %edx,%eax
f01022d1:	01 c0                	add    %eax,%eax
f01022d3:	01 d0                	add    %edx,%eax
f01022d5:	c1 e0 03             	shl    $0x3,%eax
f01022d8:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01022dd:	a3 4c 5f 74 f0       	mov    %eax,0xf0745f4c
f01022e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01022e5:	89 d0                	mov    %edx,%eax
f01022e7:	01 c0                	add    %eax,%eax
f01022e9:	01 d0                	add    %edx,%eax
f01022eb:	c1 e0 03             	shl    $0x3,%eax
f01022ee:	05 54 35 18 f0       	add    $0xf0183554,%eax
f01022f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01022f9:	a1 58 5f 74 f0       	mov    0xf0745f58,%eax
f01022fe:	40                   	inc    %eax
f01022ff:	a3 58 5f 74 f0       	mov    %eax,0xf0745f58
	            return CMD_INV_NUM_ARGS;
f0102304:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f0102309:	e9 19 01 00 00       	jmp    f0102427 <process_command+0x257>
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	//make the foundCommands list empty
	LIST_INIT(&foundCommands);

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f010230e:	ff 45 f4             	incl   -0xc(%ebp)
f0102311:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102314:	a1 90 39 18 f0       	mov    0xf0183990,%eax
f0102319:	39 c2                	cmp    %eax,%edx
f010231b:	0f 82 df fe ff ff    	jb     f0102200 <process_command+0x30>
	            LIST_INSERT_HEAD(&foundCommands, &commands[i]);
	            return CMD_INV_NUM_ARGS;
	        }
	    }
	}
	bool found=0;
f0102321:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

		for (int i = 0; i < NUM_OF_COMMANDS; i++)
f0102328:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010232f:	e9 d1 00 00 00       	jmp    f0102405 <process_command+0x235>
			{
			    if (subsequence(arguments[0], commands[i].name)) {
f0102334:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102337:	89 d0                	mov    %edx,%eax
f0102339:	01 c0                	add    %eax,%eax
f010233b:	01 d0                	add    %edx,%eax
f010233d:	c1 e0 03             	shl    $0x3,%eax
f0102340:	05 40 35 18 f0       	add    $0xf0183540,%eax
f0102345:	8b 10                	mov    (%eax),%edx
f0102347:	8b 45 0c             	mov    0xc(%ebp),%eax
f010234a:	8b 00                	mov    (%eax),%eax
f010234c:	83 ec 08             	sub    $0x8,%esp
f010234f:	52                   	push   %edx
f0102350:	50                   	push   %eax
f0102351:	e8 d3 00 00 00       	call   f0102429 <subsequence>
f0102356:	83 c4 10             	add    $0x10,%esp
f0102359:	85 c0                	test   %eax,%eax
f010235b:	0f 84 a1 00 00 00    	je     f0102402 <process_command+0x232>
			        LIST_INSERT_HEAD(&foundCommands, &commands[i]);
f0102361:	8b 15 4c 5f 74 f0    	mov    0xf0745f4c,%edx
f0102367:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010236a:	89 c8                	mov    %ecx,%eax
f010236c:	01 c0                	add    %eax,%eax
f010236e:	01 c8                	add    %ecx,%eax
f0102370:	c1 e0 03             	shl    $0x3,%eax
f0102373:	05 50 35 18 f0       	add    $0xf0183550,%eax
f0102378:	89 10                	mov    %edx,(%eax)
f010237a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010237d:	89 d0                	mov    %edx,%eax
f010237f:	01 c0                	add    %eax,%eax
f0102381:	01 d0                	add    %edx,%eax
f0102383:	c1 e0 03             	shl    $0x3,%eax
f0102386:	05 50 35 18 f0       	add    $0xf0183550,%eax
f010238b:	8b 00                	mov    (%eax),%eax
f010238d:	85 c0                	test   %eax,%eax
f010238f:	74 1c                	je     f01023ad <process_command+0x1dd>
f0102391:	8b 15 4c 5f 74 f0    	mov    0xf0745f4c,%edx
f0102397:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010239a:	89 c8                	mov    %ecx,%eax
f010239c:	01 c0                	add    %eax,%eax
f010239e:	01 c8                	add    %ecx,%eax
f01023a0:	c1 e0 03             	shl    $0x3,%eax
f01023a3:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01023a8:	89 42 14             	mov    %eax,0x14(%edx)
f01023ab:	eb 16                	jmp    f01023c3 <process_command+0x1f3>
f01023ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023b0:	89 d0                	mov    %edx,%eax
f01023b2:	01 c0                	add    %eax,%eax
f01023b4:	01 d0                	add    %edx,%eax
f01023b6:	c1 e0 03             	shl    $0x3,%eax
f01023b9:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01023be:	a3 50 5f 74 f0       	mov    %eax,0xf0745f50
f01023c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023c6:	89 d0                	mov    %edx,%eax
f01023c8:	01 c0                	add    %eax,%eax
f01023ca:	01 d0                	add    %edx,%eax
f01023cc:	c1 e0 03             	shl    $0x3,%eax
f01023cf:	05 40 35 18 f0       	add    $0xf0183540,%eax
f01023d4:	a3 4c 5f 74 f0       	mov    %eax,0xf0745f4c
f01023d9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023dc:	89 d0                	mov    %edx,%eax
f01023de:	01 c0                	add    %eax,%eax
f01023e0:	01 d0                	add    %edx,%eax
f01023e2:	c1 e0 03             	shl    $0x3,%eax
f01023e5:	05 54 35 18 f0       	add    $0xf0183554,%eax
f01023ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01023f0:	a1 58 5f 74 f0       	mov    0xf0745f58,%eax
f01023f5:	40                   	inc    %eax
f01023f6:	a3 58 5f 74 f0       	mov    %eax,0xf0745f58
			        found=1;
f01023fb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	        }
	    }
	}
	bool found=0;

		for (int i = 0; i < NUM_OF_COMMANDS; i++)
f0102402:	ff 45 ec             	incl   -0x14(%ebp)
f0102405:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102408:	a1 90 39 18 f0       	mov    0xf0183990,%eax
f010240d:	39 c2                	cmp    %eax,%edx
f010240f:	0f 82 1f ff ff ff    	jb     f0102334 <process_command+0x164>
			        LIST_INSERT_HEAD(&foundCommands, &commands[i]);
			        found=1;
			    }

			}
                 if(found){
f0102415:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102419:	74 07                	je     f0102422 <process_command+0x252>
                	 return CMD_MATCHED;
f010241b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0102420:	eb 05                	jmp    f0102427 <process_command+0x257>
                 }

	return CMD_INVALID;
f0102422:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102427:	c9                   	leave  
f0102428:	c3                   	ret    

f0102429 <subsequence>:


int subsequence(char *commandInput, char *commandName){
f0102429:	55                   	push   %ebp
f010242a:	89 e5                	mov    %esp,%ebp

	//while the string does not end
	while(*commandName !='\0'){
f010242c:	eb 24                	jmp    f0102452 <subsequence+0x29>
		//clk command input
		//clock command name (original)
		if(*commandInput== *commandName){
f010242e:	8b 45 08             	mov    0x8(%ebp),%eax
f0102431:	8a 10                	mov    (%eax),%dl
f0102433:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102436:	8a 00                	mov    (%eax),%al
f0102438:	38 c2                	cmp    %al,%dl
f010243a:	75 03                	jne    f010243f <subsequence+0x16>
			commandInput++;
f010243c:	ff 45 08             	incl   0x8(%ebp)
		}
		commandName++;
f010243f:	ff 45 0c             	incl   0xc(%ebp)
		if(*commandInput=='\0'){
f0102442:	8b 45 08             	mov    0x8(%ebp),%eax
f0102445:	8a 00                	mov    (%eax),%al
f0102447:	84 c0                	test   %al,%al
f0102449:	75 07                	jne    f0102452 <subsequence+0x29>
			return 1;
f010244b:	b8 01 00 00 00       	mov    $0x1,%eax
f0102450:	eb 0e                	jmp    f0102460 <subsequence+0x37>


int subsequence(char *commandInput, char *commandName){

	//while the string does not end
	while(*commandName !='\0'){
f0102452:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102455:	8a 00                	mov    (%eax),%al
f0102457:	84 c0                	test   %al,%al
f0102459:	75 d3                	jne    f010242e <subsequence+0x5>
		commandName++;
		if(*commandInput=='\0'){
			return 1;
		}
	}
	return 0;
f010245b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102460:	5d                   	pop    %ebp
f0102461:	c3                   	ret    

f0102462 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f0102462:	55                   	push   %ebp
f0102463:	89 e5                	mov    %esp,%ebp
f0102465:	c7 05 90 5d 74 f0 00 	movl   $0x0,0xf0745d90
f010246c:	00 00 00 
f010246f:	90                   	nop
f0102470:	5d                   	pop    %ebp
f0102471:	c3                   	ret    

f0102472 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102472:	55                   	push   %ebp
f0102473:	89 e5                	mov    %esp,%ebp
f0102475:	c7 05 90 5d 74 f0 01 	movl   $0x1,0xf0745d90
f010247c:	00 00 00 
f010247f:	90                   	nop
f0102480:	5d                   	pop    %ebp
f0102481:	c3                   	ret    

f0102482 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102482:	55                   	push   %ebp
f0102483:	89 e5                	mov    %esp,%ebp
f0102485:	c7 05 90 5d 74 f0 02 	movl   $0x2,0xf0745d90
f010248c:	00 00 00 
f010248f:	90                   	nop
f0102490:	5d                   	pop    %ebp
f0102491:	c3                   	ret    

f0102492 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102492:	55                   	push   %ebp
f0102493:	89 e5                	mov    %esp,%ebp
f0102495:	c7 05 90 5d 74 f0 03 	movl   $0x3,0xf0745d90
f010249c:	00 00 00 
f010249f:	90                   	nop
f01024a0:	5d                   	pop    %ebp
f01024a1:	c3                   	ret    

f01024a2 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f01024a2:	55                   	push   %ebp
f01024a3:	89 e5                	mov    %esp,%ebp
f01024a5:	c7 05 90 5d 74 f0 04 	movl   $0x4,0xf0745d90
f01024ac:	00 00 00 
f01024af:	90                   	nop
f01024b0:	5d                   	pop    %ebp
f01024b1:	c3                   	ret    

f01024b2 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f01024b2:	55                   	push   %ebp
f01024b3:	89 e5                	mov    %esp,%ebp
f01024b5:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f01024ba:	85 c0                	test   %eax,%eax
f01024bc:	75 04                	jne    f01024c2 <isKHeapPlacementStrategyCONTALLOC+0x10>
f01024be:	b0 01                	mov    $0x1,%al
f01024c0:	eb 02                	jmp    f01024c4 <isKHeapPlacementStrategyCONTALLOC+0x12>
f01024c2:	b0 00                	mov    $0x0,%al
f01024c4:	5d                   	pop    %ebp
f01024c5:	c3                   	ret    

f01024c6 <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01024c6:	55                   	push   %ebp
f01024c7:	89 e5                	mov    %esp,%ebp
f01024c9:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f01024ce:	83 f8 01             	cmp    $0x1,%eax
f01024d1:	75 04                	jne    f01024d7 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01024d3:	b0 01                	mov    $0x1,%al
f01024d5:	eb 02                	jmp    f01024d9 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01024d7:	b0 00                	mov    $0x0,%al
f01024d9:	5d                   	pop    %ebp
f01024da:	c3                   	ret    

f01024db <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f01024db:	55                   	push   %ebp
f01024dc:	89 e5                	mov    %esp,%ebp
f01024de:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f01024e3:	83 f8 02             	cmp    $0x2,%eax
f01024e6:	75 04                	jne    f01024ec <isKHeapPlacementStrategyBESTFIT+0x11>
f01024e8:	b0 01                	mov    $0x1,%al
f01024ea:	eb 02                	jmp    f01024ee <isKHeapPlacementStrategyBESTFIT+0x13>
f01024ec:	b0 00                	mov    $0x0,%al
f01024ee:	5d                   	pop    %ebp
f01024ef:	c3                   	ret    

f01024f0 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01024f0:	55                   	push   %ebp
f01024f1:	89 e5                	mov    %esp,%ebp
f01024f3:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f01024f8:	83 f8 03             	cmp    $0x3,%eax
f01024fb:	75 04                	jne    f0102501 <isKHeapPlacementStrategyNEXTFIT+0x11>
f01024fd:	b0 01                	mov    $0x1,%al
f01024ff:	eb 02                	jmp    f0102503 <isKHeapPlacementStrategyNEXTFIT+0x13>
f0102501:	b0 00                	mov    $0x0,%al
f0102503:	5d                   	pop    %ebp
f0102504:	c3                   	ret    

f0102505 <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f0102505:	55                   	push   %ebp
f0102506:	89 e5                	mov    %esp,%ebp
f0102508:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f010250d:	83 f8 04             	cmp    $0x4,%eax
f0102510:	75 04                	jne    f0102516 <isKHeapPlacementStrategyWORSTFIT+0x11>
f0102512:	b0 01                	mov    $0x1,%al
f0102514:	eb 02                	jmp    f0102518 <isKHeapPlacementStrategyWORSTFIT+0x13>
f0102516:	b0 00                	mov    $0x0,%al
f0102518:	5d                   	pop    %ebp
f0102519:	c3                   	ret    

f010251a <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010251a:	55                   	push   %ebp
f010251b:	89 e5                	mov    %esp,%ebp
f010251d:	c7 05 e4 5c 74 f0 01 	movl   $0x1,0xf0745ce4
f0102524:	00 00 00 
f0102527:	90                   	nop
f0102528:	5d                   	pop    %ebp
f0102529:	c3                   	ret    

f010252a <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f010252a:	55                   	push   %ebp
f010252b:	89 e5                	mov    %esp,%ebp
f010252d:	c7 05 e4 5c 74 f0 02 	movl   $0x2,0xf0745ce4
f0102534:	00 00 00 
f0102537:	90                   	nop
f0102538:	5d                   	pop    %ebp
f0102539:	c3                   	ret    

f010253a <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f010253a:	55                   	push   %ebp
f010253b:	89 e5                	mov    %esp,%ebp
f010253d:	c7 05 e4 5c 74 f0 03 	movl   $0x3,0xf0745ce4
f0102544:	00 00 00 
f0102547:	90                   	nop
f0102548:	5d                   	pop    %ebp
f0102549:	c3                   	ret    

f010254a <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f010254a:	55                   	push   %ebp
f010254b:	89 e5                	mov    %esp,%ebp
f010254d:	c7 05 e4 5c 74 f0 04 	movl   $0x4,0xf0745ce4
f0102554:	00 00 00 
f0102557:	90                   	nop
f0102558:	5d                   	pop    %ebp
f0102559:	c3                   	ret    

f010255a <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f010255a:	55                   	push   %ebp
f010255b:	89 e5                	mov    %esp,%ebp
f010255d:	a1 e4 5c 74 f0       	mov    0xf0745ce4,%eax
f0102562:	83 f8 01             	cmp    $0x1,%eax
f0102565:	75 04                	jne    f010256b <isUHeapPlacementStrategyFIRSTFIT+0x11>
f0102567:	b0 01                	mov    $0x1,%al
f0102569:	eb 02                	jmp    f010256d <isUHeapPlacementStrategyFIRSTFIT+0x13>
f010256b:	b0 00                	mov    $0x0,%al
f010256d:	5d                   	pop    %ebp
f010256e:	c3                   	ret    

f010256f <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f010256f:	55                   	push   %ebp
f0102570:	89 e5                	mov    %esp,%ebp
f0102572:	a1 e4 5c 74 f0       	mov    0xf0745ce4,%eax
f0102577:	83 f8 02             	cmp    $0x2,%eax
f010257a:	75 04                	jne    f0102580 <isUHeapPlacementStrategyBESTFIT+0x11>
f010257c:	b0 01                	mov    $0x1,%al
f010257e:	eb 02                	jmp    f0102582 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102580:	b0 00                	mov    $0x0,%al
f0102582:	5d                   	pop    %ebp
f0102583:	c3                   	ret    

f0102584 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102584:	55                   	push   %ebp
f0102585:	89 e5                	mov    %esp,%ebp
f0102587:	a1 e4 5c 74 f0       	mov    0xf0745ce4,%eax
f010258c:	83 f8 03             	cmp    $0x3,%eax
f010258f:	75 04                	jne    f0102595 <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102591:	b0 01                	mov    $0x1,%al
f0102593:	eb 02                	jmp    f0102597 <isUHeapPlacementStrategyNEXTFIT+0x13>
f0102595:	b0 00                	mov    $0x0,%al
f0102597:	5d                   	pop    %ebp
f0102598:	c3                   	ret    

f0102599 <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f0102599:	55                   	push   %ebp
f010259a:	89 e5                	mov    %esp,%ebp
f010259c:	a1 e4 5c 74 f0       	mov    0xf0745ce4,%eax
f01025a1:	83 f8 04             	cmp    $0x4,%eax
f01025a4:	75 04                	jne    f01025aa <isUHeapPlacementStrategyWORSTFIT+0x11>
f01025a6:	b0 01                	mov    $0x1,%al
f01025a8:	eb 02                	jmp    f01025ac <isUHeapPlacementStrategyWORSTFIT+0x13>
f01025aa:	b0 00                	mov    $0x0,%al
f01025ac:	5d                   	pop    %ebp
f01025ad:	c3                   	ret    

f01025ae <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f01025ae:	55                   	push   %ebp
f01025af:	89 e5                	mov    %esp,%ebp
f01025b1:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01025b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01025b7:	c1 e8 0c             	shr    $0xc,%eax
f01025ba:	89 c2                	mov    %eax,%edx
f01025bc:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f01025c1:	39 c2                	cmp    %eax,%edx
f01025c3:	72 14                	jb     f01025d9 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01025c5:	83 ec 04             	sub    $0x4,%esp
f01025c8:	68 f4 51 12 f0       	push   $0xf01251f4
f01025cd:	6a 55                	push   $0x55
f01025cf:	68 1c 52 12 f0       	push   $0xf012521c
f01025d4:	e8 60 dd ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f01025d9:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f01025df:	8b 45 08             	mov    0x8(%ebp),%eax
f01025e2:	c1 e8 0c             	shr    $0xc,%eax
f01025e5:	89 c1                	mov    %eax,%ecx
f01025e7:	89 c8                	mov    %ecx,%eax
f01025e9:	c1 e0 02             	shl    $0x2,%eax
f01025ec:	01 c8                	add    %ecx,%eax
f01025ee:	c1 e0 03             	shl    $0x3,%eax
f01025f1:	01 d0                	add    %edx,%eax
}
f01025f3:	c9                   	leave  
f01025f4:	c3                   	ret    

f01025f5 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f01025f5:	55                   	push   %ebp
f01025f6:	89 e5                	mov    %esp,%ebp
f01025f8:	53                   	push   %ebx
f01025f9:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01025fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102603:	eb 3b                	jmp    f0102640 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102605:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102608:	89 d0                	mov    %edx,%eax
f010260a:	01 c0                	add    %eax,%eax
f010260c:	01 d0                	add    %edx,%eax
f010260e:	c1 e0 03             	shl    $0x3,%eax
f0102611:	05 44 35 18 f0       	add    $0xf0183544,%eax
f0102616:	8b 10                	mov    (%eax),%edx
f0102618:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010261b:	89 c8                	mov    %ecx,%eax
f010261d:	01 c0                	add    %eax,%eax
f010261f:	01 c8                	add    %ecx,%eax
f0102621:	c1 e0 03             	shl    $0x3,%eax
f0102624:	05 40 35 18 f0       	add    $0xf0183540,%eax
f0102629:	8b 00                	mov    (%eax),%eax
f010262b:	83 ec 04             	sub    $0x4,%esp
f010262e:	52                   	push   %edx
f010262f:	50                   	push   %eax
f0102630:	68 cb 5b 12 f0       	push   $0xf0125bcb
f0102635:	e8 51 e9 ff ff       	call   f0100f8b <cprintf>
f010263a:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f010263d:	ff 45 f4             	incl   -0xc(%ebp)
f0102640:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102643:	a1 90 39 18 f0       	mov    0xf0183990,%eax
f0102648:	39 c2                	cmp    %eax,%edx
f010264a:	72 b9                	jb     f0102605 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f010264c:	83 ec 0c             	sub    $0xc,%esp
f010264f:	68 d4 5b 12 f0       	push   $0xf0125bd4
f0102654:	e8 32 e9 ff ff       	call   f0100f8b <cprintf>
f0102659:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f010265c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102663:	eb 42                	jmp    f01026a7 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102665:	8b 0d 68 3d 18 f0    	mov    0xf0183d68,%ecx
f010266b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010266e:	89 d0                	mov    %edx,%eax
f0102670:	01 c0                	add    %eax,%eax
f0102672:	01 d0                	add    %edx,%eax
f0102674:	c1 e0 02             	shl    $0x2,%eax
f0102677:	01 c8                	add    %ecx,%eax
f0102679:	8b 50 04             	mov    0x4(%eax),%edx
f010267c:	8b 1d 68 3d 18 f0    	mov    0xf0183d68,%ebx
f0102682:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102685:	89 c8                	mov    %ecx,%eax
f0102687:	01 c0                	add    %eax,%eax
f0102689:	01 c8                	add    %ecx,%eax
f010268b:	c1 e0 02             	shl    $0x2,%eax
f010268e:	01 d8                	add    %ebx,%eax
f0102690:	8b 00                	mov    (%eax),%eax
f0102692:	83 ec 04             	sub    $0x4,%esp
f0102695:	52                   	push   %edx
f0102696:	50                   	push   %eax
f0102697:	68 e9 5b 12 f0       	push   $0xf0125be9
f010269c:	e8 ea e8 ff ff       	call   f0100f8b <cprintf>
f01026a1:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f01026a4:	ff 45 f4             	incl   -0xc(%ebp)
f01026a7:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f01026ac:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01026af:	7c b4                	jl     f0102665 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f01026b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01026b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01026b9:	c9                   	leave  
f01026ba:	c3                   	ret    

f01026bb <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f01026bb:	55                   	push   %ebp
f01026bc:	89 e5                	mov    %esp,%ebp
f01026be:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f01026c1:	83 ec 0c             	sub    $0xc,%esp
f01026c4:	68 05 5c 12 f0       	push   $0xf0125c05
f01026c9:	e8 bd e8 ff ff       	call   f0100f8b <cprintf>
f01026ce:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f01026d1:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f01026d6:	83 ec 04             	sub    $0x4,%esp
f01026d9:	50                   	push   %eax
f01026da:	68 0c 00 10 f0       	push   $0xf010000c
f01026df:	68 20 5c 12 f0       	push   $0xf0125c20
f01026e4:	e8 a2 e8 ff ff       	call   f0100f8b <cprintf>
f01026e9:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f01026ec:	b8 31 40 12 00       	mov    $0x124031,%eax
f01026f1:	83 ec 04             	sub    $0x4,%esp
f01026f4:	50                   	push   %eax
f01026f5:	68 31 40 12 f0       	push   $0xf0124031
f01026fa:	68 5c 5c 12 f0       	push   $0xf0125c5c
f01026ff:	e8 87 e8 ff ff       	call   f0100f8b <cprintf>
f0102704:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f0102707:	b8 b8 ca 71 00       	mov    $0x71cab8,%eax
f010270c:	83 ec 04             	sub    $0x4,%esp
f010270f:	50                   	push   %eax
f0102710:	68 b8 ca 71 f0       	push   $0xf071cab8
f0102715:	68 98 5c 12 f0       	push   $0xf0125c98
f010271a:	e8 6c e8 ff ff       	call   f0100f8b <cprintf>
f010271f:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0102722:	b8 b0 8a 76 00       	mov    $0x768ab0,%eax
f0102727:	83 ec 04             	sub    $0x4,%esp
f010272a:	50                   	push   %eax
f010272b:	68 b0 8a 76 f0       	push   $0xf0768ab0
f0102730:	68 e0 5c 12 f0       	push   $0xf0125ce0
f0102735:	e8 51 e8 ff ff       	call   f0100f8b <cprintf>
f010273a:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f010273d:	b8 b0 8a 76 f0       	mov    $0xf0768ab0,%eax
f0102742:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0102748:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f010274d:	29 c2                	sub    %eax,%edx
f010274f:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f0102751:	85 c0                	test   %eax,%eax
f0102753:	79 05                	jns    f010275a <command_kernel_info+0x9f>
f0102755:	05 ff 03 00 00       	add    $0x3ff,%eax
f010275a:	c1 f8 0a             	sar    $0xa,%eax
f010275d:	83 ec 08             	sub    $0x8,%esp
f0102760:	50                   	push   %eax
f0102761:	68 1c 5d 12 f0       	push   $0xf0125d1c
f0102766:	e8 20 e8 ff ff       	call   f0100f8b <cprintf>
f010276b:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010276e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102773:	c9                   	leave  
f0102774:	c3                   	ret    

f0102775 <command_schedPRIRR>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_schedPRIRR(int number_of_arguments, char **arguments){
f0102775:	55                   	push   %ebp
f0102776:	89 e5                	mov    %esp,%ebp
f0102778:	83 ec 18             	sub    $0x18,%esp

	//EDITED(The new command function)
	/*Checking the validation of the passed parameters*/
	if (number_of_arguments < 4)
f010277b:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010277f:	7f 17                	jg     f0102798 <command_schedPRIRR+0x23>
	{
		cprintf("Invalid Number of arguments\n");
f0102781:	83 ec 0c             	sub    $0xc,%esp
f0102784:	68 47 5d 12 f0       	push   $0xf0125d47
f0102789:	e8 fd e7 ff ff       	call   f0100f8b <cprintf>
f010278e:	83 c4 10             	add    $0x10,%esp
		return -1; //Indicating that there is an error
f0102791:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0102796:	eb 6e                	jmp    f0102806 <command_schedPRIRR+0x91>
	}

	uint8 numOfPriorities_CMD = (uint8)strtol(arguments[1],NULL, 10);// Casting the passed NUM_OF_PRIORITES
f0102798:	8b 45 0c             	mov    0xc(%ebp),%eax
f010279b:	83 c0 04             	add    $0x4,%eax
f010279e:	8b 00                	mov    (%eax),%eax
f01027a0:	83 ec 04             	sub    $0x4,%esp
f01027a3:	6a 0a                	push   $0xa
f01027a5:	6a 00                	push   $0x0
f01027a7:	50                   	push   %eax
f01027a8:	e8 ee fa 01 00       	call   f012229b <strtol>
f01027ad:	83 c4 10             	add    $0x10,%esp
f01027b0:	88 45 f7             	mov    %al,-0x9(%ebp)

	uint8 quantum_CMD = (uint8)strtol(arguments[2],NULL, 10);// Casting the passed QUANTUMS
f01027b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027b6:	83 c0 08             	add    $0x8,%eax
f01027b9:	8b 00                	mov    (%eax),%eax
f01027bb:	83 ec 04             	sub    $0x4,%esp
f01027be:	6a 0a                	push   $0xa
f01027c0:	6a 00                	push   $0x0
f01027c2:	50                   	push   %eax
f01027c3:	e8 d3 fa 01 00       	call   f012229b <strtol>
f01027c8:	83 c4 10             	add    $0x10,%esp
f01027cb:	88 45 f6             	mov    %al,-0xa(%ebp)

	uint32 starvThresh_CMD = (uint32)strtol(arguments[3],NULL, 10);// Casting the passed STARVATION THRESHOLD
f01027ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027d1:	83 c0 0c             	add    $0xc,%eax
f01027d4:	8b 00                	mov    (%eax),%eax
f01027d6:	83 ec 04             	sub    $0x4,%esp
f01027d9:	6a 0a                	push   $0xa
f01027db:	6a 00                	push   $0x0
f01027dd:	50                   	push   %eax
f01027de:	e8 b8 fa 01 00       	call   f012229b <strtol>
f01027e3:	83 c4 10             	add    $0x10,%esp
f01027e6:	89 45 f0             	mov    %eax,-0x10(%ebp)

	sched_init_PRIRR(numOfPriorities_CMD, quantum_CMD, starvThresh_CMD);//Initialize the PRIORITY RR scheduler
f01027e9:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01027ed:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01027f1:	83 ec 04             	sub    $0x4,%esp
f01027f4:	ff 75 f0             	pushl  -0x10(%ebp)
f01027f7:	52                   	push   %edx
f01027f8:	50                   	push   %eax
f01027f9:	e8 5d 46 00 00       	call   f0106e5b <sched_init_PRIRR>
f01027fe:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102801:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102806:	c9                   	leave  
f0102807:	c3                   	ret    

f0102808 <command_writeusermem>:

int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102808:	55                   	push   %ebp
f0102809:	89 e5                	mov    %esp,%ebp
f010280b:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010280e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102812:	75 37                	jne    f010284b <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102814:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102817:	83 c0 04             	add    $0x4,%eax
f010281a:	8b 00                	mov    (%eax),%eax
f010281c:	83 ec 04             	sub    $0x4,%esp
f010281f:	6a 10                	push   $0x10
f0102821:	6a 00                	push   $0x0
f0102823:	50                   	push   %eax
f0102824:	e8 72 fa 01 00       	call   f012229b <strtol>
f0102829:	83 c4 10             	add    $0x10,%esp
f010282c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010282f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102832:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102835:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102838:	83 c0 08             	add    $0x8,%eax
f010283b:	8b 00                	mov    (%eax),%eax
f010283d:	8a 00                	mov    (%eax),%al
f010283f:	88 c2                	mov    %al,%dl
f0102841:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102844:	88 10                	mov    %dl,(%eax)
f0102846:	e9 b9 00 00 00       	jmp    f0102904 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f010284b:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010284f:	0f 85 9f 00 00 00    	jne    f01028f4 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102855:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102858:	83 c0 04             	add    $0x4,%eax
f010285b:	8b 00                	mov    (%eax),%eax
f010285d:	83 ec 04             	sub    $0x4,%esp
f0102860:	6a 0a                	push   $0xa
f0102862:	6a 00                	push   $0x0
f0102864:	50                   	push   %eax
f0102865:	e8 31 fa 01 00       	call   f012229b <strtol>
f010286a:	83 c4 10             	add    $0x10,%esp
f010286d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102870:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102877:	83 ec 04             	sub    $0x4,%esp
f010287a:	6a 00                	push   $0x0
f010287c:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010287f:	50                   	push   %eax
f0102880:	ff 75 f4             	pushl  -0xc(%ebp)
f0102883:	e8 0c 97 00 00       	call   f010bf94 <envid2env>
f0102888:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010288b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010288e:	83 c0 08             	add    $0x8,%eax
f0102891:	8b 00                	mov    (%eax),%eax
f0102893:	83 ec 04             	sub    $0x4,%esp
f0102896:	6a 10                	push   $0x10
f0102898:	6a 00                	push   $0x0
f010289a:	50                   	push   %eax
f010289b:	e8 fb f9 01 00       	call   f012229b <strtol>
f01028a0:	83 c4 10             	add    $0x10,%esp
f01028a3:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028a9:	85 c0                	test   %eax,%eax
f01028ab:	75 07                	jne    f01028b4 <command_writeusermem+0xac>
f01028ad:	b8 00 00 00 00       	mov    $0x0,%eax
f01028b2:	eb 55                	jmp    f0102909 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028b4:	0f 20 d8             	mov    %cr3,%eax
f01028b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028ba:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028c3:	8b 40 68             	mov    0x68(%eax),%eax
f01028c6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028cc:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01028cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01028d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028d8:	83 c0 0c             	add    $0xc,%eax
f01028db:	8b 00                	mov    (%eax),%eax
f01028dd:	8a 00                	mov    (%eax),%al
f01028df:	88 c2                	mov    %al,%dl
f01028e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01028e4:	88 10                	mov    %dl,(%eax)
f01028e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01028e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01028ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028ef:	0f 22 d8             	mov    %eax,%cr3
f01028f2:	eb 10                	jmp    f0102904 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01028f4:	83 ec 0c             	sub    $0xc,%esp
f01028f7:	68 64 5d 12 f0       	push   $0xf0125d64
f01028fc:	e8 8a e6 ff ff       	call   f0100f8b <cprintf>
f0102901:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102904:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102909:	c9                   	leave  
f010290a:	c3                   	ret    

f010290b <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f010290b:	55                   	push   %ebp
f010290c:	89 e5                	mov    %esp,%ebp
f010290e:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102911:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102914:	83 c0 04             	add    $0x4,%eax
f0102917:	8b 00                	mov    (%eax),%eax
f0102919:	83 ec 04             	sub    $0x4,%esp
f010291c:	6a 10                	push   $0x10
f010291e:	6a 00                	push   $0x0
f0102920:	50                   	push   %eax
f0102921:	e8 75 f9 01 00       	call   f012229b <strtol>
f0102926:	83 c4 10             	add    $0x10,%esp
f0102929:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010292e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102931:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102938:	8b 45 0c             	mov    0xc(%ebp),%eax
f010293b:	83 c0 08             	add    $0x8,%eax
f010293e:	8b 00                	mov    (%eax),%eax
f0102940:	83 ec 0c             	sub    $0xc,%esp
f0102943:	50                   	push   %eax
f0102944:	e8 f2 f5 01 00       	call   f0121f3b <strlen>
f0102949:	83 c4 10             	add    $0x10,%esp
f010294c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f010294f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102956:	eb 1c                	jmp    f0102974 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102958:	8b 45 0c             	mov    0xc(%ebp),%eax
f010295b:	83 c0 08             	add    $0x8,%eax
f010295e:	8b 10                	mov    (%eax),%edx
f0102960:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102963:	01 d0                	add    %edx,%eax
f0102965:	8a 00                	mov    (%eax),%al
f0102967:	88 c2                	mov    %al,%dl
f0102969:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010296c:	88 10                	mov    %dl,(%eax)
		address++;
f010296e:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f0102971:	ff 45 f0             	incl   -0x10(%ebp)
f0102974:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102977:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010297a:	7c dc                	jl     f0102958 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010297c:	b8 00 00 00 00       	mov    $0x0,%eax


}
f0102981:	c9                   	leave  
f0102982:	c3                   	ret    

f0102983 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102983:	55                   	push   %ebp
f0102984:	89 e5                	mov    %esp,%ebp
f0102986:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f0102989:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010298d:	75 42                	jne    f01029d1 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010298f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102992:	83 c0 04             	add    $0x4,%eax
f0102995:	8b 00                	mov    (%eax),%eax
f0102997:	83 ec 04             	sub    $0x4,%esp
f010299a:	6a 10                	push   $0x10
f010299c:	6a 00                	push   $0x0
f010299e:	50                   	push   %eax
f010299f:	e8 f7 f8 01 00       	call   f012229b <strtol>
f01029a4:	83 c4 10             	add    $0x10,%esp
f01029a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029ad:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b3:	8a 00                	mov    (%eax),%al
f01029b5:	0f b6 c0             	movzbl %al,%eax
f01029b8:	83 ec 04             	sub    $0x4,%esp
f01029bb:	50                   	push   %eax
f01029bc:	ff 75 d8             	pushl  -0x28(%ebp)
f01029bf:	68 8e 5d 12 f0       	push   $0xf0125d8e
f01029c4:	e8 c2 e5 ff ff       	call   f0100f8b <cprintf>
f01029c9:	83 c4 10             	add    $0x10,%esp
f01029cc:	e9 c4 00 00 00       	jmp    f0102a95 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01029d1:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01029d5:	0f 85 aa 00 00 00    	jne    f0102a85 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01029db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029de:	83 c0 04             	add    $0x4,%eax
f01029e1:	8b 00                	mov    (%eax),%eax
f01029e3:	83 ec 04             	sub    $0x4,%esp
f01029e6:	6a 0a                	push   $0xa
f01029e8:	6a 00                	push   $0x0
f01029ea:	50                   	push   %eax
f01029eb:	e8 ab f8 01 00       	call   f012229b <strtol>
f01029f0:	83 c4 10             	add    $0x10,%esp
f01029f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01029f6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01029fd:	83 ec 04             	sub    $0x4,%esp
f0102a00:	6a 00                	push   $0x0
f0102a02:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a05:	50                   	push   %eax
f0102a06:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a09:	e8 86 95 00 00       	call   f010bf94 <envid2env>
f0102a0e:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a11:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a14:	83 c0 08             	add    $0x8,%eax
f0102a17:	8b 00                	mov    (%eax),%eax
f0102a19:	83 ec 04             	sub    $0x4,%esp
f0102a1c:	6a 10                	push   $0x10
f0102a1e:	6a 00                	push   $0x0
f0102a20:	50                   	push   %eax
f0102a21:	e8 75 f8 01 00       	call   f012229b <strtol>
f0102a26:	83 c4 10             	add    $0x10,%esp
f0102a29:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a2f:	85 c0                	test   %eax,%eax
f0102a31:	75 07                	jne    f0102a3a <command_readusermem+0xb7>
f0102a33:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a38:	eb 60                	jmp    f0102a9a <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a3a:	0f 20 d8             	mov    %cr3,%eax
f0102a3d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a40:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a43:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a46:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a49:	8b 40 68             	mov    0x68(%eax),%eax
f0102a4c:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a4f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a52:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a55:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a58:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a5e:	8a 00                	mov    (%eax),%al
f0102a60:	0f b6 c0             	movzbl %al,%eax
f0102a63:	83 ec 04             	sub    $0x4,%esp
f0102a66:	50                   	push   %eax
f0102a67:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a6a:	68 8e 5d 12 f0       	push   $0xf0125d8e
f0102a6f:	e8 17 e5 ff ff       	call   f0100f8b <cprintf>
f0102a74:	83 c4 10             	add    $0x10,%esp
f0102a77:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102a7a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102a7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a80:	0f 22 d8             	mov    %eax,%cr3
f0102a83:	eb 10                	jmp    f0102a95 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102a85:	83 ec 0c             	sub    $0xc,%esp
f0102a88:	68 a8 5d 12 f0       	push   $0xf0125da8
f0102a8d:	e8 f9 e4 ff ff       	call   f0100f8b <cprintf>
f0102a92:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102a95:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102a9a:	c9                   	leave  
f0102a9b:	c3                   	ret    

f0102a9c <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102a9c:	55                   	push   %ebp
f0102a9d:	89 e5                	mov    %esp,%ebp
f0102a9f:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102aa2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aa5:	83 c0 04             	add    $0x4,%eax
f0102aa8:	8b 00                	mov    (%eax),%eax
f0102aaa:	83 ec 04             	sub    $0x4,%esp
f0102aad:	6a 10                	push   $0x10
f0102aaf:	6a 00                	push   $0x0
f0102ab1:	50                   	push   %eax
f0102ab2:	e8 e4 f7 01 00       	call   f012229b <strtol>
f0102ab7:	83 c4 10             	add    $0x10,%esp
f0102aba:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102ac2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102ac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102acc:	8a 00                	mov    (%eax),%al
f0102ace:	0f b6 c0             	movzbl %al,%eax
f0102ad1:	83 ec 08             	sub    $0x8,%esp
f0102ad4:	50                   	push   %eax
f0102ad5:	68 d2 5d 12 f0       	push   $0xf0125dd2
f0102ada:	e8 ac e4 ff ff       	call   f0100f8b <cprintf>
f0102adf:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102ae2:	83 ec 0c             	sub    $0xc,%esp
f0102ae5:	68 d5 5d 12 f0       	push   $0xf0125dd5
f0102aea:	e8 9c e4 ff ff       	call   f0100f8b <cprintf>
f0102aef:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102af2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102af7:	c9                   	leave  
f0102af8:	c3                   	ret    

f0102af9 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102af9:	55                   	push   %ebp
f0102afa:	89 e5                	mov    %esp,%ebp
f0102afc:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102aff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b02:	83 c0 04             	add    $0x4,%eax
f0102b05:	8b 00                	mov    (%eax),%eax
f0102b07:	83 ec 04             	sub    $0x4,%esp
f0102b0a:	6a 0a                	push   $0xa
f0102b0c:	6a 00                	push   $0x0
f0102b0e:	50                   	push   %eax
f0102b0f:	e8 87 f7 01 00       	call   f012229b <strtol>
f0102b14:	83 c4 10             	add    $0x10,%esp
f0102b17:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b1a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b21:	83 ec 04             	sub    $0x4,%esp
f0102b24:	6a 00                	push   $0x0
f0102b26:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b29:	50                   	push   %eax
f0102b2a:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b2d:	e8 62 94 00 00       	call   f010bf94 <envid2env>
f0102b32:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b35:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b38:	83 c0 08             	add    $0x8,%eax
f0102b3b:	8b 00                	mov    (%eax),%eax
f0102b3d:	83 ec 04             	sub    $0x4,%esp
f0102b40:	6a 10                	push   $0x10
f0102b42:	6a 00                	push   $0x0
f0102b44:	50                   	push   %eax
f0102b45:	e8 51 f7 01 00       	call   f012229b <strtol>
f0102b4a:	83 c4 10             	add    $0x10,%esp
f0102b4d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b53:	83 c0 0c             	add    $0xc,%eax
f0102b56:	8b 00                	mov    (%eax),%eax
f0102b58:	83 ec 04             	sub    $0x4,%esp
f0102b5b:	6a 0a                	push   $0xa
f0102b5d:	6a 00                	push   $0x0
f0102b5f:	50                   	push   %eax
f0102b60:	e8 36 f7 01 00       	call   f012229b <strtol>
f0102b65:	83 c4 10             	add    $0x10,%esp
f0102b68:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102b6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102b6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102b71:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b74:	85 c0                	test   %eax,%eax
f0102b76:	75 07                	jne    f0102b7f <command_readuserblock+0x86>
f0102b78:	b8 00 00 00 00       	mov    $0x0,%eax
f0102b7d:	eb 65                	jmp    f0102be4 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102b7f:	0f 20 d8             	mov    %cr3,%eax
f0102b82:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102b85:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102b88:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102b8b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102b8e:	8b 40 68             	mov    0x68(%eax),%eax
f0102b91:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102b94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b97:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102b9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102ba1:	eb 28                	jmp    f0102bcb <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ba6:	8a 00                	mov    (%eax),%al
f0102ba8:	0f b6 d0             	movzbl %al,%edx
f0102bab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102bae:	8a 00                	mov    (%eax),%al
f0102bb0:	0f b6 c0             	movzbl %al,%eax
f0102bb3:	52                   	push   %edx
f0102bb4:	50                   	push   %eax
f0102bb5:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bb8:	68 d7 5d 12 f0       	push   $0xf0125dd7
f0102bbd:	e8 c9 e3 ff ff       	call   f0100f8b <cprintf>
f0102bc2:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bc5:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102bc8:	ff 45 f0             	incl   -0x10(%ebp)
f0102bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102bce:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102bd1:	7c d0                	jl     f0102ba3 <command_readuserblock+0xaa>
f0102bd3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102bd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102bd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102bdc:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102bdf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102be4:	c9                   	leave  
f0102be5:	c3                   	ret    

f0102be6 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102be6:	55                   	push   %ebp
f0102be7:	89 e5                	mov    %esp,%ebp
f0102be9:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102bec:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bef:	83 c0 04             	add    $0x4,%eax
f0102bf2:	8b 00                	mov    (%eax),%eax
f0102bf4:	83 ec 04             	sub    $0x4,%esp
f0102bf7:	6a 0a                	push   $0xa
f0102bf9:	6a 00                	push   $0x0
f0102bfb:	50                   	push   %eax
f0102bfc:	e8 9a f6 01 00       	call   f012229b <strtol>
f0102c01:	83 c4 10             	add    $0x10,%esp
f0102c04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c07:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c0e:	83 ec 04             	sub    $0x4,%esp
f0102c11:	6a 00                	push   $0x0
f0102c13:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c16:	50                   	push   %eax
f0102c17:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c1a:	e8 75 93 00 00       	call   f010bf94 <envid2env>
f0102c1f:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c22:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c25:	85 c0                	test   %eax,%eax
f0102c27:	75 0a                	jne    f0102c33 <command_remove_table+0x4d>
f0102c29:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c2e:	e9 c7 00 00 00       	jmp    f0102cfa <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c36:	83 c0 08             	add    $0x8,%eax
f0102c39:	8b 00                	mov    (%eax),%eax
f0102c3b:	83 ec 04             	sub    $0x4,%esp
f0102c3e:	6a 10                	push   $0x10
f0102c40:	6a 00                	push   $0x0
f0102c42:	50                   	push   %eax
f0102c43:	e8 53 f6 01 00       	call   f012229b <strtol>
f0102c48:	83 c4 10             	add    $0x10,%esp
f0102c4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c51:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c54:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c57:	8b 40 64             	mov    0x64(%eax),%eax
f0102c5a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c5d:	c1 ea 16             	shr    $0x16,%edx
f0102c60:	c1 e2 02             	shl    $0x2,%edx
f0102c63:	01 d0                	add    %edx,%eax
f0102c65:	8b 00                	mov    (%eax),%eax
f0102c67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102c6c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102c6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102c72:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102c77:	77 1c                	ja     f0102c95 <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102c79:	83 ec 0c             	sub    $0xc,%esp
f0102c7c:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c7f:	e8 0e 74 00 00       	call   f010a092 <kheap_virtual_address>
f0102c84:	83 c4 10             	add    $0x10,%esp
f0102c87:	83 ec 0c             	sub    $0xc,%esp
f0102c8a:	50                   	push   %eax
f0102c8b:	e8 44 72 00 00       	call   f0109ed4 <kfree>
f0102c90:	83 c4 10             	add    $0x10,%esp
f0102c93:	eb 28                	jmp    f0102cbd <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102c95:	83 ec 0c             	sub    $0xc,%esp
f0102c98:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9b:	e8 0e f9 ff ff       	call   f01025ae <to_frame_info>
f0102ca0:	83 c4 10             	add    $0x10,%esp
f0102ca3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102ca6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102ca9:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102caf:	83 ec 0c             	sub    $0xc,%esp
f0102cb2:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cb5:	e8 3d 5d 00 00       	call   f01089f7 <free_frame>
f0102cba:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cc0:	c1 e8 16             	shr    $0x16,%eax
f0102cc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cc6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cc9:	8b 40 64             	mov    0x64(%eax),%eax
f0102ccc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102ccf:	c1 e2 02             	shl    $0x2,%edx
f0102cd2:	01 c2                	add    %eax,%edx
f0102cd4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102cd7:	8b 40 64             	mov    0x64(%eax),%eax
f0102cda:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102cdd:	c1 e1 02             	shl    $0x2,%ecx
f0102ce0:	01 c8                	add    %ecx,%eax
f0102ce2:	8b 00                	mov    (%eax),%eax
f0102ce4:	83 e0 fe             	and    $0xfffffffe,%eax
f0102ce7:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102ce9:	0f 20 d8             	mov    %cr3,%eax
f0102cec:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102cef:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102cf2:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102cf5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102cfa:	c9                   	leave  
f0102cfb:	c3                   	ret    

f0102cfc <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102cfc:	55                   	push   %ebp
f0102cfd:	89 e5                	mov    %esp,%ebp
f0102cff:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d02:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d06:	7e 06                	jle    f0102d0e <command_allocuserpage+0x12>
f0102d08:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d0c:	7e 1a                	jle    f0102d28 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d0e:	83 ec 0c             	sub    $0xc,%esp
f0102d11:	68 e8 5d 12 f0       	push   $0xf0125de8
f0102d16:	e8 70 e2 ff ff       	call   f0100f8b <cprintf>
f0102d1b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d1e:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d23:	e9 46 01 00 00       	jmp    f0102e6e <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d28:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d2b:	83 c0 04             	add    $0x4,%eax
f0102d2e:	8b 00                	mov    (%eax),%eax
f0102d30:	83 ec 04             	sub    $0x4,%esp
f0102d33:	6a 0a                	push   $0xa
f0102d35:	6a 00                	push   $0x0
f0102d37:	50                   	push   %eax
f0102d38:	e8 5e f5 01 00       	call   f012229b <strtol>
f0102d3d:	83 c4 10             	add    $0x10,%esp
f0102d40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d43:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d4a:	83 ec 04             	sub    $0x4,%esp
f0102d4d:	6a 00                	push   $0x0
f0102d4f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d52:	50                   	push   %eax
f0102d53:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d56:	e8 39 92 00 00       	call   f010bf94 <envid2env>
f0102d5b:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d5e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d61:	85 c0                	test   %eax,%eax
f0102d63:	75 0a                	jne    f0102d6f <command_allocuserpage+0x73>
f0102d65:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d6a:	e9 ff 00 00 00       	jmp    f0102e6e <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102d6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d72:	83 c0 08             	add    $0x8,%eax
f0102d75:	8b 00                	mov    (%eax),%eax
f0102d77:	83 ec 04             	sub    $0x4,%esp
f0102d7a:	6a 10                	push   $0x10
f0102d7c:	6a 00                	push   $0x0
f0102d7e:	50                   	push   %eax
f0102d7f:	e8 17 f5 01 00       	call   f012229b <strtol>
f0102d84:	83 c4 10             	add    $0x10,%esp
f0102d87:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102d8a:	83 ec 0c             	sub    $0xc,%esp
f0102d8d:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102d90:	50                   	push   %eax
f0102d91:	e8 0d 5b 00 00       	call   f01088a3 <allocate_frame>
f0102d96:	83 c4 10             	add    $0x10,%esp
f0102d99:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102d9c:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102da0:	75 1a                	jne    f0102dbc <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102da2:	83 ec 0c             	sub    $0xc,%esp
f0102da5:	68 12 5e 12 f0       	push   $0xf0125e12
f0102daa:	e8 dc e1 ff ff       	call   f0100f8b <cprintf>
f0102daf:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102db2:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db7:	e9 b2 00 00 00       	jmp    f0102e6e <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102dbc:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102dc0:	75 1d                	jne    f0102ddf <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dc2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102dc8:	8b 40 64             	mov    0x64(%eax),%eax
f0102dcb:	6a 06                	push   $0x6
f0102dcd:	ff 75 ec             	pushl  -0x14(%ebp)
f0102dd0:	52                   	push   %edx
f0102dd1:	50                   	push   %eax
f0102dd2:	e8 99 5f 00 00       	call   f0108d70 <map_frame>
f0102dd7:	83 c4 10             	add    $0x10,%esp
f0102dda:	e9 8a 00 00 00       	jmp    f0102e69 <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102ddf:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102de3:	0f 85 80 00 00 00    	jne    f0102e69 <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102de9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dec:	83 c0 0c             	add    $0xc,%eax
f0102def:	8b 00                	mov    (%eax),%eax
f0102df1:	8a 00                	mov    (%eax),%al
f0102df3:	3c 72                	cmp    $0x72,%al
f0102df5:	74 0e                	je     f0102e05 <command_allocuserpage+0x109>
f0102df7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102dfa:	83 c0 0c             	add    $0xc,%eax
f0102dfd:	8b 00                	mov    (%eax),%eax
f0102dff:	8a 00                	mov    (%eax),%al
f0102e01:	3c 52                	cmp    $0x52,%al
f0102e03:	75 09                	jne    f0102e0e <command_allocuserpage+0x112>
			rw = 0 ;
f0102e05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e0c:	eb 3c                	jmp    f0102e4a <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e11:	83 c0 0c             	add    $0xc,%eax
f0102e14:	8b 00                	mov    (%eax),%eax
f0102e16:	8a 00                	mov    (%eax),%al
f0102e18:	3c 77                	cmp    $0x77,%al
f0102e1a:	74 0e                	je     f0102e2a <command_allocuserpage+0x12e>
f0102e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e1f:	83 c0 0c             	add    $0xc,%eax
f0102e22:	8b 00                	mov    (%eax),%eax
f0102e24:	8a 00                	mov    (%eax),%al
f0102e26:	3c 57                	cmp    $0x57,%al
f0102e28:	75 09                	jne    f0102e33 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e2a:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e31:	eb 17                	jmp    f0102e4a <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e33:	83 ec 0c             	sub    $0xc,%esp
f0102e36:	68 2c 5e 12 f0       	push   $0xf0125e2c
f0102e3b:	e8 4b e1 ff ff       	call   f0100f8b <cprintf>
f0102e40:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e43:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e4d:	83 c8 04             	or     $0x4,%eax
f0102e50:	89 c1                	mov    %eax,%ecx
f0102e52:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e58:	8b 40 64             	mov    0x64(%eax),%eax
f0102e5b:	51                   	push   %ecx
f0102e5c:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e5f:	52                   	push   %edx
f0102e60:	50                   	push   %eax
f0102e61:	e8 0a 5f 00 00       	call   f0108d70 <map_frame>
f0102e66:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102e69:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e6e:	c9                   	leave  
f0102e6f:	c3                   	ret    

f0102e70 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102e70:	55                   	push   %ebp
f0102e71:	89 e5                	mov    %esp,%ebp
f0102e73:	56                   	push   %esi
f0102e74:	53                   	push   %ebx
f0102e75:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102e78:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102e7b:	83 ec 0c             	sub    $0xc,%esp
f0102e7e:	50                   	push   %eax
f0102e7f:	e8 e5 61 00 00       	call   f0109069 <calculate_available_frames>
f0102e84:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e87:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102e8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102e8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102e90:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102e93:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102e96:	01 de                	add    %ebx,%esi
f0102e98:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102e9b:	01 f3                	add    %esi,%ebx
f0102e9d:	83 ec 0c             	sub    $0xc,%esp
f0102ea0:	51                   	push   %ecx
f0102ea1:	52                   	push   %edx
f0102ea2:	50                   	push   %eax
f0102ea3:	53                   	push   %ebx
f0102ea4:	68 70 5e 12 f0       	push   $0xf0125e70
f0102ea9:	e8 dd e0 ff ff       	call   f0100f8b <cprintf>
f0102eae:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102eb1:	a1 b0 5e 74 f0       	mov    0xf0745eb0,%eax
f0102eb6:	83 ec 08             	sub    $0x8,%esp
f0102eb9:	50                   	push   %eax
f0102eba:	68 c8 5e 12 f0       	push   $0xf0125ec8
f0102ebf:	e8 c7 e0 ff ff       	call   f0100f8b <cprintf>
f0102ec4:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102ec7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ecc:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102ecf:	5b                   	pop    %ebx
f0102ed0:	5e                   	pop    %esi
f0102ed1:	5d                   	pop    %ebp
f0102ed2:	c3                   	ret    

f0102ed3 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102ed3:	55                   	push   %ebp
f0102ed4:	89 e5                	mov    %esp,%ebp
f0102ed6:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102ed9:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102ee0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102ee7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102eee:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0102ef5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102efc:	8b 45 08             	mov    0x8(%ebp),%eax
f0102eff:	83 f8 04             	cmp    $0x4,%eax
f0102f02:	0f 84 c3 00 00 00    	je     f0102fcb <CreateEnv+0xf8>
f0102f08:	83 f8 05             	cmp    $0x5,%eax
f0102f0b:	74 0e                	je     f0102f1b <CreateEnv+0x48>
f0102f0d:	83 f8 03             	cmp    $0x3,%eax
f0102f10:	0f 84 4a 01 00 00    	je     f0103060 <CreateEnv+0x18d>
f0102f16:	e9 8d 01 00 00       	jmp    f01030a8 <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f1b:	83 ec 0c             	sub    $0xc,%esp
f0102f1e:	6a 02                	push   $0x2
f0102f20:	e8 4f cd 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f0102f25:	83 c4 10             	add    $0x10,%esp
f0102f28:	85 c0                	test   %eax,%eax
f0102f2a:	75 1a                	jne    f0102f46 <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f2c:	83 ec 0c             	sub    $0xc,%esp
f0102f2f:	68 04 5f 12 f0       	push   $0xf0125f04
f0102f34:	e8 52 e0 ff ff       	call   f0100f8b <cprintf>
f0102f39:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f3c:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f41:	e9 7b 02 00 00       	jmp    f01031c1 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0102f46:	e8 73 3b 00 00       	call   f0106abe <isSchedMethodBSD>
f0102f4b:	85 c0                	test   %eax,%eax
f0102f4d:	74 1d                	je     f0102f6c <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f52:	83 c0 10             	add    $0x10,%eax
f0102f55:	8b 00                	mov    (%eax),%eax
f0102f57:	83 ec 04             	sub    $0x4,%esp
f0102f5a:	6a 0a                	push   $0xa
f0102f5c:	6a 00                	push   $0x0
f0102f5e:	50                   	push   %eax
f0102f5f:	e8 37 f3 01 00       	call   f012229b <strtol>
f0102f64:	83 c4 10             	add    $0x10,%esp
f0102f67:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102f6a:	eb 24                	jmp    f0102f90 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0102f6c:	e8 60 3b 00 00       	call   f0106ad1 <isSchedMethodPRIRR>
f0102f71:	85 c0                	test   %eax,%eax
f0102f73:	74 1b                	je     f0102f90 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0102f75:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f78:	83 c0 10             	add    $0x10,%eax
f0102f7b:	8b 00                	mov    (%eax),%eax
f0102f7d:	83 ec 04             	sub    $0x4,%esp
f0102f80:	6a 0a                	push   $0xa
f0102f82:	6a 00                	push   $0x0
f0102f84:	50                   	push   %eax
f0102f85:	e8 11 f3 01 00       	call   f012229b <strtol>
f0102f8a:	83 c4 10             	add    $0x10,%esp
f0102f8d:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f90:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f93:	83 c0 0c             	add    $0xc,%eax
f0102f96:	8b 00                	mov    (%eax),%eax
f0102f98:	83 ec 04             	sub    $0x4,%esp
f0102f9b:	6a 0a                	push   $0xa
f0102f9d:	6a 00                	push   $0x0
f0102f9f:	50                   	push   %eax
f0102fa0:	e8 f6 f2 01 00       	call   f012229b <strtol>
f0102fa5:	83 c4 10             	add    $0x10,%esp
f0102fa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fae:	83 c0 08             	add    $0x8,%eax
f0102fb1:	8b 00                	mov    (%eax),%eax
f0102fb3:	83 ec 04             	sub    $0x4,%esp
f0102fb6:	6a 0a                	push   $0xa
f0102fb8:	6a 00                	push   $0x0
f0102fba:	50                   	push   %eax
f0102fbb:	e8 db f2 01 00       	call   f012229b <strtol>
f0102fc0:	83 c4 10             	add    $0x10,%esp
f0102fc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102fc6:	e9 f7 00 00 00       	jmp    f01030c2 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102fcb:	83 ec 0c             	sub    $0xc,%esp
f0102fce:	6a 02                	push   $0x2
f0102fd0:	e8 9f cc 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f0102fd5:	83 c4 10             	add    $0x10,%esp
f0102fd8:	85 c0                	test   %eax,%eax
f0102fda:	75 4c                	jne    f0103028 <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0102fdc:	e8 dd 3a 00 00       	call   f0106abe <isSchedMethodBSD>
f0102fe1:	85 c0                	test   %eax,%eax
f0102fe3:	74 1d                	je     f0103002 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fe5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe8:	83 c0 0c             	add    $0xc,%eax
f0102feb:	8b 00                	mov    (%eax),%eax
f0102fed:	83 ec 04             	sub    $0x4,%esp
f0102ff0:	6a 0a                	push   $0xa
f0102ff2:	6a 00                	push   $0x0
f0102ff4:	50                   	push   %eax
f0102ff5:	e8 a1 f2 01 00       	call   f012229b <strtol>
f0102ffa:	83 c4 10             	add    $0x10,%esp
f0102ffd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103000:	eb 41                	jmp    f0103043 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103002:	e8 ca 3a 00 00       	call   f0106ad1 <isSchedMethodPRIRR>
f0103007:	85 c0                	test   %eax,%eax
f0103009:	74 38                	je     f0103043 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f010300b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010300e:	83 c0 0c             	add    $0xc,%eax
f0103011:	8b 00                	mov    (%eax),%eax
f0103013:	83 ec 04             	sub    $0x4,%esp
f0103016:	6a 0a                	push   $0xa
f0103018:	6a 00                	push   $0x0
f010301a:	50                   	push   %eax
f010301b:	e8 7b f2 01 00       	call   f012229b <strtol>
f0103020:	83 c4 10             	add    $0x10,%esp
f0103023:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103026:	eb 1b                	jmp    f0103043 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103028:	8b 45 0c             	mov    0xc(%ebp),%eax
f010302b:	83 c0 0c             	add    $0xc,%eax
f010302e:	8b 00                	mov    (%eax),%eax
f0103030:	83 ec 04             	sub    $0x4,%esp
f0103033:	6a 0a                	push   $0xa
f0103035:	6a 00                	push   $0x0
f0103037:	50                   	push   %eax
f0103038:	e8 5e f2 01 00       	call   f012229b <strtol>
f010303d:	83 c4 10             	add    $0x10,%esp
f0103040:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103043:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103046:	83 c0 08             	add    $0x8,%eax
f0103049:	8b 00                	mov    (%eax),%eax
f010304b:	83 ec 04             	sub    $0x4,%esp
f010304e:	6a 0a                	push   $0xa
f0103050:	6a 00                	push   $0x0
f0103052:	50                   	push   %eax
f0103053:	e8 43 f2 01 00       	call   f012229b <strtol>
f0103058:	83 c4 10             	add    $0x10,%esp
f010305b:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f010305e:	eb 62                	jmp    f01030c2 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103060:	83 ec 0c             	sub    $0xc,%esp
f0103063:	6a 02                	push   $0x2
f0103065:	e8 0a cc 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010306a:	83 c4 10             	add    $0x10,%esp
f010306d:	85 c0                	test   %eax,%eax
f010306f:	74 1a                	je     f010308b <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103071:	83 ec 0c             	sub    $0xc,%esp
f0103074:	68 b0 5f 12 f0       	push   $0xf0125fb0
f0103079:	e8 0d df ff ff       	call   f0100f8b <cprintf>
f010307e:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103081:	b8 00 00 00 00       	mov    $0x0,%eax
f0103086:	e9 36 01 00 00       	jmp    f01031c1 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f010308b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010308e:	83 c0 08             	add    $0x8,%eax
f0103091:	8b 00                	mov    (%eax),%eax
f0103093:	83 ec 04             	sub    $0x4,%esp
f0103096:	6a 0a                	push   $0xa
f0103098:	6a 00                	push   $0x0
f010309a:	50                   	push   %eax
f010309b:	e8 fb f1 01 00       	call   f012229b <strtol>
f01030a0:	83 c4 10             	add    $0x10,%esp
f01030a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f01030a6:	eb 1a                	jmp    f01030c2 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f01030a8:	83 ec 0c             	sub    $0xc,%esp
f01030ab:	68 40 60 12 f0       	push   $0xf0126040
f01030b0:	e8 d6 de ff ff       	call   f0100f8b <cprintf>
f01030b5:	83 c4 10             	add    $0x10,%esp
			return NULL;
f01030b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01030bd:	e9 ff 00 00 00       	jmp    f01031c1 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01030c2:	83 ec 0c             	sub    $0xc,%esp
f01030c5:	6a 02                	push   $0x2
f01030c7:	e8 a8 cb 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f01030cc:	83 c4 10             	add    $0x10,%esp
f01030cf:	85 c0                	test   %eax,%eax
f01030d1:	74 23                	je     f01030f6 <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f01030d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030d6:	48                   	dec    %eax
f01030d7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01030da:	73 1a                	jae    f01030f6 <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f01030dc:	83 ec 0c             	sub    $0xc,%esp
f01030df:	68 d8 60 12 f0       	push   $0xf01260d8
f01030e4:	e8 a2 de ff ff       	call   f0100f8b <cprintf>
f01030e9:	83 c4 10             	add    $0x10,%esp
				return NULL;
f01030ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01030f1:	e9 cb 00 00 00       	jmp    f01031c1 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030f6:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01030fa:	76 19                	jbe    f0103115 <CreateEnv+0x242>
f01030fc:	68 30 61 12 f0       	push   $0xf0126130
f0103101:	68 75 61 12 f0       	push   $0xf0126175
f0103106:	68 c5 01 00 00       	push   $0x1c5
f010310b:	68 8a 61 12 f0       	push   $0xf012618a
f0103110:	e8 24 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103115:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103119:	76 19                	jbe    f0103134 <CreateEnv+0x261>
f010311b:	68 30 61 12 f0       	push   $0xf0126130
f0103120:	68 75 61 12 f0       	push   $0xf0126175
f0103125:	68 e3 01 00 00       	push   $0x1e3
f010312a:	68 8a 61 12 f0       	push   $0xf012618a
f010312f:	e8 05 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103134:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103137:	83 c0 04             	add    $0x4,%eax
f010313a:	8b 00                	mov    (%eax),%eax
f010313c:	ff 75 e4             	pushl  -0x1c(%ebp)
f010313f:	ff 75 f0             	pushl  -0x10(%ebp)
f0103142:	ff 75 f4             	pushl  -0xc(%ebp)
f0103145:	50                   	push   %eax
f0103146:	e8 7b 83 00 00       	call   f010b4c6 <env_create>
f010314b:	83 c4 10             	add    $0x10,%esp
f010314e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103151:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103155:	74 49                	je     f01031a0 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103157:	83 ec 08             	sub    $0x8,%esp
f010315a:	ff 75 ec             	pushl  -0x14(%ebp)
f010315d:	68 9e 61 12 f0       	push   $0xf012619e
f0103162:	e8 24 de ff ff       	call   f0100f8b <cprintf>
f0103167:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f010316a:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f010316e:	7c 06                	jl     f0103176 <CreateEnv+0x2a3>
f0103170:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103174:	7e 19                	jle    f010318f <CreateEnv+0x2bc>
f0103176:	68 b0 61 12 f0       	push   $0xf01261b0
f010317b:	68 75 61 12 f0       	push   $0xf0126175
f0103180:	68 e8 01 00 00       	push   $0x1e8
f0103185:	68 8a 61 12 f0       	push   $0xf012618a
f010318a:	e8 aa d1 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f010318f:	83 ec 08             	sub    $0x8,%esp
f0103192:	ff 75 ec             	pushl  -0x14(%ebp)
f0103195:	ff 75 e0             	pushl  -0x20(%ebp)
f0103198:	e8 79 37 00 00       	call   f0106916 <env_set_nice>
f010319d:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f01031a0:	e8 2c 39 00 00       	call   f0106ad1 <isSchedMethodPRIRR>
f01031a5:	85 c0                	test   %eax,%eax
f01031a7:	74 15                	je     f01031be <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f01031a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01031ac:	8b 40 10             	mov    0x10(%eax),%eax
f01031af:	83 ec 08             	sub    $0x8,%esp
f01031b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01031b5:	50                   	push   %eax
f01031b6:	e8 b2 37 00 00       	call   f010696d <env_set_priority>
f01031bb:	83 c4 10             	add    $0x10,%esp

	return env;
f01031be:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01031c1:	c9                   	leave  
f01031c2:	c3                   	ret    

f01031c3 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f01031c3:	55                   	push   %ebp
f01031c4:	89 e5                	mov    %esp,%ebp
f01031c6:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f01031c9:	83 ec 08             	sub    $0x8,%esp
f01031cc:	ff 75 0c             	pushl  0xc(%ebp)
f01031cf:	ff 75 08             	pushl  0x8(%ebp)
f01031d2:	e8 fc fc ff ff       	call   f0102ed3 <CreateEnv>
f01031d7:	83 c4 10             	add    $0x10,%esp
f01031da:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f01031dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01031e1:	75 07                	jne    f01031ea <command_run_program+0x27>
f01031e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01031e8:	eb 46                	jmp    f0103230 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f01031ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031ed:	8b 40 10             	mov    0x10(%eax),%eax
f01031f0:	83 ec 08             	sub    $0x8,%esp
f01031f3:	50                   	push   %eax
f01031f4:	68 e0 61 12 f0       	push   $0xf01261e0
f01031f9:	e8 8d dd ff ff       	call   f0100f8b <cprintf>
f01031fe:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103201:	83 ec 0c             	sub    $0xc,%esp
f0103204:	ff 75 f4             	pushl  -0xc(%ebp)
f0103207:	e8 a0 27 00 00       	call   f01059ac <sched_new_env>
f010320c:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f010320f:	c7 05 b0 5e 74 f0 00 	movl   $0x0,0xf0745eb0
f0103216:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103219:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010321c:	8b 40 10             	mov    0x10(%eax),%eax
f010321f:	83 ec 0c             	sub    $0xc,%esp
f0103222:	50                   	push   %eax
f0103223:	e8 da 27 00 00       	call   f0105a02 <sched_run_env>
f0103228:	83 c4 10             	add    $0x10,%esp

	return 0;
f010322b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103230:	c9                   	leave  
f0103231:	c3                   	ret    

f0103232 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103232:	55                   	push   %ebp
f0103233:	89 e5                	mov    %esp,%ebp
f0103235:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103238:	8b 45 0c             	mov    0xc(%ebp),%eax
f010323b:	83 c0 04             	add    $0x4,%eax
f010323e:	8b 00                	mov    (%eax),%eax
f0103240:	83 ec 04             	sub    $0x4,%esp
f0103243:	6a 0a                	push   $0xa
f0103245:	6a 00                	push   $0x0
f0103247:	50                   	push   %eax
f0103248:	e8 4e f0 01 00       	call   f012229b <strtol>
f010324d:	83 c4 10             	add    $0x10,%esp
f0103250:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103256:	83 ec 0c             	sub    $0xc,%esp
f0103259:	50                   	push   %eax
f010325a:	e8 e9 2a 00 00       	call   f0105d48 <sched_kill_env>
f010325f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103262:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103267:	c9                   	leave  
f0103268:	c3                   	ret    

f0103269 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103269:	55                   	push   %ebp
f010326a:	89 e5                	mov    %esp,%ebp
f010326c:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f010326f:	83 ec 08             	sub    $0x8,%esp
f0103272:	ff 75 0c             	pushl  0xc(%ebp)
f0103275:	ff 75 08             	pushl  0x8(%ebp)
f0103278:	e8 56 fc ff ff       	call   f0102ed3 <CreateEnv>
f010327d:	83 c4 10             	add    $0x10,%esp
f0103280:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103283:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103287:	75 07                	jne    f0103290 <commnad_load_env+0x27>
		return 0 ;
f0103289:	b8 00 00 00 00       	mov    $0x0,%eax
f010328e:	eb 2a                	jmp    f01032ba <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103290:	83 ec 0c             	sub    $0xc,%esp
f0103293:	ff 75 f4             	pushl  -0xc(%ebp)
f0103296:	e8 11 27 00 00       	call   f01059ac <sched_new_env>
f010329b:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010329e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01032a1:	8b 40 10             	mov    0x10(%eax),%eax
f01032a4:	83 ec 08             	sub    $0x8,%esp
f01032a7:	50                   	push   %eax
f01032a8:	68 e0 61 12 f0       	push   $0xf01261e0
f01032ad:	e8 d9 dc ff ff       	call   f0100f8b <cprintf>
f01032b2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032ba:	c9                   	leave  
f01032bb:	c3                   	ret    

f01032bc <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f01032bc:	55                   	push   %ebp
f01032bd:	89 e5                	mov    %esp,%ebp
f01032bf:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f01032c2:	c7 05 b0 5e 74 f0 00 	movl   $0x0,0xf0745eb0
f01032c9:	00 00 00 
	sched_run_all();
f01032cc:	e8 34 30 00 00       	call   f0106305 <sched_run_all>

	return 0 ;
f01032d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032d6:	c9                   	leave  
f01032d7:	c3                   	ret    

f01032d8 <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f01032d8:	55                   	push   %ebp
f01032d9:	89 e5                	mov    %esp,%ebp
f01032db:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f01032de:	e8 01 2e 00 00       	call   f01060e4 <sched_print_all>

	return 0 ;
f01032e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032e8:	c9                   	leave  
f01032e9:	c3                   	ret    

f01032ea <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f01032ea:	55                   	push   %ebp
f01032eb:	89 e5                	mov    %esp,%ebp
f01032ed:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01032f0:	e8 a5 30 00 00       	call   f010639a <sched_kill_all>

	return 0 ;
f01032f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032fa:	c9                   	leave  
f01032fb:	c3                   	ret    

f01032fc <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01032fc:	55                   	push   %ebp
f01032fd:	89 e5                	mov    %esp,%ebp
f01032ff:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103302:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103306:	7f 1a                	jg     f0103322 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103308:	83 ec 0c             	sub    $0xc,%esp
f010330b:	68 f8 61 12 f0       	push   $0xf01261f8
f0103310:	e8 76 dc ff ff       	call   f0100f8b <cprintf>
f0103315:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103318:	b8 00 00 00 00       	mov    $0x0,%eax
f010331d:	e9 83 00 00 00       	jmp    f01033a5 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103322:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103325:	83 c0 04             	add    $0x4,%eax
f0103328:	8b 00                	mov    (%eax),%eax
f010332a:	83 ec 04             	sub    $0x4,%esp
f010332d:	6a 0a                	push   $0xa
f010332f:	6a 00                	push   $0x0
f0103331:	50                   	push   %eax
f0103332:	e8 64 ef 01 00       	call   f012229b <strtol>
f0103337:	83 c4 10             	add    $0x10,%esp
f010333a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f010333d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103341:	75 20                	jne    f0103363 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103343:	83 ec 0c             	sub    $0xc,%esp
f0103346:	ff 75 f4             	pushl  -0xc(%ebp)
f0103349:	e8 9b c8 00 00       	call   f010fbe9 <setPageReplacmentAlgorithmLRU>
f010334e:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103351:	83 ec 0c             	sub    $0xc,%esp
f0103354:	68 58 62 12 f0       	push   $0xf0126258
f0103359:	e8 2d dc ff ff       	call   f0100f8b <cprintf>
f010335e:	83 c4 10             	add    $0x10,%esp
f0103361:	eb 3d                	jmp    f01033a0 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103363:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103367:	75 20                	jne    f0103389 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103369:	83 ec 0c             	sub    $0xc,%esp
f010336c:	ff 75 f4             	pushl  -0xc(%ebp)
f010336f:	e8 75 c8 00 00       	call   f010fbe9 <setPageReplacmentAlgorithmLRU>
f0103374:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103377:	83 ec 0c             	sub    $0xc,%esp
f010337a:	68 9c 62 12 f0       	push   $0xf012629c
f010337f:	e8 07 dc ff ff       	call   f0100f8b <cprintf>
f0103384:	83 c4 10             	add    $0x10,%esp
f0103387:	eb 17                	jmp    f01033a0 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103389:	83 ec 0c             	sub    $0xc,%esp
f010338c:	68 dc 62 12 f0       	push   $0xf01262dc
f0103391:	e8 f5 db ff ff       	call   f0100f8b <cprintf>
f0103396:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103399:	b8 00 00 00 00       	mov    $0x0,%eax
f010339e:	eb 05                	jmp    f01033a5 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01033a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a5:	c9                   	leave  
f01033a6:	c3                   	ret    

f01033a7 <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01033a7:	55                   	push   %ebp
f01033a8:	89 e5                	mov    %esp,%ebp
f01033aa:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01033ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033b0:	83 c0 04             	add    $0x4,%eax
f01033b3:	8b 00                	mov    (%eax),%eax
f01033b5:	83 ec 04             	sub    $0x4,%esp
f01033b8:	6a 0a                	push   $0xa
f01033ba:	6a 00                	push   $0x0
f01033bc:	50                   	push   %eax
f01033bd:	e8 d9 ee 01 00       	call   f012229b <strtol>
f01033c2:	83 c4 10             	add    $0x10,%esp
f01033c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f01033c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033cb:	83 c0 08             	add    $0x8,%eax
f01033ce:	8b 00                	mov    (%eax),%eax
f01033d0:	83 ec 04             	sub    $0x4,%esp
f01033d3:	6a 0a                	push   $0xa
f01033d5:	6a 00                	push   $0x0
f01033d7:	50                   	push   %eax
f01033d8:	e8 be ee 01 00       	call   f012229b <strtol>
f01033dd:	83 c4 10             	add    $0x10,%esp
f01033e0:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f01033e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01033e7:	75 17                	jne    f0103400 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f01033e9:	83 ec 0c             	sub    $0xc,%esp
f01033ec:	68 30 63 12 f0       	push   $0xf0126330
f01033f1:	e8 95 db ff ff       	call   f0100f8b <cprintf>
f01033f6:	83 c4 10             	add    $0x10,%esp
		return 0;
f01033f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01033fe:	eb 4b                	jmp    f010344b <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0103400:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f0103404:	74 22                	je     f0103428 <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f0103406:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f010340a:	75 05                	jne    f0103411 <command_set_page_rep_nthCLOCK+0x6a>
f010340c:	f7 5d f4             	negl   -0xc(%ebp)
f010340f:	eb 17                	jmp    f0103428 <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0103411:	83 ec 0c             	sub    $0xc,%esp
f0103414:	68 60 63 12 f0       	push   $0xf0126360
f0103419:	e8 6d db ff ff       	call   f0100f8b <cprintf>
f010341e:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103421:	b8 00 00 00 00       	mov    $0x0,%eax
f0103426:	eb 23                	jmp    f010344b <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0103428:	83 ec 0c             	sub    $0xc,%esp
f010342b:	ff 75 f4             	pushl  -0xc(%ebp)
f010342e:	e8 29 c8 00 00       	call   f010fc5c <setPageReplacmentAlgorithmNchanceCLOCK>
f0103433:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0103436:	83 ec 0c             	sub    $0xc,%esp
f0103439:	68 9c 63 12 f0       	push   $0xf012639c
f010343e:	e8 48 db ff ff       	call   f0100f8b <cprintf>
f0103443:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103446:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010344b:	c9                   	leave  
f010344c:	c3                   	ret    

f010344d <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f010344d:	55                   	push   %ebp
f010344e:	89 e5                	mov    %esp,%ebp
f0103450:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0103453:	e8 c4 c7 00 00       	call   f010fc1c <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0103458:	83 ec 0c             	sub    $0xc,%esp
f010345b:	68 d0 63 12 f0       	push   $0xf01263d0
f0103460:	e8 26 db ff ff       	call   f0100f8b <cprintf>
f0103465:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103468:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010346d:	c9                   	leave  
f010346e:	c3                   	ret    

f010346f <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f010346f:	55                   	push   %ebp
f0103470:	89 e5                	mov    %esp,%ebp
f0103472:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0103475:	e8 b2 c7 00 00       	call   f010fc2c <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f010347a:	83 ec 0c             	sub    $0xc,%esp
f010347d:	68 fc 63 12 f0       	push   $0xf01263fc
f0103482:	e8 04 db ff ff       	call   f0100f8b <cprintf>
f0103487:	83 c4 10             	add    $0x10,%esp
	return 0;
f010348a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010348f:	c9                   	leave  
f0103490:	c3                   	ret    

f0103491 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0103491:	55                   	push   %ebp
f0103492:	89 e5                	mov    %esp,%ebp
f0103494:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0103497:	e8 a0 c7 00 00       	call   f010fc3c <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f010349c:	83 ec 0c             	sub    $0xc,%esp
f010349f:	68 24 64 12 f0       	push   $0xf0126424
f01034a4:	e8 e2 da ff ff       	call   f0100f8b <cprintf>
f01034a9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034b1:	c9                   	leave  
f01034b2:	c3                   	ret    

f01034b3 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f01034b3:	55                   	push   %ebp
f01034b4:	89 e5                	mov    %esp,%ebp
f01034b6:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f01034b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034bc:	83 c0 04             	add    $0x4,%eax
f01034bf:	8b 00                	mov    (%eax),%eax
f01034c1:	83 ec 04             	sub    $0x4,%esp
f01034c4:	6a 0a                	push   $0xa
f01034c6:	6a 00                	push   $0x0
f01034c8:	50                   	push   %eax
f01034c9:	e8 cd ed 01 00       	call   f012229b <strtol>
f01034ce:	83 c4 10             	add    $0x10,%esp
f01034d1:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f01034d4:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01034d8:	83 ec 0c             	sub    $0xc,%esp
f01034db:	50                   	push   %eax
f01034dc:	e8 7b 38 00 00       	call   f0106d5c <sched_init_RR>
f01034e1:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f01034e4:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f01034e9:	8a 00                	mov    (%eax),%al
f01034eb:	0f b6 c0             	movzbl %al,%eax
f01034ee:	83 ec 08             	sub    $0x8,%esp
f01034f1:	50                   	push   %eax
f01034f2:	68 58 64 12 f0       	push   $0xf0126458
f01034f7:	e8 8f da ff ff       	call   f0100f8b <cprintf>
f01034fc:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103504:	c9                   	leave  
f0103505:	c3                   	ret    

f0103506 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0103506:	55                   	push   %ebp
f0103507:	89 e5                	mov    %esp,%ebp
f0103509:	53                   	push   %ebx
f010350a:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010350d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103510:	83 c0 04             	add    $0x4,%eax
f0103513:	8b 00                	mov    (%eax),%eax
f0103515:	83 ec 04             	sub    $0x4,%esp
f0103518:	6a 0a                	push   $0xa
f010351a:	6a 00                	push   $0x0
f010351c:	50                   	push   %eax
f010351d:	e8 79 ed 01 00       	call   f012229b <strtol>
f0103522:	83 c4 10             	add    $0x10,%esp
f0103525:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103528:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f010352f:	eb 2e                	jmp    f010355f <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0103531:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103534:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0103537:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010353a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103541:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103544:	01 d0                	add    %edx,%eax
f0103546:	8b 00                	mov    (%eax),%eax
f0103548:	83 ec 04             	sub    $0x4,%esp
f010354b:	6a 0a                	push   $0xa
f010354d:	6a 00                	push   $0x0
f010354f:	50                   	push   %eax
f0103550:	e8 46 ed 01 00       	call   f012229b <strtol>
f0103555:	83 c4 10             	add    $0x10,%esp
f0103558:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010355c:	ff 45 f4             	incl   -0xc(%ebp)
f010355f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103562:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103565:	7c ca                	jl     f0103531 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103567:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010356b:	83 ec 08             	sub    $0x8,%esp
f010356e:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103571:	52                   	push   %edx
f0103572:	50                   	push   %eax
f0103573:	e8 92 38 00 00       	call   f0106e0a <sched_init_MLFQ>
f0103578:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010357b:	83 ec 0c             	sub    $0xc,%esp
f010357e:	68 90 64 12 f0       	push   $0xf0126490
f0103583:	e8 03 da ff ff       	call   f0100f8b <cprintf>
f0103588:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010358b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103592:	eb 24                	jmp    f01035b8 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f0103594:	8b 15 c4 5b 74 f0    	mov    0xf0745bc4,%edx
f010359a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010359d:	01 d0                	add    %edx,%eax
f010359f:	8a 00                	mov    (%eax),%al
f01035a1:	0f b6 c0             	movzbl %al,%eax
f01035a4:	83 ec 08             	sub    $0x8,%esp
f01035a7:	50                   	push   %eax
f01035a8:	68 bd 64 12 f0       	push   $0xf01264bd
f01035ad:	e8 d9 d9 ff ff       	call   f0100f8b <cprintf>
f01035b2:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01035b5:	ff 45 f0             	incl   -0x10(%ebp)
f01035b8:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01035bd:	0f b6 c0             	movzbl %al,%eax
f01035c0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01035c3:	7f cf                	jg     f0103594 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f01035c5:	83 ec 0c             	sub    $0xc,%esp
f01035c8:	68 d5 5d 12 f0       	push   $0xf0125dd5
f01035cd:	e8 b9 d9 ff ff       	call   f0100f8b <cprintf>
f01035d2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01035dd:	c9                   	leave  
f01035de:	c3                   	ret    

f01035df <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f01035df:	55                   	push   %ebp
f01035e0:	89 e5                	mov    %esp,%ebp
f01035e2:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01035e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e8:	83 c0 04             	add    $0x4,%eax
f01035eb:	8b 00                	mov    (%eax),%eax
f01035ed:	83 ec 04             	sub    $0x4,%esp
f01035f0:	6a 0a                	push   $0xa
f01035f2:	6a 00                	push   $0x0
f01035f4:	50                   	push   %eax
f01035f5:	e8 a1 ec 01 00       	call   f012229b <strtol>
f01035fa:	83 c4 10             	add    $0x10,%esp
f01035fd:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103600:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103603:	83 c0 08             	add    $0x8,%eax
f0103606:	8b 00                	mov    (%eax),%eax
f0103608:	83 ec 04             	sub    $0x4,%esp
f010360b:	6a 0a                	push   $0xa
f010360d:	6a 00                	push   $0x0
f010360f:	50                   	push   %eax
f0103610:	e8 86 ec 01 00       	call   f012229b <strtol>
f0103615:	83 c4 10             	add    $0x10,%esp
f0103618:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f010361b:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010361f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103623:	83 ec 08             	sub    $0x8,%esp
f0103626:	52                   	push   %edx
f0103627:	50                   	push   %eax
f0103628:	e8 05 38 00 00       	call   f0106e32 <sched_init_BSD>
f010362d:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0103630:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103634:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103638:	83 ec 04             	sub    $0x4,%esp
f010363b:	52                   	push   %edx
f010363c:	50                   	push   %eax
f010363d:	68 c4 64 12 f0       	push   $0xf01264c4
f0103642:	e8 44 d9 ff ff       	call   f0100f8b <cprintf>
f0103647:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010364a:	83 ec 0c             	sub    $0xc,%esp
f010364d:	68 d5 5d 12 f0       	push   $0xf0125dd5
f0103652:	e8 34 d9 ff ff       	call   f0100f8b <cprintf>
f0103657:	83 c4 10             	add    $0x10,%esp
	return 0;
f010365a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010365f:	c9                   	leave  
f0103660:	c3                   	ret    

f0103661 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0103661:	55                   	push   %ebp
f0103662:	89 e5                	mov    %esp,%ebp
f0103664:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f0103667:	8b 45 0c             	mov    0xc(%ebp),%eax
f010366a:	83 c0 04             	add    $0x4,%eax
f010366d:	8b 00                	mov    (%eax),%eax
f010366f:	83 ec 04             	sub    $0x4,%esp
f0103672:	6a 0a                	push   $0xa
f0103674:	6a 00                	push   $0x0
f0103676:	50                   	push   %eax
f0103677:	e8 1f ec 01 00       	call   f012229b <strtol>
f010367c:	83 c4 10             	add    $0x10,%esp
f010367f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f0103682:	83 ec 0c             	sub    $0xc,%esp
f0103685:	ff 75 f4             	pushl  -0xc(%ebp)
f0103688:	e8 ce 33 00 00       	call   f0106a5b <sched_set_starv_thresh>
f010368d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103690:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103695:	c9                   	leave  
f0103696:	c3                   	ret    

f0103697 <command_set_priority>:
int command_set_priority(int number_of_arguments, char **arguments)
{
f0103697:	55                   	push   %ebp
f0103698:	89 e5                	mov    %esp,%ebp
f010369a:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010369d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a0:	83 c0 04             	add    $0x4,%eax
f01036a3:	8b 00                	mov    (%eax),%eax
f01036a5:	83 ec 04             	sub    $0x4,%esp
f01036a8:	6a 0a                	push   $0xa
f01036aa:	6a 00                	push   $0x0
f01036ac:	50                   	push   %eax
f01036ad:	e8 e9 eb 01 00       	call   f012229b <strtol>
f01036b2:	83 c4 10             	add    $0x10,%esp
f01036b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01036b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036bb:	83 c0 08             	add    $0x8,%eax
f01036be:	8b 00                	mov    (%eax),%eax
f01036c0:	83 ec 04             	sub    $0x4,%esp
f01036c3:	6a 0a                	push   $0xa
f01036c5:	6a 00                	push   $0x0
f01036c7:	50                   	push   %eax
f01036c8:	e8 ce eb 01 00       	call   f012229b <strtol>
f01036cd:	83 c4 10             	add    $0x10,%esp
f01036d0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01036d3:	83 ec 08             	sub    $0x8,%esp
f01036d6:	ff 75 f0             	pushl  -0x10(%ebp)
f01036d9:	ff 75 f4             	pushl  -0xc(%ebp)
f01036dc:	e8 8c 32 00 00       	call   f010696d <env_set_priority>
f01036e1:	83 c4 10             	add    $0x10,%esp

	return 0;
f01036e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036e9:	c9                   	leave  
f01036ea:	c3                   	ret    

f01036eb <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01036eb:	55                   	push   %ebp
f01036ec:	89 e5                	mov    %esp,%ebp
f01036ee:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01036f1:	e8 b5 33 00 00       	call   f0106aab <isSchedMethodMLFQ>
f01036f6:	85 c0                	test   %eax,%eax
f01036f8:	74 5f                	je     f0103759 <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01036fa:	83 ec 0c             	sub    $0xc,%esp
f01036fd:	68 00 65 12 f0       	push   $0xf0126500
f0103702:	e8 84 d8 ff ff       	call   f0100f8b <cprintf>
f0103707:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010370a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103711:	eb 24                	jmp    f0103737 <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f0103713:	8b 15 c4 5b 74 f0    	mov    0xf0745bc4,%edx
f0103719:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010371c:	01 d0                	add    %edx,%eax
f010371e:	8a 00                	mov    (%eax),%al
f0103720:	0f b6 c0             	movzbl %al,%eax
f0103723:	83 ec 08             	sub    $0x8,%esp
f0103726:	50                   	push   %eax
f0103727:	68 bd 64 12 f0       	push   $0xf01264bd
f010372c:	e8 5a d8 ff ff       	call   f0100f8b <cprintf>
f0103731:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103734:	ff 45 f4             	incl   -0xc(%ebp)
f0103737:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f010373c:	0f b6 c0             	movzbl %al,%eax
f010373f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103742:	7f cf                	jg     f0103713 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103744:	83 ec 0c             	sub    $0xc,%esp
f0103747:	68 d5 5d 12 f0       	push   $0xf0125dd5
f010374c:	e8 3a d8 ff ff       	call   f0100f8b <cprintf>
f0103751:	83 c4 10             	add    $0x10,%esp
f0103754:	e9 94 00 00 00       	jmp    f01037ed <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f0103759:	e8 3b 33 00 00       	call   f0106a99 <isSchedMethodRR>
f010375e:	85 c0                	test   %eax,%eax
f0103760:	74 1d                	je     f010377f <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103762:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0103767:	8a 00                	mov    (%eax),%al
f0103769:	0f b6 c0             	movzbl %al,%eax
f010376c:	83 ec 08             	sub    $0x8,%esp
f010376f:	50                   	push   %eax
f0103770:	68 34 65 12 f0       	push   $0xf0126534
f0103775:	e8 11 d8 ff ff       	call   f0100f8b <cprintf>
f010377a:	83 c4 10             	add    $0x10,%esp
f010377d:	eb 6e                	jmp    f01037ed <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f010377f:	e8 3a 33 00 00       	call   f0106abe <isSchedMethodBSD>
f0103784:	85 c0                	test   %eax,%eax
f0103786:	74 26                	je     f01037ae <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103788:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f010378d:	8a 00                	mov    (%eax),%al
f010378f:	0f b6 d0             	movzbl %al,%edx
f0103792:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0103797:	0f b6 c0             	movzbl %al,%eax
f010379a:	83 ec 04             	sub    $0x4,%esp
f010379d:	52                   	push   %edx
f010379e:	50                   	push   %eax
f010379f:	68 c4 64 12 f0       	push   $0xf01264c4
f01037a4:	e8 e2 d7 ff ff       	call   f0100f8b <cprintf>
f01037a9:	83 c4 10             	add    $0x10,%esp
f01037ac:	eb 3f                	jmp    f01037ed <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01037ae:	e8 1e 33 00 00       	call   f0106ad1 <isSchedMethodPRIRR>
f01037b3:	85 c0                	test   %eax,%eax
f01037b5:	74 26                	je     f01037dd <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01037b7:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f01037bc:	8a 00                	mov    (%eax),%al
f01037be:	0f b6 d0             	movzbl %al,%edx
f01037c1:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01037c6:	0f b6 c0             	movzbl %al,%eax
f01037c9:	83 ec 04             	sub    $0x4,%esp
f01037cc:	52                   	push   %edx
f01037cd:	50                   	push   %eax
f01037ce:	68 70 65 12 f0       	push   $0xf0126570
f01037d3:	e8 b3 d7 ff ff       	call   f0100f8b <cprintf>
f01037d8:	83 c4 10             	add    $0x10,%esp
f01037db:	eb 10                	jmp    f01037ed <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01037dd:	83 ec 0c             	sub    $0xc,%esp
f01037e0:	68 b8 65 12 f0       	push   $0xf01265b8
f01037e5:	e8 a1 d7 ff ff       	call   f0100f8b <cprintf>
f01037ea:	83 c4 10             	add    $0x10,%esp

	return 0;
f01037ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037f2:	c9                   	leave  
f01037f3:	c3                   	ret    

f01037f4 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01037f4:	55                   	push   %ebp
f01037f5:	89 e5                	mov    %esp,%ebp
f01037f7:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01037fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01037fd:	83 c0 04             	add    $0x4,%eax
f0103800:	8b 00                	mov    (%eax),%eax
f0103802:	83 ec 04             	sub    $0x4,%esp
f0103805:	6a 0a                	push   $0xa
f0103807:	6a 00                	push   $0x0
f0103809:	50                   	push   %eax
f010380a:	e8 8c ea 01 00       	call   f012229b <strtol>
f010380f:	83 c4 10             	add    $0x10,%esp
f0103812:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103815:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103818:	0f b6 c0             	movzbl %al,%eax
f010381b:	83 ec 0c             	sub    $0xc,%esp
f010381e:	50                   	push   %eax
f010381f:	e8 6b d8 01 00       	call   f012108f <chksch>
f0103824:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103827:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010382b:	75 12                	jne    f010383f <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010382d:	83 ec 0c             	sub    $0xc,%esp
f0103830:	68 e0 65 12 f0       	push   $0xf01265e0
f0103835:	e8 51 d7 ff ff       	call   f0100f8b <cprintf>
f010383a:	83 c4 10             	add    $0x10,%esp
f010383d:	eb 16                	jmp    f0103855 <command_sch_test+0x61>
	else if (status == 1)
f010383f:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103843:	75 10                	jne    f0103855 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103845:	83 ec 0c             	sub    $0xc,%esp
f0103848:	68 08 66 12 f0       	push   $0xf0126608
f010384d:	e8 39 d7 ff ff       	call   f0100f8b <cprintf>
f0103852:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103855:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010385a:	c9                   	leave  
f010385b:	c3                   	ret    

f010385c <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010385c:	55                   	push   %ebp
f010385d:	89 e5                	mov    %esp,%ebp
f010385f:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103862:	e8 23 c4 00 00       	call   f010fc8a <isPageReplacmentAlgorithmCLOCK>
f0103867:	85 c0                	test   %eax,%eax
f0103869:	74 15                	je     f0103880 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010386b:	83 ec 0c             	sub    $0xc,%esp
f010386e:	68 2c 66 12 f0       	push   $0xf012662c
f0103873:	e8 13 d7 ff ff       	call   f0100f8b <cprintf>
f0103878:	83 c4 10             	add    $0x10,%esp
f010387b:	e9 e1 00 00 00       	jmp    f0103961 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103880:	83 ec 0c             	sub    $0xc,%esp
f0103883:	6a 01                	push   $0x1
f0103885:	e8 ea c3 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010388a:	83 c4 10             	add    $0x10,%esp
f010388d:	85 c0                	test   %eax,%eax
f010388f:	74 15                	je     f01038a6 <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103891:	83 ec 0c             	sub    $0xc,%esp
f0103894:	68 54 66 12 f0       	push   $0xf0126654
f0103899:	e8 ed d6 ff ff       	call   f0100f8b <cprintf>
f010389e:	83 c4 10             	add    $0x10,%esp
f01038a1:	e9 bb 00 00 00       	jmp    f0103961 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01038a6:	83 ec 0c             	sub    $0xc,%esp
f01038a9:	6a 02                	push   $0x2
f01038ab:	e8 c4 c3 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f01038b0:	83 c4 10             	add    $0x10,%esp
f01038b3:	85 c0                	test   %eax,%eax
f01038b5:	74 15                	je     f01038cc <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01038b7:	83 ec 0c             	sub    $0xc,%esp
f01038ba:	68 94 66 12 f0       	push   $0xf0126694
f01038bf:	e8 c7 d6 ff ff       	call   f0100f8b <cprintf>
f01038c4:	83 c4 10             	add    $0x10,%esp
f01038c7:	e9 95 00 00 00       	jmp    f0103961 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmFIFO())
f01038cc:	e8 d4 c3 00 00       	call   f010fca5 <isPageReplacmentAlgorithmFIFO>
f01038d1:	85 c0                	test   %eax,%eax
f01038d3:	74 12                	je     f01038e7 <command_print_page_rep+0x8b>
		cprintf("Page replacement algorithm is FIFO\n");
f01038d5:	83 ec 0c             	sub    $0xc,%esp
f01038d8:	68 d0 66 12 f0       	push   $0xf01266d0
f01038dd:	e8 a9 d6 ff ff       	call   f0100f8b <cprintf>
f01038e2:	83 c4 10             	add    $0x10,%esp
f01038e5:	eb 7a                	jmp    f0103961 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01038e7:	e8 d4 c3 00 00       	call   f010fcc0 <isPageReplacmentAlgorithmModifiedCLOCK>
f01038ec:	85 c0                	test   %eax,%eax
f01038ee:	74 12                	je     f0103902 <command_print_page_rep+0xa6>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01038f0:	83 ec 0c             	sub    $0xc,%esp
f01038f3:	68 f4 66 12 f0       	push   $0xf01266f4
f01038f8:	e8 8e d6 ff ff       	call   f0100f8b <cprintf>
f01038fd:	83 c4 10             	add    $0x10,%esp
f0103900:	eb 5f                	jmp    f0103961 <command_print_page_rep+0x105>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0103902:	e8 ef c3 00 00       	call   f010fcf6 <isPageReplacmentAlgorithmNchanceCLOCK>
f0103907:	85 c0                	test   %eax,%eax
f0103909:	74 46                	je     f0103951 <command_print_page_rep+0xf5>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f010390b:	83 ec 0c             	sub    $0xc,%esp
f010390e:	68 24 67 12 f0       	push   $0xf0126724
f0103913:	e8 73 d6 ff ff       	call   f0100f8b <cprintf>
f0103918:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f010391b:	a1 94 58 74 f0       	mov    0xf0745894,%eax
f0103920:	85 c0                	test   %eax,%eax
f0103922:	7e 12                	jle    f0103936 <command_print_page_rep+0xda>
f0103924:	83 ec 0c             	sub    $0xc,%esp
f0103927:	68 54 67 12 f0       	push   $0xf0126754
f010392c:	e8 5a d6 ff ff       	call   f0100f8b <cprintf>
f0103931:	83 c4 10             	add    $0x10,%esp
f0103934:	eb 2b                	jmp    f0103961 <command_print_page_rep+0x105>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f0103936:	a1 94 58 74 f0       	mov    0xf0745894,%eax
f010393b:	85 c0                	test   %eax,%eax
f010393d:	79 22                	jns    f0103961 <command_print_page_rep+0x105>
f010393f:	83 ec 0c             	sub    $0xc,%esp
f0103942:	68 62 67 12 f0       	push   $0xf0126762
f0103947:	e8 3f d6 ff ff       	call   f0100f8b <cprintf>
f010394c:	83 c4 10             	add    $0x10,%esp
f010394f:	eb 10                	jmp    f0103961 <command_print_page_rep+0x105>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0103951:	83 ec 0c             	sub    $0xc,%esp
f0103954:	68 74 67 12 f0       	push   $0xf0126774
f0103959:	e8 2d d6 ff ff       	call   f0100f8b <cprintf>
f010395e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103961:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103966:	c9                   	leave  
f0103967:	c3                   	ret    

f0103968 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103968:	55                   	push   %ebp
f0103969:	89 e5                	mov    %esp,%ebp
f010396b:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f010396e:	e8 a7 eb ff ff       	call   f010251a <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f0103973:	83 ec 0c             	sub    $0xc,%esp
f0103976:	68 a0 67 12 f0       	push   $0xf01267a0
f010397b:	e8 0b d6 ff ff       	call   f0100f8b <cprintf>
f0103980:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103983:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103988:	c9                   	leave  
f0103989:	c3                   	ret    

f010398a <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f010398a:	55                   	push   %ebp
f010398b:	89 e5                	mov    %esp,%ebp
f010398d:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103990:	e8 95 eb ff ff       	call   f010252a <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f0103995:	83 ec 0c             	sub    $0xc,%esp
f0103998:	68 d0 67 12 f0       	push   $0xf01267d0
f010399d:	e8 e9 d5 ff ff       	call   f0100f8b <cprintf>
f01039a2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039aa:	c9                   	leave  
f01039ab:	c3                   	ret    

f01039ac <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01039ac:	55                   	push   %ebp
f01039ad:	89 e5                	mov    %esp,%ebp
f01039af:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01039b2:	e8 83 eb ff ff       	call   f010253a <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01039b7:	83 ec 0c             	sub    $0xc,%esp
f01039ba:	68 00 68 12 f0       	push   $0xf0126800
f01039bf:	e8 c7 d5 ff ff       	call   f0100f8b <cprintf>
f01039c4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039cc:	c9                   	leave  
f01039cd:	c3                   	ret    

f01039ce <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01039ce:	55                   	push   %ebp
f01039cf:	89 e5                	mov    %esp,%ebp
f01039d1:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f01039d4:	e8 71 eb ff ff       	call   f010254a <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f01039d9:	83 ec 0c             	sub    $0xc,%esp
f01039dc:	68 30 68 12 f0       	push   $0xf0126830
f01039e1:	e8 a5 d5 ff ff       	call   f0100f8b <cprintf>
f01039e6:	83 c4 10             	add    $0x10,%esp
	return 0;
f01039e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01039ee:	c9                   	leave  
f01039ef:	c3                   	ret    

f01039f0 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f01039f0:	55                   	push   %ebp
f01039f1:	89 e5                	mov    %esp,%ebp
f01039f3:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f01039f6:	e8 5f eb ff ff       	call   f010255a <isUHeapPlacementStrategyFIRSTFIT>
f01039fb:	84 c0                	test   %al,%al
f01039fd:	74 12                	je     f0103a11 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f01039ff:	83 ec 0c             	sub    $0xc,%esp
f0103a02:	68 60 68 12 f0       	push   $0xf0126860
f0103a07:	e8 7f d5 ff ff       	call   f0100f8b <cprintf>
f0103a0c:	83 c4 10             	add    $0x10,%esp
f0103a0f:	eb 61                	jmp    f0103a72 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0103a11:	e8 59 eb ff ff       	call   f010256f <isUHeapPlacementStrategyBESTFIT>
f0103a16:	84 c0                	test   %al,%al
f0103a18:	74 12                	je     f0103a2c <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f0103a1a:	83 ec 0c             	sub    $0xc,%esp
f0103a1d:	68 8c 68 12 f0       	push   $0xf012688c
f0103a22:	e8 64 d5 ff ff       	call   f0100f8b <cprintf>
f0103a27:	83 c4 10             	add    $0x10,%esp
f0103a2a:	eb 46                	jmp    f0103a72 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103a2c:	e8 53 eb ff ff       	call   f0102584 <isUHeapPlacementStrategyNEXTFIT>
f0103a31:	84 c0                	test   %al,%al
f0103a33:	74 12                	je     f0103a47 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103a35:	83 ec 0c             	sub    $0xc,%esp
f0103a38:	68 b8 68 12 f0       	push   $0xf01268b8
f0103a3d:	e8 49 d5 ff ff       	call   f0100f8b <cprintf>
f0103a42:	83 c4 10             	add    $0x10,%esp
f0103a45:	eb 2b                	jmp    f0103a72 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f0103a47:	e8 4d eb ff ff       	call   f0102599 <isUHeapPlacementStrategyWORSTFIT>
f0103a4c:	84 c0                	test   %al,%al
f0103a4e:	74 12                	je     f0103a62 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0103a50:	83 ec 0c             	sub    $0xc,%esp
f0103a53:	68 e4 68 12 f0       	push   $0xf01268e4
f0103a58:	e8 2e d5 ff ff       	call   f0100f8b <cprintf>
f0103a5d:	83 c4 10             	add    $0x10,%esp
f0103a60:	eb 10                	jmp    f0103a72 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0103a62:	83 ec 0c             	sub    $0xc,%esp
f0103a65:	68 10 69 12 f0       	push   $0xf0126910
f0103a6a:	e8 1c d5 ff ff       	call   f0100f8b <cprintf>
f0103a6f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103a72:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a77:	c9                   	leave  
f0103a78:	c3                   	ret    

f0103a79 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103a79:	55                   	push   %ebp
f0103a7a:	89 e5                	mov    %esp,%ebp
f0103a7c:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103a7f:	e8 de e9 ff ff       	call   f0102462 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103a84:	83 ec 0c             	sub    $0xc,%esp
f0103a87:	68 3c 69 12 f0       	push   $0xf012693c
f0103a8c:	e8 fa d4 ff ff       	call   f0100f8b <cprintf>
f0103a91:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103a94:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a99:	c9                   	leave  
f0103a9a:	c3                   	ret    

f0103a9b <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103a9b:	55                   	push   %ebp
f0103a9c:	89 e5                	mov    %esp,%ebp
f0103a9e:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f0103aa1:	e8 cc e9 ff ff       	call   f0102472 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103aa6:	83 ec 0c             	sub    $0xc,%esp
f0103aa9:	68 3c 69 12 f0       	push   $0xf012693c
f0103aae:	e8 d8 d4 ff ff       	call   f0100f8b <cprintf>
f0103ab3:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ab6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103abb:	c9                   	leave  
f0103abc:	c3                   	ret    

f0103abd <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103abd:	55                   	push   %ebp
f0103abe:	89 e5                	mov    %esp,%ebp
f0103ac0:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103ac3:	e8 ba e9 ff ff       	call   f0102482 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103ac8:	83 ec 0c             	sub    $0xc,%esp
f0103acb:	68 70 69 12 f0       	push   $0xf0126970
f0103ad0:	e8 b6 d4 ff ff       	call   f0100f8b <cprintf>
f0103ad5:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ad8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103add:	c9                   	leave  
f0103ade:	c3                   	ret    

f0103adf <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103adf:	55                   	push   %ebp
f0103ae0:	89 e5                	mov    %esp,%ebp
f0103ae2:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103ae5:	e8 a8 e9 ff ff       	call   f0102492 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103aea:	83 ec 0c             	sub    $0xc,%esp
f0103aed:	68 a0 69 12 f0       	push   $0xf01269a0
f0103af2:	e8 94 d4 ff ff       	call   f0100f8b <cprintf>
f0103af7:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103afa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103aff:	c9                   	leave  
f0103b00:	c3                   	ret    

f0103b01 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103b01:	55                   	push   %ebp
f0103b02:	89 e5                	mov    %esp,%ebp
f0103b04:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103b07:	e8 96 e9 ff ff       	call   f01024a2 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103b0c:	83 ec 0c             	sub    $0xc,%esp
f0103b0f:	68 d0 69 12 f0       	push   $0xf01269d0
f0103b14:	e8 72 d4 ff ff       	call   f0100f8b <cprintf>
f0103b19:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b1c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b21:	c9                   	leave  
f0103b22:	c3                   	ret    

f0103b23 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103b23:	55                   	push   %ebp
f0103b24:	89 e5                	mov    %esp,%ebp
f0103b26:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f0103b29:	e8 84 e9 ff ff       	call   f01024b2 <isKHeapPlacementStrategyCONTALLOC>
f0103b2e:	84 c0                	test   %al,%al
f0103b30:	74 12                	je     f0103b44 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103b32:	83 ec 0c             	sub    $0xc,%esp
f0103b35:	68 04 6a 12 f0       	push   $0xf0126a04
f0103b3a:	e8 4c d4 ff ff       	call   f0100f8b <cprintf>
f0103b3f:	83 c4 10             	add    $0x10,%esp
f0103b42:	eb 7c                	jmp    f0103bc0 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103b44:	e8 7d e9 ff ff       	call   f01024c6 <isKHeapPlacementStrategyFIRSTFIT>
f0103b49:	84 c0                	test   %al,%al
f0103b4b:	74 12                	je     f0103b5f <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0103b4d:	83 ec 0c             	sub    $0xc,%esp
f0103b50:	68 40 6a 12 f0       	push   $0xf0126a40
f0103b55:	e8 31 d4 ff ff       	call   f0100f8b <cprintf>
f0103b5a:	83 c4 10             	add    $0x10,%esp
f0103b5d:	eb 61                	jmp    f0103bc0 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f0103b5f:	e8 77 e9 ff ff       	call   f01024db <isKHeapPlacementStrategyBESTFIT>
f0103b64:	84 c0                	test   %al,%al
f0103b66:	74 12                	je     f0103b7a <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0103b68:	83 ec 0c             	sub    $0xc,%esp
f0103b6b:	68 70 6a 12 f0       	push   $0xf0126a70
f0103b70:	e8 16 d4 ff ff       	call   f0100f8b <cprintf>
f0103b75:	83 c4 10             	add    $0x10,%esp
f0103b78:	eb 46                	jmp    f0103bc0 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103b7a:	e8 71 e9 ff ff       	call   f01024f0 <isKHeapPlacementStrategyNEXTFIT>
f0103b7f:	84 c0                	test   %al,%al
f0103b81:	74 12                	je     f0103b95 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0103b83:	83 ec 0c             	sub    $0xc,%esp
f0103b86:	68 9c 6a 12 f0       	push   $0xf0126a9c
f0103b8b:	e8 fb d3 ff ff       	call   f0100f8b <cprintf>
f0103b90:	83 c4 10             	add    $0x10,%esp
f0103b93:	eb 2b                	jmp    f0103bc0 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f0103b95:	e8 6b e9 ff ff       	call   f0102505 <isKHeapPlacementStrategyWORSTFIT>
f0103b9a:	84 c0                	test   %al,%al
f0103b9c:	74 12                	je     f0103bb0 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103b9e:	83 ec 0c             	sub    $0xc,%esp
f0103ba1:	68 c8 6a 12 f0       	push   $0xf0126ac8
f0103ba6:	e8 e0 d3 ff ff       	call   f0100f8b <cprintf>
f0103bab:	83 c4 10             	add    $0x10,%esp
f0103bae:	eb 10                	jmp    f0103bc0 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103bb0:	83 ec 0c             	sub    $0xc,%esp
f0103bb3:	68 f8 6a 12 f0       	push   $0xf0126af8
f0103bb8:	e8 ce d3 ff ff       	call   f0100f8b <cprintf>
f0103bbd:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103bc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bc5:	c9                   	leave  
f0103bc6:	c3                   	ret    

f0103bc7 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103bc7:	55                   	push   %ebp
f0103bc8:	89 e5                	mov    %esp,%ebp
f0103bca:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103bcd:	e8 65 c1 00 00       	call   f010fd37 <isBufferingEnabled>
f0103bd2:	84 c0                	test   %al,%al
f0103bd4:	75 12                	jne    f0103be8 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103bd6:	83 ec 0c             	sub    $0xc,%esp
f0103bd9:	68 28 6b 12 f0       	push   $0xf0126b28
f0103bde:	e8 a8 d3 ff ff       	call   f0100f8b <cprintf>
f0103be3:	83 c4 10             	add    $0x10,%esp
f0103be6:	eb 1d                	jmp    f0103c05 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103be8:	83 ec 0c             	sub    $0xc,%esp
f0103beb:	6a 00                	push   $0x0
f0103bed:	e8 1f c1 00 00       	call   f010fd11 <enableModifiedBuffer>
f0103bf2:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103bf5:	83 ec 0c             	sub    $0xc,%esp
f0103bf8:	68 64 6b 12 f0       	push   $0xf0126b64
f0103bfd:	e8 89 d3 ff ff       	call   f0100f8b <cprintf>
f0103c02:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c05:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c0a:	c9                   	leave  
f0103c0b:	c3                   	ret    

f0103c0c <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103c0c:	55                   	push   %ebp
f0103c0d:	89 e5                	mov    %esp,%ebp
f0103c0f:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103c12:	e8 20 c1 00 00       	call   f010fd37 <isBufferingEnabled>
f0103c17:	84 c0                	test   %al,%al
f0103c19:	75 12                	jne    f0103c2d <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103c1b:	83 ec 0c             	sub    $0xc,%esp
f0103c1e:	68 28 6b 12 f0       	push   $0xf0126b28
f0103c23:	e8 63 d3 ff ff       	call   f0100f8b <cprintf>
f0103c28:	83 c4 10             	add    $0x10,%esp
f0103c2b:	eb 1d                	jmp    f0103c4a <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103c2d:	83 ec 0c             	sub    $0xc,%esp
f0103c30:	6a 01                	push   $0x1
f0103c32:	e8 da c0 00 00       	call   f010fd11 <enableModifiedBuffer>
f0103c37:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103c3a:	83 ec 0c             	sub    $0xc,%esp
f0103c3d:	68 88 6b 12 f0       	push   $0xf0126b88
f0103c42:	e8 44 d3 ff ff       	call   f0100f8b <cprintf>
f0103c47:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103c4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c4f:	c9                   	leave  
f0103c50:	c3                   	ret    

f0103c51 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103c51:	55                   	push   %ebp
f0103c52:	89 e5                	mov    %esp,%ebp
f0103c54:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103c57:	83 ec 0c             	sub    $0xc,%esp
f0103c5a:	6a 00                	push   $0x0
f0103c5c:	e8 c8 c0 00 00       	call   f010fd29 <enableBuffering>
f0103c61:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103c64:	83 ec 0c             	sub    $0xc,%esp
f0103c67:	6a 00                	push   $0x0
f0103c69:	e8 a3 c0 00 00       	call   f010fd11 <enableModifiedBuffer>
f0103c6e:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103c71:	83 ec 0c             	sub    $0xc,%esp
f0103c74:	68 a8 6b 12 f0       	push   $0xf0126ba8
f0103c79:	e8 0d d3 ff ff       	call   f0100f8b <cprintf>
f0103c7e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103c81:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c86:	c9                   	leave  
f0103c87:	c3                   	ret    

f0103c88 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103c88:	55                   	push   %ebp
f0103c89:	89 e5                	mov    %esp,%ebp
f0103c8b:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103c8e:	83 ec 0c             	sub    $0xc,%esp
f0103c91:	6a 01                	push   $0x1
f0103c93:	e8 91 c0 00 00       	call   f010fd29 <enableBuffering>
f0103c98:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103c9b:	83 ec 0c             	sub    $0xc,%esp
f0103c9e:	6a 01                	push   $0x1
f0103ca0:	e8 6c c0 00 00       	call   f010fd11 <enableModifiedBuffer>
f0103ca5:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103ca8:	e8 a2 c0 00 00       	call   f010fd4f <getModifiedBufferLength>
f0103cad:	85 c0                	test   %eax,%eax
f0103caf:	75 59                	jne    f0103d0a <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103cb1:	83 ec 0c             	sub    $0xc,%esp
f0103cb4:	68 c4 6b 12 f0       	push   $0xf0126bc4
f0103cb9:	e8 cd d2 ff ff       	call   f0100f8b <cprintf>
f0103cbe:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103cc1:	83 ec 08             	sub    $0x8,%esp
f0103cc4:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103cc7:	50                   	push   %eax
f0103cc8:	68 f4 6b 12 f0       	push   $0xf0126bf4
f0103ccd:	e8 61 e0 01 00       	call   f0121d33 <readline>
f0103cd2:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103cd5:	83 ec 04             	sub    $0x4,%esp
f0103cd8:	6a 0a                	push   $0xa
f0103cda:	6a 00                	push   $0x0
f0103cdc:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103cdf:	50                   	push   %eax
f0103ce0:	e8 b6 e5 01 00       	call   f012229b <strtol>
f0103ce5:	83 c4 10             	add    $0x10,%esp
f0103ce8:	83 ec 0c             	sub    $0xc,%esp
f0103ceb:	50                   	push   %eax
f0103cec:	e8 50 c0 00 00       	call   f010fd41 <setModifiedBufferLength>
f0103cf1:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103cf4:	e8 56 c0 00 00       	call   f010fd4f <getModifiedBufferLength>
f0103cf9:	83 ec 08             	sub    $0x8,%esp
f0103cfc:	50                   	push   %eax
f0103cfd:	68 20 6c 12 f0       	push   $0xf0126c20
f0103d02:	e8 84 d2 ff ff       	call   f0100f8b <cprintf>
f0103d07:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103d0a:	83 ec 0c             	sub    $0xc,%esp
f0103d0d:	68 45 6c 12 f0       	push   $0xf0126c45
f0103d12:	e8 74 d2 ff ff       	call   f0100f8b <cprintf>
f0103d17:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d1f:	c9                   	leave  
f0103d20:	c3                   	ret    

f0103d21 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d21:	55                   	push   %ebp
f0103d22:	89 e5                	mov    %esp,%ebp
f0103d24:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103d27:	e8 0b c0 00 00       	call   f010fd37 <isBufferingEnabled>
f0103d2c:	84 c0                	test   %al,%al
f0103d2e:	75 12                	jne    f0103d42 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103d30:	83 ec 0c             	sub    $0xc,%esp
f0103d33:	68 60 6c 12 f0       	push   $0xf0126c60
f0103d38:	e8 4e d2 ff ff       	call   f0100f8b <cprintf>
f0103d3d:	83 c4 10             	add    $0x10,%esp
f0103d40:	eb 19                	jmp    f0103d5b <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103d42:	e8 d8 bf 00 00       	call   f010fd1f <isModifiedBufferEnabled>
f0103d47:	84 c0                	test   %al,%al
f0103d49:	75 10                	jne    f0103d5b <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103d4b:	83 ec 0c             	sub    $0xc,%esp
f0103d4e:	68 b0 6c 12 f0       	push   $0xf0126cb0
f0103d53:	e8 33 d2 ff ff       	call   f0100f8b <cprintf>
f0103d58:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103d5b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d5e:	83 c0 04             	add    $0x4,%eax
f0103d61:	8b 00                	mov    (%eax),%eax
f0103d63:	83 ec 04             	sub    $0x4,%esp
f0103d66:	6a 0a                	push   $0xa
f0103d68:	6a 00                	push   $0x0
f0103d6a:	50                   	push   %eax
f0103d6b:	e8 2b e5 01 00       	call   f012229b <strtol>
f0103d70:	83 c4 10             	add    $0x10,%esp
f0103d73:	83 ec 0c             	sub    $0xc,%esp
f0103d76:	50                   	push   %eax
f0103d77:	e8 c5 bf 00 00       	call   f010fd41 <setModifiedBufferLength>
f0103d7c:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103d7f:	e8 cb bf 00 00       	call   f010fd4f <getModifiedBufferLength>
f0103d84:	83 ec 08             	sub    $0x8,%esp
f0103d87:	50                   	push   %eax
f0103d88:	68 20 6c 12 f0       	push   $0xf0126c20
f0103d8d:	e8 f9 d1 ff ff       	call   f0100f8b <cprintf>
f0103d92:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103d95:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d9a:	c9                   	leave  
f0103d9b:	c3                   	ret    

f0103d9c <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103d9c:	55                   	push   %ebp
f0103d9d:	89 e5                	mov    %esp,%ebp
f0103d9f:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103da2:	e8 90 bf 00 00       	call   f010fd37 <isBufferingEnabled>
f0103da7:	84 c0                	test   %al,%al
f0103da9:	75 12                	jne    f0103dbd <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103dab:	83 ec 0c             	sub    $0xc,%esp
f0103dae:	68 60 6c 12 f0       	push   $0xf0126c60
f0103db3:	e8 d3 d1 ff ff       	call   f0100f8b <cprintf>
f0103db8:	83 c4 10             	add    $0x10,%esp
f0103dbb:	eb 19                	jmp    f0103dd6 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103dbd:	e8 5d bf 00 00       	call   f010fd1f <isModifiedBufferEnabled>
f0103dc2:	84 c0                	test   %al,%al
f0103dc4:	75 10                	jne    f0103dd6 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103dc6:	83 ec 0c             	sub    $0xc,%esp
f0103dc9:	68 b0 6c 12 f0       	push   $0xf0126cb0
f0103dce:	e8 b8 d1 ff ff       	call   f0100f8b <cprintf>
f0103dd3:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103dd6:	e8 74 bf 00 00       	call   f010fd4f <getModifiedBufferLength>
f0103ddb:	83 ec 08             	sub    $0x8,%esp
f0103dde:	50                   	push   %eax
f0103ddf:	68 f6 6c 12 f0       	push   $0xf0126cf6
f0103de4:	e8 a2 d1 ff ff       	call   f0100f8b <cprintf>
f0103de9:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103dec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103df1:	c9                   	leave  
f0103df2:	c3                   	ret    

f0103df3 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103df3:	55                   	push   %ebp
f0103df4:	89 e5                	mov    %esp,%ebp
f0103df6:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103df9:	83 ec 08             	sub    $0x8,%esp
f0103dfc:	ff 75 0c             	pushl  0xc(%ebp)
f0103dff:	ff 75 08             	pushl  0x8(%ebp)
f0103e02:	e8 d6 cf 00 00       	call   f0110ddd <tst_handler>
f0103e07:	83 c4 10             	add    $0x10,%esp
}
f0103e0a:	c9                   	leave  
f0103e0b:	c3                   	ret    

f0103e0c <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103e0c:	55                   	push   %ebp
f0103e0d:	89 e5                	mov    %esp,%ebp
f0103e0f:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e12:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e15:	05 00 14 00 00       	add    $0x1400,%eax
f0103e1a:	c1 e0 03             	shl    $0x3,%eax
f0103e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e20:	83 ec 04             	sub    $0x4,%esp
f0103e23:	6a 08                	push   $0x8
f0103e25:	ff 75 0c             	pushl  0xc(%ebp)
f0103e28:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e2b:	e8 f3 e8 01 00       	call   f0122723 <ide_read>
f0103e30:	83 c4 10             	add    $0x10,%esp
f0103e33:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103e36:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e39:	c9                   	leave  
f0103e3a:	c3                   	ret    

f0103e3b <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103e3b:	55                   	push   %ebp
f0103e3c:	89 e5                	mov    %esp,%ebp
f0103e3e:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103e41:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e44:	05 00 14 00 00       	add    $0x1400,%eax
f0103e49:	c1 e0 03             	shl    $0x3,%eax
f0103e4c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103e4f:	83 ec 04             	sub    $0x4,%esp
f0103e52:	6a 08                	push   $0x8
f0103e54:	ff 75 0c             	pushl  0xc(%ebp)
f0103e57:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e5a:	e8 04 ea 01 00       	call   f0122863 <ide_write>
f0103e5f:	83 c4 10             	add    $0x10,%esp
f0103e62:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103e65:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e69:	74 14                	je     f0103e7f <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103e6b:	83 ec 04             	sub    $0x4,%esp
f0103e6e:	68 14 6d 12 f0       	push   $0xf0126d14
f0103e73:	6a 2f                	push   $0x2f
f0103e75:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0103e7a:	e8 ba c4 ff ff       	call   f0100339 <_panic>
	return success;
f0103e7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103e82:	c9                   	leave  
f0103e83:	c3                   	ret    

f0103e84 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103e84:	55                   	push   %ebp
f0103e85:	89 e5                	mov    %esp,%ebp
f0103e87:	53                   	push   %ebx
f0103e88:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103e8b:	c7 05 c0 5e 74 f0 00 	movl   $0x0,0xf0745ec0
f0103e92:	00 00 00 
f0103e95:	c7 05 c4 5e 74 f0 00 	movl   $0x0,0xf0745ec4
f0103e9c:	00 00 00 
f0103e9f:	c7 05 cc 5e 74 f0 00 	movl   $0x0,0xf0745ecc
f0103ea6:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103ea9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103eb0:	e9 ef 00 00 00       	jmp    f0103fa4 <initialize_disk_page_file+0x120>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103eb5:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103ebb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103ebe:	89 d0                	mov    %edx,%eax
f0103ec0:	c1 e0 02             	shl    $0x2,%eax
f0103ec3:	01 d0                	add    %edx,%eax
f0103ec5:	c1 e0 03             	shl    $0x3,%eax
f0103ec8:	01 c8                	add    %ecx,%eax
f0103eca:	83 ec 0c             	sub    $0xc,%esp
f0103ecd:	50                   	push   %eax
f0103ece:	e8 b5 49 00 00       	call   f0108888 <initialize_frame_info>
f0103ed3:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103ed6:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103edc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103edf:	89 d0                	mov    %edx,%eax
f0103ee1:	c1 e0 02             	shl    $0x2,%eax
f0103ee4:	01 d0                	add    %edx,%eax
f0103ee6:	c1 e0 03             	shl    $0x3,%eax
f0103ee9:	01 c8                	add    %ecx,%eax
f0103eeb:	85 c0                	test   %eax,%eax
f0103eed:	75 14                	jne    f0103f03 <initialize_disk_page_file+0x7f>
f0103eef:	83 ec 04             	sub    $0x4,%esp
f0103ef2:	68 48 6d 12 f0       	push   $0xf0126d48
f0103ef7:	6a 56                	push   $0x56
f0103ef9:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0103efe:	e8 36 c4 ff ff       	call   f0100339 <_panic>
f0103f03:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103f09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f0c:	89 d0                	mov    %edx,%eax
f0103f0e:	c1 e0 02             	shl    $0x2,%eax
f0103f11:	01 d0                	add    %edx,%eax
f0103f13:	c1 e0 03             	shl    $0x3,%eax
f0103f16:	01 c8                	add    %ecx,%eax
f0103f18:	8b 15 c0 5e 74 f0    	mov    0xf0745ec0,%edx
f0103f1e:	89 10                	mov    %edx,(%eax)
f0103f20:	8b 00                	mov    (%eax),%eax
f0103f22:	85 c0                	test   %eax,%eax
f0103f24:	74 20                	je     f0103f46 <initialize_disk_page_file+0xc2>
f0103f26:	8b 15 c0 5e 74 f0    	mov    0xf0745ec0,%edx
f0103f2c:	8b 1d c0 55 74 f0    	mov    0xf07455c0,%ebx
f0103f32:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103f35:	89 c8                	mov    %ecx,%eax
f0103f37:	c1 e0 02             	shl    $0x2,%eax
f0103f3a:	01 c8                	add    %ecx,%eax
f0103f3c:	c1 e0 03             	shl    $0x3,%eax
f0103f3f:	01 d8                	add    %ebx,%eax
f0103f41:	89 42 04             	mov    %eax,0x4(%edx)
f0103f44:	eb 1a                	jmp    f0103f60 <initialize_disk_page_file+0xdc>
f0103f46:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103f4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f4f:	89 d0                	mov    %edx,%eax
f0103f51:	c1 e0 02             	shl    $0x2,%eax
f0103f54:	01 d0                	add    %edx,%eax
f0103f56:	c1 e0 03             	shl    $0x3,%eax
f0103f59:	01 c8                	add    %ecx,%eax
f0103f5b:	a3 c4 5e 74 f0       	mov    %eax,0xf0745ec4
f0103f60:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103f66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f69:	89 d0                	mov    %edx,%eax
f0103f6b:	c1 e0 02             	shl    $0x2,%eax
f0103f6e:	01 d0                	add    %edx,%eax
f0103f70:	c1 e0 03             	shl    $0x3,%eax
f0103f73:	01 c8                	add    %ecx,%eax
f0103f75:	a3 c0 5e 74 f0       	mov    %eax,0xf0745ec0
f0103f7a:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0103f80:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103f83:	89 d0                	mov    %edx,%eax
f0103f85:	c1 e0 02             	shl    $0x2,%eax
f0103f88:	01 d0                	add    %edx,%eax
f0103f8a:	c1 e0 03             	shl    $0x3,%eax
f0103f8d:	01 c8                	add    %ecx,%eax
f0103f8f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f96:	a1 cc 5e 74 f0       	mov    0xf0745ecc,%eax
f0103f9b:	40                   	inc    %eax
f0103f9c:	a3 cc 5e 74 f0       	mov    %eax,0xf0745ecc
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103fa1:	ff 45 f4             	incl   -0xc(%ebp)
f0103fa4:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103fab:	0f 8e 04 ff ff ff    	jle    f0103eb5 <initialize_disk_page_file+0x31>

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}

	init_spinlock(&DiskFrameLists.dfllock, "Disk FrameList Lock");
f0103fb1:	83 ec 08             	sub    $0x8,%esp
f0103fb4:	68 6b 6d 12 f0       	push   $0xf0126d6b
f0103fb9:	68 d0 5e 74 f0       	push   $0xf0745ed0
f0103fbe:	e8 f6 c7 00 00       	call   f01107b9 <init_spinlock>
f0103fc3:	83 c4 10             	add    $0x10,%esp
}
f0103fc6:	90                   	nop
f0103fc7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103fca:	c9                   	leave  
f0103fcb:	c3                   	ret    

f0103fcc <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103fcc:	55                   	push   %ebp
f0103fcd:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103fcf:	8b 45 08             	mov    0x8(%ebp),%eax
f0103fd2:	8b 15 c0 55 74 f0    	mov    0xf07455c0,%edx
f0103fd8:	29 d0                	sub    %edx,%eax
f0103fda:	c1 f8 03             	sar    $0x3,%eax
f0103fdd:	89 c2                	mov    %eax,%edx
f0103fdf:	89 d0                	mov    %edx,%eax
f0103fe1:	c1 e0 02             	shl    $0x2,%eax
f0103fe4:	01 d0                	add    %edx,%eax
f0103fe6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0103fed:	01 c8                	add    %ecx,%eax
f0103fef:	01 c0                	add    %eax,%eax
f0103ff1:	01 d0                	add    %edx,%eax
f0103ff3:	89 c1                	mov    %eax,%ecx
f0103ff5:	c1 e1 08             	shl    $0x8,%ecx
f0103ff8:	01 c8                	add    %ecx,%eax
f0103ffa:	89 c1                	mov    %eax,%ecx
f0103ffc:	c1 e1 10             	shl    $0x10,%ecx
f0103fff:	01 c8                	add    %ecx,%eax
f0104001:	c1 e0 02             	shl    $0x2,%eax
f0104004:	01 d0                	add    %edx,%eax
}
f0104006:	5d                   	pop    %ebp
f0104007:	c3                   	ret    

f0104008 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0104008:	55                   	push   %ebp
f0104009:	89 e5                	mov    %esp,%ebp
f010400b:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f010400e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104015:	83 ec 0c             	sub    $0xc,%esp
f0104018:	68 d0 5e 74 f0       	push   $0xf0745ed0
f010401d:	e8 c8 c7 00 00       	call   f01107ea <acquire_spinlock>
f0104022:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104025:	a1 c0 5e 74 f0       	mov    0xf0745ec0,%eax
f010402a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f010402d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104031:	75 0c                	jne    f010403f <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104033:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f010403a:	e9 a2 00 00 00       	jmp    f01040e1 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f010403f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104043:	75 14                	jne    f0104059 <allocate_disk_frame+0x51>
f0104045:	83 ec 04             	sub    $0x4,%esp
f0104048:	68 7f 6d 12 f0       	push   $0xf0126d7f
f010404d:	6a 7d                	push   $0x7d
f010404f:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104054:	e8 e0 c2 ff ff       	call   f0100339 <_panic>
f0104059:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010405c:	8b 00                	mov    (%eax),%eax
f010405e:	85 c0                	test   %eax,%eax
f0104060:	74 10                	je     f0104072 <allocate_disk_frame+0x6a>
f0104062:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104065:	8b 00                	mov    (%eax),%eax
f0104067:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010406a:	8b 52 04             	mov    0x4(%edx),%edx
f010406d:	89 50 04             	mov    %edx,0x4(%eax)
f0104070:	eb 0b                	jmp    f010407d <allocate_disk_frame+0x75>
f0104072:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104075:	8b 40 04             	mov    0x4(%eax),%eax
f0104078:	a3 c4 5e 74 f0       	mov    %eax,0xf0745ec4
f010407d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104080:	8b 40 04             	mov    0x4(%eax),%eax
f0104083:	85 c0                	test   %eax,%eax
f0104085:	74 0f                	je     f0104096 <allocate_disk_frame+0x8e>
f0104087:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010408a:	8b 40 04             	mov    0x4(%eax),%eax
f010408d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104090:	8b 12                	mov    (%edx),%edx
f0104092:	89 10                	mov    %edx,(%eax)
f0104094:	eb 0a                	jmp    f01040a0 <allocate_disk_frame+0x98>
f0104096:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104099:	8b 00                	mov    (%eax),%eax
f010409b:	a3 c0 5e 74 f0       	mov    %eax,0xf0745ec0
f01040a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01040a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01040a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01040ac:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01040b3:	a1 cc 5e 74 f0       	mov    0xf0745ecc,%eax
f01040b8:	48                   	dec    %eax
f01040b9:	a3 cc 5e 74 f0       	mov    %eax,0xf0745ecc
			initialize_frame_info(ptr_frame_info);
f01040be:	83 ec 0c             	sub    $0xc,%esp
f01040c1:	ff 75 f0             	pushl  -0x10(%ebp)
f01040c4:	e8 bf 47 00 00       	call   f0108888 <initialize_frame_info>
f01040c9:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f01040cc:	83 ec 0c             	sub    $0xc,%esp
f01040cf:	ff 75 f0             	pushl  -0x10(%ebp)
f01040d2:	e8 f5 fe ff ff       	call   f0103fcc <to_disk_frame_number>
f01040d7:	83 c4 10             	add    $0x10,%esp
f01040da:	89 c2                	mov    %eax,%edx
f01040dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01040df:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01040e1:	83 ec 0c             	sub    $0xc,%esp
f01040e4:	68 d0 5e 74 f0       	push   $0xf0745ed0
f01040e9:	e8 83 c7 00 00       	call   f0110871 <release_spinlock>
f01040ee:	83 c4 10             	add    $0x10,%esp

	return ret;
f01040f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01040f4:	c9                   	leave  
f01040f5:	c3                   	ret    

f01040f6 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f01040f6:	55                   	push   %ebp
f01040f7:	89 e5                	mov    %esp,%ebp
f01040f9:	53                   	push   %ebx
f01040fa:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f01040fd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104101:	0f 84 f0 00 00 00    	je     f01041f7 <free_disk_frame+0x101>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104107:	83 ec 0c             	sub    $0xc,%esp
f010410a:	68 d0 5e 74 f0       	push   $0xf0745ed0
f010410f:	e8 d6 c6 00 00       	call   f01107ea <acquire_spinlock>
f0104114:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0104117:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f010411d:	8b 55 08             	mov    0x8(%ebp),%edx
f0104120:	89 d0                	mov    %edx,%eax
f0104122:	c1 e0 02             	shl    $0x2,%eax
f0104125:	01 d0                	add    %edx,%eax
f0104127:	c1 e0 03             	shl    $0x3,%eax
f010412a:	01 c8                	add    %ecx,%eax
f010412c:	85 c0                	test   %eax,%eax
f010412e:	75 17                	jne    f0104147 <free_disk_frame+0x51>
f0104130:	83 ec 04             	sub    $0x4,%esp
f0104133:	68 48 6d 12 f0       	push   $0xf0126d48
f0104138:	68 90 00 00 00       	push   $0x90
f010413d:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104142:	e8 f2 c1 ff ff       	call   f0100339 <_panic>
f0104147:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f010414d:	8b 55 08             	mov    0x8(%ebp),%edx
f0104150:	89 d0                	mov    %edx,%eax
f0104152:	c1 e0 02             	shl    $0x2,%eax
f0104155:	01 d0                	add    %edx,%eax
f0104157:	c1 e0 03             	shl    $0x3,%eax
f010415a:	01 c8                	add    %ecx,%eax
f010415c:	8b 15 c0 5e 74 f0    	mov    0xf0745ec0,%edx
f0104162:	89 10                	mov    %edx,(%eax)
f0104164:	8b 00                	mov    (%eax),%eax
f0104166:	85 c0                	test   %eax,%eax
f0104168:	74 20                	je     f010418a <free_disk_frame+0x94>
f010416a:	8b 15 c0 5e 74 f0    	mov    0xf0745ec0,%edx
f0104170:	8b 1d c0 55 74 f0    	mov    0xf07455c0,%ebx
f0104176:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104179:	89 c8                	mov    %ecx,%eax
f010417b:	c1 e0 02             	shl    $0x2,%eax
f010417e:	01 c8                	add    %ecx,%eax
f0104180:	c1 e0 03             	shl    $0x3,%eax
f0104183:	01 d8                	add    %ebx,%eax
f0104185:	89 42 04             	mov    %eax,0x4(%edx)
f0104188:	eb 1a                	jmp    f01041a4 <free_disk_frame+0xae>
f010418a:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f0104190:	8b 55 08             	mov    0x8(%ebp),%edx
f0104193:	89 d0                	mov    %edx,%eax
f0104195:	c1 e0 02             	shl    $0x2,%eax
f0104198:	01 d0                	add    %edx,%eax
f010419a:	c1 e0 03             	shl    $0x3,%eax
f010419d:	01 c8                	add    %ecx,%eax
f010419f:	a3 c4 5e 74 f0       	mov    %eax,0xf0745ec4
f01041a4:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f01041aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01041ad:	89 d0                	mov    %edx,%eax
f01041af:	c1 e0 02             	shl    $0x2,%eax
f01041b2:	01 d0                	add    %edx,%eax
f01041b4:	c1 e0 03             	shl    $0x3,%eax
f01041b7:	01 c8                	add    %ecx,%eax
f01041b9:	a3 c0 5e 74 f0       	mov    %eax,0xf0745ec0
f01041be:	8b 0d c0 55 74 f0    	mov    0xf07455c0,%ecx
f01041c4:	8b 55 08             	mov    0x8(%ebp),%edx
f01041c7:	89 d0                	mov    %edx,%eax
f01041c9:	c1 e0 02             	shl    $0x2,%eax
f01041cc:	01 d0                	add    %edx,%eax
f01041ce:	c1 e0 03             	shl    $0x3,%eax
f01041d1:	01 c8                	add    %ecx,%eax
f01041d3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01041da:	a1 cc 5e 74 f0       	mov    0xf0745ecc,%eax
f01041df:	40                   	inc    %eax
f01041e0:	a3 cc 5e 74 f0       	mov    %eax,0xf0745ecc
	}
	release_spinlock(&DiskFrameLists.dfllock);
f01041e5:	83 ec 0c             	sub    $0xc,%esp
f01041e8:	68 d0 5e 74 f0       	push   $0xf0745ed0
f01041ed:	e8 7f c6 00 00       	call   f0110871 <release_spinlock>
f01041f2:	83 c4 10             	add    $0x10,%esp
f01041f5:	eb 01                	jmp    f01041f8 <free_disk_frame+0x102>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f01041f7:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f01041f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01041fb:	c9                   	leave  
f01041fc:	c3                   	ret    

f01041fd <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f01041fd:	55                   	push   %ebp
f01041fe:	89 e5                	mov    %esp,%ebp
f0104200:	53                   	push   %ebx
f0104201:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0104204:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104207:	c1 e8 16             	shr    $0x16,%eax
f010420a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104211:	8b 45 08             	mov    0x8(%ebp),%eax
f0104214:	01 d0                	add    %edx,%eax
f0104216:	8b 00                	mov    (%eax),%eax
f0104218:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010421b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104222:	77 1d                	ja     f0104241 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f0104224:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104227:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010422c:	83 ec 0c             	sub    $0xc,%esp
f010422f:	50                   	push   %eax
f0104230:	e8 5d 5e 00 00       	call   f010a092 <kheap_virtual_address>
f0104235:	83 c4 10             	add    $0x10,%esp
f0104238:	89 c2                	mov    %eax,%edx
f010423a:	8b 45 14             	mov    0x14(%ebp),%eax
f010423d:	89 10                	mov    %edx,(%eax)
f010423f:	eb 44                	jmp    f0104285 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104241:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104244:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104249:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010424c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010424f:	c1 e8 0c             	shr    $0xc,%eax
f0104252:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104255:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f010425a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010425d:	72 17                	jb     f0104276 <get_disk_page_table+0x79>
f010425f:	ff 75 f0             	pushl  -0x10(%ebp)
f0104262:	68 a0 6d 12 f0       	push   $0xf0126da0
f0104267:	68 9f 00 00 00       	push   $0x9f
f010426c:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104271:	e8 c3 c0 ff ff       	call   f0100339 <_panic>
f0104276:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104279:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010427e:	89 c2                	mov    %eax,%edx
f0104280:	8b 45 14             	mov    0x14(%ebp),%eax
f0104283:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0104285:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104289:	0f 85 80 00 00 00    	jne    f010430f <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010428f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0104293:	74 6a                	je     f01042ff <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0104295:	83 ec 0c             	sub    $0xc,%esp
f0104298:	68 00 10 00 00       	push   $0x1000
f010429d:	e8 c8 59 00 00       	call   f0109c6a <kmalloc>
f01042a2:	83 c4 10             	add    $0x10,%esp
f01042a5:	89 c2                	mov    %eax,%edx
f01042a7:	8b 45 14             	mov    0x14(%ebp),%eax
f01042aa:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f01042ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01042af:	8b 00                	mov    (%eax),%eax
f01042b1:	85 c0                	test   %eax,%eax
f01042b3:	75 07                	jne    f01042bc <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f01042b5:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01042ba:	eb 58                	jmp    f0104314 <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01042bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042bf:	c1 e8 16             	shr    $0x16,%eax
f01042c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01042cc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01042cf:	8b 45 14             	mov    0x14(%ebp),%eax
f01042d2:	8b 00                	mov    (%eax),%eax
f01042d4:	83 ec 0c             	sub    $0xc,%esp
f01042d7:	50                   	push   %eax
f01042d8:	e8 24 5d 00 00       	call   f010a001 <kheap_physical_address>
f01042dd:	83 c4 10             	add    $0x10,%esp
f01042e0:	83 c8 01             	or     $0x1,%eax
f01042e3:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f01042e5:	8b 45 14             	mov    0x14(%ebp),%eax
f01042e8:	8b 00                	mov    (%eax),%eax
f01042ea:	83 ec 04             	sub    $0x4,%esp
f01042ed:	68 00 10 00 00       	push   $0x1000
f01042f2:	6a 00                	push   $0x0
f01042f4:	50                   	push   %eax
f01042f5:	e8 2f de 01 00       	call   f0122129 <memset>
f01042fa:	83 c4 10             	add    $0x10,%esp
f01042fd:	eb 10                	jmp    f010430f <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01042ff:	8b 45 14             	mov    0x14(%ebp),%eax
f0104302:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f0104308:	b8 00 00 00 00       	mov    $0x0,%eax
f010430d:	eb 05                	jmp    f0104314 <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f010430f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104314:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104317:	c9                   	leave  
f0104318:	c3                   	ret    

f0104319 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0104319:	55                   	push   %ebp
f010431a:	89 e5                	mov    %esp,%ebp
f010431c:	83 ec 28             	sub    $0x28,%esp
f010431f:	8b 45 10             	mov    0x10(%ebp),%eax
f0104322:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0104325:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0104329:	74 72                	je     f010439d <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f010432b:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0104332:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104335:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010433a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010433d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104340:	ba 00 00 00 00       	mov    $0x0,%edx
f0104345:	f7 75 f4             	divl   -0xc(%ebp)
f0104348:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010434b:	29 d0                	sub    %edx,%eax
f010434d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104350:	73 2f                	jae    f0104381 <pf_add_empty_env_page+0x68>
f0104352:	8b 45 08             	mov    0x8(%ebp),%eax
f0104355:	8b 50 6c             	mov    0x6c(%eax),%edx
f0104358:	b8 00 00 00 00       	mov    $0x0,%eax
f010435d:	29 d0                	sub    %edx,%eax
f010435f:	c1 e0 0c             	shl    $0xc,%eax
f0104362:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0104367:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010436a:	76 15                	jbe    f0104381 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f010436c:	8b 45 08             	mov    0x8(%ebp),%eax
f010436f:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f0104375:	8d 50 01             	lea    0x1(%eax),%edx
f0104378:	8b 45 08             	mov    0x8(%ebp),%eax
f010437b:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0104381:	a1 94 5d 74 f0       	mov    0xf0745d94,%eax
f0104386:	83 ec 04             	sub    $0x4,%esp
f0104389:	50                   	push   %eax
f010438a:	ff 75 0c             	pushl  0xc(%ebp)
f010438d:	ff 75 08             	pushl  0x8(%ebp)
f0104390:	e8 b5 00 00 00       	call   f010444a <pf_add_env_page>
f0104395:	83 c4 10             	add    $0x10,%esp
f0104398:	e9 ab 00 00 00       	jmp    f0104448 <pf_add_empty_env_page+0x12f>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010439d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01043a4:	76 19                	jbe    f01043bf <pf_add_empty_env_page+0xa6>
f01043a6:	68 d0 6d 12 f0       	push   $0xf0126dd0
f01043ab:	68 f6 6d 12 f0       	push   $0xf0126df6
f01043b0:	68 de 00 00 00       	push   $0xde
f01043b5:	68 2b 6d 12 f0       	push   $0xf0126d2b
f01043ba:	e8 7a bf ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01043bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01043c2:	83 e8 80             	sub    $0xffffff80,%eax
f01043c5:	83 ec 08             	sub    $0x8,%esp
f01043c8:	50                   	push   %eax
f01043c9:	ff 75 08             	pushl  0x8(%ebp)
f01043cc:	e8 c2 05 00 00       	call   f0104993 <get_disk_page_directory>
f01043d1:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f01043d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01043d7:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01043dd:	8d 55 ec             	lea    -0x14(%ebp),%edx
f01043e0:	52                   	push   %edx
f01043e1:	6a 01                	push   $0x1
f01043e3:	ff 75 0c             	pushl  0xc(%ebp)
f01043e6:	50                   	push   %eax
f01043e7:	e8 11 fe ff ff       	call   f01041fd <get_disk_page_table>
f01043ec:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01043ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01043f2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01043f5:	c1 ea 0c             	shr    $0xc,%edx
f01043f8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01043fe:	c1 e2 02             	shl    $0x2,%edx
f0104401:	01 d0                	add    %edx,%eax
f0104403:	8b 00                	mov    (%eax),%eax
f0104405:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f0104408:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010440b:	85 c0                	test   %eax,%eax
f010440d:	75 34                	jne    f0104443 <pf_add_empty_env_page+0x12a>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010440f:	83 ec 0c             	sub    $0xc,%esp
f0104412:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0104415:	50                   	push   %eax
f0104416:	e8 ed fb ff ff       	call   f0104008 <allocate_disk_frame>
f010441b:	83 c4 10             	add    $0x10,%esp
f010441e:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104421:	75 07                	jne    f010442a <pf_add_empty_env_page+0x111>
f0104423:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104428:	eb 1e                	jmp    f0104448 <pf_add_empty_env_page+0x12f>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f010442a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010442d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104430:	c1 ea 0c             	shr    $0xc,%edx
f0104433:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104439:	c1 e2 02             	shl    $0x2,%edx
f010443c:	01 c2                	add    %eax,%edx
f010443e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104441:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0104443:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0104448:	c9                   	leave  
f0104449:	c3                   	ret    

f010444a <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f010444a:	55                   	push   %ebp
f010444b:	89 e5                	mov    %esp,%ebp
f010444d:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104450:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104457:	76 19                	jbe    f0104472 <pf_add_env_page+0x28>
f0104459:	68 d0 6d 12 f0       	push   $0xf0126dd0
f010445e:	68 f6 6d 12 f0       	push   $0xf0126df6
f0104463:	68 f3 00 00 00       	push   $0xf3
f0104468:	68 2b 6d 12 f0       	push   $0xf0126d2b
f010446d:	e8 c7 be ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104472:	8b 45 08             	mov    0x8(%ebp),%eax
f0104475:	83 e8 80             	sub    $0xffffff80,%eax
f0104478:	83 ec 08             	sub    $0x8,%esp
f010447b:	50                   	push   %eax
f010447c:	ff 75 08             	pushl  0x8(%ebp)
f010447f:	e8 0f 05 00 00       	call   f0104993 <get_disk_page_directory>
f0104484:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0104487:	8b 45 08             	mov    0x8(%ebp),%eax
f010448a:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104490:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104493:	52                   	push   %edx
f0104494:	6a 01                	push   $0x1
f0104496:	ff 75 0c             	pushl  0xc(%ebp)
f0104499:	50                   	push   %eax
f010449a:	e8 5e fd ff ff       	call   f01041fd <get_disk_page_table>
f010449f:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01044a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044a5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044a8:	c1 ea 0c             	shr    $0xc,%edx
f01044ab:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044b1:	c1 e2 02             	shl    $0x2,%edx
f01044b4:	01 d0                	add    %edx,%eax
f01044b6:	8b 00                	mov    (%eax),%eax
f01044b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f01044bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044be:	85 c0                	test   %eax,%eax
f01044c0:	75 34                	jne    f01044f6 <pf_add_env_page+0xac>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01044c2:	83 ec 0c             	sub    $0xc,%esp
f01044c5:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01044c8:	50                   	push   %eax
f01044c9:	e8 3a fb ff ff       	call   f0104008 <allocate_disk_frame>
f01044ce:	83 c4 10             	add    $0x10,%esp
f01044d1:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01044d4:	75 07                	jne    f01044dd <pf_add_env_page+0x93>
f01044d6:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01044db:	eb 31                	jmp    f010450e <pf_add_env_page+0xc4>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01044dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01044e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044e3:	c1 ea 0c             	shr    $0xc,%edx
f01044e6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044ec:	c1 e2 02             	shl    $0x2,%edx
f01044ef:	01 c2                	add    %eax,%edx
f01044f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044f4:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01044f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01044f9:	83 ec 08             	sub    $0x8,%esp
f01044fc:	ff 75 10             	pushl  0x10(%ebp)
f01044ff:	50                   	push   %eax
f0104500:	e8 36 f9 ff ff       	call   f0103e3b <write_disk_page>
f0104505:	83 c4 10             	add    $0x10,%esp
f0104508:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f010450b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010450e:	c9                   	leave  
f010450f:	c3                   	ret    

f0104510 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f0104510:	55                   	push   %ebp
f0104511:	89 e5                	mov    %esp,%ebp
f0104513:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f0104516:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010451d:	76 19                	jbe    f0104538 <pf_update_env_page+0x28>
f010451f:	68 d0 6d 12 f0       	push   $0xf0126dd0
f0104524:	68 f6 6d 12 f0       	push   $0xf0126df6
f0104529:	68 15 01 00 00       	push   $0x115
f010452e:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104533:	e8 01 be ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104538:	8b 45 08             	mov    0x8(%ebp),%eax
f010453b:	83 e8 80             	sub    $0xffffff80,%eax
f010453e:	83 ec 08             	sub    $0x8,%esp
f0104541:	50                   	push   %eax
f0104542:	ff 75 08             	pushl  0x8(%ebp)
f0104545:	e8 49 04 00 00       	call   f0104993 <get_disk_page_directory>
f010454a:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f010454d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104550:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104556:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104559:	52                   	push   %edx
f010455a:	6a 00                	push   $0x0
f010455c:	ff 75 0c             	pushl  0xc(%ebp)
f010455f:	50                   	push   %eax
f0104560:	e8 98 fc ff ff       	call   f01041fd <get_disk_page_table>
f0104565:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0104568:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010456b:	85 c0                	test   %eax,%eax
f010456d:	74 29                	je     f0104598 <pf_update_env_page+0x88>
f010456f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104572:	85 c0                	test   %eax,%eax
f0104574:	0f 84 bf 00 00 00    	je     f0104639 <pf_update_env_page+0x129>
f010457a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010457d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104580:	c1 ea 0c             	shr    $0xc,%edx
f0104583:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104589:	c1 e2 02             	shl    $0x2,%edx
f010458c:	01 d0                	add    %edx,%eax
f010458e:	8b 00                	mov    (%eax),%eax
f0104590:	85 c0                	test   %eax,%eax
f0104592:	0f 85 a1 00 00 00    	jne    f0104639 <pf_update_env_page+0x129>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0104598:	8b 45 0c             	mov    0xc(%ebp),%eax
f010459b:	85 c0                	test   %eax,%eax
f010459d:	79 09                	jns    f01045a8 <pf_update_env_page+0x98>
f010459f:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f01045a6:	76 30                	jbe    f01045d8 <pf_update_env_page+0xc8>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01045a8:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01045af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01045b2:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01045b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01045ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045bd:	ba 00 00 00 00       	mov    $0x0,%edx
f01045c2:	f7 75 f4             	divl   -0xc(%ebp)
f01045c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045c8:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f01045ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01045cd:	77 53                	ja     f0104622 <pf_update_env_page+0x112>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f01045cf:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f01045d6:	77 4a                	ja     f0104622 <pf_update_env_page+0x112>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f01045d8:	83 ec 04             	sub    $0x4,%esp
f01045db:	6a 00                	push   $0x0
f01045dd:	ff 75 0c             	pushl  0xc(%ebp)
f01045e0:	ff 75 08             	pushl  0x8(%ebp)
f01045e3:	e8 31 fd ff ff       	call   f0104319 <pf_add_empty_env_page>
f01045e8:	83 c4 10             	add    $0x10,%esp
f01045eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f01045ee:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f01045f2:	75 17                	jne    f010460b <pf_update_env_page+0xfb>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f01045f4:	83 ec 04             	sub    $0x4,%esp
f01045f7:	68 0c 6e 12 f0       	push   $0xf0126e0c
f01045fc:	68 45 01 00 00       	push   $0x145
f0104601:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104606:	e8 2e bd ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f010460b:	8b 45 08             	mov    0x8(%ebp),%eax
f010460e:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f0104614:	8d 50 01             	lea    0x1(%eax),%edx
f0104617:	8b 45 08             	mov    0x8(%ebp),%eax
f010461a:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
f0104620:	eb 17                	jmp    f0104639 <pf_update_env_page+0x129>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0104622:	83 ec 04             	sub    $0x4,%esp
f0104625:	68 58 6e 12 f0       	push   $0xf0126e58
f010462a:	68 4e 01 00 00       	push   $0x14e
f010462f:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104634:	e8 00 bd ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104639:	8b 45 08             	mov    0x8(%ebp),%eax
f010463c:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104642:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0104645:	52                   	push   %edx
f0104646:	6a 00                	push   $0x0
f0104648:	ff 75 0c             	pushl  0xc(%ebp)
f010464b:	50                   	push   %eax
f010464c:	e8 ac fb ff ff       	call   f01041fd <get_disk_page_table>
f0104651:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104654:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104657:	8b 55 0c             	mov    0xc(%ebp),%edx
f010465a:	c1 ea 0c             	shr    $0xc,%edx
f010465d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104663:	c1 e2 02             	shl    $0x2,%edx
f0104666:	01 d0                	add    %edx,%eax
f0104668:	8b 00                	mov    (%eax),%eax
f010466a:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f010466d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104670:	8b 40 64             	mov    0x64(%eax),%eax
f0104673:	6a 00                	push   $0x0
f0104675:	68 00 f0 3f 00       	push   $0x3ff000
f010467a:	ff 75 10             	pushl  0x10(%ebp)
f010467d:	50                   	push   %eax
f010467e:	e8 ed 46 00 00       	call   f0108d70 <map_frame>
f0104683:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f0104686:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f010468d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104690:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104695:	83 ec 08             	sub    $0x8,%esp
f0104698:	50                   	push   %eax
f0104699:	ff 75 e8             	pushl  -0x18(%ebp)
f010469c:	e8 9a f7 ff ff       	call   f0103e3b <write_disk_page>
f01046a1:	83 c4 10             	add    $0x10,%esp
f01046a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f01046a7:	8b 45 10             	mov    0x10(%ebp),%eax
f01046aa:	8b 40 08             	mov    0x8(%eax),%eax
f01046ad:	40                   	inc    %eax
f01046ae:	8b 55 10             	mov    0x10(%ebp),%edx
f01046b1:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f01046b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01046b8:	8b 40 64             	mov    0x64(%eax),%eax
f01046bb:	83 ec 08             	sub    $0x8,%esp
f01046be:	68 00 f0 3f 00       	push   $0x3ff000
f01046c3:	50                   	push   %eax
f01046c4:	e8 10 48 00 00       	call   f0108ed9 <unmap_frame>
f01046c9:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f01046cc:	8b 45 10             	mov    0x10(%ebp),%eax
f01046cf:	8b 40 08             	mov    0x8(%eax),%eax
f01046d2:	48                   	dec    %eax
f01046d3:	8b 55 10             	mov    0x10(%ebp),%edx
f01046d6:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01046da:	8b 45 08             	mov    0x8(%ebp),%eax
f01046dd:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f01046e3:	8d 50 01             	lea    0x1(%eax),%edx
f01046e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01046e9:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
	//======================

	return ret;
f01046ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01046f2:	c9                   	leave  
f01046f3:	c3                   	ret    

f01046f4 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01046f4:	55                   	push   %ebp
f01046f5:	89 e5                	mov    %esp,%ebp
f01046f7:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01046fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01046fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104700:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104703:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104708:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010470b:	8b 45 08             	mov    0x8(%ebp),%eax
f010470e:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104714:	85 c0                	test   %eax,%eax
f0104716:	75 0a                	jne    f0104722 <pf_read_env_page+0x2e>
f0104718:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010471d:	e9 93 00 00 00       	jmp    f01047b5 <pf_read_env_page+0xc1>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104722:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104725:	8b 45 08             	mov    0x8(%ebp),%eax
f0104728:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010472e:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f0104731:	51                   	push   %ecx
f0104732:	6a 00                	push   $0x0
f0104734:	52                   	push   %edx
f0104735:	50                   	push   %eax
f0104736:	e8 c2 fa ff ff       	call   f01041fd <get_disk_page_table>
f010473b:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010473e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104741:	85 c0                	test   %eax,%eax
f0104743:	75 07                	jne    f010474c <pf_read_env_page+0x58>
f0104745:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010474a:	eb 69                	jmp    f01047b5 <pf_read_env_page+0xc1>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010474c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010474f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104752:	c1 ea 0c             	shr    $0xc,%edx
f0104755:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010475b:	c1 e2 02             	shl    $0x2,%edx
f010475e:	01 d0                	add    %edx,%eax
f0104760:	8b 00                	mov    (%eax),%eax
f0104762:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104765:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104769:	75 07                	jne    f0104772 <pf_read_env_page+0x7e>
f010476b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104770:	eb 43                	jmp    f01047b5 <pf_read_env_page+0xc1>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0104772:	83 ec 08             	sub    $0x8,%esp
f0104775:	ff 75 0c             	pushl  0xc(%ebp)
f0104778:	ff 75 f0             	pushl  -0x10(%ebp)
f010477b:	e8 8c f6 ff ff       	call   f0103e0c <read_disk_page>
f0104780:	83 c4 10             	add    $0x10,%esp
f0104783:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104786:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104789:	8b 45 08             	mov    0x8(%ebp),%eax
f010478c:	8b 40 64             	mov    0x64(%eax),%eax
f010478f:	6a 40                	push   $0x40
f0104791:	6a 00                	push   $0x0
f0104793:	52                   	push   %edx
f0104794:	50                   	push   %eax
f0104795:	e8 98 59 00 00       	call   f010a132 <pt_set_page_permissions>
f010479a:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010479d:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a0:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f01047a6:	8d 50 01             	lea    0x1(%eax),%edx
f01047a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01047ac:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
	//======================

	return disk_read_error;
f01047b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01047b5:	c9                   	leave  
f01047b6:	c3                   	ret    

f01047b7 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01047b7:	55                   	push   %ebp
f01047b8:	89 e5                	mov    %esp,%ebp
f01047ba:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01047bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01047c0:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047c6:	85 c0                	test   %eax,%eax
f01047c8:	74 65                	je     f010482f <pf_remove_env_page+0x78>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01047ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01047cd:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01047d3:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01047d6:	52                   	push   %edx
f01047d7:	6a 00                	push   $0x0
f01047d9:	ff 75 0c             	pushl  0xc(%ebp)
f01047dc:	50                   	push   %eax
f01047dd:	e8 1b fa ff ff       	call   f01041fd <get_disk_page_table>
f01047e2:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01047e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047e8:	85 c0                	test   %eax,%eax
f01047ea:	74 46                	je     f0104832 <pf_remove_env_page+0x7b>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01047ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01047ef:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047f2:	c1 ea 0c             	shr    $0xc,%edx
f01047f5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01047fb:	c1 e2 02             	shl    $0x2,%edx
f01047fe:	01 d0                	add    %edx,%eax
f0104800:	8b 00                	mov    (%eax),%eax
f0104802:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f0104805:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104808:	8b 55 0c             	mov    0xc(%ebp),%edx
f010480b:	c1 ea 0c             	shr    $0xc,%edx
f010480e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104814:	c1 e2 02             	shl    $0x2,%edx
f0104817:	01 d0                	add    %edx,%eax
f0104819:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010481f:	83 ec 0c             	sub    $0xc,%esp
f0104822:	ff 75 f4             	pushl  -0xc(%ebp)
f0104825:	e8 cc f8 ff ff       	call   f01040f6 <free_disk_frame>
f010482a:	83 c4 10             	add    $0x10,%esp
f010482d:	eb 04                	jmp    f0104833 <pf_remove_env_page+0x7c>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010482f:	90                   	nop
f0104830:	eb 01                	jmp    f0104833 <pf_remove_env_page+0x7c>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f0104832:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104833:	c9                   	leave  
f0104834:	c3                   	ret    

f0104835 <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f0104835:	55                   	push   %ebp
f0104836:	89 e5                	mov    %esp,%ebp
f0104838:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010483b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104842:	e9 c1 00 00 00       	jmp    f0104908 <pf_free_env+0xd3>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f0104847:	8b 45 08             	mov    0x8(%ebp),%eax
f010484a:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104850:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104853:	c1 e2 02             	shl    $0x2,%edx
f0104856:	01 d0                	add    %edx,%eax
f0104858:	8b 00                	mov    (%eax),%eax
f010485a:	83 e0 01             	and    $0x1,%eax
f010485d:	85 c0                	test   %eax,%eax
f010485f:	0f 84 9f 00 00 00    	je     f0104904 <pf_free_env+0xcf>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104865:	8b 45 08             	mov    0x8(%ebp),%eax
f0104868:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010486e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104871:	c1 e2 02             	shl    $0x2,%edx
f0104874:	01 d0                	add    %edx,%eax
f0104876:	8b 00                	mov    (%eax),%eax
f0104878:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010487d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0104880:	83 ec 0c             	sub    $0xc,%esp
f0104883:	ff 75 ec             	pushl  -0x14(%ebp)
f0104886:	e8 07 58 00 00       	call   f010a092 <kheap_virtual_address>
f010488b:	83 c4 10             	add    $0x10,%esp
f010488e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104898:	eb 3a                	jmp    f01048d4 <pf_free_env+0x9f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010489a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010489d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01048a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01048a7:	01 d0                	add    %edx,%eax
f01048a9:	8b 00                	mov    (%eax),%eax
f01048ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f01048ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01048b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01048b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01048bb:	01 d0                	add    %edx,%eax
f01048bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01048c3:	83 ec 0c             	sub    $0xc,%esp
f01048c6:	ff 75 e4             	pushl  -0x1c(%ebp)
f01048c9:	e8 28 f8 ff ff       	call   f01040f6 <free_disk_frame>
f01048ce:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01048d1:	ff 45 f0             	incl   -0x10(%ebp)
f01048d4:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01048db:	76 bd                	jbe    f010489a <pf_free_env+0x65>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01048dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01048e0:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f01048e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01048e9:	c1 e2 02             	shl    $0x2,%edx
f01048ec:	01 d0                	add    %edx,%eax
f01048ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f01048f4:	83 ec 0c             	sub    $0xc,%esp
f01048f7:	ff 75 e8             	pushl  -0x18(%ebp)
f01048fa:	e8 d5 55 00 00       	call   f0109ed4 <kfree>
f01048ff:	83 c4 10             	add    $0x10,%esp
f0104902:	eb 01                	jmp    f0104905 <pf_free_env+0xd0>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0104904:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104905:	ff 45 f4             	incl   -0xc(%ebp)
f0104908:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010490f:	0f 86 32 ff ff ff    	jbe    f0104847 <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104915:	8b 45 08             	mov    0x8(%ebp),%eax
f0104918:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010491e:	83 ec 0c             	sub    $0xc,%esp
f0104921:	50                   	push   %eax
f0104922:	e8 ad 55 00 00       	call   f0109ed4 <kfree>
f0104927:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f010492a:	8b 45 08             	mov    0x8(%ebp),%eax
f010492d:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104934:	00 00 00 
	ptr_env->disk_env_pgdir_PA = 0;
f0104937:	8b 45 08             	mov    0x8(%ebp),%eax
f010493a:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f0104941:	00 00 00 


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104944:	8b 45 08             	mov    0x8(%ebp),%eax
f0104947:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010494d:	85 c0                	test   %eax,%eax
f010494f:	74 3f                	je     f0104990 <pf_free_env+0x15b>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104951:	83 ec 0c             	sub    $0xc,%esp
f0104954:	ff 75 08             	pushl  0x8(%ebp)
f0104957:	e8 14 03 00 00       	call   f0104c70 <__pf_remove_env_all_tables>
f010495c:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f010495f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104962:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104968:	83 ec 0c             	sub    $0xc,%esp
f010496b:	50                   	push   %eax
f010496c:	e8 63 55 00 00       	call   f0109ed4 <kfree>
f0104971:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104974:	8b 45 08             	mov    0x8(%ebp),%eax
f0104977:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010497e:	00 00 00 
	ptr_env->disk_env_tabledir_PA = 0;
f0104981:	8b 45 08             	mov    0x8(%ebp),%eax
f0104984:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010498b:	00 00 00 
f010498e:	eb 01                	jmp    f0104991 <pf_free_env+0x15c>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f0104990:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f0104991:	c9                   	leave  
f0104992:	c3                   	ret    

f0104993 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0104993:	55                   	push   %ebp
f0104994:	89 e5                	mov    %esp,%ebp
f0104996:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0104999:	8b 45 08             	mov    0x8(%ebp),%eax
f010499c:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
f01049a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049a5:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f01049a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049aa:	8b 00                	mov    (%eax),%eax
f01049ac:	85 c0                	test   %eax,%eax
f01049ae:	75 5b                	jne    f0104a0b <get_disk_page_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f01049b0:	83 ec 0c             	sub    $0xc,%esp
f01049b3:	68 00 10 00 00       	push   $0x1000
f01049b8:	e8 ad 52 00 00       	call   f0109c6a <kmalloc>
f01049bd:	83 c4 10             	add    $0x10,%esp
f01049c0:	89 c2                	mov    %eax,%edx
f01049c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049c5:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f01049c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049ca:	8b 00                	mov    (%eax),%eax
f01049cc:	85 c0                	test   %eax,%eax
f01049ce:	75 07                	jne    f01049d7 <get_disk_page_directory+0x44>
			{
				return E_NO_VM;
f01049d0:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f01049d5:	eb 39                	jmp    f0104a10 <get_disk_page_directory+0x7d>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f01049d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049da:	8b 00                	mov    (%eax),%eax
f01049dc:	83 ec 0c             	sub    $0xc,%esp
f01049df:	50                   	push   %eax
f01049e0:	e8 1c 56 00 00       	call   f010a001 <kheap_physical_address>
f01049e5:	83 c4 10             	add    $0x10,%esp
f01049e8:	89 c2                	mov    %eax,%edx
f01049ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01049ed:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f01049f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01049f6:	8b 00                	mov    (%eax),%eax
f01049f8:	83 ec 04             	sub    $0x4,%esp
f01049fb:	68 00 10 00 00       	push   $0x1000
f0104a00:	6a 00                	push   $0x0
f0104a02:	50                   	push   %eax
f0104a03:	e8 21 d7 01 00       	call   f0122129 <memset>
f0104a08:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104a0b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104a10:	c9                   	leave  
f0104a11:	c3                   	ret    

f0104a12 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0104a12:	55                   	push   %ebp
f0104a13:	89 e5                	mov    %esp,%ebp
f0104a15:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104a18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104a1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104a26:	eb 7e                	jmp    f0104aa6 <pf_calculate_allocated_pages+0x94>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104a28:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a2b:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a34:	c1 e2 02             	shl    $0x2,%edx
f0104a37:	01 d0                	add    %edx,%eax
f0104a39:	8b 00                	mov    (%eax),%eax
f0104a3b:	83 e0 01             	and    $0x1,%eax
f0104a3e:	85 c0                	test   %eax,%eax
f0104a40:	74 60                	je     f0104aa2 <pf_calculate_allocated_pages+0x90>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104a42:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a45:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f0104a4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a4e:	c1 e2 02             	shl    $0x2,%edx
f0104a51:	01 d0                	add    %edx,%eax
f0104a53:	8b 00                	mov    (%eax),%eax
f0104a55:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104a5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0104a5d:	83 ec 0c             	sub    $0xc,%esp
f0104a60:	ff 75 e8             	pushl  -0x18(%ebp)
f0104a63:	e8 2a 56 00 00       	call   f010a092 <kheap_virtual_address>
f0104a68:	83 c4 10             	add    $0x10,%esp
f0104a6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0104a75:	eb 20                	jmp    f0104a97 <pf_calculate_allocated_pages+0x85>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104a77:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104a7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104a81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104a84:	01 d0                	add    %edx,%eax
f0104a86:	8b 00                	mov    (%eax),%eax
f0104a88:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f0104a8b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0104a8f:	74 03                	je     f0104a94 <pf_calculate_allocated_pages+0x82>
				counter ++;
f0104a91:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104a94:	ff 45 ec             	incl   -0x14(%ebp)
f0104a97:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104a9e:	76 d7                	jbe    f0104a77 <pf_calculate_allocated_pages+0x65>
f0104aa0:	eb 01                	jmp    f0104aa3 <pf_calculate_allocated_pages+0x91>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104aa2:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104aa3:	ff 45 f4             	incl   -0xc(%ebp)
f0104aa6:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104aad:	0f 86 75 ff ff ff    	jbe    f0104a28 <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104ab3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104ab6:	c9                   	leave  
f0104ab7:	c3                   	ret    

f0104ab8 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104ab8:	55                   	push   %ebp
f0104ab9:	89 e5                	mov    %esp,%ebp
f0104abb:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104abe:	83 ec 0c             	sub    $0xc,%esp
f0104ac1:	68 d0 5e 74 f0       	push   $0xf0745ed0
f0104ac6:	e8 1f bd 00 00       	call   f01107ea <acquire_spinlock>
f0104acb:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104ace:	a1 cc 5e 74 f0       	mov    0xf0745ecc,%eax
f0104ad3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104ad6:	83 ec 0c             	sub    $0xc,%esp
f0104ad9:	68 d0 5e 74 f0       	push   $0xf0745ed0
f0104ade:	e8 8e bd 00 00       	call   f0110871 <release_spinlock>
f0104ae3:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104ae6:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104ae9:	c9                   	leave  
f0104aea:	c3                   	ret    

f0104aeb <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104aeb:	55                   	push   %ebp
f0104aec:	89 e5                	mov    %esp,%ebp
f0104aee:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104af1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104af4:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f0104afa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afd:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104aff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b02:	8b 00                	mov    (%eax),%eax
f0104b04:	85 c0                	test   %eax,%eax
f0104b06:	75 5b                	jne    f0104b63 <get_disk_table_directory+0x78>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0104b08:	83 ec 0c             	sub    $0xc,%esp
f0104b0b:	68 00 10 00 00       	push   $0x1000
f0104b10:	e8 55 51 00 00       	call   f0109c6a <kmalloc>
f0104b15:	83 c4 10             	add    $0x10,%esp
f0104b18:	89 c2                	mov    %eax,%edx
f0104b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b1d:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f0104b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b22:	8b 00                	mov    (%eax),%eax
f0104b24:	85 c0                	test   %eax,%eax
f0104b26:	75 07                	jne    f0104b2f <get_disk_table_directory+0x44>
			{
				return E_NO_VM;
f0104b28:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104b2d:	eb 39                	jmp    f0104b68 <get_disk_table_directory+0x7d>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f0104b2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b32:	8b 00                	mov    (%eax),%eax
f0104b34:	83 ec 0c             	sub    $0xc,%esp
f0104b37:	50                   	push   %eax
f0104b38:	e8 c4 54 00 00       	call   f010a001 <kheap_physical_address>
f0104b3d:	83 c4 10             	add    $0x10,%esp
f0104b40:	89 c2                	mov    %eax,%edx
f0104b42:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b45:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104b4b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104b4e:	8b 00                	mov    (%eax),%eax
f0104b50:	83 ec 04             	sub    $0x4,%esp
f0104b53:	68 00 10 00 00       	push   $0x1000
f0104b58:	6a 00                	push   $0x0
f0104b5a:	50                   	push   %eax
f0104b5b:	e8 c9 d5 01 00       	call   f0122129 <memset>
f0104b60:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104b63:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b68:	c9                   	leave  
f0104b69:	c3                   	ret    

f0104b6a <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104b6a:	55                   	push   %ebp
f0104b6b:	89 e5                	mov    %esp,%ebp
f0104b6d:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104b70:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104b77:	76 19                	jbe    f0104b92 <__pf_write_env_table+0x28>
f0104b79:	68 d0 6d 12 f0       	push   $0xf0126dd0
f0104b7e:	68 f6 6d 12 f0       	push   $0xf0126df6
f0104b83:	68 98 02 00 00       	push   $0x298
f0104b88:	68 2b 6d 12 f0       	push   $0xf0126d2b
f0104b8d:	e8 a7 b7 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0104b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b95:	05 88 00 00 00       	add    $0x88,%eax
f0104b9a:	83 ec 08             	sub    $0x8,%esp
f0104b9d:	50                   	push   %eax
f0104b9e:	ff 75 08             	pushl  0x8(%ebp)
f0104ba1:	e8 45 ff ff ff       	call   f0104aeb <get_disk_table_directory>
f0104ba6:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104ba9:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bac:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104bb2:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104bb5:	c1 ea 16             	shr    $0x16,%edx
f0104bb8:	c1 e2 02             	shl    $0x2,%edx
f0104bbb:	01 d0                	add    %edx,%eax
f0104bbd:	8b 00                	mov    (%eax),%eax
f0104bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bc5:	85 c0                	test   %eax,%eax
f0104bc7:	75 34                	jne    f0104bfd <__pf_write_env_table+0x93>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104bc9:	83 ec 0c             	sub    $0xc,%esp
f0104bcc:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104bcf:	50                   	push   %eax
f0104bd0:	e8 33 f4 ff ff       	call   f0104008 <allocate_disk_frame>
f0104bd5:	83 c4 10             	add    $0x10,%esp
f0104bd8:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104bdb:	75 07                	jne    f0104be4 <__pf_write_env_table+0x7a>
f0104bdd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104be2:	eb 31                	jmp    f0104c15 <__pf_write_env_table+0xab>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0104be4:	8b 45 08             	mov    0x8(%ebp),%eax
f0104be7:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104bed:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104bf0:	c1 ea 16             	shr    $0x16,%edx
f0104bf3:	c1 e2 02             	shl    $0x2,%edx
f0104bf6:	01 c2                	add    %eax,%edx
f0104bf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104bfb:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0104bfd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104c00:	83 ec 08             	sub    $0x8,%esp
f0104c03:	ff 75 10             	pushl  0x10(%ebp)
f0104c06:	50                   	push   %eax
f0104c07:	e8 2f f2 ff ff       	call   f0103e3b <write_disk_page>
f0104c0c:	83 c4 10             	add    $0x10,%esp
f0104c0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104c15:	c9                   	leave  
f0104c16:	c3                   	ret    

f0104c17 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104c17:	55                   	push   %ebp
f0104c18:	89 e5                	mov    %esp,%ebp
f0104c1a:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104c1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c20:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c26:	85 c0                	test   %eax,%eax
f0104c28:	75 07                	jne    f0104c31 <__pf_read_env_table+0x1a>
f0104c2a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c2f:	eb 3d                	jmp    f0104c6e <__pf_read_env_table+0x57>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104c31:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c34:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c3a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104c3d:	c1 ea 16             	shr    $0x16,%edx
f0104c40:	c1 e2 02             	shl    $0x2,%edx
f0104c43:	01 d0                	add    %edx,%eax
f0104c45:	8b 00                	mov    (%eax),%eax
f0104c47:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104c4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104c4e:	75 07                	jne    f0104c57 <__pf_read_env_table+0x40>
f0104c50:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104c55:	eb 17                	jmp    f0104c6e <__pf_read_env_table+0x57>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104c57:	83 ec 08             	sub    $0x8,%esp
f0104c5a:	ff 75 10             	pushl  0x10(%ebp)
f0104c5d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c60:	e8 a7 f1 ff ff       	call   f0103e0c <read_disk_page>
f0104c65:	83 c4 10             	add    $0x10,%esp
f0104c68:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104c6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c6e:	c9                   	leave  
f0104c6f:	c3                   	ret    

f0104c70 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104c70:	55                   	push   %ebp
f0104c71:	89 e5                	mov    %esp,%ebp
f0104c73:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104c76:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c79:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c7f:	85 c0                	test   %eax,%eax
f0104c81:	74 52                	je     f0104cd5 <__pf_remove_env_all_tables+0x65>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104c83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104c8a:	eb 3e                	jmp    f0104cca <__pf_remove_env_all_tables+0x5a>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104c8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c8f:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104c95:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c98:	c1 e2 02             	shl    $0x2,%edx
f0104c9b:	01 d0                	add    %edx,%eax
f0104c9d:	8b 00                	mov    (%eax),%eax
f0104c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104ca2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ca5:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cae:	c1 e2 02             	shl    $0x2,%edx
f0104cb1:	01 d0                	add    %edx,%eax
f0104cb3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104cb9:	83 ec 0c             	sub    $0xc,%esp
f0104cbc:	ff 75 f0             	pushl  -0x10(%ebp)
f0104cbf:	e8 32 f4 ff ff       	call   f01040f6 <free_disk_frame>
f0104cc4:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104cc7:	ff 45 f4             	incl   -0xc(%ebp)
f0104cca:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104cd1:	76 b9                	jbe    f0104c8c <__pf_remove_env_all_tables+0x1c>
f0104cd3:	eb 01                	jmp    f0104cd6 <__pf_remove_env_all_tables+0x66>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104cd5:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104cd6:	c9                   	leave  
f0104cd7:	c3                   	ret    

f0104cd8 <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104cd8:	55                   	push   %ebp
f0104cd9:	89 e5                	mov    %esp,%ebp
f0104cdb:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104cde:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104ce2:	75 10                	jne    f0104cf4 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104ce4:	83 ec 0c             	sub    $0xc,%esp
f0104ce7:	68 d4 6e 12 f0       	push   $0xf0126ed4
f0104cec:	e8 9a c2 ff ff       	call   f0100f8b <cprintf>
f0104cf1:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104cf4:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf7:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104cfd:	85 c0                	test   %eax,%eax
f0104cff:	74 43                	je     f0104d44 <__pf_remove_env_table+0x6c>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104d01:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d04:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104d0a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d0d:	c1 ea 16             	shr    $0x16,%edx
f0104d10:	c1 e2 02             	shl    $0x2,%edx
f0104d13:	01 d0                	add    %edx,%eax
f0104d15:	8b 00                	mov    (%eax),%eax
f0104d17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104d1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d1d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0104d23:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d26:	c1 ea 16             	shr    $0x16,%edx
f0104d29:	c1 e2 02             	shl    $0x2,%edx
f0104d2c:	01 d0                	add    %edx,%eax
f0104d2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104d34:	83 ec 0c             	sub    $0xc,%esp
f0104d37:	ff 75 f4             	pushl  -0xc(%ebp)
f0104d3a:	e8 b7 f3 ff ff       	call   f01040f6 <free_disk_frame>
f0104d3f:	83 c4 10             	add    $0x10,%esp
f0104d42:	eb 01                	jmp    f0104d45 <__pf_remove_env_table+0x6d>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104d44:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104d45:	c9                   	leave  
f0104d46:	c3                   	ret    

f0104d47 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104d47:	55                   	push   %ebp
f0104d48:	89 e5                	mov    %esp,%ebp
f0104d4a:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104d4d:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104d54:	eb 1f                	jmp    f0104d75 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d59:	83 ec 04             	sub    $0x4,%esp
f0104d5c:	6a 08                	push   $0x8
f0104d5e:	ff 75 08             	pushl  0x8(%ebp)
f0104d61:	50                   	push   %eax
f0104d62:	e8 fc da 01 00       	call   f0122863 <ide_write>
f0104d67:	83 c4 10             	add    $0x10,%esp
f0104d6a:	85 c0                	test   %eax,%eax
f0104d6c:	75 12                	jne    f0104d80 <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104d6e:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104d75:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104d7c:	7e d8                	jle    f0104d56 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d7e:	eb 01                	jmp    f0104d81 <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104d80:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104d81:	90                   	nop
f0104d82:	c9                   	leave  
f0104d83:	c3                   	ret    

f0104d84 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104d84:	55                   	push   %ebp
  pushl %eax
f0104d85:	50                   	push   %eax
  pushl %ebx
f0104d86:	53                   	push   %ebx
  pushl %ecx
f0104d87:	51                   	push   %ecx
  pushl %edx
f0104d88:	52                   	push   %edx
  pushl %esi
f0104d89:	56                   	push   %esi
  pushl %edi
f0104d8a:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104d8b:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104d8f:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104d93:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104d95:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104d97:	5f                   	pop    %edi
  popl %esi
f0104d98:	5e                   	pop    %esi
  popl %edx
f0104d99:	5a                   	pop    %edx
  popl %ecx
f0104d9a:	59                   	pop    %ecx
  popl %ebx
f0104d9b:	5b                   	pop    %ebx
  popl %eax
f0104d9c:	58                   	pop    %eax
  popl %ebp
f0104d9d:	5d                   	pop    %ebp
  ret
f0104d9e:	c3                   	ret    

f0104d9f <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104d9f:	55                   	push   %ebp
f0104da0:	89 e5                	mov    %esp,%ebp
f0104da2:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104da5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104da8:	0f b6 c0             	movzbl %al,%eax
f0104dab:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104db2:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104db5:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104db8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104dbb:	ee                   	out    %al,(%dx)
f0104dbc:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104dc3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104dc6:	89 c2                	mov    %eax,%edx
f0104dc8:	ec                   	in     (%dx),%al
f0104dc9:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104dcc:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104dcf:	0f b6 c0             	movzbl %al,%eax
}
f0104dd2:	c9                   	leave  
f0104dd3:	c3                   	ret    

f0104dd4 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104dd4:	55                   	push   %ebp
f0104dd5:	89 e5                	mov    %esp,%ebp
f0104dd7:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104dda:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ddd:	0f b6 c0             	movzbl %al,%eax
f0104de0:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104de7:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104dea:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104ded:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104df0:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104df1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104df4:	0f b6 c0             	movzbl %al,%eax
f0104df7:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104dfe:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104e01:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104e04:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104e07:	ee                   	out    %al,(%dx)
}
f0104e08:	90                   	nop
f0104e09:	c9                   	leave  
f0104e0a:	c3                   	ret    

f0104e0b <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104e0b:	55                   	push   %ebp
f0104e0c:	89 e5                	mov    %esp,%ebp
f0104e0e:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104e11:	c7 05 a8 5e 74 f0 00 	movl   $0x0,0xf0745ea8
f0104e18:	00 00 00 
f0104e1b:	c7 05 ac 5e 74 f0 00 	movl   $0x0,0xf0745eac
f0104e22:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104e25:	83 ec 08             	sub    $0x8,%esp
f0104e28:	68 73 71 10 f0       	push   $0xf0107173
f0104e2d:	6a 00                	push   $0x0
f0104e2f:	e8 72 99 00 00       	call   f010e7a6 <irq_install_handler>
f0104e34:	83 c4 10             	add    $0x10,%esp
}
f0104e37:	90                   	nop
f0104e38:	c9                   	leave  
f0104e39:	c3                   	ret    

f0104e3a <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104e3a:	55                   	push   %ebp
f0104e3b:	89 e5                	mov    %esp,%ebp
f0104e3d:	53                   	push   %ebx
f0104e3e:	83 ec 24             	sub    $0x24,%esp
f0104e41:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e44:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104e47:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e4e:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e52:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e55:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e58:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104e59:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104e5d:	77 48                	ja     f0104ea7 <kclock_start+0x6d>
f0104e5f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104e66:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104e6a:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104e6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e70:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104e71:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e75:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104e7a:	99                   	cltd   
f0104e7b:	f7 fb                	idiv   %ebx
f0104e7d:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104e83:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104e87:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104e8c:	99                   	cltd   
f0104e8d:	f7 fb                	idiv   %ebx
f0104e8f:	89 c3                	mov    %eax,%ebx
f0104e91:	89 c8                	mov    %ecx,%eax
f0104e93:	99                   	cltd   
f0104e94:	f7 fb                	idiv   %ebx
f0104e96:	0f b7 c0             	movzwl %ax,%eax
f0104e99:	83 ec 0c             	sub    $0xc,%esp
f0104e9c:	50                   	push   %eax
f0104e9d:	e8 b3 01 00 00       	call   f0105055 <kclock_write_cnt0_LSB_first>
f0104ea2:	83 c4 10             	add    $0x10,%esp
f0104ea5:	eb 13                	jmp    f0104eba <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104ea7:	6a 35                	push   $0x35
f0104ea9:	68 f8 6e 12 f0       	push   $0xf0126ef8
f0104eae:	6a 41                	push   $0x41
f0104eb0:	68 54 6f 12 f0       	push   $0xf0126f54
f0104eb5:	e8 7f b4 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104eba:	83 ec 0c             	sub    $0xc,%esp
f0104ebd:	6a 00                	push   $0x0
f0104ebf:	e8 0b 28 00 00       	call   f01076cf <irq_clear_mask>
f0104ec4:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104ec7:	90                   	nop
f0104ec8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104ecb:	c9                   	leave  
f0104ecc:	c3                   	ret    

f0104ecd <kclock_stop>:

void
kclock_stop(void)
{
f0104ecd:	55                   	push   %ebp
f0104ece:	89 e5                	mov    %esp,%ebp
f0104ed0:	83 ec 18             	sub    $0x18,%esp
f0104ed3:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104eda:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104ede:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104ee1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ee4:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104ee5:	83 ec 0c             	sub    $0xc,%esp
f0104ee8:	6a 00                	push   $0x0
f0104eea:	e8 6b 27 00 00       	call   f010765a <irq_set_mask>
f0104eef:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104ef2:	90                   	nop
f0104ef3:	c9                   	leave  
f0104ef4:	c3                   	ret    

f0104ef5 <kclock_resume>:

void
kclock_resume(void)
{
f0104ef5:	55                   	push   %ebp
f0104ef6:	89 e5                	mov    %esp,%ebp
f0104ef8:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104efb:	e8 f5 01 00 00       	call   f01050f5 <kclock_read_cnt0_latch>
f0104f00:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104f04:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104f09:	77 06                	ja     f0104f11 <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104f0b:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104f11:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104f15:	83 e0 01             	and    $0x1,%eax
f0104f18:	66 85 c0             	test   %ax,%ax
f0104f1b:	74 09                	je     f0104f26 <kclock_resume+0x31>
		cnt0++;
f0104f1d:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104f21:	40                   	inc    %eax
f0104f22:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104f26:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104f2d:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104f31:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104f34:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f37:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f38:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104f3c:	83 ec 0c             	sub    $0xc,%esp
f0104f3f:	50                   	push   %eax
f0104f40:	e8 10 01 00 00       	call   f0105055 <kclock_write_cnt0_LSB_first>
f0104f45:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f48:	83 ec 0c             	sub    $0xc,%esp
f0104f4b:	6a 00                	push   $0x0
f0104f4d:	e8 7d 27 00 00       	call   f01076cf <irq_clear_mask>
f0104f52:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104f55:	90                   	nop
f0104f56:	c9                   	leave  
f0104f57:	c3                   	ret    

f0104f58 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104f58:	55                   	push   %ebp
f0104f59:	89 e5                	mov    %esp,%ebp
f0104f5b:	83 ec 28             	sub    $0x28,%esp
f0104f5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f61:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104f64:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f6b:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104f6f:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104f72:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f75:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104f76:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104f7a:	83 ec 0c             	sub    $0xc,%esp
f0104f7d:	50                   	push   %eax
f0104f7e:	e8 d2 00 00 00       	call   f0105055 <kclock_write_cnt0_LSB_first>
f0104f83:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104f86:	83 ec 0c             	sub    $0xc,%esp
f0104f89:	6a 00                	push   $0x0
f0104f8b:	e8 3f 27 00 00       	call   f01076cf <irq_clear_mask>
f0104f90:	83 c4 10             	add    $0x10,%esp
}
f0104f93:	90                   	nop
f0104f94:	c9                   	leave  
f0104f95:	c3                   	ret    

f0104f96 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104f96:	55                   	push   %ebp
f0104f97:	89 e5                	mov    %esp,%ebp
f0104f99:	56                   	push   %esi
f0104f9a:	53                   	push   %ebx
f0104f9b:	83 ec 20             	sub    $0x20,%esp
f0104f9e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fa1:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104fa4:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104fa8:	0f 87 8a 00 00 00    	ja     f0105038 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104fae:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104fb2:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104fb7:	99                   	cltd   
f0104fb8:	f7 fe                	idiv   %esi
f0104fba:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104fc0:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104fc4:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104fc9:	99                   	cltd   
f0104fca:	f7 fb                	idiv   %ebx
f0104fcc:	89 c6                	mov    %eax,%esi
f0104fce:	89 c8                	mov    %ecx,%eax
f0104fd0:	99                   	cltd   
f0104fd1:	f7 fe                	idiv   %esi
f0104fd3:	89 c3                	mov    %eax,%ebx
f0104fd5:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104fd9:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104fde:	99                   	cltd   
f0104fdf:	f7 f9                	idiv   %ecx
f0104fe1:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104fe7:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104feb:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ff0:	99                   	cltd   
f0104ff1:	f7 fe                	idiv   %esi
f0104ff3:	89 c6                	mov    %eax,%esi
f0104ff5:	89 c8                	mov    %ecx,%eax
f0104ff7:	99                   	cltd   
f0104ff8:	f7 fe                	idiv   %esi
f0104ffa:	25 01 00 00 80       	and    $0x80000001,%eax
f0104fff:	85 c0                	test   %eax,%eax
f0105001:	79 05                	jns    f0105008 <kclock_set_quantum+0x72>
f0105003:	48                   	dec    %eax
f0105004:	83 c8 fe             	or     $0xfffffffe,%eax
f0105007:	40                   	inc    %eax
f0105008:	01 d8                	add    %ebx,%eax
f010500a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010500d:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105014:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105018:	8a 45 ef             	mov    -0x11(%ebp),%al
f010501b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010501e:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f010501f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105022:	0f b7 c0             	movzwl %ax,%eax
f0105025:	83 ec 0c             	sub    $0xc,%esp
f0105028:	50                   	push   %eax
f0105029:	e8 27 00 00 00       	call   f0105055 <kclock_write_cnt0_LSB_first>
f010502e:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0105031:	e8 97 fe ff ff       	call   f0104ecd <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105036:	eb 16                	jmp    f010504e <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105038:	6a 35                	push   $0x35
f010503a:	68 f8 6e 12 f0       	push   $0xf0126ef8
f010503f:	68 ea 00 00 00       	push   $0xea
f0105044:	68 54 6f 12 f0       	push   $0xf0126f54
f0105049:	e8 eb b2 ff ff       	call   f0100339 <_panic>
	}
}
f010504e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105051:	5b                   	pop    %ebx
f0105052:	5e                   	pop    %esi
f0105053:	5d                   	pop    %ebp
f0105054:	c3                   	ret    

f0105055 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105055:	55                   	push   %ebp
f0105056:	89 e5                	mov    %esp,%ebp
f0105058:	83 ec 28             	sub    $0x28,%esp
f010505b:	8b 45 08             	mov    0x8(%ebp),%eax
f010505e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0105062:	e8 43 28 00 00       	call   f01078aa <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010506a:	0f b6 c0             	movzbl %al,%eax
f010506d:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0105074:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105077:	8a 45 ee             	mov    -0x12(%ebp),%al
f010507a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010507d:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f010507e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105081:	66 c1 e8 08          	shr    $0x8,%ax
f0105085:	0f b6 c0             	movzbl %al,%eax
f0105088:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f010508f:	88 45 ef             	mov    %al,-0x11(%ebp)
f0105092:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105095:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105098:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105099:	e8 5e 28 00 00       	call   f01078fc <popcli>

}
f010509e:	90                   	nop
f010509f:	c9                   	leave  
f01050a0:	c3                   	ret    

f01050a1 <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f01050a1:	55                   	push   %ebp
f01050a2:	89 e5                	mov    %esp,%ebp
f01050a4:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f01050a7:	e8 fe 27 00 00       	call   f01078aa <pushcli>
f01050ac:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050b6:	89 c2                	mov    %eax,%edx
f01050b8:	ec                   	in     (%dx),%al
f01050b9:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f01050bc:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f01050bf:	88 45 f7             	mov    %al,-0x9(%ebp)
f01050c2:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01050c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01050cc:	89 c2                	mov    %eax,%edx
f01050ce:	ec                   	in     (%dx),%al
f01050cf:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f01050d2:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f01050d5:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f01050d8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01050dc:	c1 e0 08             	shl    $0x8,%eax
f01050df:	89 c2                	mov    %eax,%edx
f01050e1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01050e5:	09 d0                	or     %edx,%eax
f01050e7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f01050eb:	e8 0c 28 00 00       	call   f01078fc <popcli>
	return cnt0 ;
f01050f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01050f3:	c9                   	leave  
f01050f4:	c3                   	ret    

f01050f5 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f01050f5:	55                   	push   %ebp
f01050f6:	89 e5                	mov    %esp,%ebp
f01050f8:	83 ec 30             	sub    $0x30,%esp
f01050fb:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105102:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105105:	89 c2                	mov    %eax,%edx
f0105107:	ec                   	in     (%dx),%al
f0105108:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f010510b:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f010510e:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105111:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105118:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010511c:	8a 45 dc             	mov    -0x24(%ebp),%al
f010511f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105122:	ee                   	out    %al,(%dx)
f0105123:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010512a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010512d:	89 c2                	mov    %eax,%edx
f010512f:	ec                   	in     (%dx),%al
f0105130:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105133:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105136:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105139:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105140:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105143:	89 c2                	mov    %eax,%edx
f0105145:	ec                   	in     (%dx),%al
f0105146:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105149:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f010514c:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f010514f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105153:	c1 e0 08             	shl    $0x8,%eax
f0105156:	89 c2                	mov    %eax,%edx
f0105158:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f010515c:	09 d0                	or     %edx,%eax
f010515e:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105162:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105166:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f010516d:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105170:	8a 45 df             	mov    -0x21(%ebp),%al
f0105173:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105176:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105177:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f010517a:	c9                   	leave  
f010517b:	c3                   	ret    

f010517c <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f010517c:	55                   	push   %ebp
f010517d:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f010517f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105183:	74 1d                	je     f01051a2 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105185:	8b 45 08             	mov    0x8(%ebp),%eax
f0105188:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010518e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105191:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105198:	8b 45 08             	mov    0x8(%ebp),%eax
f010519b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f01051a2:	90                   	nop
f01051a3:	5d                   	pop    %ebp
f01051a4:	c3                   	ret    

f01051a5 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f01051a5:	55                   	push   %ebp
f01051a6:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f01051a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051ac:	74 08                	je     f01051b6 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f01051ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01051b1:	8b 40 0c             	mov    0xc(%eax),%eax
f01051b4:	eb 05                	jmp    f01051bb <queue_size+0x16>
	}
	else
	{
		return 0;
f01051b6:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f01051bb:	5d                   	pop    %ebp
f01051bc:	c3                   	ret    

f01051bd <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f01051bd:	55                   	push   %ebp
f01051be:	89 e5                	mov    %esp,%ebp
f01051c0:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f01051c3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051c7:	75 16                	jne    f01051df <enqueue+0x22>
f01051c9:	68 68 6f 12 f0       	push   $0xf0126f68
f01051ce:	68 76 6f 12 f0       	push   $0xf0126f76
f01051d3:	6a 34                	push   $0x34
f01051d5:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01051da:	e8 5a b1 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f01051df:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051e3:	74 66                	je     f010524b <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f01051e5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01051e9:	75 14                	jne    f01051ff <enqueue+0x42>
f01051eb:	83 ec 04             	sub    $0x4,%esp
f01051ee:	68 a4 6f 12 f0       	push   $0xf0126fa4
f01051f3:	6a 37                	push   $0x37
f01051f5:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01051fa:	e8 3a b1 ff ff       	call   f0100339 <_panic>
f01051ff:	8b 45 08             	mov    0x8(%ebp),%eax
f0105202:	8b 10                	mov    (%eax),%edx
f0105204:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105207:	89 50 08             	mov    %edx,0x8(%eax)
f010520a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010520d:	8b 40 08             	mov    0x8(%eax),%eax
f0105210:	85 c0                	test   %eax,%eax
f0105212:	74 0d                	je     f0105221 <enqueue+0x64>
f0105214:	8b 45 08             	mov    0x8(%ebp),%eax
f0105217:	8b 00                	mov    (%eax),%eax
f0105219:	8b 55 0c             	mov    0xc(%ebp),%edx
f010521c:	89 50 0c             	mov    %edx,0xc(%eax)
f010521f:	eb 09                	jmp    f010522a <enqueue+0x6d>
f0105221:	8b 45 08             	mov    0x8(%ebp),%eax
f0105224:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105227:	89 50 04             	mov    %edx,0x4(%eax)
f010522a:	8b 45 08             	mov    0x8(%ebp),%eax
f010522d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105230:	89 10                	mov    %edx,(%eax)
f0105232:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105235:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010523c:	8b 45 08             	mov    0x8(%ebp),%eax
f010523f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105242:	8d 50 01             	lea    0x1(%eax),%edx
f0105245:	8b 45 08             	mov    0x8(%ebp),%eax
f0105248:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f010524b:	90                   	nop
f010524c:	c9                   	leave  
f010524d:	c3                   	ret    

f010524e <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010524e:	55                   	push   %ebp
f010524f:	89 e5                	mov    %esp,%ebp
f0105251:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105254:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105258:	75 0a                	jne    f0105264 <dequeue+0x16>
f010525a:	b8 00 00 00 00       	mov    $0x0,%eax
f010525f:	e9 a0 00 00 00       	jmp    f0105304 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105264:	8b 45 08             	mov    0x8(%ebp),%eax
f0105267:	8b 40 04             	mov    0x4(%eax),%eax
f010526a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010526d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105271:	0f 84 8a 00 00 00    	je     f0105301 <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105277:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010527b:	75 14                	jne    f0105291 <dequeue+0x43>
f010527d:	83 ec 04             	sub    $0x4,%esp
f0105280:	68 c7 6f 12 f0       	push   $0xf0126fc7
f0105285:	6a 44                	push   $0x44
f0105287:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010528c:	e8 a8 b0 ff ff       	call   f0100339 <_panic>
f0105291:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105294:	8b 40 08             	mov    0x8(%eax),%eax
f0105297:	85 c0                	test   %eax,%eax
f0105299:	74 11                	je     f01052ac <dequeue+0x5e>
f010529b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010529e:	8b 40 08             	mov    0x8(%eax),%eax
f01052a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052a4:	8b 52 0c             	mov    0xc(%edx),%edx
f01052a7:	89 50 0c             	mov    %edx,0xc(%eax)
f01052aa:	eb 0c                	jmp    f01052b8 <dequeue+0x6a>
f01052ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052af:	8b 50 0c             	mov    0xc(%eax),%edx
f01052b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01052b5:	89 50 04             	mov    %edx,0x4(%eax)
f01052b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052bb:	8b 40 0c             	mov    0xc(%eax),%eax
f01052be:	85 c0                	test   %eax,%eax
f01052c0:	74 11                	je     f01052d3 <dequeue+0x85>
f01052c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01052c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01052cb:	8b 52 08             	mov    0x8(%edx),%edx
f01052ce:	89 50 08             	mov    %edx,0x8(%eax)
f01052d1:	eb 0b                	jmp    f01052de <dequeue+0x90>
f01052d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052d6:	8b 50 08             	mov    0x8(%eax),%edx
f01052d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01052dc:	89 10                	mov    %edx,(%eax)
f01052de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052e1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01052e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01052eb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01052f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01052f5:	8b 40 0c             	mov    0xc(%eax),%eax
f01052f8:	8d 50 ff             	lea    -0x1(%eax),%edx
f01052fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01052fe:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f0105301:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105304:	c9                   	leave  
f0105305:	c3                   	ret    

f0105306 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0105306:	55                   	push   %ebp
f0105307:	89 e5                	mov    %esp,%ebp
f0105309:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010530c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105310:	75 16                	jne    f0105328 <remove_from_queue+0x22>
f0105312:	68 68 6f 12 f0       	push   $0xf0126f68
f0105317:	68 76 6f 12 f0       	push   $0xf0126f76
f010531c:	6a 4e                	push   $0x4e
f010531e:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105323:	e8 11 b0 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105328:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010532c:	0f 84 8a 00 00 00    	je     f01053bc <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0105332:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105336:	75 14                	jne    f010534c <remove_from_queue+0x46>
f0105338:	83 ec 04             	sub    $0x4,%esp
f010533b:	68 c7 6f 12 f0       	push   $0xf0126fc7
f0105340:	6a 52                	push   $0x52
f0105342:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105347:	e8 ed af ff ff       	call   f0100339 <_panic>
f010534c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010534f:	8b 40 08             	mov    0x8(%eax),%eax
f0105352:	85 c0                	test   %eax,%eax
f0105354:	74 11                	je     f0105367 <remove_from_queue+0x61>
f0105356:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105359:	8b 40 08             	mov    0x8(%eax),%eax
f010535c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010535f:	8b 52 0c             	mov    0xc(%edx),%edx
f0105362:	89 50 0c             	mov    %edx,0xc(%eax)
f0105365:	eb 0c                	jmp    f0105373 <remove_from_queue+0x6d>
f0105367:	8b 45 0c             	mov    0xc(%ebp),%eax
f010536a:	8b 50 0c             	mov    0xc(%eax),%edx
f010536d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105370:	89 50 04             	mov    %edx,0x4(%eax)
f0105373:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105376:	8b 40 0c             	mov    0xc(%eax),%eax
f0105379:	85 c0                	test   %eax,%eax
f010537b:	74 11                	je     f010538e <remove_from_queue+0x88>
f010537d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105380:	8b 40 0c             	mov    0xc(%eax),%eax
f0105383:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105386:	8b 52 08             	mov    0x8(%edx),%edx
f0105389:	89 50 08             	mov    %edx,0x8(%eax)
f010538c:	eb 0b                	jmp    f0105399 <remove_from_queue+0x93>
f010538e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105391:	8b 50 08             	mov    0x8(%eax),%edx
f0105394:	8b 45 08             	mov    0x8(%ebp),%eax
f0105397:	89 10                	mov    %edx,(%eax)
f0105399:	8b 45 0c             	mov    0xc(%ebp),%eax
f010539c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01053a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01053a6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01053ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b0:	8b 40 0c             	mov    0xc(%eax),%eax
f01053b3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01053b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b9:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01053bc:	90                   	nop
f01053bd:	c9                   	leave  
f01053be:	c3                   	ret    

f01053bf <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01053bf:	55                   	push   %ebp
f01053c0:	89 e5                	mov    %esp,%ebp
f01053c2:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01053c5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053c9:	75 07                	jne    f01053d2 <find_env_in_queue+0x13>
f01053cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01053d0:	eb 58                	jmp    f010542a <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f01053d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f01053d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01053dc:	8b 00                	mov    (%eax),%eax
f01053de:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053e1:	eb 19                	jmp    f01053fc <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f01053e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053e6:	8b 40 10             	mov    0x10(%eax),%eax
f01053e9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01053ec:	75 05                	jne    f01053f3 <find_env_in_queue+0x34>
		{
			return ptr_env;
f01053ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01053f1:	eb 37                	jmp    f010542a <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f01053f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01053f6:	8b 40 08             	mov    0x8(%eax),%eax
f01053f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01053fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105400:	74 08                	je     f010540a <find_env_in_queue+0x4b>
f0105402:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105405:	8b 40 08             	mov    0x8(%eax),%eax
f0105408:	eb 05                	jmp    f010540f <find_env_in_queue+0x50>
f010540a:	b8 00 00 00 00       	mov    $0x0,%eax
f010540f:	8b 55 08             	mov    0x8(%ebp),%edx
f0105412:	89 42 08             	mov    %eax,0x8(%edx)
f0105415:	8b 45 08             	mov    0x8(%ebp),%eax
f0105418:	8b 40 08             	mov    0x8(%eax),%eax
f010541b:	85 c0                	test   %eax,%eax
f010541d:	75 c4                	jne    f01053e3 <find_env_in_queue+0x24>
f010541f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105423:	75 be                	jne    f01053e3 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105425:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010542a:	c9                   	leave  
f010542b:	c3                   	ret    

f010542c <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f010542c:	55                   	push   %ebp
f010542d:	89 e5                	mov    %esp,%ebp
f010542f:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f0105432:	83 ec 0c             	sub    $0xc,%esp
f0105435:	68 00 58 74 f0       	push   $0xf0745800
f010543a:	e8 ab b3 00 00       	call   f01107ea <acquire_spinlock>
f010543f:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f0105442:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105447:	85 c0                	test   %eax,%eax
f0105449:	74 11                	je     f010545c <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f010544b:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105450:	83 ec 0c             	sub    $0xc,%esp
f0105453:	50                   	push   %eax
f0105454:	e8 7b 4a 00 00       	call   f0109ed4 <kfree>
f0105459:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f010545c:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0105461:	85 c0                	test   %eax,%eax
f0105463:	74 11                	je     f0105476 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105465:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f010546a:	83 ec 0c             	sub    $0xc,%esp
f010546d:	50                   	push   %eax
f010546e:	e8 61 4a 00 00       	call   f0109ed4 <kfree>
f0105473:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f0105476:	83 ec 0c             	sub    $0xc,%esp
f0105479:	68 00 58 74 f0       	push   $0xf0745800
f010547e:	e8 ee b3 00 00       	call   f0110871 <release_spinlock>
f0105483:	83 c4 10             	add    $0x10,%esp

#endif
}
f0105486:	90                   	nop
f0105487:	c9                   	leave  
f0105488:	c3                   	ret    

f0105489 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0105489:	55                   	push   %ebp
f010548a:	89 e5                	mov    %esp,%ebp
f010548c:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010548f:	83 ec 0c             	sub    $0xc,%esp
f0105492:	68 00 58 74 f0       	push   $0xf0745800
f0105497:	e8 67 b5 00 00       	call   f0110a03 <holding_spinlock>
f010549c:	83 c4 10             	add    $0x10,%esp
f010549f:	85 c0                	test   %eax,%eax
f01054a1:	75 17                	jne    f01054ba <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054a3:	83 ec 04             	sub    $0x4,%esp
f01054a6:	68 e8 6f 12 f0       	push   $0xf0126fe8
f01054ab:	68 85 00 00 00       	push   $0x85
f01054b0:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01054b5:	e8 7f ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01054ba:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054be:	75 19                	jne    f01054d9 <sched_insert_ready0+0x50>
f01054c0:	68 29 70 12 f0       	push   $0xf0127029
f01054c5:	68 76 6f 12 f0       	push   $0xf0126f76
f01054ca:	68 88 00 00 00       	push   $0x88
f01054cf:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01054d4:	e8 60 ae ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f01054d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01054dc:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f01054e3:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01054e8:	83 ec 08             	sub    $0x8,%esp
f01054eb:	ff 75 08             	pushl  0x8(%ebp)
f01054ee:	50                   	push   %eax
f01054ef:	e8 c9 fc ff ff       	call   f01051bd <enqueue>
f01054f4:	83 c4 10             	add    $0x10,%esp
	}
}
f01054f7:	90                   	nop
f01054f8:	c9                   	leave  
f01054f9:	c3                   	ret    

f01054fa <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01054fa:	55                   	push   %ebp
f01054fb:	89 e5                	mov    %esp,%ebp
f01054fd:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105500:	83 ec 0c             	sub    $0xc,%esp
f0105503:	68 00 58 74 f0       	push   $0xf0745800
f0105508:	e8 f6 b4 00 00       	call   f0110a03 <holding_spinlock>
f010550d:	83 c4 10             	add    $0x10,%esp
f0105510:	85 c0                	test   %eax,%eax
f0105512:	75 17                	jne    f010552b <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105514:	83 ec 04             	sub    $0x4,%esp
f0105517:	68 e8 6f 12 f0       	push   $0xf0126fe8
f010551c:	68 97 00 00 00       	push   $0x97
f0105521:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105526:	e8 0e ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010552b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010552f:	75 19                	jne    f010554a <sched_insert_ready+0x50>
f0105531:	68 29 70 12 f0       	push   $0xf0127029
f0105536:	68 76 6f 12 f0       	push   $0xf0126f76
f010553b:	68 9a 00 00 00       	push   $0x9a
f0105540:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105545:	e8 ef ad ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f010554a:	8b 45 08             	mov    0x8(%ebp),%eax
f010554d:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f0105554:	8b 15 90 58 74 f0    	mov    0xf0745890,%edx
f010555a:	8b 45 08             	mov    0x8(%ebp),%eax
f010555d:	8b 40 1c             	mov    0x1c(%eax),%eax
f0105560:	c1 e0 04             	shl    $0x4,%eax
f0105563:	01 d0                	add    %edx,%eax
f0105565:	83 ec 08             	sub    $0x8,%esp
f0105568:	ff 75 08             	pushl  0x8(%ebp)
f010556b:	50                   	push   %eax
f010556c:	e8 4c fc ff ff       	call   f01051bd <enqueue>
f0105571:	83 c4 10             	add    $0x10,%esp
	}
}
f0105574:	90                   	nop
f0105575:	c9                   	leave  
f0105576:	c3                   	ret    

f0105577 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105577:	55                   	push   %ebp
f0105578:	89 e5                	mov    %esp,%ebp
f010557a:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010557d:	83 ec 0c             	sub    $0xc,%esp
f0105580:	68 00 58 74 f0       	push   $0xf0745800
f0105585:	e8 79 b4 00 00       	call   f0110a03 <holding_spinlock>
f010558a:	83 c4 10             	add    $0x10,%esp
f010558d:	85 c0                	test   %eax,%eax
f010558f:	75 17                	jne    f01055a8 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105591:	83 ec 04             	sub    $0x4,%esp
f0105594:	68 e8 6f 12 f0       	push   $0xf0126fe8
f0105599:	68 a9 00 00 00       	push   $0xa9
f010559e:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01055a3:	e8 91 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f01055a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01055ac:	74 0b                	je     f01055b9 <sched_remove_ready+0x42>
f01055ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01055b1:	8b 40 18             	mov    0x18(%eax),%eax
f01055b4:	83 f8 01             	cmp    $0x1,%eax
f01055b7:	74 19                	je     f01055d2 <sched_remove_ready+0x5b>
f01055b9:	68 38 70 12 f0       	push   $0xf0127038
f01055be:	68 76 6f 12 f0       	push   $0xf0126f76
f01055c3:	68 ac 00 00 00       	push   $0xac
f01055c8:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01055cd:	e8 67 ad ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01055d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055d9:	e9 e4 00 00 00       	jmp    f01056c2 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01055de:	8b 45 08             	mov    0x8(%ebp),%eax
f01055e1:	8b 40 10             	mov    0x10(%eax),%eax
f01055e4:	89 c2                	mov    %eax,%edx
f01055e6:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01055eb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01055ee:	c1 e1 04             	shl    $0x4,%ecx
f01055f1:	01 c8                	add    %ecx,%eax
f01055f3:	83 ec 08             	sub    $0x8,%esp
f01055f6:	52                   	push   %edx
f01055f7:	50                   	push   %eax
f01055f8:	e8 c2 fd ff ff       	call   f01053bf <find_env_in_queue>
f01055fd:	83 c4 10             	add    $0x10,%esp
f0105600:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105603:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105607:	0f 84 b2 00 00 00    	je     f01056bf <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f010560d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105611:	75 17                	jne    f010562a <sched_remove_ready+0xb3>
f0105613:	83 ec 04             	sub    $0x4,%esp
f0105616:	68 c7 6f 12 f0       	push   $0xf0126fc7
f010561b:	68 b3 00 00 00       	push   $0xb3
f0105620:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105625:	e8 0f ad ff ff       	call   f0100339 <_panic>
f010562a:	8b 45 08             	mov    0x8(%ebp),%eax
f010562d:	8b 40 08             	mov    0x8(%eax),%eax
f0105630:	85 c0                	test   %eax,%eax
f0105632:	74 11                	je     f0105645 <sched_remove_ready+0xce>
f0105634:	8b 45 08             	mov    0x8(%ebp),%eax
f0105637:	8b 40 08             	mov    0x8(%eax),%eax
f010563a:	8b 55 08             	mov    0x8(%ebp),%edx
f010563d:	8b 52 0c             	mov    0xc(%edx),%edx
f0105640:	89 50 0c             	mov    %edx,0xc(%eax)
f0105643:	eb 16                	jmp    f010565b <sched_remove_ready+0xe4>
f0105645:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010564a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010564d:	c1 e2 04             	shl    $0x4,%edx
f0105650:	01 c2                	add    %eax,%edx
f0105652:	8b 45 08             	mov    0x8(%ebp),%eax
f0105655:	8b 40 0c             	mov    0xc(%eax),%eax
f0105658:	89 42 04             	mov    %eax,0x4(%edx)
f010565b:	8b 45 08             	mov    0x8(%ebp),%eax
f010565e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105661:	85 c0                	test   %eax,%eax
f0105663:	74 11                	je     f0105676 <sched_remove_ready+0xff>
f0105665:	8b 45 08             	mov    0x8(%ebp),%eax
f0105668:	8b 40 0c             	mov    0xc(%eax),%eax
f010566b:	8b 55 08             	mov    0x8(%ebp),%edx
f010566e:	8b 52 08             	mov    0x8(%edx),%edx
f0105671:	89 50 08             	mov    %edx,0x8(%eax)
f0105674:	eb 15                	jmp    f010568b <sched_remove_ready+0x114>
f0105676:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010567b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010567e:	c1 e2 04             	shl    $0x4,%edx
f0105681:	01 c2                	add    %eax,%edx
f0105683:	8b 45 08             	mov    0x8(%ebp),%eax
f0105686:	8b 40 08             	mov    0x8(%eax),%eax
f0105689:	89 02                	mov    %eax,(%edx)
f010568b:	8b 45 08             	mov    0x8(%ebp),%eax
f010568e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105695:	8b 45 08             	mov    0x8(%ebp),%eax
f0105698:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010569f:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01056a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01056a7:	c1 e2 04             	shl    $0x4,%edx
f01056aa:	01 d0                	add    %edx,%eax
f01056ac:	8b 50 0c             	mov    0xc(%eax),%edx
f01056af:	4a                   	dec    %edx
f01056b0:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f01056b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b6:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01056bd:	eb 14                	jmp    f01056d3 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01056bf:	ff 45 f4             	incl   -0xc(%ebp)
f01056c2:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01056c7:	0f b6 c0             	movzbl %al,%eax
f01056ca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01056cd:	0f 8f 0b ff ff ff    	jg     f01055de <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01056d3:	c9                   	leave  
f01056d4:	c3                   	ret    

f01056d5 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01056d5:	55                   	push   %ebp
f01056d6:	89 e5                	mov    %esp,%ebp
f01056d8:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01056db:	83 ec 0c             	sub    $0xc,%esp
f01056de:	68 00 58 74 f0       	push   $0xf0745800
f01056e3:	e8 1b b3 00 00       	call   f0110a03 <holding_spinlock>
f01056e8:	83 c4 10             	add    $0x10,%esp
f01056eb:	85 c0                	test   %eax,%eax
f01056ed:	75 17                	jne    f0105706 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01056ef:	83 ec 04             	sub    $0x4,%esp
f01056f2:	68 e8 6f 12 f0       	push   $0xf0126fe8
f01056f7:	68 c2 00 00 00       	push   $0xc2
f01056fc:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105701:	e8 33 ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105706:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010570a:	75 19                	jne    f0105725 <sched_insert_new+0x50>
f010570c:	68 29 70 12 f0       	push   $0xf0127029
f0105711:	68 76 6f 12 f0       	push   $0xf0126f76
f0105716:	68 c5 00 00 00       	push   $0xc5
f010571b:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105720:	e8 14 ac ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f0105725:	8b 45 08             	mov    0x8(%ebp),%eax
f0105728:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010572f:	83 ec 08             	sub    $0x8,%esp
f0105732:	ff 75 08             	pushl  0x8(%ebp)
f0105735:	68 70 58 74 f0       	push   $0xf0745870
f010573a:	e8 7e fa ff ff       	call   f01051bd <enqueue>
f010573f:	83 c4 10             	add    $0x10,%esp
	}
}
f0105742:	90                   	nop
f0105743:	c9                   	leave  
f0105744:	c3                   	ret    

f0105745 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0105745:	55                   	push   %ebp
f0105746:	89 e5                	mov    %esp,%ebp
f0105748:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010574b:	83 ec 0c             	sub    $0xc,%esp
f010574e:	68 00 58 74 f0       	push   $0xf0745800
f0105753:	e8 ab b2 00 00       	call   f0110a03 <holding_spinlock>
f0105758:	83 c4 10             	add    $0x10,%esp
f010575b:	85 c0                	test   %eax,%eax
f010575d:	75 17                	jne    f0105776 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010575f:	83 ec 04             	sub    $0x4,%esp
f0105762:	68 e8 6f 12 f0       	push   $0xf0126fe8
f0105767:	68 d3 00 00 00       	push   $0xd3
f010576c:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105771:	e8 c3 ab ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105776:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010577a:	74 0b                	je     f0105787 <sched_remove_new+0x42>
f010577c:	8b 45 08             	mov    0x8(%ebp),%eax
f010577f:	8b 40 18             	mov    0x18(%eax),%eax
f0105782:	83 f8 04             	cmp    $0x4,%eax
f0105785:	74 19                	je     f01057a0 <sched_remove_new+0x5b>
f0105787:	68 64 70 12 f0       	push   $0xf0127064
f010578c:	68 76 6f 12 f0       	push   $0xf0126f76
f0105791:	68 d6 00 00 00       	push   $0xd6
f0105796:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010579b:	e8 99 ab ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f01057a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01057a4:	75 17                	jne    f01057bd <sched_remove_new+0x78>
f01057a6:	83 ec 04             	sub    $0x4,%esp
f01057a9:	68 c7 6f 12 f0       	push   $0xf0126fc7
f01057ae:	68 d8 00 00 00       	push   $0xd8
f01057b3:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01057b8:	e8 7c ab ff ff       	call   f0100339 <_panic>
f01057bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c0:	8b 40 08             	mov    0x8(%eax),%eax
f01057c3:	85 c0                	test   %eax,%eax
f01057c5:	74 11                	je     f01057d8 <sched_remove_new+0x93>
f01057c7:	8b 45 08             	mov    0x8(%ebp),%eax
f01057ca:	8b 40 08             	mov    0x8(%eax),%eax
f01057cd:	8b 55 08             	mov    0x8(%ebp),%edx
f01057d0:	8b 52 0c             	mov    0xc(%edx),%edx
f01057d3:	89 50 0c             	mov    %edx,0xc(%eax)
f01057d6:	eb 0b                	jmp    f01057e3 <sched_remove_new+0x9e>
f01057d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01057db:	8b 40 0c             	mov    0xc(%eax),%eax
f01057de:	a3 74 58 74 f0       	mov    %eax,0xf0745874
f01057e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e6:	8b 40 0c             	mov    0xc(%eax),%eax
f01057e9:	85 c0                	test   %eax,%eax
f01057eb:	74 11                	je     f01057fe <sched_remove_new+0xb9>
f01057ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01057f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01057f3:	8b 55 08             	mov    0x8(%ebp),%edx
f01057f6:	8b 52 08             	mov    0x8(%edx),%edx
f01057f9:	89 50 08             	mov    %edx,0x8(%eax)
f01057fc:	eb 0b                	jmp    f0105809 <sched_remove_new+0xc4>
f01057fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0105801:	8b 40 08             	mov    0x8(%eax),%eax
f0105804:	a3 70 58 74 f0       	mov    %eax,0xf0745870
f0105809:	8b 45 08             	mov    0x8(%ebp),%eax
f010580c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105813:	8b 45 08             	mov    0x8(%ebp),%eax
f0105816:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010581d:	a1 7c 58 74 f0       	mov    0xf074587c,%eax
f0105822:	48                   	dec    %eax
f0105823:	a3 7c 58 74 f0       	mov    %eax,0xf074587c
		env->env_status = ENV_UNKNOWN;
f0105828:	8b 45 08             	mov    0x8(%ebp),%eax
f010582b:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105832:	90                   	nop
f0105833:	c9                   	leave  
f0105834:	c3                   	ret    

f0105835 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0105835:	55                   	push   %ebp
f0105836:	89 e5                	mov    %esp,%ebp
f0105838:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010583b:	83 ec 0c             	sub    $0xc,%esp
f010583e:	68 00 58 74 f0       	push   $0xf0745800
f0105843:	e8 bb b1 00 00       	call   f0110a03 <holding_spinlock>
f0105848:	83 c4 10             	add    $0x10,%esp
f010584b:	85 c0                	test   %eax,%eax
f010584d:	75 17                	jne    f0105866 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010584f:	83 ec 04             	sub    $0x4,%esp
f0105852:	68 e8 6f 12 f0       	push   $0xf0126fe8
f0105857:	68 e4 00 00 00       	push   $0xe4
f010585c:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105861:	e8 d3 aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105866:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010586a:	75 19                	jne    f0105885 <sched_insert_exit+0x50>
f010586c:	68 29 70 12 f0       	push   $0xf0127029
f0105871:	68 76 6f 12 f0       	push   $0xf0126f76
f0105876:	68 e7 00 00 00       	push   $0xe7
f010587b:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105880:	e8 b4 aa ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105885:	e8 ad a4 00 00       	call   f010fd37 <isBufferingEnabled>
f010588a:	84 c0                	test   %al,%al
f010588c:	74 0e                	je     f010589c <sched_insert_exit+0x67>
f010588e:	83 ec 0c             	sub    $0xc,%esp
f0105891:	ff 75 08             	pushl  0x8(%ebp)
f0105894:	e8 f6 78 00 00       	call   f010d18f <cleanup_buffers>
f0105899:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010589c:	8b 45 08             	mov    0x8(%ebp),%eax
f010589f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f01058a6:	83 ec 08             	sub    $0x8,%esp
f01058a9:	ff 75 08             	pushl  0x8(%ebp)
f01058ac:	68 80 58 74 f0       	push   $0xf0745880
f01058b1:	e8 07 f9 ff ff       	call   f01051bd <enqueue>
f01058b6:	83 c4 10             	add    $0x10,%esp
	}
}
f01058b9:	90                   	nop
f01058ba:	c9                   	leave  
f01058bb:	c3                   	ret    

f01058bc <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01058bc:	55                   	push   %ebp
f01058bd:	89 e5                	mov    %esp,%ebp
f01058bf:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01058c2:	83 ec 0c             	sub    $0xc,%esp
f01058c5:	68 00 58 74 f0       	push   $0xf0745800
f01058ca:	e8 34 b1 00 00       	call   f0110a03 <holding_spinlock>
f01058cf:	83 c4 10             	add    $0x10,%esp
f01058d2:	85 c0                	test   %eax,%eax
f01058d4:	75 17                	jne    f01058ed <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01058d6:	83 ec 04             	sub    $0x4,%esp
f01058d9:	68 e8 6f 12 f0       	push   $0xf0126fe8
f01058de:	68 f5 00 00 00       	push   $0xf5
f01058e3:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01058e8:	e8 4c aa ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01058ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01058f1:	74 0b                	je     f01058fe <sched_remove_exit+0x42>
f01058f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01058f6:	8b 40 18             	mov    0x18(%eax),%eax
f01058f9:	83 f8 05             	cmp    $0x5,%eax
f01058fc:	74 19                	je     f0105917 <sched_remove_exit+0x5b>
f01058fe:	68 90 70 12 f0       	push   $0xf0127090
f0105903:	68 76 6f 12 f0       	push   $0xf0126f76
f0105908:	68 f8 00 00 00       	push   $0xf8
f010590d:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105912:	e8 22 aa ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105917:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010591b:	75 17                	jne    f0105934 <sched_remove_exit+0x78>
f010591d:	83 ec 04             	sub    $0x4,%esp
f0105920:	68 c7 6f 12 f0       	push   $0xf0126fc7
f0105925:	68 fa 00 00 00       	push   $0xfa
f010592a:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010592f:	e8 05 aa ff ff       	call   f0100339 <_panic>
f0105934:	8b 45 08             	mov    0x8(%ebp),%eax
f0105937:	8b 40 08             	mov    0x8(%eax),%eax
f010593a:	85 c0                	test   %eax,%eax
f010593c:	74 11                	je     f010594f <sched_remove_exit+0x93>
f010593e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105941:	8b 40 08             	mov    0x8(%eax),%eax
f0105944:	8b 55 08             	mov    0x8(%ebp),%edx
f0105947:	8b 52 0c             	mov    0xc(%edx),%edx
f010594a:	89 50 0c             	mov    %edx,0xc(%eax)
f010594d:	eb 0b                	jmp    f010595a <sched_remove_exit+0x9e>
f010594f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105952:	8b 40 0c             	mov    0xc(%eax),%eax
f0105955:	a3 84 58 74 f0       	mov    %eax,0xf0745884
f010595a:	8b 45 08             	mov    0x8(%ebp),%eax
f010595d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105960:	85 c0                	test   %eax,%eax
f0105962:	74 11                	je     f0105975 <sched_remove_exit+0xb9>
f0105964:	8b 45 08             	mov    0x8(%ebp),%eax
f0105967:	8b 40 0c             	mov    0xc(%eax),%eax
f010596a:	8b 55 08             	mov    0x8(%ebp),%edx
f010596d:	8b 52 08             	mov    0x8(%edx),%edx
f0105970:	89 50 08             	mov    %edx,0x8(%eax)
f0105973:	eb 0b                	jmp    f0105980 <sched_remove_exit+0xc4>
f0105975:	8b 45 08             	mov    0x8(%ebp),%eax
f0105978:	8b 40 08             	mov    0x8(%eax),%eax
f010597b:	a3 80 58 74 f0       	mov    %eax,0xf0745880
f0105980:	8b 45 08             	mov    0x8(%ebp),%eax
f0105983:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010598a:	8b 45 08             	mov    0x8(%ebp),%eax
f010598d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105994:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f0105999:	48                   	dec    %eax
f010599a:	a3 8c 58 74 f0       	mov    %eax,0xf074588c
		env->env_status = ENV_UNKNOWN;
f010599f:	8b 45 08             	mov    0x8(%ebp),%eax
f01059a2:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01059a9:	90                   	nop
f01059aa:	c9                   	leave  
f01059ab:	c3                   	ret    

f01059ac <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01059ac:	55                   	push   %ebp
f01059ad:	89 e5                	mov    %esp,%ebp
f01059af:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059b2:	83 ec 0c             	sub    $0xc,%esp
f01059b5:	68 00 58 74 f0       	push   $0xf0745800
f01059ba:	e8 2b ae 00 00       	call   f01107ea <acquire_spinlock>
f01059bf:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01059c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01059c6:	75 19                	jne    f01059e1 <sched_new_env+0x35>
f01059c8:	68 bb 70 12 f0       	push   $0xf01270bb
f01059cd:	68 76 6f 12 f0       	push   $0xf0126f76
f01059d2:	68 08 01 00 00       	push   $0x108
f01059d7:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01059dc:	e8 58 a9 ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f01059e1:	83 ec 0c             	sub    $0xc,%esp
f01059e4:	ff 75 08             	pushl  0x8(%ebp)
f01059e7:	e8 e9 fc ff ff       	call   f01056d5 <sched_insert_new>
f01059ec:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01059ef:	83 ec 0c             	sub    $0xc,%esp
f01059f2:	68 00 58 74 f0       	push   $0xf0745800
f01059f7:	e8 75 ae 00 00       	call   f0110871 <release_spinlock>
f01059fc:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01059ff:	90                   	nop
f0105a00:	c9                   	leave  
f0105a01:	c3                   	ret    

f0105a02 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105a02:	55                   	push   %ebp
f0105a03:	89 e5                	mov    %esp,%ebp
f0105a05:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a08:	83 ec 0c             	sub    $0xc,%esp
f0105a0b:	68 00 58 74 f0       	push   $0xf0745800
f0105a10:	e8 d5 ad 00 00       	call   f01107ea <acquire_spinlock>
f0105a15:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105a18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a1f:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f0105a24:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a27:	eb 53                	jmp    f0105a7c <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a2c:	8b 40 10             	mov    0x10(%eax),%eax
f0105a2f:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105a32:	75 40                	jne    f0105a74 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0105a34:	83 ec 0c             	sub    $0xc,%esp
f0105a37:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a3a:	e8 06 fd ff ff       	call   f0105745 <sched_remove_new>
f0105a3f:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f0105a42:	83 ec 0c             	sub    $0xc,%esp
f0105a45:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a48:	e8 ad fa ff ff       	call   f01054fa <sched_insert_ready>
f0105a4d:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105a50:	e8 92 1d 00 00       	call   f01077e7 <mycpu>
f0105a55:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105a5b:	85 c0                	test   %eax,%eax
f0105a5d:	75 46                	jne    f0105aa5 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a5f:	83 ec 0c             	sub    $0xc,%esp
f0105a62:	68 00 58 74 f0       	push   $0xf0745800
f0105a67:	e8 05 ae 00 00       	call   f0110871 <release_spinlock>
f0105a6c:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105a6f:	e8 d4 10 00 00       	call   f0106b48 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105a74:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105a79:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a80:	74 08                	je     f0105a8a <sched_run_env+0x88>
f0105a82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a85:	8b 40 08             	mov    0x8(%eax),%eax
f0105a88:	eb 05                	jmp    f0105a8f <sched_run_env+0x8d>
f0105a8a:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a8f:	a3 78 58 74 f0       	mov    %eax,0xf0745878
f0105a94:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105a99:	85 c0                	test   %eax,%eax
f0105a9b:	75 8c                	jne    f0105a29 <sched_run_env+0x27>
f0105a9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105aa1:	75 86                	jne    f0105a29 <sched_run_env+0x27>
f0105aa3:	eb 01                	jmp    f0105aa6 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105aa5:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105aa6:	83 ec 0c             	sub    $0xc,%esp
f0105aa9:	68 00 58 74 f0       	push   $0xf0745800
f0105aae:	e8 be ad 00 00       	call   f0110871 <release_spinlock>
f0105ab3:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105ab6:	90                   	nop
f0105ab7:	c9                   	leave  
f0105ab8:	c3                   	ret    

f0105ab9 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0105ab9:	55                   	push   %ebp
f0105aba:	89 e5                	mov    %esp,%ebp
f0105abc:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f0105abf:	83 ec 0c             	sub    $0xc,%esp
f0105ac2:	68 00 58 74 f0       	push   $0xf0745800
f0105ac7:	e8 37 af 00 00       	call   f0110a03 <holding_spinlock>
f0105acc:	83 c4 10             	add    $0x10,%esp
f0105acf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105ad2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105ad6:	75 10                	jne    f0105ae8 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105ad8:	83 ec 0c             	sub    $0xc,%esp
f0105adb:	68 00 58 74 f0       	push   $0xf0745800
f0105ae0:	e8 05 ad 00 00       	call   f01107ea <acquire_spinlock>
f0105ae5:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105ae8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105aef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105af6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105afa:	75 59                	jne    f0105b55 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105afc:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f0105b01:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b04:	eb 28                	jmp    f0105b2e <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b09:	8b 40 10             	mov    0x10(%eax),%eax
f0105b0c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b0f:	75 15                	jne    f0105b26 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105b11:	83 ec 0c             	sub    $0xc,%esp
f0105b14:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b17:	e8 29 fc ff ff       	call   f0105745 <sched_remove_new>
f0105b1c:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b1f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b26:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105b2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b32:	74 08                	je     f0105b3c <sched_exit_env+0x83>
f0105b34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b37:	8b 40 08             	mov    0x8(%eax),%eax
f0105b3a:	eb 05                	jmp    f0105b41 <sched_exit_env+0x88>
f0105b3c:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b41:	a3 78 58 74 f0       	mov    %eax,0xf0745878
f0105b46:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105b4b:	85 c0                	test   %eax,%eax
f0105b4d:	75 b7                	jne    f0105b06 <sched_exit_env+0x4d>
f0105b4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b53:	75 b1                	jne    f0105b06 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105b55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b59:	0f 85 67 01 00 00    	jne    f0105cc6 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105b5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105b66:	e9 47 01 00 00       	jmp    f0105cb2 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105b6b:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105b70:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b73:	c1 e2 04             	shl    $0x4,%edx
f0105b76:	01 d0                	add    %edx,%eax
f0105b78:	8b 00                	mov    (%eax),%eax
f0105b7a:	85 c0                	test   %eax,%eax
f0105b7c:	0f 84 27 01 00 00    	je     f0105ca9 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105b82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105b89:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105b8e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105b91:	c1 e2 04             	shl    $0x4,%edx
f0105b94:	01 d0                	add    %edx,%eax
f0105b96:	8b 00                	mov    (%eax),%eax
f0105b98:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b9b:	e9 d1 00 00 00       	jmp    f0105c71 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba3:	8b 40 10             	mov    0x10(%eax),%eax
f0105ba6:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ba9:	0f 85 af 00 00 00    	jne    f0105c5e <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105baf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bb3:	75 17                	jne    f0105bcc <sched_exit_env+0x113>
f0105bb5:	83 ec 04             	sub    $0x4,%esp
f0105bb8:	68 c7 6f 12 f0       	push   $0xf0126fc7
f0105bbd:	68 56 01 00 00       	push   $0x156
f0105bc2:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105bc7:	e8 6d a7 ff ff       	call   f0100339 <_panic>
f0105bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bcf:	8b 40 08             	mov    0x8(%eax),%eax
f0105bd2:	85 c0                	test   %eax,%eax
f0105bd4:	74 11                	je     f0105be7 <sched_exit_env+0x12e>
f0105bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bd9:	8b 40 08             	mov    0x8(%eax),%eax
f0105bdc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bdf:	8b 52 0c             	mov    0xc(%edx),%edx
f0105be2:	89 50 0c             	mov    %edx,0xc(%eax)
f0105be5:	eb 16                	jmp    f0105bfd <sched_exit_env+0x144>
f0105be7:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105bec:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bef:	c1 e2 04             	shl    $0x4,%edx
f0105bf2:	01 c2                	add    %eax,%edx
f0105bf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf7:	8b 40 0c             	mov    0xc(%eax),%eax
f0105bfa:	89 42 04             	mov    %eax,0x4(%edx)
f0105bfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c00:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c03:	85 c0                	test   %eax,%eax
f0105c05:	74 11                	je     f0105c18 <sched_exit_env+0x15f>
f0105c07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c0a:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c10:	8b 52 08             	mov    0x8(%edx),%edx
f0105c13:	89 50 08             	mov    %edx,0x8(%eax)
f0105c16:	eb 15                	jmp    f0105c2d <sched_exit_env+0x174>
f0105c18:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105c1d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c20:	c1 e2 04             	shl    $0x4,%edx
f0105c23:	01 c2                	add    %eax,%edx
f0105c25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c28:	8b 40 08             	mov    0x8(%eax),%eax
f0105c2b:	89 02                	mov    %eax,(%edx)
f0105c2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c30:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c3a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105c41:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105c46:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c49:	c1 e2 04             	shl    $0x4,%edx
f0105c4c:	01 d0                	add    %edx,%eax
f0105c4e:	8b 50 0c             	mov    0xc(%eax),%edx
f0105c51:	4a                   	dec    %edx
f0105c52:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105c55:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105c5c:	eb 4b                	jmp    f0105ca9 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c5e:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105c63:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c66:	c1 e2 04             	shl    $0x4,%edx
f0105c69:	01 d0                	add    %edx,%eax
f0105c6b:	8b 40 08             	mov    0x8(%eax),%eax
f0105c6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c71:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105c76:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c79:	c1 e2 04             	shl    $0x4,%edx
f0105c7c:	01 d0                	add    %edx,%eax
f0105c7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c82:	74 08                	je     f0105c8c <sched_exit_env+0x1d3>
f0105c84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c87:	8b 52 08             	mov    0x8(%edx),%edx
f0105c8a:	eb 05                	jmp    f0105c91 <sched_exit_env+0x1d8>
f0105c8c:	ba 00 00 00 00       	mov    $0x0,%edx
f0105c91:	89 50 08             	mov    %edx,0x8(%eax)
f0105c94:	8b 40 08             	mov    0x8(%eax),%eax
f0105c97:	85 c0                	test   %eax,%eax
f0105c99:	0f 85 01 ff ff ff    	jne    f0105ba0 <sched_exit_env+0xe7>
f0105c9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca3:	0f 85 f7 fe ff ff    	jne    f0105ba0 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105ca9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cad:	75 16                	jne    f0105cc5 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105caf:	ff 45 ec             	incl   -0x14(%ebp)
f0105cb2:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0105cb7:	0f b6 c0             	movzbl %al,%eax
f0105cba:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105cbd:	0f 8f a8 fe ff ff    	jg     f0105b6b <sched_exit_env+0xb2>
f0105cc3:	eb 01                	jmp    f0105cc6 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105cc5:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105cc6:	e8 79 62 00 00       	call   f010bf44 <get_cpu_proc>
f0105ccb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105cce:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105cd2:	75 19                	jne    f0105ced <sched_exit_env+0x234>
f0105cd4:	68 c3 70 12 f0       	push   $0xf01270c3
f0105cd9:	68 76 6f 12 f0       	push   $0xf0126f76
f0105cde:	68 60 01 00 00       	push   $0x160
f0105ce3:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105ce8:	e8 4c a6 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105ced:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105cf1:	75 18                	jne    f0105d0b <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105cf3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105cf6:	8b 40 10             	mov    0x10(%eax),%eax
f0105cf9:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105cfc:	75 0d                	jne    f0105d0b <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105cfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105d04:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105d0b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d0f:	74 1e                	je     f0105d2f <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105d11:	83 ec 0c             	sub    $0xc,%esp
f0105d14:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d17:	e8 19 fb ff ff       	call   f0105835 <sched_insert_exit>
f0105d1c:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105d1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105d22:	8b 40 10             	mov    0x10(%eax),%eax
f0105d25:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d28:	75 05                	jne    f0105d2f <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105d2a:	e8 8f 63 00 00       	call   f010c0be <sched>
		}
	}
	if (!lock_already_held)
f0105d2f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105d33:	75 10                	jne    f0105d45 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105d35:	83 ec 0c             	sub    $0xc,%esp
f0105d38:	68 00 58 74 f0       	push   $0xf0745800
f0105d3d:	e8 2f ab 00 00       	call   f0110871 <release_spinlock>
f0105d42:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105d45:	90                   	nop
f0105d46:	c9                   	leave  
f0105d47:	c3                   	ret    

f0105d48 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105d48:	55                   	push   %ebp
f0105d49:	89 e5                	mov    %esp,%ebp
f0105d4b:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d4e:	83 ec 0c             	sub    $0xc,%esp
f0105d51:	68 00 58 74 f0       	push   $0xf0745800
f0105d56:	e8 8f aa 00 00       	call   f01107ea <acquire_spinlock>
f0105d5b:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105d65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105d6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d70:	75 79                	jne    f0105deb <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105d72:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f0105d77:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d7a:	eb 48                	jmp    f0105dc4 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105d7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d7f:	8b 40 10             	mov    0x10(%eax),%eax
f0105d82:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d85:	75 35                	jne    f0105dbc <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d8a:	8d 50 20             	lea    0x20(%eax),%edx
f0105d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d90:	8b 40 10             	mov    0x10(%eax),%eax
f0105d93:	83 ec 04             	sub    $0x4,%esp
f0105d96:	52                   	push   %edx
f0105d97:	50                   	push   %eax
f0105d98:	68 d4 70 12 f0       	push   $0xf01270d4
f0105d9d:	e8 e9 b1 ff ff       	call   f0100f8b <cprintf>
f0105da2:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105da5:	83 ec 0c             	sub    $0xc,%esp
f0105da8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dab:	e8 95 f9 ff ff       	call   f0105745 <sched_remove_new>
f0105db0:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105db3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105dba:	eb 2f                	jmp    f0105deb <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105dbc:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105dc1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105dc4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105dc8:	74 08                	je     f0105dd2 <sched_kill_env+0x8a>
f0105dca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105dcd:	8b 40 08             	mov    0x8(%eax),%eax
f0105dd0:	eb 05                	jmp    f0105dd7 <sched_kill_env+0x8f>
f0105dd2:	b8 00 00 00 00       	mov    $0x0,%eax
f0105dd7:	a3 78 58 74 f0       	mov    %eax,0xf0745878
f0105ddc:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0105de1:	85 c0                	test   %eax,%eax
f0105de3:	75 97                	jne    f0105d7c <sched_kill_env+0x34>
f0105de5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105de9:	75 91                	jne    f0105d7c <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105deb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105def:	0f 85 85 01 00 00    	jne    f0105f7a <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105df5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105dfc:	e9 65 01 00 00       	jmp    f0105f66 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105e01:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105e06:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e09:	c1 e2 04             	shl    $0x4,%edx
f0105e0c:	01 d0                	add    %edx,%eax
f0105e0e:	8b 00                	mov    (%eax),%eax
f0105e10:	85 c0                	test   %eax,%eax
f0105e12:	0f 84 45 01 00 00    	je     f0105f5d <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105e18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105e1f:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105e24:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105e27:	c1 e2 04             	shl    $0x4,%edx
f0105e2a:	01 d0                	add    %edx,%eax
f0105e2c:	8b 00                	mov    (%eax),%eax
f0105e2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e31:	e9 ef 00 00 00       	jmp    f0105f25 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105e36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e39:	8b 40 10             	mov    0x10(%eax),%eax
f0105e3c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105e3f:	0f 85 cd 00 00 00    	jne    f0105f12 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e48:	8d 50 20             	lea    0x20(%eax),%edx
f0105e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e4e:	8b 40 10             	mov    0x10(%eax),%eax
f0105e51:	ff 75 ec             	pushl  -0x14(%ebp)
f0105e54:	52                   	push   %edx
f0105e55:	50                   	push   %eax
f0105e56:	68 fc 70 12 f0       	push   $0xf01270fc
f0105e5b:	e8 2b b1 ff ff       	call   f0100f8b <cprintf>
f0105e60:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105e63:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e67:	75 17                	jne    f0105e80 <sched_kill_env+0x138>
f0105e69:	83 ec 04             	sub    $0x4,%esp
f0105e6c:	68 c7 6f 12 f0       	push   $0xf0126fc7
f0105e71:	68 a3 01 00 00       	push   $0x1a3
f0105e76:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0105e7b:	e8 b9 a4 ff ff       	call   f0100339 <_panic>
f0105e80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e83:	8b 40 08             	mov    0x8(%eax),%eax
f0105e86:	85 c0                	test   %eax,%eax
f0105e88:	74 11                	je     f0105e9b <sched_kill_env+0x153>
f0105e8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e8d:	8b 40 08             	mov    0x8(%eax),%eax
f0105e90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e93:	8b 52 0c             	mov    0xc(%edx),%edx
f0105e96:	89 50 0c             	mov    %edx,0xc(%eax)
f0105e99:	eb 16                	jmp    f0105eb1 <sched_kill_env+0x169>
f0105e9b:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105ea0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ea3:	c1 e2 04             	shl    $0x4,%edx
f0105ea6:	01 c2                	add    %eax,%edx
f0105ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eab:	8b 40 0c             	mov    0xc(%eax),%eax
f0105eae:	89 42 04             	mov    %eax,0x4(%edx)
f0105eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eb4:	8b 40 0c             	mov    0xc(%eax),%eax
f0105eb7:	85 c0                	test   %eax,%eax
f0105eb9:	74 11                	je     f0105ecc <sched_kill_env+0x184>
f0105ebb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ebe:	8b 40 0c             	mov    0xc(%eax),%eax
f0105ec1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ec4:	8b 52 08             	mov    0x8(%edx),%edx
f0105ec7:	89 50 08             	mov    %edx,0x8(%eax)
f0105eca:	eb 15                	jmp    f0105ee1 <sched_kill_env+0x199>
f0105ecc:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105ed1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ed4:	c1 e2 04             	shl    $0x4,%edx
f0105ed7:	01 c2                	add    %eax,%edx
f0105ed9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105edc:	8b 40 08             	mov    0x8(%eax),%eax
f0105edf:	89 02                	mov    %eax,(%edx)
f0105ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ee4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105eee:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105ef5:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105efa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105efd:	c1 e2 04             	shl    $0x4,%edx
f0105f00:	01 d0                	add    %edx,%eax
f0105f02:	8b 50 0c             	mov    0xc(%eax),%edx
f0105f05:	4a                   	dec    %edx
f0105f06:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105f09:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105f10:	eb 4b                	jmp    f0105f5d <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f12:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105f17:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105f1a:	c1 e2 04             	shl    $0x4,%edx
f0105f1d:	01 d0                	add    %edx,%eax
f0105f1f:	8b 40 08             	mov    0x8(%eax),%eax
f0105f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f25:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0105f2a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105f2d:	c1 e2 04             	shl    $0x4,%edx
f0105f30:	01 d0                	add    %edx,%eax
f0105f32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f36:	74 08                	je     f0105f40 <sched_kill_env+0x1f8>
f0105f38:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f3b:	8b 52 08             	mov    0x8(%edx),%edx
f0105f3e:	eb 05                	jmp    f0105f45 <sched_kill_env+0x1fd>
f0105f40:	ba 00 00 00 00       	mov    $0x0,%edx
f0105f45:	89 50 08             	mov    %edx,0x8(%eax)
f0105f48:	8b 40 08             	mov    0x8(%eax),%eax
f0105f4b:	85 c0                	test   %eax,%eax
f0105f4d:	0f 85 e3 fe ff ff    	jne    f0105e36 <sched_kill_env+0xee>
f0105f53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f57:	0f 85 d9 fe ff ff    	jne    f0105e36 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105f5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f61:	75 16                	jne    f0105f79 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f63:	ff 45 ec             	incl   -0x14(%ebp)
f0105f66:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0105f6b:	0f b6 c0             	movzbl %al,%eax
f0105f6e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105f71:	0f 8f 8a fe ff ff    	jg     f0105e01 <sched_kill_env+0xb9>
f0105f77:	eb 01                	jmp    f0105f7a <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105f79:	90                   	nop
		}
	}
	if (!found)
f0105f7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105f7e:	0f 85 80 00 00 00    	jne    f0106004 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105f84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105f8b:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f0105f90:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f93:	eb 48                	jmp    f0105fdd <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f98:	8b 40 10             	mov    0x10(%eax),%eax
f0105f9b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105f9e:	75 35                	jne    f0105fd5 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fa3:	8d 50 20             	lea    0x20(%eax),%edx
f0105fa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fa9:	8b 40 10             	mov    0x10(%eax),%eax
f0105fac:	83 ec 04             	sub    $0x4,%esp
f0105faf:	52                   	push   %edx
f0105fb0:	50                   	push   %eax
f0105fb1:	68 28 71 12 f0       	push   $0xf0127128
f0105fb6:	e8 d0 af ff ff       	call   f0100f8b <cprintf>
f0105fbb:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105fbe:	83 ec 0c             	sub    $0xc,%esp
f0105fc1:	ff 75 f4             	pushl  -0xc(%ebp)
f0105fc4:	e8 f3 f8 ff ff       	call   f01058bc <sched_remove_exit>
f0105fc9:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105fcc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105fd3:	eb 2f                	jmp    f0106004 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105fd5:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0105fda:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fdd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fe1:	74 08                	je     f0105feb <sched_kill_env+0x2a3>
f0105fe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe6:	8b 40 08             	mov    0x8(%eax),%eax
f0105fe9:	eb 05                	jmp    f0105ff0 <sched_kill_env+0x2a8>
f0105feb:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ff0:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f0105ff5:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0105ffa:	85 c0                	test   %eax,%eax
f0105ffc:	75 97                	jne    f0105f95 <sched_kill_env+0x24d>
f0105ffe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106002:	75 91                	jne    f0105f95 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106004:	83 ec 0c             	sub    $0xc,%esp
f0106007:	68 00 58 74 f0       	push   $0xf0745800
f010600c:	e8 60 a8 00 00       	call   f0110871 <release_spinlock>
f0106011:	83 c4 10             	add    $0x10,%esp

	if (found)
f0106014:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106018:	74 23                	je     f010603d <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f010601a:	83 ec 0c             	sub    $0xc,%esp
f010601d:	ff 75 f4             	pushl  -0xc(%ebp)
f0106020:	e8 d7 5e 00 00       	call   f010befc <env_free>
f0106025:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0106028:	83 ec 0c             	sub    $0xc,%esp
f010602b:	68 4e 71 12 f0       	push   $0xf012714e
f0106030:	e8 56 af ff ff       	call   f0100f8b <cprintf>
f0106035:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0106038:	e9 a4 00 00 00       	jmp    f01060e1 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f010603d:	e8 02 5f 00 00       	call   f010bf44 <get_cpu_proc>
f0106042:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106045:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106049:	75 19                	jne    f0106064 <sched_kill_env+0x31c>
f010604b:	68 c3 70 12 f0       	push   $0xf01270c3
f0106050:	68 76 6f 12 f0       	push   $0xf0126f76
f0106055:	68 c5 01 00 00       	push   $0x1c5
f010605a:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010605f:	e8 d5 a2 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0106064:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106067:	8b 40 10             	mov    0x10(%eax),%eax
f010606a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010606d:	75 72                	jne    f01060e1 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f010606f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106072:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106075:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106078:	8b 40 18             	mov    0x18(%eax),%eax
f010607b:	83 f8 02             	cmp    $0x2,%eax
f010607e:	74 19                	je     f0106099 <sched_kill_env+0x351>
f0106080:	68 54 71 12 f0       	push   $0xf0127154
f0106085:	68 76 6f 12 f0       	push   $0xf0126f76
f010608a:	68 ca 01 00 00       	push   $0x1ca
f010608f:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0106094:	e8 a0 a2 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106099:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010609c:	8d 50 20             	lea    0x20(%eax),%edx
f010609f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060a2:	8b 40 10             	mov    0x10(%eax),%eax
f01060a5:	83 ec 04             	sub    $0x4,%esp
f01060a8:	52                   	push   %edx
f01060a9:	50                   	push   %eax
f01060aa:	68 78 71 12 f0       	push   $0xf0127178
f01060af:	e8 d7 ae ff ff       	call   f0100f8b <cprintf>
f01060b4:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01060b7:	83 ec 0c             	sub    $0xc,%esp
f01060ba:	ff 75 f4             	pushl  -0xc(%ebp)
f01060bd:	e8 3a 5e 00 00       	call   f010befc <env_free>
f01060c2:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01060c5:	83 ec 0c             	sub    $0xc,%esp
f01060c8:	68 4e 71 12 f0       	push   $0xf012714e
f01060cd:	e8 b9 ae ff ff       	call   f0100f8b <cprintf>
f01060d2:	83 c4 10             	add    $0x10,%esp
			found = 1;
f01060d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f01060dc:	e8 dd 5f 00 00       	call   f010c0be <sched>
		}
	}

}
f01060e1:	90                   	nop
f01060e2:	c9                   	leave  
f01060e3:	c3                   	ret    

f01060e4 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f01060e4:	55                   	push   %ebp
f01060e5:	89 e5                	mov    %esp,%ebp
f01060e7:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060ea:	83 ec 0c             	sub    $0xc,%esp
f01060ed:	68 00 58 74 f0       	push   $0xf0745800
f01060f2:	e8 f3 a6 00 00       	call   f01107ea <acquire_spinlock>
f01060f7:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01060fa:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f01060ff:	85 c0                	test   %eax,%eax
f0106101:	74 69                	je     f010616c <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0106103:	83 ec 0c             	sub    $0xc,%esp
f0106106:	68 a4 71 12 f0       	push   $0xf01271a4
f010610b:	e8 7b ae ff ff       	call   f0100f8b <cprintf>
f0106110:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106113:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f0106118:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010611b:	eb 26                	jmp    f0106143 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f010611d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106120:	8d 50 20             	lea    0x20(%eax),%edx
f0106123:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106126:	8b 40 10             	mov    0x10(%eax),%eax
f0106129:	83 ec 04             	sub    $0x4,%esp
f010612c:	52                   	push   %edx
f010612d:	50                   	push   %eax
f010612e:	68 c6 71 12 f0       	push   $0xf01271c6
f0106133:	e8 53 ae ff ff       	call   f0100f8b <cprintf>
f0106138:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010613b:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0106140:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106143:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106147:	74 08                	je     f0106151 <sched_print_all+0x6d>
f0106149:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010614c:	8b 40 08             	mov    0x8(%eax),%eax
f010614f:	eb 05                	jmp    f0106156 <sched_print_all+0x72>
f0106151:	b8 00 00 00 00       	mov    $0x0,%eax
f0106156:	a3 78 58 74 f0       	mov    %eax,0xf0745878
f010615b:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0106160:	85 c0                	test   %eax,%eax
f0106162:	75 b9                	jne    f010611d <sched_print_all+0x39>
f0106164:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106168:	75 b3                	jne    f010611d <sched_print_all+0x39>
f010616a:	eb 10                	jmp    f010617c <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f010616c:	83 ec 0c             	sub    $0xc,%esp
f010616f:	68 d0 71 12 f0       	push   $0xf01271d0
f0106174:	e8 12 ae ff ff       	call   f0100f8b <cprintf>
f0106179:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f010617c:	83 ec 0c             	sub    $0xc,%esp
f010617f:	68 ec 71 12 f0       	push   $0xf01271ec
f0106184:	e8 02 ae ff ff       	call   f0100f8b <cprintf>
f0106189:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010618c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106193:	e9 c7 00 00 00       	jmp    f010625f <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106198:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010619d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061a0:	c1 e2 04             	shl    $0x4,%edx
f01061a3:	01 d0                	add    %edx,%eax
f01061a5:	8b 00                	mov    (%eax),%eax
f01061a7:	85 c0                	test   %eax,%eax
f01061a9:	0f 84 8a 00 00 00    	je     f0106239 <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f01061af:	83 ec 08             	sub    $0x8,%esp
f01061b2:	ff 75 f0             	pushl  -0x10(%ebp)
f01061b5:	68 20 72 12 f0       	push   $0xf0127220
f01061ba:	e8 cc ad ff ff       	call   f0100f8b <cprintf>
f01061bf:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061c2:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01061c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061ca:	c1 e2 04             	shl    $0x4,%edx
f01061cd:	01 d0                	add    %edx,%eax
f01061cf:	8b 00                	mov    (%eax),%eax
f01061d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061d4:	eb 31                	jmp    f0106207 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f01061d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061d9:	8d 50 20             	lea    0x20(%eax),%edx
f01061dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061df:	8b 40 10             	mov    0x10(%eax),%eax
f01061e2:	83 ec 04             	sub    $0x4,%esp
f01061e5:	52                   	push   %edx
f01061e6:	50                   	push   %eax
f01061e7:	68 c6 71 12 f0       	push   $0xf01271c6
f01061ec:	e8 9a ad ff ff       	call   f0100f8b <cprintf>
f01061f1:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01061f4:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01061f9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01061fc:	c1 e2 04             	shl    $0x4,%edx
f01061ff:	01 d0                	add    %edx,%eax
f0106201:	8b 40 08             	mov    0x8(%eax),%eax
f0106204:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106207:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010620c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010620f:	c1 e2 04             	shl    $0x4,%edx
f0106212:	01 d0                	add    %edx,%eax
f0106214:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106218:	74 08                	je     f0106222 <sched_print_all+0x13e>
f010621a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010621d:	8b 52 08             	mov    0x8(%edx),%edx
f0106220:	eb 05                	jmp    f0106227 <sched_print_all+0x143>
f0106222:	ba 00 00 00 00       	mov    $0x0,%edx
f0106227:	89 50 08             	mov    %edx,0x8(%eax)
f010622a:	8b 40 08             	mov    0x8(%eax),%eax
f010622d:	85 c0                	test   %eax,%eax
f010622f:	75 a5                	jne    f01061d6 <sched_print_all+0xf2>
f0106231:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106235:	75 9f                	jne    f01061d6 <sched_print_all+0xf2>
f0106237:	eb 13                	jmp    f010624c <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106239:	83 ec 08             	sub    $0x8,%esp
f010623c:	ff 75 f0             	pushl  -0x10(%ebp)
f010623f:	68 48 72 12 f0       	push   $0xf0127248
f0106244:	e8 42 ad ff ff       	call   f0100f8b <cprintf>
f0106249:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f010624c:	83 ec 0c             	sub    $0xc,%esp
f010624f:	68 ec 71 12 f0       	push   $0xf01271ec
f0106254:	e8 32 ad ff ff       	call   f0100f8b <cprintf>
f0106259:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010625c:	ff 45 f0             	incl   -0x10(%ebp)
f010625f:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106264:	0f b6 c0             	movzbl %al,%eax
f0106267:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010626a:	0f 8f 28 ff ff ff    	jg     f0106198 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106270:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f0106275:	85 c0                	test   %eax,%eax
f0106277:	74 69                	je     f01062e2 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106279:	83 ec 0c             	sub    $0xc,%esp
f010627c:	68 6c 72 12 f0       	push   $0xf012726c
f0106281:	e8 05 ad ff ff       	call   f0100f8b <cprintf>
f0106286:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106289:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f010628e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106291:	eb 26                	jmp    f01062b9 <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106293:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106296:	8d 50 20             	lea    0x20(%eax),%edx
f0106299:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010629c:	8b 40 10             	mov    0x10(%eax),%eax
f010629f:	83 ec 04             	sub    $0x4,%esp
f01062a2:	52                   	push   %edx
f01062a3:	50                   	push   %eax
f01062a4:	68 c6 71 12 f0       	push   $0xf01271c6
f01062a9:	e8 dd ac ff ff       	call   f0100f8b <cprintf>
f01062ae:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01062b1:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f01062b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01062b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062bd:	74 08                	je     f01062c7 <sched_print_all+0x1e3>
f01062bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c2:	8b 40 08             	mov    0x8(%eax),%eax
f01062c5:	eb 05                	jmp    f01062cc <sched_print_all+0x1e8>
f01062c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01062cc:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f01062d1:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f01062d6:	85 c0                	test   %eax,%eax
f01062d8:	75 b9                	jne    f0106293 <sched_print_all+0x1af>
f01062da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01062de:	75 b3                	jne    f0106293 <sched_print_all+0x1af>
f01062e0:	eb 10                	jmp    f01062f2 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01062e2:	83 ec 0c             	sub    $0xc,%esp
f01062e5:	68 8e 72 12 f0       	push   $0xf012728e
f01062ea:	e8 9c ac ff ff       	call   f0100f8b <cprintf>
f01062ef:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01062f2:	83 ec 0c             	sub    $0xc,%esp
f01062f5:	68 00 58 74 f0       	push   $0xf0745800
f01062fa:	e8 72 a5 00 00       	call   f0110871 <release_spinlock>
f01062ff:	83 c4 10             	add    $0x10,%esp
}
f0106302:	90                   	nop
f0106303:	c9                   	leave  
f0106304:	c3                   	ret    

f0106305 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106305:	55                   	push   %ebp
f0106306:	89 e5                	mov    %esp,%ebp
f0106308:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010630b:	83 ec 0c             	sub    $0xc,%esp
f010630e:	68 00 58 74 f0       	push   $0xf0745800
f0106313:	e8 d2 a4 00 00       	call   f01107ea <acquire_spinlock>
f0106318:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010631b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0106322:	a1 7c 58 74 f0       	mov    0xf074587c,%eax
f0106327:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010632a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106331:	eb 24                	jmp    f0106357 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0106333:	83 ec 0c             	sub    $0xc,%esp
f0106336:	68 70 58 74 f0       	push   $0xf0745870
f010633b:	e8 0e ef ff ff       	call   f010524e <dequeue>
f0106340:	83 c4 10             	add    $0x10,%esp
f0106343:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0106346:	83 ec 0c             	sub    $0xc,%esp
f0106349:	ff 75 f0             	pushl  -0x10(%ebp)
f010634c:	e8 a9 f1 ff ff       	call   f01054fa <sched_insert_ready>
f0106351:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0106354:	ff 45 f4             	incl   -0xc(%ebp)
f0106357:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010635a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010635d:	7c d4                	jl     f0106333 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010635f:	83 ec 0c             	sub    $0xc,%esp
f0106362:	68 00 58 74 f0       	push   $0xf0745800
f0106367:	e8 05 a5 00 00       	call   f0110871 <release_spinlock>
f010636c:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f010636f:	e8 73 14 00 00       	call   f01077e7 <mycpu>
f0106374:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010637a:	85 c0                	test   %eax,%eax
f010637c:	75 05                	jne    f0106383 <sched_run_all+0x7e>
		fos_scheduler();
f010637e:	e8 c5 07 00 00       	call   f0106b48 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0106383:	83 ec 04             	sub    $0x4,%esp
f0106386:	68 ac 72 12 f0       	push   $0xf01272ac
f010638b:	68 27 02 00 00       	push   $0x227
f0106390:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0106395:	e8 9f 9f ff ff       	call   f0100339 <_panic>

f010639a <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010639a:	55                   	push   %ebp
f010639b:	89 e5                	mov    %esp,%ebp
f010639d:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01063a0:	83 ec 0c             	sub    $0xc,%esp
f01063a3:	68 00 58 74 f0       	push   $0xf0745800
f01063a8:	e8 3d a4 00 00       	call   f01107ea <acquire_spinlock>
f01063ad:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01063b0:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f01063b5:	85 c0                	test   %eax,%eax
f01063b7:	0f 84 95 00 00 00    	je     f0106452 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01063bd:	83 ec 0c             	sub    $0xc,%esp
f01063c0:	68 e8 72 12 f0       	push   $0xf01272e8
f01063c5:	e8 c1 ab ff ff       	call   f0100f8b <cprintf>
f01063ca:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01063cd:	a1 70 58 74 f0       	mov    0xf0745870,%eax
f01063d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063d5:	eb 52                	jmp    f0106429 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063da:	8d 50 20             	lea    0x20(%eax),%edx
f01063dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01063e0:	8b 40 10             	mov    0x10(%eax),%eax
f01063e3:	83 ec 04             	sub    $0x4,%esp
f01063e6:	52                   	push   %edx
f01063e7:	50                   	push   %eax
f01063e8:	68 14 73 12 f0       	push   $0xf0127314
f01063ed:	e8 99 ab ff ff       	call   f0100f8b <cprintf>
f01063f2:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01063f5:	83 ec 0c             	sub    $0xc,%esp
f01063f8:	ff 75 f4             	pushl  -0xc(%ebp)
f01063fb:	e8 45 f3 ff ff       	call   f0105745 <sched_remove_new>
f0106400:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106403:	83 ec 0c             	sub    $0xc,%esp
f0106406:	ff 75 f4             	pushl  -0xc(%ebp)
f0106409:	e8 ee 5a 00 00       	call   f010befc <env_free>
f010640e:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106411:	83 ec 0c             	sub    $0xc,%esp
f0106414:	68 4e 71 12 f0       	push   $0xf012714e
f0106419:	e8 6d ab ff ff       	call   f0100f8b <cprintf>
f010641e:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106421:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0106426:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106429:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010642d:	74 08                	je     f0106437 <sched_kill_all+0x9d>
f010642f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106432:	8b 40 08             	mov    0x8(%eax),%eax
f0106435:	eb 05                	jmp    f010643c <sched_kill_all+0xa2>
f0106437:	b8 00 00 00 00       	mov    $0x0,%eax
f010643c:	a3 78 58 74 f0       	mov    %eax,0xf0745878
f0106441:	a1 78 58 74 f0       	mov    0xf0745878,%eax
f0106446:	85 c0                	test   %eax,%eax
f0106448:	75 8d                	jne    f01063d7 <sched_kill_all+0x3d>
f010644a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010644e:	75 87                	jne    f01063d7 <sched_kill_all+0x3d>
f0106450:	eb 10                	jmp    f0106462 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0106452:	83 ec 0c             	sub    $0xc,%esp
f0106455:	68 27 73 12 f0       	push   $0xf0127327
f010645a:	e8 2c ab ff ff       	call   f0100f8b <cprintf>
f010645f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106462:	83 ec 0c             	sub    $0xc,%esp
f0106465:	68 ec 71 12 f0       	push   $0xf01271ec
f010646a:	e8 1c ab ff ff       	call   f0100f8b <cprintf>
f010646f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106472:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106479:	e9 96 01 00 00       	jmp    f0106614 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010647e:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106483:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106486:	c1 e2 04             	shl    $0x4,%edx
f0106489:	01 d0                	add    %edx,%eax
f010648b:	8b 00                	mov    (%eax),%eax
f010648d:	85 c0                	test   %eax,%eax
f010648f:	0f 84 59 01 00 00    	je     f01065ee <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106495:	83 ec 08             	sub    $0x8,%esp
f0106498:	ff 75 f0             	pushl  -0x10(%ebp)
f010649b:	68 44 73 12 f0       	push   $0xf0127344
f01064a0:	e8 e6 aa ff ff       	call   f0100f8b <cprintf>
f01064a5:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01064a8:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01064ad:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01064b0:	c1 e2 04             	shl    $0x4,%edx
f01064b3:	01 d0                	add    %edx,%eax
f01064b5:	8b 00                	mov    (%eax),%eax
f01064b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01064ba:	e9 f5 00 00 00       	jmp    f01065b4 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01064bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064c2:	8d 50 20             	lea    0x20(%eax),%edx
f01064c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064c8:	8b 40 10             	mov    0x10(%eax),%eax
f01064cb:	83 ec 04             	sub    $0x4,%esp
f01064ce:	52                   	push   %edx
f01064cf:	50                   	push   %eax
f01064d0:	68 14 73 12 f0       	push   $0xf0127314
f01064d5:	e8 b1 aa ff ff       	call   f0100f8b <cprintf>
f01064da:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01064dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01064e1:	75 17                	jne    f01064fa <sched_kill_all+0x160>
f01064e3:	83 ec 04             	sub    $0x4,%esp
f01064e6:	68 c7 6f 12 f0       	push   $0xf0126fc7
f01064eb:	68 49 02 00 00       	push   $0x249
f01064f0:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01064f5:	e8 3f 9e ff ff       	call   f0100339 <_panic>
f01064fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064fd:	8b 40 08             	mov    0x8(%eax),%eax
f0106500:	85 c0                	test   %eax,%eax
f0106502:	74 11                	je     f0106515 <sched_kill_all+0x17b>
f0106504:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106507:	8b 40 08             	mov    0x8(%eax),%eax
f010650a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010650d:	8b 52 0c             	mov    0xc(%edx),%edx
f0106510:	89 50 0c             	mov    %edx,0xc(%eax)
f0106513:	eb 16                	jmp    f010652b <sched_kill_all+0x191>
f0106515:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010651a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010651d:	c1 e2 04             	shl    $0x4,%edx
f0106520:	01 c2                	add    %eax,%edx
f0106522:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106525:	8b 40 0c             	mov    0xc(%eax),%eax
f0106528:	89 42 04             	mov    %eax,0x4(%edx)
f010652b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010652e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106531:	85 c0                	test   %eax,%eax
f0106533:	74 11                	je     f0106546 <sched_kill_all+0x1ac>
f0106535:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106538:	8b 40 0c             	mov    0xc(%eax),%eax
f010653b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010653e:	8b 52 08             	mov    0x8(%edx),%edx
f0106541:	89 50 08             	mov    %edx,0x8(%eax)
f0106544:	eb 15                	jmp    f010655b <sched_kill_all+0x1c1>
f0106546:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010654b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010654e:	c1 e2 04             	shl    $0x4,%edx
f0106551:	01 c2                	add    %eax,%edx
f0106553:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106556:	8b 40 08             	mov    0x8(%eax),%eax
f0106559:	89 02                	mov    %eax,(%edx)
f010655b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010655e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106565:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106568:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010656f:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106574:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106577:	c1 e2 04             	shl    $0x4,%edx
f010657a:	01 d0                	add    %edx,%eax
f010657c:	8b 50 0c             	mov    0xc(%eax),%edx
f010657f:	4a                   	dec    %edx
f0106580:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0106583:	83 ec 0c             	sub    $0xc,%esp
f0106586:	ff 75 f4             	pushl  -0xc(%ebp)
f0106589:	e8 6e 59 00 00       	call   f010befc <env_free>
f010658e:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106591:	83 ec 0c             	sub    $0xc,%esp
f0106594:	68 4e 71 12 f0       	push   $0xf012714e
f0106599:	e8 ed a9 ff ff       	call   f0100f8b <cprintf>
f010659e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01065a1:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01065a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065a9:	c1 e2 04             	shl    $0x4,%edx
f01065ac:	01 d0                	add    %edx,%eax
f01065ae:	8b 40 08             	mov    0x8(%eax),%eax
f01065b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01065b4:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01065b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065bc:	c1 e2 04             	shl    $0x4,%edx
f01065bf:	01 d0                	add    %edx,%eax
f01065c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065c5:	74 08                	je     f01065cf <sched_kill_all+0x235>
f01065c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065ca:	8b 52 08             	mov    0x8(%edx),%edx
f01065cd:	eb 05                	jmp    f01065d4 <sched_kill_all+0x23a>
f01065cf:	ba 00 00 00 00       	mov    $0x0,%edx
f01065d4:	89 50 08             	mov    %edx,0x8(%eax)
f01065d7:	8b 40 08             	mov    0x8(%eax),%eax
f01065da:	85 c0                	test   %eax,%eax
f01065dc:	0f 85 dd fe ff ff    	jne    f01064bf <sched_kill_all+0x125>
f01065e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01065e6:	0f 85 d3 fe ff ff    	jne    f01064bf <sched_kill_all+0x125>
f01065ec:	eb 13                	jmp    f0106601 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01065ee:	83 ec 08             	sub    $0x8,%esp
f01065f1:	ff 75 f0             	pushl  -0x10(%ebp)
f01065f4:	68 48 72 12 f0       	push   $0xf0127248
f01065f9:	e8 8d a9 ff ff       	call   f0100f8b <cprintf>
f01065fe:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106601:	83 ec 0c             	sub    $0xc,%esp
f0106604:	68 ec 71 12 f0       	push   $0xf01271ec
f0106609:	e8 7d a9 ff ff       	call   f0100f8b <cprintf>
f010660e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106611:	ff 45 f0             	incl   -0x10(%ebp)
f0106614:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106619:	0f b6 c0             	movzbl %al,%eax
f010661c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010661f:	0f 8f 59 fe ff ff    	jg     f010647e <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106625:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f010662a:	85 c0                	test   %eax,%eax
f010662c:	0f 84 95 00 00 00    	je     f01066c7 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0106632:	83 ec 0c             	sub    $0xc,%esp
f0106635:	68 78 73 12 f0       	push   $0xf0127378
f010663a:	e8 4c a9 ff ff       	call   f0100f8b <cprintf>
f010663f:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106642:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f0106647:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010664a:	eb 52                	jmp    f010669e <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010664c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010664f:	8d 50 20             	lea    0x20(%eax),%edx
f0106652:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106655:	8b 40 10             	mov    0x10(%eax),%eax
f0106658:	83 ec 04             	sub    $0x4,%esp
f010665b:	52                   	push   %edx
f010665c:	50                   	push   %eax
f010665d:	68 14 73 12 f0       	push   $0xf0127314
f0106662:	e8 24 a9 ff ff       	call   f0100f8b <cprintf>
f0106667:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010666a:	83 ec 0c             	sub    $0xc,%esp
f010666d:	ff 75 f4             	pushl  -0xc(%ebp)
f0106670:	e8 47 f2 ff ff       	call   f01058bc <sched_remove_exit>
f0106675:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106678:	83 ec 0c             	sub    $0xc,%esp
f010667b:	ff 75 f4             	pushl  -0xc(%ebp)
f010667e:	e8 79 58 00 00       	call   f010befc <env_free>
f0106683:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106686:	83 ec 0c             	sub    $0xc,%esp
f0106689:	68 4e 71 12 f0       	push   $0xf012714e
f010668e:	e8 f8 a8 ff ff       	call   f0100f8b <cprintf>
f0106693:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106696:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f010669b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010669e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01066a2:	74 08                	je     f01066ac <sched_kill_all+0x312>
f01066a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066a7:	8b 40 08             	mov    0x8(%eax),%eax
f01066aa:	eb 05                	jmp    f01066b1 <sched_kill_all+0x317>
f01066ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01066b1:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f01066b6:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f01066bb:	85 c0                	test   %eax,%eax
f01066bd:	75 8d                	jne    f010664c <sched_kill_all+0x2b2>
f01066bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01066c3:	75 87                	jne    f010664c <sched_kill_all+0x2b2>
f01066c5:	eb 10                	jmp    f01066d7 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01066c7:	83 ec 0c             	sub    $0xc,%esp
f01066ca:	68 8e 72 12 f0       	push   $0xf012728e
f01066cf:	e8 b7 a8 ff ff       	call   f0100f8b <cprintf>
f01066d4:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01066d7:	e8 68 58 00 00       	call   f010bf44 <get_cpu_proc>
f01066dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01066df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01066e3:	74 6b                	je     f0106750 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01066e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01066e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01066eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01066ee:	8b 40 18             	mov    0x18(%eax),%eax
f01066f1:	83 f8 02             	cmp    $0x2,%eax
f01066f4:	74 19                	je     f010670f <sched_kill_all+0x375>
f01066f6:	68 54 71 12 f0       	push   $0xf0127154
f01066fb:	68 76 6f 12 f0       	push   $0xf0126f76
f0106700:	68 69 02 00 00       	push   $0x269
f0106705:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010670a:	e8 2a 9c ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010670f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106712:	8d 50 20             	lea    0x20(%eax),%edx
f0106715:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106718:	8b 40 10             	mov    0x10(%eax),%eax
f010671b:	83 ec 04             	sub    $0x4,%esp
f010671e:	52                   	push   %edx
f010671f:	50                   	push   %eax
f0106720:	68 78 71 12 f0       	push   $0xf0127178
f0106725:	e8 61 a8 ff ff       	call   f0100f8b <cprintf>
f010672a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010672d:	83 ec 0c             	sub    $0xc,%esp
f0106730:	ff 75 f4             	pushl  -0xc(%ebp)
f0106733:	e8 c4 57 00 00       	call   f010befc <env_free>
f0106738:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f010673b:	83 ec 0c             	sub    $0xc,%esp
f010673e:	68 4e 71 12 f0       	push   $0xf012714e
f0106743:	e8 43 a8 ff ff       	call   f0100f8b <cprintf>
f0106748:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f010674b:	e8 6e 59 00 00       	call   f010c0be <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106750:	83 ec 0c             	sub    $0xc,%esp
f0106753:	68 00 58 74 f0       	push   $0xf0745800
f0106758:	e8 14 a1 00 00       	call   f0110871 <release_spinlock>
f010675d:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f0106760:	e8 5d b6 ff ff       	call   f0101dc2 <get_into_prompt>

f0106765 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106765:	55                   	push   %ebp
f0106766:	89 e5                	mov    %esp,%ebp
f0106768:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010676b:	83 ec 0c             	sub    $0xc,%esp
f010676e:	68 00 58 74 f0       	push   $0xf0745800
f0106773:	e8 72 a0 00 00       	call   f01107ea <acquire_spinlock>
f0106778:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010677b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106782:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106789:	e9 37 01 00 00       	jmp    f01068c5 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010678e:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106793:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106796:	c1 e2 04             	shl    $0x4,%edx
f0106799:	01 d0                	add    %edx,%eax
f010679b:	8b 00                	mov    (%eax),%eax
f010679d:	85 c0                	test   %eax,%eax
f010679f:	0f 84 1d 01 00 00    	je     f01068c2 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f01067a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01067ac:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01067b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01067b4:	c1 e2 04             	shl    $0x4,%edx
f01067b7:	01 d0                	add    %edx,%eax
f01067b9:	8b 00                	mov    (%eax),%eax
f01067bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01067be:	e9 c7 00 00 00       	jmp    f010688a <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01067c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01067c7:	75 17                	jne    f01067e0 <sched_exit_all_ready_envs+0x7b>
f01067c9:	83 ec 04             	sub    $0x4,%esp
f01067cc:	68 c7 6f 12 f0       	push   $0xf0126fc7
f01067d1:	68 8b 02 00 00       	push   $0x28b
f01067d6:	68 8b 6f 12 f0       	push   $0xf0126f8b
f01067db:	e8 59 9b ff ff       	call   f0100339 <_panic>
f01067e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e3:	8b 40 08             	mov    0x8(%eax),%eax
f01067e6:	85 c0                	test   %eax,%eax
f01067e8:	74 11                	je     f01067fb <sched_exit_all_ready_envs+0x96>
f01067ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067ed:	8b 40 08             	mov    0x8(%eax),%eax
f01067f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01067f3:	8b 52 0c             	mov    0xc(%edx),%edx
f01067f6:	89 50 0c             	mov    %edx,0xc(%eax)
f01067f9:	eb 16                	jmp    f0106811 <sched_exit_all_ready_envs+0xac>
f01067fb:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106800:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106803:	c1 e2 04             	shl    $0x4,%edx
f0106806:	01 c2                	add    %eax,%edx
f0106808:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010680b:	8b 40 0c             	mov    0xc(%eax),%eax
f010680e:	89 42 04             	mov    %eax,0x4(%edx)
f0106811:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106814:	8b 40 0c             	mov    0xc(%eax),%eax
f0106817:	85 c0                	test   %eax,%eax
f0106819:	74 11                	je     f010682c <sched_exit_all_ready_envs+0xc7>
f010681b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010681e:	8b 40 0c             	mov    0xc(%eax),%eax
f0106821:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106824:	8b 52 08             	mov    0x8(%edx),%edx
f0106827:	89 50 08             	mov    %edx,0x8(%eax)
f010682a:	eb 15                	jmp    f0106841 <sched_exit_all_ready_envs+0xdc>
f010682c:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106831:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106834:	c1 e2 04             	shl    $0x4,%edx
f0106837:	01 c2                	add    %eax,%edx
f0106839:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010683c:	8b 40 08             	mov    0x8(%eax),%eax
f010683f:	89 02                	mov    %eax,(%edx)
f0106841:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106844:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010684b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010684e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106855:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010685a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010685d:	c1 e2 04             	shl    $0x4,%edx
f0106860:	01 d0                	add    %edx,%eax
f0106862:	8b 50 0c             	mov    0xc(%eax),%edx
f0106865:	4a                   	dec    %edx
f0106866:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f0106869:	83 ec 0c             	sub    $0xc,%esp
f010686c:	ff 75 f4             	pushl  -0xc(%ebp)
f010686f:	e8 c1 ef ff ff       	call   f0105835 <sched_insert_exit>
f0106874:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106877:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010687c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010687f:	c1 e2 04             	shl    $0x4,%edx
f0106882:	01 d0                	add    %edx,%eax
f0106884:	8b 40 08             	mov    0x8(%eax),%eax
f0106887:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010688a:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010688f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106892:	c1 e2 04             	shl    $0x4,%edx
f0106895:	01 d0                	add    %edx,%eax
f0106897:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010689b:	74 08                	je     f01068a5 <sched_exit_all_ready_envs+0x140>
f010689d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01068a0:	8b 52 08             	mov    0x8(%edx),%edx
f01068a3:	eb 05                	jmp    f01068aa <sched_exit_all_ready_envs+0x145>
f01068a5:	ba 00 00 00 00       	mov    $0x0,%edx
f01068aa:	89 50 08             	mov    %edx,0x8(%eax)
f01068ad:	8b 40 08             	mov    0x8(%eax),%eax
f01068b0:	85 c0                	test   %eax,%eax
f01068b2:	0f 85 0b ff ff ff    	jne    f01067c3 <sched_exit_all_ready_envs+0x5e>
f01068b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01068bc:	0f 85 01 ff ff ff    	jne    f01067c3 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01068c2:	ff 45 f0             	incl   -0x10(%ebp)
f01068c5:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01068ca:	0f b6 c0             	movzbl %al,%eax
f01068cd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01068d0:	0f 8f b8 fe ff ff    	jg     f010678e <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01068d6:	83 ec 0c             	sub    $0xc,%esp
f01068d9:	68 00 58 74 f0       	push   $0xf0745800
f01068de:	e8 8e 9f 00 00       	call   f0110871 <release_spinlock>
f01068e3:	83 c4 10             	add    $0x10,%esp
}
f01068e6:	90                   	nop
f01068e7:	c9                   	leave  
f01068e8:	c3                   	ret    

f01068e9 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01068e9:	55                   	push   %ebp
f01068ea:	89 e5                	mov    %esp,%ebp
	return ticks;
f01068ec:	a1 a8 5e 74 f0       	mov    0xf0745ea8,%eax
f01068f1:	8b 15 ac 5e 74 f0    	mov    0xf0745eac,%edx
}
f01068f7:	5d                   	pop    %ebp
f01068f8:	c3                   	ret    

f01068f9 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01068f9:	55                   	push   %ebp
f01068fa:	89 e5                	mov    %esp,%ebp
f01068fc:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068ff:	83 ec 04             	sub    $0x4,%esp
f0106902:	68 a4 73 12 f0       	push   $0xf01273a4
f0106907:	68 9e 02 00 00       	push   $0x29e
f010690c:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0106911:	e8 23 9a ff ff       	call   f0100339 <_panic>

f0106916 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0106916:	55                   	push   %ebp
f0106917:	89 e5                	mov    %esp,%ebp
f0106919:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010691c:	83 ec 04             	sub    $0x4,%esp
f010691f:	68 a4 73 12 f0       	push   $0xf01273a4
f0106924:	68 a6 02 00 00       	push   $0x2a6
f0106929:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010692e:	e8 06 9a ff ff       	call   f0100339 <_panic>

f0106933 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f0106933:	55                   	push   %ebp
f0106934:	89 e5                	mov    %esp,%ebp
f0106936:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106939:	83 ec 04             	sub    $0x4,%esp
f010693c:	68 a4 73 12 f0       	push   $0xf01273a4
f0106941:	68 ae 02 00 00       	push   $0x2ae
f0106946:	68 8b 6f 12 f0       	push   $0xf0126f8b
f010694b:	e8 e9 99 ff ff       	call   f0100339 <_panic>

f0106950 <get_load_average>:
}
int get_load_average()
{
f0106950:	55                   	push   %ebp
f0106951:	89 e5                	mov    %esp,%ebp
f0106953:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106956:	83 ec 04             	sub    $0x4,%esp
f0106959:	68 a4 73 12 f0       	push   $0xf01273a4
f010695e:	68 b6 02 00 00       	push   $0x2b6
f0106963:	68 8b 6f 12 f0       	push   $0xf0126f8b
f0106968:	e8 cc 99 ff ff       	call   f0100339 <_panic>

f010696d <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f010696d:	55                   	push   %ebp
f010696e:	89 e5                	mov    %esp,%ebp
f0106970:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - env_set_priority

	//Get the process of the given ID
	struct Env* proc ;
	int exist_or_not = envid2env(envID, &proc, 0);//This function checks whether the process of the passed envID parameter exists or not
f0106973:	83 ec 04             	sub    $0x4,%esp
f0106976:	6a 00                	push   $0x0
f0106978:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010697b:	50                   	push   %eax
f010697c:	ff 75 08             	pushl  0x8(%ebp)
f010697f:	e8 10 56 00 00       	call   f010bf94 <envid2env>
f0106984:	83 c4 10             	add    $0x10,%esp
f0106987:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Your code is here
	//Comment the following line
	//panic("Not implemented yet");

	/*Checking the validation of the passed parameters*/
	if (exist_or_not != 0)
f010698a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010698e:	74 15                	je     f01069a5 <env_set_priority+0x38>
	{
		cprintf("The passed process is NOT FOUND");
f0106990:	83 ec 0c             	sub    $0xc,%esp
f0106993:	68 b8 73 12 f0       	push   $0xf01273b8
f0106998:	e8 ee a5 ff ff       	call   f0100f8b <cprintf>
f010699d:	83 c4 10             	add    $0x10,%esp
		return;
f01069a0:	e9 b4 00 00 00       	jmp    f0106a59 <env_set_priority+0xec>
	}
	if (priority < 0)
f01069a5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01069a9:	79 15                	jns    f01069c0 <env_set_priority+0x53>
	{
		cprintf("INVALID PRIORITY\n");
f01069ab:	83 ec 0c             	sub    $0xc,%esp
f01069ae:	68 d8 73 12 f0       	push   $0xf01273d8
f01069b3:	e8 d3 a5 ff ff       	call   f0100f8b <cprintf>
f01069b8:	83 c4 10             	add    $0x10,%esp
		return;
f01069bb:	e9 99 00 00 00       	jmp    f0106a59 <env_set_priority+0xec>
	}
	if (priority > num_of_ready_queues)
f01069c0:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01069c5:	0f b6 c0             	movzbl %al,%eax
f01069c8:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01069cb:	7d 22                	jge    f01069ef <env_set_priority+0x82>
	{
		cprintf("The passed Priority EXCEEDS the number of ready queues\n");
f01069cd:	83 ec 0c             	sub    $0xc,%esp
f01069d0:	68 ec 73 12 f0       	push   $0xf01273ec
f01069d5:	e8 b1 a5 ff ff       	call   f0100f8b <cprintf>
f01069da:	83 c4 10             	add    $0x10,%esp
		cprintf("HINT: You can use the command schedPRIRR if you want to increase the number of ready queues\n");
f01069dd:	83 ec 0c             	sub    $0xc,%esp
f01069e0:	68 24 74 12 f0       	push   $0xf0127424
f01069e5:	e8 a1 a5 ff ff       	call   f0100f8b <cprintf>
f01069ea:	83 c4 10             	add    $0x10,%esp
		return;
f01069ed:	eb 6a                	jmp    f0106a59 <env_set_priority+0xec>
	}

	/*Checking if the process was already in a ready queue, then it must be removed from its previous queue
	  not to be existing in two ready queues, then add it to its new ready queue*/
	if (proc->env_status == ENV_READY)
f01069ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01069f2:	8b 40 18             	mov    0x18(%eax),%eax
f01069f5:	83 f8 01             	cmp    $0x1,%eax
f01069f8:	75 56                	jne    f0106a50 <env_set_priority+0xe3>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01069fa:	83 ec 0c             	sub    $0xc,%esp
f01069fd:	68 00 58 74 f0       	push   $0xf0745800
f0106a02:	e8 e3 9d 00 00       	call   f01107ea <acquire_spinlock>
f0106a07:	83 c4 10             	add    $0x10,%esp
		sched_remove_ready(proc);
f0106a0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106a0d:	83 ec 0c             	sub    $0xc,%esp
f0106a10:	50                   	push   %eax
f0106a11:	e8 61 eb ff ff       	call   f0105577 <sched_remove_ready>
f0106a16:	83 c4 10             	add    $0x10,%esp
		proc->priority = priority;
f0106a19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106a1c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0106a1f:	89 50 1c             	mov    %edx,0x1c(%eax)
		proc->starv_thrs_ticks = 0;
f0106a22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106a25:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f0106a2c:	00 00 00 
		sched_insert_ready(proc);
f0106a2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106a32:	83 ec 0c             	sub    $0xc,%esp
f0106a35:	50                   	push   %eax
f0106a36:	e8 bf ea ff ff       	call   f01054fa <sched_insert_ready>
f0106a3b:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&ProcessQueues.qlock);
f0106a3e:	83 ec 0c             	sub    $0xc,%esp
f0106a41:	68 00 58 74 f0       	push   $0xf0745800
f0106a46:	e8 26 9e 00 00       	call   f0110871 <release_spinlock>
f0106a4b:	83 c4 10             	add    $0x10,%esp
f0106a4e:	eb 09                	jmp    f0106a59 <env_set_priority+0xec>
	}
	else
	{proc->priority= priority;}
f0106a50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106a53:	8b 55 0c             	mov    0xc(%ebp),%edx
f0106a56:	89 50 1c             	mov    %edx,0x1c(%eax)
}
f0106a59:	c9                   	leave  
f0106a5a:	c3                   	ret    

f0106a5b <sched_set_starv_thresh>:

void sched_set_starv_thresh(uint32 starvThresh)
{
f0106a5b:	55                   	push   %ebp
f0106a5c:	89 e5                	mov    %esp,%ebp
f0106a5e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS3 - #06] [3] PRIORITY RR Scheduler - sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	//panic("Not implemented yet");

	if (starvThresh <= 0)
f0106a61:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106a65:	75 12                	jne    f0106a79 <sched_set_starv_thresh+0x1e>
	{
		cprintf("Invalid Number of Thresholds\n");
f0106a67:	83 ec 0c             	sub    $0xc,%esp
f0106a6a:	68 81 74 12 f0       	push   $0xf0127481
f0106a6f:	e8 17 a5 ff ff       	call   f0100f8b <cprintf>
f0106a74:	83 c4 10             	add    $0x10,%esp
		return;
f0106a77:	eb 1e                	jmp    f0106a97 <sched_set_starv_thresh+0x3c>
	}

	num_of_starvation_Threshold_MS3 = starvThresh;
f0106a79:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a7c:	a3 bc 5f 74 f0       	mov    %eax,0xf0745fbc
	cprintf("The current starvation threshold is %d\n",num_of_starvation_Threshold_MS3);
f0106a81:	a1 bc 5f 74 f0       	mov    0xf0745fbc,%eax
f0106a86:	83 ec 08             	sub    $0x8,%esp
f0106a89:	50                   	push   %eax
f0106a8a:	68 a0 74 12 f0       	push   $0xf01274a0
f0106a8f:	e8 f7 a4 ff ff       	call   f0100f8b <cprintf>
f0106a94:	83 c4 10             	add    $0x10,%esp
}
f0106a97:	c9                   	leave  
f0106a98:	c3                   	ret    

f0106a99 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0106a99:	55                   	push   %ebp
f0106a9a:	89 e5                	mov    %esp,%ebp
f0106a9c:	a1 f4 5c 74 f0       	mov    0xf0745cf4,%eax
f0106aa1:	85 c0                	test   %eax,%eax
f0106aa3:	0f 94 c0             	sete   %al
f0106aa6:	0f b6 c0             	movzbl %al,%eax
f0106aa9:	5d                   	pop    %ebp
f0106aaa:	c3                   	ret    

f0106aab <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f0106aab:	55                   	push   %ebp
f0106aac:	89 e5                	mov    %esp,%ebp
f0106aae:	a1 f4 5c 74 f0       	mov    0xf0745cf4,%eax
f0106ab3:	83 f8 01             	cmp    $0x1,%eax
f0106ab6:	0f 94 c0             	sete   %al
f0106ab9:	0f b6 c0             	movzbl %al,%eax
f0106abc:	5d                   	pop    %ebp
f0106abd:	c3                   	ret    

f0106abe <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f0106abe:	55                   	push   %ebp
f0106abf:	89 e5                	mov    %esp,%ebp
f0106ac1:	a1 f4 5c 74 f0       	mov    0xf0745cf4,%eax
f0106ac6:	83 f8 02             	cmp    $0x2,%eax
f0106ac9:	0f 94 c0             	sete   %al
f0106acc:	0f b6 c0             	movzbl %al,%eax
f0106acf:	5d                   	pop    %ebp
f0106ad0:	c3                   	ret    

f0106ad1 <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f0106ad1:	55                   	push   %ebp
f0106ad2:	89 e5                	mov    %esp,%ebp
f0106ad4:	a1 f4 5c 74 f0       	mov    0xf0745cf4,%eax
f0106ad9:	83 f8 03             	cmp    $0x3,%eax
f0106adc:	0f 94 c0             	sete   %al
f0106adf:	0f b6 c0             	movzbl %al,%eax
f0106ae2:	5d                   	pop    %ebp
f0106ae3:	c3                   	ret    

f0106ae4 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f0106ae4:	55                   	push   %ebp
f0106ae5:	89 e5                	mov    %esp,%ebp
f0106ae7:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106aea:	c7 05 d8 59 74 f0 00 	movl   $0x0,0xf07459d8
f0106af1:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f0106af4:	83 ec 0c             	sub    $0xc,%esp
f0106af7:	6a 0a                	push   $0xa
f0106af9:	e8 5e 02 00 00       	call   f0106d5c <sched_init_RR>
f0106afe:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0106b01:	83 ec 0c             	sub    $0xc,%esp
f0106b04:	68 70 58 74 f0       	push   $0xf0745870
f0106b09:	e8 6e e6 ff ff       	call   f010517c <init_queue>
f0106b0e:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106b11:	83 ec 0c             	sub    $0xc,%esp
f0106b14:	68 80 58 74 f0       	push   $0xf0745880
f0106b19:	e8 5e e6 ff ff       	call   f010517c <init_queue>
f0106b1e:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0106b21:	e8 c1 0c 00 00       	call   f01077e7 <mycpu>
f0106b26:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106b2d:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f0106b30:	83 ec 08             	sub    $0x8,%esp
f0106b33:	68 c8 74 12 f0       	push   $0xf01274c8
f0106b38:	68 00 58 74 f0       	push   $0xf0745800
f0106b3d:	e8 77 9c 00 00       	call   f01107b9 <init_spinlock>
f0106b42:	83 c4 10             	add    $0x10,%esp
}
f0106b45:	90                   	nop
f0106b46:	c9                   	leave  
f0106b47:	c3                   	ret    

f0106b48 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0106b48:	55                   	push   %ebp
f0106b49:	89 e5                	mov    %esp,%ebp
f0106b4b:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106b4e:	9c                   	pushf  
f0106b4f:	58                   	pop    %eax
f0106b50:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0106b53:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0106b56:	25 00 02 00 00       	and    $0x200,%eax
f0106b5b:	85 c0                	test   %eax,%eax
f0106b5d:	74 14                	je     f0106b73 <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f0106b5f:	83 ec 04             	sub    $0x4,%esp
f0106b62:	68 dc 74 12 f0       	push   $0xf01274dc
f0106b67:	6a 3a                	push   $0x3a
f0106b69:	68 12 75 12 f0       	push   $0xf0127512
f0106b6e:	e8 c6 97 ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0106b73:	e8 6f 0c 00 00       	call   f01077e7 <mycpu>
f0106b78:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106b7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b7e:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106b85:	00 00 00 

	chk1();
f0106b88:	e8 6a a5 01 00       	call   f01210f7 <chk1>
	c->scheduler_status = SCH_STARTED;
f0106b8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106b90:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106b97:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106b9a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f0106ba1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106ba8:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106ba9:	83 ec 0c             	sub    $0xc,%esp
f0106bac:	68 00 58 74 f0       	push   $0xf0745800
f0106bb1:	e8 34 9c 00 00       	call   f01107ea <acquire_spinlock>
f0106bb6:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106bb9:	a1 f4 5c 74 f0       	mov    0xf0745cf4,%eax
f0106bbe:	8b 04 85 94 39 18 f0 	mov    -0xfe7c66c(,%eax,4),%eax
f0106bc5:	ff d0                	call   *%eax
f0106bc7:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106bca:	e8 75 53 00 00       	call   f010bf44 <get_cpu_proc>
f0106bcf:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f0106bd2:	83 ec 0c             	sub    $0xc,%esp
f0106bd5:	ff 75 e8             	pushl  -0x18(%ebp)
f0106bd8:	e8 90 53 00 00       	call   f010bf6d <set_cpu_proc>
f0106bdd:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106be0:	83 ec 0c             	sub    $0xc,%esp
f0106be3:	ff 75 e8             	pushl  -0x18(%ebp)
f0106be6:	e8 12 a5 01 00       	call   f01210fd <chk2>
f0106beb:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106bee:	83 ec 0c             	sub    $0xc,%esp
f0106bf1:	ff 75 e0             	pushl  -0x20(%ebp)
f0106bf4:	e8 74 53 00 00       	call   f010bf6d <set_cpu_proc>
f0106bf9:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106bfc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106c00:	0f 84 dc 00 00 00    	je     f0106ce2 <fos_scheduler+0x19a>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106c06:	83 ec 0c             	sub    $0xc,%esp
f0106c09:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c0c:	e8 5c 53 00 00       	call   f010bf6d <set_cpu_proc>
f0106c11:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106c14:	83 ec 0c             	sub    $0xc,%esp
f0106c17:	ff 75 e8             	pushl  -0x18(%ebp)
f0106c1a:	e8 c2 55 00 00       	call   f010c1e1 <switchuvm>
f0106c1f:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f0106c22:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c25:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106c2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106c2f:	8b 40 04             	mov    0x4(%eax),%eax
f0106c32:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c35:	83 c2 04             	add    $0x4,%edx
f0106c38:	83 ec 08             	sub    $0x8,%esp
f0106c3b:	50                   	push   %eax
f0106c3c:	52                   	push   %edx
f0106c3d:	e8 42 e1 ff ff       	call   f0104d84 <context_switch>
f0106c42:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106c45:	9c                   	pushf  
f0106c46:	58                   	pop    %eax
f0106c47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f0106c4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f0106c4d:	25 00 02 00 00       	and    $0x200,%eax
f0106c52:	85 c0                	test   %eax,%eax
f0106c54:	74 14                	je     f0106c6a <fos_scheduler+0x122>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f0106c56:	83 ec 04             	sub    $0x4,%esp
f0106c59:	68 24 75 12 f0       	push   $0xf0127524
f0106c5e:	6a 77                	push   $0x77
f0106c60:	68 12 75 12 f0       	push   $0xf0127512
f0106c65:	e8 cf 96 ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f0106c6a:	e8 5e e2 ff ff       	call   f0104ecd <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f0106c6f:	e8 d0 52 00 00       	call   f010bf44 <get_cpu_proc>
f0106c74:	89 c2                	mov    %eax,%edx
f0106c76:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c79:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106c7f:	39 c2                	cmp    %eax,%edx
f0106c81:	74 19                	je     f0106c9c <fos_scheduler+0x154>
f0106c83:	68 5b 75 12 f0       	push   $0xf012755b
f0106c88:	68 75 75 12 f0       	push   $0xf0127575
f0106c8d:	68 80 00 00 00       	push   $0x80
f0106c92:	68 12 75 12 f0       	push   $0xf0127512
f0106c97:	e8 9d 96 ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106c9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c9f:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106ca5:	8b 40 18             	mov    0x18(%eax),%eax
f0106ca8:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106cab:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106caf:	75 19                	jne    f0106cca <fos_scheduler+0x182>
f0106cb1:	68 8a 75 12 f0       	push   $0xf012758a
f0106cb6:	68 75 75 12 f0       	push   $0xf0127575
f0106cbb:	68 82 00 00 00       	push   $0x82
f0106cc0:	68 12 75 12 f0       	push   $0xf0127512
f0106cc5:	e8 6f 96 ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f0106cca:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106cce:	74 12                	je     f0106ce2 <fos_scheduler+0x19a>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106cd0:	e8 f5 54 00 00       	call   f010c1ca <switchkvm>
					set_cpu_proc(NULL);
f0106cd5:	83 ec 0c             	sub    $0xc,%esp
f0106cd8:	6a 00                	push   $0x0
f0106cda:	e8 8e 52 00 00       	call   f010bf6d <set_cpu_proc>
f0106cdf:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106ce2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106ce6:	0f 85 cd fe ff ff    	jne    f0106bb9 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106cec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106cf3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106cfa:	eb 37                	jmp    f0106d33 <fos_scheduler+0x1eb>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106cfc:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f0106d02:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d05:	89 d0                	mov    %edx,%eax
f0106d07:	c1 e0 02             	shl    $0x2,%eax
f0106d0a:	01 d0                	add    %edx,%eax
f0106d0c:	c1 e0 03             	shl    $0x3,%eax
f0106d0f:	01 d0                	add    %edx,%eax
f0106d11:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0106d18:	01 d0                	add    %edx,%eax
f0106d1a:	c1 e0 02             	shl    $0x2,%eax
f0106d1d:	01 c8                	add    %ecx,%eax
f0106d1f:	8b 40 18             	mov    0x18(%eax),%eax
f0106d22:	83 f8 03             	cmp    $0x3,%eax
f0106d25:	75 09                	jne    f0106d30 <fos_scheduler+0x1e8>
			{
				is_any_blocked = 1;
f0106d27:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0106d2e:	eb 0d                	jmp    f0106d3d <fos_scheduler+0x1f5>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0106d30:	ff 45 f0             	incl   -0x10(%ebp)
f0106d33:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106d36:	3d c5 02 00 00       	cmp    $0x2c5,%eax
f0106d3b:	76 bf                	jbe    f0106cfc <fos_scheduler+0x1b4>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0106d3d:	83 ec 0c             	sub    $0xc,%esp
f0106d40:	68 00 58 74 f0       	push   $0xf0745800
f0106d45:	e8 27 9b 00 00       	call   f0110871 <release_spinlock>
f0106d4a:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f0106d4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d51:	0f 8f 51 fe ff ff    	jg     f0106ba8 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0106d57:	e8 66 b0 ff ff       	call   f0101dc2 <get_into_prompt>

f0106d5c <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0106d5c:	55                   	push   %ebp
f0106d5d:	89 e5                	mov    %esp,%ebp
f0106d5f:	83 ec 28             	sub    $0x28,%esp
f0106d62:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d65:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0106d68:	c6 05 40 5f 74 f0 01 	movb   $0x1,0xf0745f40
#if USE_KHEAP
	sched_delete_ready_queues();
f0106d6f:	e8 b8 e6 ff ff       	call   f010542c <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0106d74:	83 ec 0c             	sub    $0xc,%esp
f0106d77:	6a 10                	push   $0x10
f0106d79:	e8 ec 2e 00 00       	call   f0109c6a <kmalloc>
f0106d7e:	83 c4 10             	add    $0x10,%esp
f0106d81:	a3 90 58 74 f0       	mov    %eax,0xf0745890
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106d86:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106d8b:	0f b6 c0             	movzbl %al,%eax
f0106d8e:	83 ec 0c             	sub    $0xc,%esp
f0106d91:	50                   	push   %eax
f0106d92:	e8 d3 2e 00 00       	call   f0109c6a <kmalloc>
f0106d97:	83 c4 10             	add    $0x10,%esp
f0106d9a:	a3 c4 5b 74 f0       	mov    %eax,0xf0745bc4
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106d9f:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0106da4:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106da7:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106da9:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0106dae:	8a 00                	mov    (%eax),%al
f0106db0:	0f b6 c0             	movzbl %al,%eax
f0106db3:	83 ec 0c             	sub    $0xc,%esp
f0106db6:	50                   	push   %eax
f0106db7:	e8 da e1 ff ff       	call   f0104f96 <kclock_set_quantum>
f0106dbc:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106dbf:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106dc4:	83 ec 0c             	sub    $0xc,%esp
f0106dc7:	50                   	push   %eax
f0106dc8:	e8 af e3 ff ff       	call   f010517c <init_queue>
f0106dcd:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106dd0:	e8 20 e3 ff ff       	call   f01050f5 <kclock_read_cnt0_latch>
f0106dd5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106dd9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106ddd:	83 ec 08             	sub    $0x8,%esp
f0106de0:	50                   	push   %eax
f0106de1:	68 a0 75 12 f0       	push   $0xf01275a0
f0106de6:	e8 a0 a1 ff ff       	call   f0100f8b <cprintf>
f0106deb:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106dee:	e8 f4 09 00 00       	call   f01077e7 <mycpu>
f0106df3:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106dfa:	00 00 00 
	scheduler_method = SCH_RR;
f0106dfd:	c7 05 f4 5c 74 f0 00 	movl   $0x0,0xf0745cf4
f0106e04:	00 00 00 
	//=========================================
	//=========================================
}
f0106e07:	90                   	nop
f0106e08:	c9                   	leave  
f0106e09:	c3                   	ret    

f0106e0a <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106e0a:	55                   	push   %ebp
f0106e0b:	89 e5                	mov    %esp,%ebp
f0106e0d:	83 ec 18             	sub    $0x18,%esp
f0106e10:	8b 45 08             	mov    0x8(%ebp),%eax
f0106e13:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106e16:	e8 11 e6 ff ff       	call   f010542c <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e1b:	83 ec 04             	sub    $0x4,%esp
f0106e1e:	68 c8 75 12 f0       	push   $0xf01275c8
f0106e23:	68 d1 00 00 00       	push   $0xd1
f0106e28:	68 12 75 12 f0       	push   $0xf0127512
f0106e2d:	e8 07 95 ff ff       	call   f0100339 <_panic>

f0106e32 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106e32:	55                   	push   %ebp
f0106e33:	89 e5                	mov    %esp,%ebp
f0106e35:	83 ec 18             	sub    $0x18,%esp
f0106e38:	8b 55 08             	mov    0x8(%ebp),%edx
f0106e3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106e3e:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106e41:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106e44:	83 ec 04             	sub    $0x4,%esp
f0106e47:	68 c8 75 12 f0       	push   $0xf01275c8
f0106e4c:	68 e7 00 00 00       	push   $0xe7
f0106e51:	68 12 75 12 f0       	push   $0xf0127512
f0106e56:	e8 de 94 ff ff       	call   f0100339 <_panic>

f0106e5b <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0106e5b:	55                   	push   %ebp
f0106e5c:	89 e5                	mov    %esp,%ebp
f0106e5e:	83 ec 28             	sub    $0x28,%esp
f0106e61:	8b 55 08             	mov    0x8(%ebp),%edx
f0106e64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106e67:	88 55 e4             	mov    %dl,-0x1c(%ebp)
f0106e6a:	88 45 e0             	mov    %al,-0x20(%ebp)
	//Comment the following line
	//panic("Not implemented yet");

	//EDITED
	/*Checking the validation of the passed arguments*/
	if (numOfPriorities <= 0)
f0106e6d:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0106e71:	75 15                	jne    f0106e88 <sched_init_PRIRR+0x2d>
	{
		cprintf("Invalid number of priorities\n");
f0106e73:	83 ec 0c             	sub    $0xc,%esp
f0106e76:	68 dc 75 12 f0       	push   $0xf01275dc
f0106e7b:	e8 0b a1 ff ff       	call   f0100f8b <cprintf>
f0106e80:	83 c4 10             	add    $0x10,%esp
		return;
f0106e83:	e9 0a 01 00 00       	jmp    f0106f92 <sched_init_PRIRR+0x137>
	}
	if (quantum <= 0)
f0106e88:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
f0106e8c:	75 15                	jne    f0106ea3 <sched_init_PRIRR+0x48>
	{
		cprintf("Invalid Quantum\n");
f0106e8e:	83 ec 0c             	sub    $0xc,%esp
f0106e91:	68 fa 75 12 f0       	push   $0xf01275fa
f0106e96:	e8 f0 a0 ff ff       	call   f0100f8b <cprintf>
f0106e9b:	83 c4 10             	add    $0x10,%esp
		return;
f0106e9e:	e9 ef 00 00 00       	jmp    f0106f92 <sched_init_PRIRR+0x137>
	}
	if (starvThresh <= 0)
f0106ea3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0106ea7:	75 15                	jne    f0106ebe <sched_init_PRIRR+0x63>
	{
		cprintf("Invalid Starvation Threshold\n");
f0106ea9:	83 ec 0c             	sub    $0xc,%esp
f0106eac:	68 0b 76 12 f0       	push   $0xf012760b
f0106eb1:	e8 d5 a0 ff ff       	call   f0100f8b <cprintf>
f0106eb6:	83 c4 10             	add    $0x10,%esp
		return;
f0106eb9:	e9 d4 00 00 00       	jmp    f0106f92 <sched_init_PRIRR+0x137>
	}
	num_of_ready_queues = numOfPriorities;
f0106ebe:	8a 45 e4             	mov    -0x1c(%ebp),%al
f0106ec1:	a2 40 5f 74 f0       	mov    %al,0xf0745f40
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106ec6:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106ecb:	0f b6 c0             	movzbl %al,%eax
f0106ece:	83 ec 0c             	sub    $0xc,%esp
f0106ed1:	50                   	push   %eax
f0106ed2:	e8 93 2d 00 00       	call   f0109c6a <kmalloc>
f0106ed7:	83 c4 10             	add    $0x10,%esp
f0106eda:	a3 c4 5b 74 f0       	mov    %eax,0xf0745bc4
	quantums[0] = quantum;
f0106edf:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0106ee4:	8a 55 e0             	mov    -0x20(%ebp),%dl
f0106ee7:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106ee9:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0106eee:	8a 00                	mov    (%eax),%al
f0106ef0:	0f b6 c0             	movzbl %al,%eax
f0106ef3:	83 ec 0c             	sub    $0xc,%esp
f0106ef6:	50                   	push   %eax
f0106ef7:	e8 9a e0 ff ff       	call   f0104f96 <kclock_set_quantum>
f0106efc:	83 c4 10             	add    $0x10,%esp
	ProcessQueues.env_ready_queues = kmalloc(num_of_ready_queues * sizeof(struct Env_Queue));
f0106eff:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106f04:	0f b6 c0             	movzbl %al,%eax
f0106f07:	c1 e0 04             	shl    $0x4,%eax
f0106f0a:	83 ec 0c             	sub    $0xc,%esp
f0106f0d:	50                   	push   %eax
f0106f0e:	e8 57 2d 00 00       	call   f0109c6a <kmalloc>
f0106f13:	83 c4 10             	add    $0x10,%esp
f0106f16:	a3 90 58 74 f0       	mov    %eax,0xf0745890
	for (int k_priRR = 0; k_priRR < num_of_ready_queues; k_priRR++)
f0106f1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106f22:	eb 1c                	jmp    f0106f40 <sched_init_PRIRR+0xe5>
	{
		init_queue(&(ProcessQueues.env_ready_queues[k_priRR]));
f0106f24:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106f29:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106f2c:	c1 e2 04             	shl    $0x4,%edx
f0106f2f:	01 d0                	add    %edx,%eax
f0106f31:	83 ec 0c             	sub    $0xc,%esp
f0106f34:	50                   	push   %eax
f0106f35:	e8 42 e2 ff ff       	call   f010517c <init_queue>
f0106f3a:	83 c4 10             	add    $0x10,%esp
	num_of_ready_queues = numOfPriorities;
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
	quantums[0] = quantum;
	kclock_set_quantum(quantums[0]);
	ProcessQueues.env_ready_queues = kmalloc(num_of_ready_queues * sizeof(struct Env_Queue));
	for (int k_priRR = 0; k_priRR < num_of_ready_queues; k_priRR++)
f0106f3d:	ff 45 f4             	incl   -0xc(%ebp)
f0106f40:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0106f45:	0f b6 c0             	movzbl %al,%eax
f0106f48:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0106f4b:	7f d7                	jg     f0106f24 <sched_init_PRIRR+0xc9>
	{
		init_queue(&(ProcessQueues.env_ready_queues[k_priRR]));
	}
	sched_set_starv_thresh(starvThresh);
f0106f4d:	83 ec 0c             	sub    $0xc,%esp
f0106f50:	ff 75 10             	pushl  0x10(%ebp)
f0106f53:	e8 03 fb ff ff       	call   f0106a5b <sched_set_starv_thresh>
f0106f58:	83 c4 10             	add    $0x10,%esp

	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106f5b:	e8 95 e1 ff ff       	call   f01050f5 <kclock_read_cnt0_latch>
f0106f60:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	cprintf("*	PRIORITY RR scheduler with initial clock = %d\n", cnt0);
f0106f64:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
f0106f68:	83 ec 08             	sub    $0x8,%esp
f0106f6b:	50                   	push   %eax
f0106f6c:	68 2c 76 12 f0       	push   $0xf012762c
f0106f71:	e8 15 a0 ff ff       	call   f0100f8b <cprintf>
f0106f76:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106f79:	e8 69 08 00 00       	call   f01077e7 <mycpu>
f0106f7e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106f85:	00 00 00 
	scheduler_method = SCH_PRIRR;
f0106f88:	c7 05 f4 5c 74 f0 03 	movl   $0x3,0xf0745cf4
f0106f8f:	00 00 00 
	//=========================================
	//=========================================
}
f0106f92:	c9                   	leave  
f0106f93:	c3                   	ret    

f0106f94 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106f94:	55                   	push   %ebp
f0106f95:	89 e5                	mov    %esp,%ebp
f0106f97:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106f9a:	83 ec 0c             	sub    $0xc,%esp
f0106f9d:	68 00 58 74 f0       	push   $0xf0745800
f0106fa2:	e8 5c 9a 00 00       	call   f0110a03 <holding_spinlock>
f0106fa7:	83 c4 10             	add    $0x10,%esp
f0106faa:	85 c0                	test   %eax,%eax
f0106fac:	75 17                	jne    f0106fc5 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106fae:	83 ec 04             	sub    $0x4,%esp
f0106fb1:	68 60 76 12 f0       	push   $0xf0127660
f0106fb6:	68 30 01 00 00       	push   $0x130
f0106fbb:	68 12 75 12 f0       	push   $0xf0127512
f0106fc0:	e8 74 93 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106fc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106fcc:	e8 73 4f 00 00       	call   f010bf44 <get_cpu_proc>
f0106fd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106fd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106fd8:	74 14                	je     f0106fee <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106fda:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106fdf:	83 ec 08             	sub    $0x8,%esp
f0106fe2:	ff 75 f0             	pushl  -0x10(%ebp)
f0106fe5:	50                   	push   %eax
f0106fe6:	e8 d2 e1 ff ff       	call   f01051bd <enqueue>
f0106feb:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106fee:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0106ff3:	83 ec 0c             	sub    $0xc,%esp
f0106ff6:	50                   	push   %eax
f0106ff7:	e8 52 e2 ff ff       	call   f010524e <dequeue>
f0106ffc:	83 c4 10             	add    $0x10,%esp
f0106fff:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0107002:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f0107007:	8a 00                	mov    (%eax),%al
f0107009:	0f b6 c0             	movzbl %al,%eax
f010700c:	83 ec 0c             	sub    $0xc,%esp
f010700f:	50                   	push   %eax
f0107010:	e8 81 df ff ff       	call   f0104f96 <kclock_set_quantum>
f0107015:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0107018:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010701b:	c9                   	leave  
f010701c:	c3                   	ret    

f010701d <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f010701d:	55                   	push   %ebp
f010701e:	89 e5                	mov    %esp,%ebp
f0107020:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0107023:	83 ec 0c             	sub    $0xc,%esp
f0107026:	68 00 58 74 f0       	push   $0xf0745800
f010702b:	e8 d3 99 00 00       	call   f0110a03 <holding_spinlock>
f0107030:	83 c4 10             	add    $0x10,%esp
f0107033:	85 c0                	test   %eax,%eax
f0107035:	75 17                	jne    f010704e <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0107037:	83 ec 04             	sub    $0x4,%esp
f010703a:	68 ac 76 12 f0       	push   $0xf01276ac
f010703f:	68 4f 01 00 00       	push   $0x14f
f0107044:	68 12 75 12 f0       	push   $0xf0127512
f0107049:	e8 eb 92 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010704e:	83 ec 04             	sub    $0x4,%esp
f0107051:	68 c8 75 12 f0       	push   $0xf01275c8
f0107056:	68 55 01 00 00       	push   $0x155
f010705b:	68 12 75 12 f0       	push   $0xf0127512
f0107060:	e8 d4 92 ff ff       	call   f0100339 <_panic>

f0107065 <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0107065:	55                   	push   %ebp
f0107066:	89 e5                	mov    %esp,%ebp
f0107068:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010706b:	83 ec 0c             	sub    $0xc,%esp
f010706e:	68 00 58 74 f0       	push   $0xf0745800
f0107073:	e8 8b 99 00 00       	call   f0110a03 <holding_spinlock>
f0107078:	83 c4 10             	add    $0x10,%esp
f010707b:	85 c0                	test   %eax,%eax
f010707d:	75 17                	jne    f0107096 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f010707f:	83 ec 04             	sub    $0x4,%esp
f0107082:	68 fc 76 12 f0       	push   $0xf01276fc
f0107087:	68 60 01 00 00       	push   $0x160
f010708c:	68 12 75 12 f0       	push   $0xf0127512
f0107091:	e8 a3 92 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0107096:	83 ec 04             	sub    $0x4,%esp
f0107099:	68 c8 75 12 f0       	push   $0xf01275c8
f010709e:	68 66 01 00 00       	push   $0x166
f01070a3:	68 12 75 12 f0       	push   $0xf0127512
f01070a8:	e8 8c 92 ff ff       	call   f0100339 <_panic>

f01070ad <fos_scheduler_PRIRR>:
}
//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f01070ad:	55                   	push   %ebp
f01070ae:	89 e5                	mov    %esp,%ebp
f01070b0:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01070b3:	83 ec 0c             	sub    $0xc,%esp
f01070b6:	68 00 58 74 f0       	push   $0xf0745800
f01070bb:	e8 43 99 00 00       	call   f0110a03 <holding_spinlock>
f01070c0:	83 c4 10             	add    $0x10,%esp
f01070c3:	85 c0                	test   %eax,%eax
f01070c5:	75 17                	jne    f01070de <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f01070c7:	83 ec 04             	sub    $0x4,%esp
f01070ca:	68 4c 77 12 f0       	push   $0xf012774c
f01070cf:	68 70 01 00 00       	push   $0x170
f01070d4:	68 12 75 12 f0       	push   $0xf0127512
f01070d9:	e8 5b 92 ff ff       	call   f0100339 <_panic>
	//TODO: [PROJECT'24.MS3 - #08] [3] PRIORITY RR Scheduler - fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	//panic("Not implemented yet");

	struct Env *cur_running_procs = get_cpu_proc();
f01070de:	e8 61 4e 00 00       	call   f010bf44 <get_cpu_proc>
f01070e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env *next_running_procs = NULL;
f01070e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (cur_running_procs != NULL)
f01070ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01070f1:	74 1b                	je     f010710e <fos_scheduler_PRIRR+0x61>
	{
		sched_insert_ready(cur_running_procs);
f01070f3:	83 ec 0c             	sub    $0xc,%esp
f01070f6:	ff 75 ec             	pushl  -0x14(%ebp)
f01070f9:	e8 fc e3 ff ff       	call   f01054fa <sched_insert_ready>
f01070fe:	83 c4 10             	add    $0x10,%esp
		cur_running_procs->starv_thrs_ticks = 0;
f0107101:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107104:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010710b:	00 00 00 
	}
	for (int k = 0; k < num_of_ready_queues; k++)//Looping on the ready queues
f010710e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0107115:	eb 34                	jmp    f010714b <fos_scheduler_PRIRR+0x9e>
	{
		if(!LIST_EMPTY(&ProcessQueues.env_ready_queues[k]))
f0107117:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010711c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010711f:	c1 e2 04             	shl    $0x4,%edx
f0107122:	01 d0                	add    %edx,%eax
f0107124:	8b 00                	mov    (%eax),%eax
f0107126:	85 c0                	test   %eax,%eax
f0107128:	74 1e                	je     f0107148 <fos_scheduler_PRIRR+0x9b>
		{
			next_running_procs= dequeue(&ProcessQueues.env_ready_queues[k]);
f010712a:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f010712f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107132:	c1 e2 04             	shl    $0x4,%edx
f0107135:	01 d0                	add    %edx,%eax
f0107137:	83 ec 0c             	sub    $0xc,%esp
f010713a:	50                   	push   %eax
f010713b:	e8 0e e1 ff ff       	call   f010524e <dequeue>
f0107140:	83 c4 10             	add    $0x10,%esp
f0107143:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0107146:	eb 10                	jmp    f0107158 <fos_scheduler_PRIRR+0xab>
	if (cur_running_procs != NULL)
	{
		sched_insert_ready(cur_running_procs);
		cur_running_procs->starv_thrs_ticks = 0;
	}
	for (int k = 0; k < num_of_ready_queues; k++)//Looping on the ready queues
f0107148:	ff 45 f0             	incl   -0x10(%ebp)
f010714b:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0107150:	0f b6 c0             	movzbl %al,%eax
f0107153:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107156:	7f bf                	jg     f0107117 <fos_scheduler_PRIRR+0x6a>
		{
			next_running_procs= dequeue(&ProcessQueues.env_ready_queues[k]);
			break;
		}
	}
	kclock_set_quantum(quantums[0]);
f0107158:	a1 c4 5b 74 f0       	mov    0xf0745bc4,%eax
f010715d:	8a 00                	mov    (%eax),%al
f010715f:	0f b6 c0             	movzbl %al,%eax
f0107162:	83 ec 0c             	sub    $0xc,%esp
f0107165:	50                   	push   %eax
f0107166:	e8 2b de ff ff       	call   f0104f96 <kclock_set_quantum>
f010716b:	83 c4 10             	add    $0x10,%esp
	return next_running_procs;
f010716e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0107171:	c9                   	leave  
f0107172:	c3                   	ret    

f0107173 <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0107173:	55                   	push   %ebp
f0107174:	89 e5                	mov    %esp,%ebp
f0107176:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0107179:	e8 53 f9 ff ff       	call   f0106ad1 <isSchedMethodPRIRR>
f010717e:	85 c0                	test   %eax,%eax
f0107180:	0f 84 3a 01 00 00    	je     f01072c0 <clock_interrupt_handler+0x14d>
//			}
//			release_spinlock(&ProcessQueues.qlock);
//		}


		for (int k_priRR = 0; k_priRR < num_of_ready_queues; k_priRR++)
f0107186:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010718d:	e9 1d 01 00 00       	jmp    f01072af <clock_interrupt_handler+0x13c>
		{
			if ((&ProcessQueues.env_ready_queues[k_priRR])->size == 0) {continue;}
f0107192:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0107197:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010719a:	c1 e2 04             	shl    $0x4,%edx
f010719d:	01 d0                	add    %edx,%eax
f010719f:	8b 40 0c             	mov    0xc(%eax),%eax
f01071a2:	85 c0                	test   %eax,%eax
f01071a4:	0f 84 01 01 00 00    	je     f01072ab <clock_interrupt_handler+0x138>
			else
			{

				for (int j = 0; j < (&ProcessQueues.env_ready_queues[k_priRR])->size; j++)
f01071aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01071b1:	e9 d8 00 00 00       	jmp    f010728e <clock_interrupt_handler+0x11b>
				{
					struct Env *Ready_Head = dequeue(&ProcessQueues.env_ready_queues[k_priRR]);
f01071b6:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f01071bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01071be:	c1 e2 04             	shl    $0x4,%edx
f01071c1:	01 d0                	add    %edx,%eax
f01071c3:	83 ec 0c             	sub    $0xc,%esp
f01071c6:	50                   	push   %eax
f01071c7:	e8 82 e0 ff ff       	call   f010524e <dequeue>
f01071cc:	83 c4 10             	add    $0x10,%esp
f01071cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
					if (Ready_Head->starv_thrs_ticks > num_of_starvation_Threshold_MS3 && Ready_Head->priority != 0)
f01071d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01071d5:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f01071db:	a1 bc 5f 74 f0       	mov    0xf0745fbc,%eax
f01071e0:	39 c2                	cmp    %eax,%edx
f01071e2:	76 64                	jbe    f0107248 <clock_interrupt_handler+0xd5>
f01071e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01071e7:	8b 40 1c             	mov    0x1c(%eax),%eax
f01071ea:	85 c0                	test   %eax,%eax
f01071ec:	74 5a                	je     f0107248 <clock_interrupt_handler+0xd5>
					{
						acquire_spinlock(&ProcessQueues.qlock);
f01071ee:	83 ec 0c             	sub    $0xc,%esp
f01071f1:	68 00 58 74 f0       	push   $0xf0745800
f01071f6:	e8 ef 95 00 00       	call   f01107ea <acquire_spinlock>
f01071fb:	83 c4 10             	add    $0x10,%esp
						sched_remove_ready(Ready_Head);
f01071fe:	83 ec 0c             	sub    $0xc,%esp
f0107201:	ff 75 ec             	pushl  -0x14(%ebp)
f0107204:	e8 6e e3 ff ff       	call   f0105577 <sched_remove_ready>
f0107209:	83 c4 10             	add    $0x10,%esp
						Ready_Head->priority--;
f010720c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010720f:	8b 40 1c             	mov    0x1c(%eax),%eax
f0107212:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107215:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107218:	89 50 1c             	mov    %edx,0x1c(%eax)
						Ready_Head->starv_thrs_ticks = 0;
f010721b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010721e:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f0107225:	00 00 00 
						sched_insert_ready(Ready_Head);
f0107228:	83 ec 0c             	sub    $0xc,%esp
f010722b:	ff 75 ec             	pushl  -0x14(%ebp)
f010722e:	e8 c7 e2 ff ff       	call   f01054fa <sched_insert_ready>
f0107233:	83 c4 10             	add    $0x10,%esp
						release_spinlock(&ProcessQueues.qlock);
f0107236:	83 ec 0c             	sub    $0xc,%esp
f0107239:	68 00 58 74 f0       	push   $0xf0745800
f010723e:	e8 2e 96 00 00       	call   f0110871 <release_spinlock>
f0107243:	83 c4 10             	add    $0x10,%esp
f0107246:	eb 43                	jmp    f010728b <clock_interrupt_handler+0x118>
					}
					else
					{
						acquire_spinlock(&ProcessQueues.qlock);
f0107248:	83 ec 0c             	sub    $0xc,%esp
f010724b:	68 00 58 74 f0       	push   $0xf0745800
f0107250:	e8 95 95 00 00       	call   f01107ea <acquire_spinlock>
f0107255:	83 c4 10             	add    $0x10,%esp
						Ready_Head->starv_thrs_ticks ++;
f0107258:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010725b:	8b 80 94 05 00 00    	mov    0x594(%eax),%eax
f0107261:	8d 50 01             	lea    0x1(%eax),%edx
f0107264:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107267:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)
						sched_insert_ready(Ready_Head);
f010726d:	83 ec 0c             	sub    $0xc,%esp
f0107270:	ff 75 ec             	pushl  -0x14(%ebp)
f0107273:	e8 82 e2 ff ff       	call   f01054fa <sched_insert_ready>
f0107278:	83 c4 10             	add    $0x10,%esp
						release_spinlock(&ProcessQueues.qlock);
f010727b:	83 ec 0c             	sub    $0xc,%esp
f010727e:	68 00 58 74 f0       	push   $0xf0745800
f0107283:	e8 e9 95 00 00       	call   f0110871 <release_spinlock>
f0107288:	83 c4 10             	add    $0x10,%esp
		{
			if ((&ProcessQueues.env_ready_queues[k_priRR])->size == 0) {continue;}
			else
			{

				for (int j = 0; j < (&ProcessQueues.env_ready_queues[k_priRR])->size; j++)
f010728b:	ff 45 f0             	incl   -0x10(%ebp)
f010728e:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0107293:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107296:	c1 e2 04             	shl    $0x4,%edx
f0107299:	01 d0                	add    %edx,%eax
f010729b:	8b 50 0c             	mov    0xc(%eax),%edx
f010729e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01072a1:	39 c2                	cmp    %eax,%edx
f01072a3:	0f 87 0d ff ff ff    	ja     f01071b6 <clock_interrupt_handler+0x43>
f01072a9:	eb 01                	jmp    f01072ac <clock_interrupt_handler+0x139>
//		}


		for (int k_priRR = 0; k_priRR < num_of_ready_queues; k_priRR++)
		{
			if ((&ProcessQueues.env_ready_queues[k_priRR])->size == 0) {continue;}
f01072ab:	90                   	nop
//			}
//			release_spinlock(&ProcessQueues.qlock);
//		}


		for (int k_priRR = 0; k_priRR < num_of_ready_queues; k_priRR++)
f01072ac:	ff 45 f4             	incl   -0xc(%ebp)
f01072af:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01072b4:	0f b6 c0             	movzbl %al,%eax
f01072b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01072ba:	0f 8f d2 fe ff ff    	jg     f0107192 <clock_interrupt_handler+0x1f>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f01072c0:	a1 a8 5e 74 f0       	mov    0xf0745ea8,%eax
f01072c5:	8b 15 ac 5e 74 f0    	mov    0xf0745eac,%edx
f01072cb:	83 c0 01             	add    $0x1,%eax
f01072ce:	83 d2 00             	adc    $0x0,%edx
f01072d1:	a3 a8 5e 74 f0       	mov    %eax,0xf0745ea8
f01072d6:	89 15 ac 5e 74 f0    	mov    %edx,0xf0745eac
	struct Env* p = get_cpu_proc();
f01072dc:	e8 63 4c 00 00       	call   f010bf44 <get_cpu_proc>
f01072e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (p == NULL)
f01072e4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01072e8:	74 30                	je     f010731a <clock_interrupt_handler+0x1a7>
	{
	}
	else
	{
		p->nClocks++ ;
f01072ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01072ed:	8b 80 c0 05 00 00    	mov    0x5c0(%eax),%eax
f01072f3:	8d 50 01             	lea    0x1(%eax),%edx
f01072f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01072f9:	89 90 c0 05 00 00    	mov    %edx,0x5c0(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f01072ff:	83 ec 0c             	sub    $0xc,%esp
f0107302:	6a 01                	push   $0x1
f0107304:	e8 6b 89 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f0107309:	83 c4 10             	add    $0x10,%esp
f010730c:	85 c0                	test   %eax,%eax
f010730e:	74 05                	je     f0107315 <clock_interrupt_handler+0x1a2>
		{
			update_WS_time_stamps();
f0107310:	e8 08 00 00 00       	call   f010731d <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0107315:	e8 45 4d 00 00       	call   f010c05f <yield>
	}
	/*****************************************/
}
f010731a:	90                   	nop
f010731b:	c9                   	leave  
f010731c:	c3                   	ret    

f010731d <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f010731d:	55                   	push   %ebp
f010731e:	89 e5                	mov    %esp,%ebp
f0107320:	53                   	push   %ebx
f0107321:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0107324:	e8 1b 4c 00 00       	call   f010bf44 <get_cpu_proc>
f0107329:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f010732c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107330:	0f 84 a1 01 00 00    	je     f01074d7 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0107336:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107339:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010733f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107342:	eb 78                	jmp    f01073bc <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0107344:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107347:	8b 00                	mov    (%eax),%eax
f0107349:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f010734c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010734f:	8b 40 64             	mov    0x64(%eax),%eax
f0107352:	83 ec 08             	sub    $0x8,%esp
f0107355:	ff 75 e8             	pushl  -0x18(%ebp)
f0107358:	50                   	push   %eax
f0107359:	e8 98 2e 00 00       	call   f010a1f6 <pt_get_page_permissions>
f010735e:	83 c4 10             	add    $0x10,%esp
f0107361:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0107364:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107367:	8b 40 08             	mov    0x8(%eax),%eax
f010736a:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f010736d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107370:	83 e0 20             	and    $0x20,%eax
f0107373:	85 c0                	test   %eax,%eax
f0107375:	74 2b                	je     f01073a2 <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0107377:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010737a:	c1 e8 02             	shr    $0x2,%eax
f010737d:	0d 00 00 00 80       	or     $0x80000000,%eax
f0107382:	89 c2                	mov    %eax,%edx
f0107384:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107387:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f010738a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010738d:	8b 40 64             	mov    0x64(%eax),%eax
f0107390:	6a 20                	push   $0x20
f0107392:	6a 00                	push   $0x0
f0107394:	ff 75 e8             	pushl  -0x18(%ebp)
f0107397:	50                   	push   %eax
f0107398:	e8 95 2d 00 00       	call   f010a132 <pt_set_page_permissions>
f010739d:	83 c4 10             	add    $0x10,%esp
f01073a0:	eb 0e                	jmp    f01073b0 <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f01073a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01073a5:	c1 e8 02             	shr    $0x2,%eax
f01073a8:	89 c2                	mov    %eax,%edx
f01073aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073ad:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f01073b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01073b3:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01073b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01073bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073c0:	74 08                	je     f01073ca <update_WS_time_stamps+0xad>
f01073c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c5:	8b 40 10             	mov    0x10(%eax),%eax
f01073c8:	eb 05                	jmp    f01073cf <update_WS_time_stamps+0xb2>
f01073ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01073cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01073d2:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01073d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01073db:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01073e1:	85 c0                	test   %eax,%eax
f01073e3:	0f 85 5b ff ff ff    	jne    f0107344 <update_WS_time_stamps+0x27>
f01073e9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073ed:	0f 85 51 ff ff ff    	jne    f0107344 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f01073f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01073fa:	e9 ce 00 00 00       	jmp    f01074cd <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f01073ff:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107402:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107405:	89 d0                	mov    %edx,%eax
f0107407:	01 c0                	add    %eax,%eax
f0107409:	01 d0                	add    %edx,%eax
f010740b:	c1 e0 03             	shl    $0x3,%eax
f010740e:	01 c8                	add    %ecx,%eax
f0107410:	05 b4 00 00 00       	add    $0xb4,%eax
f0107415:	8a 00                	mov    (%eax),%al
f0107417:	3c 01                	cmp    $0x1,%al
f0107419:	0f 84 ab 00 00 00    	je     f01074ca <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f010741f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0107422:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107425:	89 d0                	mov    %edx,%eax
f0107427:	01 c0                	add    %eax,%eax
f0107429:	01 d0                	add    %edx,%eax
f010742b:	c1 e0 03             	shl    $0x3,%eax
f010742e:	01 c8                	add    %ecx,%eax
f0107430:	05 b0 00 00 00       	add    $0xb0,%eax
f0107435:	8b 00                	mov    (%eax),%eax
f0107437:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f010743a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010743d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107440:	89 d0                	mov    %edx,%eax
f0107442:	01 c0                	add    %eax,%eax
f0107444:	01 d0                	add    %edx,%eax
f0107446:	c1 e0 03             	shl    $0x3,%eax
f0107449:	01 c8                	add    %ecx,%eax
f010744b:	05 b8 00 00 00       	add    $0xb8,%eax
f0107450:	8b 00                	mov    (%eax),%eax
f0107452:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0107455:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107458:	8b 40 64             	mov    0x64(%eax),%eax
f010745b:	83 ec 08             	sub    $0x8,%esp
f010745e:	ff 75 dc             	pushl  -0x24(%ebp)
f0107461:	50                   	push   %eax
f0107462:	e8 6b 2e 00 00       	call   f010a2d2 <pd_is_table_used>
f0107467:	83 c4 10             	add    $0x10,%esp
f010746a:	85 c0                	test   %eax,%eax
f010746c:	74 3c                	je     f01074aa <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f010746e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0107471:	c1 e8 02             	shr    $0x2,%eax
f0107474:	0d 00 00 00 80       	or     $0x80000000,%eax
f0107479:	89 c1                	mov    %eax,%ecx
f010747b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f010747e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107481:	89 d0                	mov    %edx,%eax
f0107483:	01 c0                	add    %eax,%eax
f0107485:	01 d0                	add    %edx,%eax
f0107487:	c1 e0 03             	shl    $0x3,%eax
f010748a:	01 d8                	add    %ebx,%eax
f010748c:	05 b8 00 00 00       	add    $0xb8,%eax
f0107491:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0107493:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107496:	8b 40 64             	mov    0x64(%eax),%eax
f0107499:	83 ec 08             	sub    $0x8,%esp
f010749c:	ff 75 dc             	pushl  -0x24(%ebp)
f010749f:	50                   	push   %eax
f01074a0:	e8 51 2e 00 00       	call   f010a2f6 <pd_set_table_unused>
f01074a5:	83 c4 10             	add    $0x10,%esp
f01074a8:	eb 20                	jmp    f01074ca <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f01074aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01074ad:	c1 e8 02             	shr    $0x2,%eax
f01074b0:	89 c1                	mov    %eax,%ecx
f01074b2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01074b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01074b8:	89 d0                	mov    %edx,%eax
f01074ba:	01 c0                	add    %eax,%eax
f01074bc:	01 d0                	add    %edx,%eax
f01074be:	c1 e0 03             	shl    $0x3,%eax
f01074c1:	01 d8                	add    %ebx,%eax
f01074c3:	05 b8 00 00 00       	add    $0xb8,%eax
f01074c8:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f01074ca:	ff 45 f0             	incl   -0x10(%ebp)
f01074cd:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f01074d1:	0f 8e 28 ff ff ff    	jle    f01073ff <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f01074d7:	90                   	nop
f01074d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01074db:	c9                   	leave  
f01074dc:	c3                   	ret    

f01074dd <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f01074dd:	55                   	push   %ebp
f01074de:	89 e5                	mov    %esp,%ebp
f01074e0:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f01074e3:	c7 05 0c cd 71 f0 01 	movl   $0x1,0xf071cd0c
f01074ea:	00 00 00 
f01074ed:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f01074f4:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01074f8:	8a 45 b2             	mov    -0x4e(%ebp),%al
f01074fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01074fe:	ee                   	out    %al,(%dx)
f01074ff:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107506:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f010750a:	8a 45 b3             	mov    -0x4d(%ebp),%al
f010750d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107510:	ee                   	out    %al,(%dx)
f0107511:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107518:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f010751c:	8a 45 b4             	mov    -0x4c(%ebp),%al
f010751f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107522:	ee                   	out    %al,(%dx)
f0107523:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f010752a:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f010752e:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107531:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107534:	ee                   	out    %al,(%dx)
f0107535:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f010753c:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107540:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107543:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107546:	ee                   	out    %al,(%dx)
f0107547:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f010754e:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0107552:	8a 45 b7             	mov    -0x49(%ebp),%al
f0107555:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107558:	ee                   	out    %al,(%dx)
f0107559:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0107560:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0107564:	8a 45 b8             	mov    -0x48(%ebp),%al
f0107567:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010756a:	ee                   	out    %al,(%dx)
f010756b:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0107572:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0107576:	8a 45 b9             	mov    -0x47(%ebp),%al
f0107579:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010757c:	ee                   	out    %al,(%dx)
f010757d:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0107584:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0107588:	8a 45 ba             	mov    -0x46(%ebp),%al
f010758b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010758e:	ee                   	out    %al,(%dx)
f010758f:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0107596:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f010759a:	8a 45 bb             	mov    -0x45(%ebp),%al
f010759d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01075a0:	ee                   	out    %al,(%dx)
f01075a1:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f01075a8:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f01075ac:	8a 45 bc             	mov    -0x44(%ebp),%al
f01075af:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01075b2:	ee                   	out    %al,(%dx)
f01075b3:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f01075ba:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f01075be:	8a 45 bd             	mov    -0x43(%ebp),%al
f01075c1:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01075c4:	ee                   	out    %al,(%dx)
f01075c5:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f01075cc:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f01075d0:	8a 45 be             	mov    -0x42(%ebp),%al
f01075d3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01075d6:	ee                   	out    %al,(%dx)
f01075d7:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f01075de:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f01075e2:	8a 45 bf             	mov    -0x41(%ebp),%al
f01075e5:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01075e8:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f01075e9:	66 a1 a4 39 18 f0    	mov    0xf01839a4,%ax
f01075ef:	66 83 f8 ff          	cmp    $0xffff,%ax
f01075f3:	74 15                	je     f010760a <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f01075f5:	66 a1 a4 39 18 f0    	mov    0xf01839a4,%ax
f01075fb:	0f b7 c0             	movzwl %ax,%eax
f01075fe:	83 ec 0c             	sub    $0xc,%esp
f0107601:	50                   	push   %eax
f0107602:	e8 06 00 00 00       	call   f010760d <irq_setmask_8259A>
f0107607:	83 c4 10             	add    $0x10,%esp
}
f010760a:	90                   	nop
f010760b:	c9                   	leave  
f010760c:	c3                   	ret    

f010760d <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f010760d:	55                   	push   %ebp
f010760e:	89 e5                	mov    %esp,%ebp
f0107610:	83 ec 14             	sub    $0x14,%esp
f0107613:	8b 45 08             	mov    0x8(%ebp),%eax
f0107616:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f010761a:	a1 0c cd 71 f0       	mov    0xf071cd0c,%eax
f010761f:	85 c0                	test   %eax,%eax
f0107621:	74 34                	je     f0107657 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107623:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107626:	0f b6 c0             	movzbl %al,%eax
f0107629:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107630:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107633:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107636:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107639:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f010763a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010763d:	66 c1 e8 08          	shr    $0x8,%ax
f0107641:	0f b6 c0             	movzbl %al,%eax
f0107644:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f010764b:	88 45 f7             	mov    %al,-0x9(%ebp)
f010764e:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107651:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107654:	ee                   	out    %al,(%dx)
f0107655:	eb 01                	jmp    f0107658 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0107657:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0107658:	c9                   	leave  
f0107659:	c3                   	ret    

f010765a <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f010765a:	55                   	push   %ebp
f010765b:	89 e5                	mov    %esp,%ebp
f010765d:	53                   	push   %ebx
f010765e:	83 ec 14             	sub    $0x14,%esp
f0107661:	8b 45 08             	mov    0x8(%ebp),%eax
f0107664:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107667:	a1 0c cd 71 f0       	mov    0xf071cd0c,%eax
f010766c:	85 c0                	test   %eax,%eax
f010766e:	74 58                	je     f01076c8 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107670:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107674:	77 08                	ja     f010767e <irq_set_mask+0x24>
		port = PIC1_DATA;
f0107676:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f010767c:	eb 0a                	jmp    f0107688 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f010767e:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107684:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0107688:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f010768c:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010768f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107692:	89 c2                	mov    %eax,%edx
f0107694:	ec                   	in     (%dx),%al
f0107695:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107698:	8a 45 ee             	mov    -0x12(%ebp),%al
f010769b:	88 c2                	mov    %al,%dl
f010769d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01076a1:	bb 01 00 00 00       	mov    $0x1,%ebx
f01076a6:	88 c1                	mov    %al,%cl
f01076a8:	d3 e3                	shl    %cl,%ebx
f01076aa:	89 d8                	mov    %ebx,%eax
f01076ac:	09 d0                	or     %edx,%eax
f01076ae:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f01076b1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f01076b5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f01076b9:	89 55 f0             	mov    %edx,-0x10(%ebp)
f01076bc:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01076bf:	8a 45 ef             	mov    -0x11(%ebp),%al
f01076c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01076c5:	ee                   	out    %al,(%dx)
f01076c6:	eb 01                	jmp    f01076c9 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f01076c8:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f01076c9:	83 c4 14             	add    $0x14,%esp
f01076cc:	5b                   	pop    %ebx
f01076cd:	5d                   	pop    %ebp
f01076ce:	c3                   	ret    

f01076cf <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f01076cf:	55                   	push   %ebp
f01076d0:	89 e5                	mov    %esp,%ebp
f01076d2:	53                   	push   %ebx
f01076d3:	83 ec 14             	sub    $0x14,%esp
f01076d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01076d9:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01076dc:	a1 0c cd 71 f0       	mov    0xf071cd0c,%eax
f01076e1:	85 c0                	test   %eax,%eax
f01076e3:	74 5a                	je     f010773f <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01076e5:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01076e9:	77 08                	ja     f01076f3 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f01076eb:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01076f1:	eb 0a                	jmp    f01076fd <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f01076f3:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01076f9:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f01076fd:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107701:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107704:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107707:	89 c2                	mov    %eax,%edx
f0107709:	ec                   	in     (%dx),%al
f010770a:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f010770d:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107710:	88 c2                	mov    %al,%dl
f0107712:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107716:	bb 01 00 00 00       	mov    $0x1,%ebx
f010771b:	88 c1                	mov    %al,%cl
f010771d:	d3 e3                	shl    %cl,%ebx
f010771f:	89 d8                	mov    %ebx,%eax
f0107721:	f7 d0                	not    %eax
f0107723:	21 d0                	and    %edx,%eax
f0107725:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107728:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f010772c:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107730:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107733:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107736:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107739:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010773c:	ee                   	out    %al,(%dx)
f010773d:	eb 01                	jmp    f0107740 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010773f:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107740:	83 c4 14             	add    $0x14,%esp
f0107743:	5b                   	pop    %ebx
f0107744:	5d                   	pop    %ebp
f0107745:	c3                   	ret    

f0107746 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107746:	55                   	push   %ebp
f0107747:	89 e5                	mov    %esp,%ebp
f0107749:	53                   	push   %ebx
f010774a:	83 ec 14             	sub    $0x14,%esp
f010774d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107750:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107753:	a1 0c cd 71 f0       	mov    0xf071cd0c,%eax
f0107758:	85 c0                	test   %eax,%eax
f010775a:	75 07                	jne    f0107763 <irq_get_mask+0x1d>
		return -1;
f010775c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107761:	eb 45                	jmp    f01077a8 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107763:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107767:	77 08                	ja     f0107771 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107769:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f010776f:	eb 0a                	jmp    f010777b <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107771:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107777:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f010777b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f010777f:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107782:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107785:	89 c2                	mov    %eax,%edx
f0107787:	ec                   	in     (%dx),%al
f0107788:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f010778b:	8a 45 f3             	mov    -0xd(%ebp),%al
f010778e:	88 c2                	mov    %al,%dl
f0107790:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107794:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107799:	88 c1                	mov    %al,%cl
f010779b:	d3 e3                	shl    %cl,%ebx
f010779d:	89 d8                	mov    %ebx,%eax
f010779f:	21 d0                	and    %edx,%eax
f01077a1:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f01077a4:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f01077a8:	83 c4 14             	add    $0x14,%esp
f01077ab:	5b                   	pop    %ebx
f01077ac:	5d                   	pop    %ebp
f01077ad:	c3                   	ret    

f01077ae <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f01077ae:	55                   	push   %ebp
f01077af:	89 e5                	mov    %esp,%ebp
f01077b1:	83 ec 14             	sub    $0x14,%esp
f01077b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01077b7:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f01077ba:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f01077be:	76 12                	jbe    f01077d2 <pic_sendEOI+0x24>
f01077c0:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f01077c7:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01077cb:	8a 45 f7             	mov    -0x9(%ebp),%al
f01077ce:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01077d1:	ee                   	out    %al,(%dx)
f01077d2:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f01077d9:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f01077dd:	8a 45 f6             	mov    -0xa(%ebp),%al
f01077e0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01077e3:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f01077e4:	90                   	nop
f01077e5:	c9                   	leave  
f01077e6:	c3                   	ret    

f01077e7 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f01077e7:	55                   	push   %ebp
f01077e8:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f01077ea:	b8 e0 59 74 f0       	mov    $0xf07459e0,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f01077ef:	5d                   	pop    %ebp
f01077f0:	c3                   	ret    

f01077f1 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f01077f1:	55                   	push   %ebp
f01077f2:	89 e5                	mov    %esp,%ebp
f01077f4:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f01077f7:	e8 eb ff ff ff       	call   f01077e7 <mycpu>
f01077fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f01077ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107802:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107809:	00 00 00 
  c->ncli = 0;
f010780c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010780f:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107816:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107819:	9c                   	pushf  
f010781a:	58                   	pop    %eax
f010781b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010781e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107821:	25 00 02 00 00       	and    $0x200,%eax
f0107826:	85 c0                	test   %eax,%eax
f0107828:	0f 95 c0             	setne  %al
f010782b:	0f b6 d0             	movzbl %al,%edx
f010782e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107831:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107837:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010783a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107841:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107844:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f010784b:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f010784e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107851:	40                   	inc    %eax
f0107852:	c1 e0 0f             	shl    $0xf,%eax
f0107855:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f010785a:	29 c2                	sub    %eax,%edx
f010785c:	89 d0                	mov    %edx,%eax
f010785e:	89 c2                	mov    %eax,%edx
f0107860:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107863:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107866:	e8 18 01 00 00       	call   f0107983 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f010786b:	e8 6d 5d 00 00       	call   f010d5dd <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107870:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107873:	83 c0 0c             	add    $0xc,%eax
f0107876:	83 ec 04             	sub    $0x4,%esp
f0107879:	6a 68                	push   $0x68
f010787b:	6a 00                	push   $0x0
f010787d:	50                   	push   %eax
f010787e:	e8 a6 a8 01 00       	call   f0122129 <memset>
f0107883:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0107886:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107889:	05 a4 00 00 00       	add    $0xa4,%eax
f010788e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107891:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0107898:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010789b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010789e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01078a1:	f0 87 02             	lock xchg %eax,(%edx)
f01078a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f01078a7:	90                   	nop
f01078a8:	c9                   	leave  
f01078a9:	c3                   	ret    

f01078aa <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f01078aa:	55                   	push   %ebp
f01078ab:	89 e5                	mov    %esp,%ebp
f01078ad:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01078b0:	9c                   	pushf  
f01078b1:	58                   	pop    %eax
f01078b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f01078b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f01078b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f01078bb:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f01078bc:	e8 26 ff ff ff       	call   f01077e7 <mycpu>
f01078c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f01078c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078c7:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01078cd:	85 c0                	test   %eax,%eax
f01078cf:	75 13                	jne    f01078e4 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f01078d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01078d4:	25 00 02 00 00       	and    $0x200,%eax
f01078d9:	89 c2                	mov    %eax,%edx
f01078db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078de:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f01078e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078e7:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01078ed:	8d 50 01             	lea    0x1(%eax),%edx
f01078f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078f3:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f01078f9:	90                   	nop
f01078fa:	c9                   	leave  
f01078fb:	c3                   	ret    

f01078fc <popcli>:

void popcli(void)
{
f01078fc:	55                   	push   %ebp
f01078fd:	89 e5                	mov    %esp,%ebp
f01078ff:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107902:	9c                   	pushf  
f0107903:	58                   	pop    %eax
f0107904:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107907:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f010790a:	25 00 02 00 00       	and    $0x200,%eax
f010790f:	85 c0                	test   %eax,%eax
f0107911:	74 14                	je     f0107927 <popcli+0x2b>
    panic("popcli - interruptible");
f0107913:	83 ec 04             	sub    $0x4,%esp
f0107916:	68 9b 77 12 f0       	push   $0xf012779b
f010791b:	6a 5e                	push   $0x5e
f010791d:	68 b2 77 12 f0       	push   $0xf01277b2
f0107922:	e8 12 8a ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f0107927:	e8 bb fe ff ff       	call   f01077e7 <mycpu>
f010792c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010792f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107932:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107938:	8d 50 ff             	lea    -0x1(%eax),%edx
f010793b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010793e:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0107944:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107947:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010794d:	85 c0                	test   %eax,%eax
f010794f:	79 14                	jns    f0107965 <popcli+0x69>
    panic("popcli");
f0107951:	83 ec 04             	sub    $0x4,%esp
f0107954:	68 c1 77 12 f0       	push   $0xf01277c1
f0107959:	6a 61                	push   $0x61
f010795b:	68 b2 77 12 f0       	push   $0xf01277b2
f0107960:	e8 d4 89 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f0107965:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107968:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010796e:	85 c0                	test   %eax,%eax
f0107970:	75 0e                	jne    f0107980 <popcli+0x84>
f0107972:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107975:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010797b:	85 c0                	test   %eax,%eax
f010797d:	74 01                	je     f0107980 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010797f:	fb                   	sti    
    sti();
}
f0107980:	90                   	nop
f0107981:	c9                   	leave  
f0107982:	c3                   	ret    

f0107983 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0107983:	55                   	push   %ebp
f0107984:	89 e5                	mov    %esp,%ebp
f0107986:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0107989:	e8 1c ff ff ff       	call   f01078aa <pushcli>

	c = mycpu();
f010798e:	e8 54 fe ff ff       	call   f01077e7 <mycpu>
f0107993:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0107996:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107999:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01079a0:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f01079a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079aa:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f01079b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079b3:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f01079b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079bc:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f01079c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079c6:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01079cc:	83 e2 f0             	and    $0xfffffff0,%edx
f01079cf:	83 ca 0a             	or     $0xa,%edx
f01079d2:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01079d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079db:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01079e1:	83 ca 10             	or     $0x10,%edx
f01079e4:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01079ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079ed:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f01079f3:	83 e2 9f             	and    $0xffffff9f,%edx
f01079f6:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f01079fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079ff:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107a05:	83 ca 80             	or     $0xffffff80,%edx
f0107a08:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a11:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107a17:	83 ca 0f             	or     $0xf,%edx
f0107a1a:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a23:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107a29:	83 e2 ef             	and    $0xffffffef,%edx
f0107a2c:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a35:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107a3b:	83 e2 df             	and    $0xffffffdf,%edx
f0107a3e:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a47:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107a4d:	83 ca 40             	or     $0x40,%edx
f0107a50:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107a56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a59:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107a5f:	83 ca 80             	or     $0xffffff80,%edx
f0107a62:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107a68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a6b:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a75:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107a7c:	ff ff 
f0107a7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a81:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f0107a88:	00 00 
f0107a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a8d:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f0107a94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a97:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107a9d:	83 e2 f0             	and    $0xfffffff0,%edx
f0107aa0:	83 ca 02             	or     $0x2,%edx
f0107aa3:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107aac:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107ab2:	83 ca 10             	or     $0x10,%edx
f0107ab5:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107abb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107abe:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107ac4:	83 e2 9f             	and    $0xffffff9f,%edx
f0107ac7:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ad0:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107ad6:	83 ca 80             	or     $0xffffff80,%edx
f0107ad9:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107adf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ae2:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107ae8:	83 ca 0f             	or     $0xf,%edx
f0107aeb:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107af1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107af4:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107afa:	83 e2 ef             	and    $0xffffffef,%edx
f0107afd:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b06:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107b0c:	83 e2 df             	and    $0xffffffdf,%edx
f0107b0f:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b18:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107b1e:	83 ca 40             	or     $0x40,%edx
f0107b21:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107b27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b2a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107b30:	83 ca 80             	or     $0xffffff80,%edx
f0107b33:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b3c:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b46:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107b4d:	ff ff 
f0107b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b52:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0107b59:	00 00 
f0107b5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b5e:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f0107b65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b68:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107b6e:	83 e2 f0             	and    $0xfffffff0,%edx
f0107b71:	83 ca 0a             	or     $0xa,%edx
f0107b74:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107b7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b7d:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107b83:	83 ca 10             	or     $0x10,%edx
f0107b86:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b8f:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107b95:	83 ca 60             	or     $0x60,%edx
f0107b98:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ba1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107ba7:	83 ca 80             	or     $0xffffff80,%edx
f0107baa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bb3:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107bb9:	83 ca 0f             	or     $0xf,%edx
f0107bbc:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107bc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bc5:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107bcb:	83 e2 ef             	and    $0xffffffef,%edx
f0107bce:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bd7:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107bdd:	83 e2 df             	and    $0xffffffdf,%edx
f0107be0:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107be6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107be9:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107bef:	83 ca 40             	or     $0x40,%edx
f0107bf2:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bfb:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107c01:	83 ca 80             	or     $0xffffff80,%edx
f0107c04:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107c0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c0d:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107c14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c17:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107c1e:	ff ff 
f0107c20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c23:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0107c2a:	00 00 
f0107c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c2f:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c39:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107c3f:	83 e2 f0             	and    $0xfffffff0,%edx
f0107c42:	83 ca 02             	or     $0x2,%edx
f0107c45:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107c4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c4e:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107c54:	83 ca 10             	or     $0x10,%edx
f0107c57:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c60:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107c66:	83 ca 60             	or     $0x60,%edx
f0107c69:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c72:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107c78:	83 ca 80             	or     $0xffffff80,%edx
f0107c7b:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c84:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107c8a:	83 ca 0f             	or     $0xf,%edx
f0107c8d:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c96:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107c9c:	83 e2 ef             	and    $0xffffffef,%edx
f0107c9f:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107ca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ca8:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107cae:	83 e2 df             	and    $0xffffffdf,%edx
f0107cb1:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107cb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107cba:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107cc0:	83 ca 40             	or     $0x40,%edx
f0107cc3:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107cc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ccc:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107cd2:	83 ca 80             	or     $0xffffff80,%edx
f0107cd5:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107cdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107cde:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ce8:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107cef:	00 00 00 
f0107cf2:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107cf9:	00 00 00 

	popcli();	//enable interrupt
f0107cfc:	e8 fb fb ff ff       	call   f01078fc <popcli>


}
f0107d01:	90                   	nop
f0107d02:	c9                   	leave  
f0107d03:	c3                   	ret    

f0107d04 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107d04:	55                   	push   %ebp
f0107d05:	89 e5                	mov    %esp,%ebp
f0107d07:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0107d0a:	83 ec 08             	sub    $0x8,%esp
f0107d0d:	68 00 10 00 00       	push   $0x1000
f0107d12:	68 00 10 00 00       	push   $0x1000
f0107d17:	e8 43 02 00 00       	call   f0107f5f <boot_allocate_space>
f0107d1c:	83 c4 10             	add    $0x10,%esp
f0107d1f:	a3 bc 5e 74 f0       	mov    %eax,0xf0745ebc
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107d24:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107d29:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107d2c:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107d33:	77 14                	ja     f0107d49 <initialize_kernel_VM+0x45>
f0107d35:	ff 75 e0             	pushl  -0x20(%ebp)
f0107d38:	68 c8 77 12 f0       	push   $0xf01277c8
f0107d3d:	6a 57                	push   $0x57
f0107d3f:	68 fc 77 12 f0       	push   $0xf01277fc
f0107d44:	e8 f0 85 ff ff       	call   f0100339 <_panic>
f0107d49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d4c:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d51:	a3 c8 5f 74 f0       	mov    %eax,0xf0745fc8
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f0107d56:	c7 45 dc 00 b0 17 f0 	movl   $0xf017b000,-0x24(%ebp)
f0107d5d:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107d64:	77 14                	ja     f0107d7a <initialize_kernel_VM+0x76>
f0107d66:	ff 75 dc             	pushl  -0x24(%ebp)
f0107d69:	68 c8 77 12 f0       	push   $0xf01277c8
f0107d6e:	6a 63                	push   $0x63
f0107d70:	68 fc 77 12 f0       	push   $0xf01277fc
f0107d75:	e8 bf 85 ff ff       	call   f0100339 <_panic>
f0107d7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d7d:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107d83:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107d88:	83 ec 0c             	sub    $0xc,%esp
f0107d8b:	6a 02                	push   $0x2
f0107d8d:	52                   	push   %edx
f0107d8e:	68 00 80 00 00       	push   $0x8000
f0107d93:	68 00 80 bf ef       	push   $0xefbf8000
f0107d98:	50                   	push   %eax
f0107d99:	e8 35 02 00 00       	call   f0107fd3 <boot_map_range>
f0107d9e:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107da1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107da8:	eb 24                	jmp    f0107dce <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0107daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107dad:	40                   	inc    %eax
f0107dae:	c1 e0 0f             	shl    $0xf,%eax
f0107db1:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107db6:	29 c2                	sub    %eax,%edx
f0107db8:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107dbd:	6a 01                	push   $0x1
f0107dbf:	6a 00                	push   $0x0
f0107dc1:	52                   	push   %edx
f0107dc2:	50                   	push   %eax
f0107dc3:	e8 6a 23 00 00       	call   f010a132 <pt_set_page_permissions>
f0107dc8:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107dcb:	ff 45 f4             	incl   -0xc(%ebp)
f0107dce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107dd2:	7e d6                	jle    f0107daa <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107dd4:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107ddb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107de2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107de9:	eb 25                	jmp    f0107e10 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107deb:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107dee:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107df1:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107df6:	83 ec 04             	sub    $0x4,%esp
f0107df9:	6a 01                	push   $0x1
f0107dfb:	52                   	push   %edx
f0107dfc:	50                   	push   %eax
f0107dfd:	e8 45 02 00 00       	call   f0108047 <boot_get_page_table>
f0107e02:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107e05:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107e0c:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107e10:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107e14:	72 d5                	jb     f0107deb <initialize_kernel_VM+0xe7>
f0107e16:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107e1a:	77 06                	ja     f0107e22 <initialize_kernel_VM+0x11e>
f0107e1c:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107e20:	76 c9                	jbe    f0107deb <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107e22:	8b 15 98 5a 74 f0    	mov    0xf0745a98,%edx
f0107e28:	89 d0                	mov    %edx,%eax
f0107e2a:	c1 e0 02             	shl    $0x2,%eax
f0107e2d:	01 d0                	add    %edx,%eax
f0107e2f:	c1 e0 03             	shl    $0x3,%eax
f0107e32:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107e35:	83 ec 08             	sub    $0x8,%esp
f0107e38:	68 00 10 00 00       	push   $0x1000
f0107e3d:	ff 75 d8             	pushl  -0x28(%ebp)
f0107e40:	e8 1a 01 00 00       	call   f0107f5f <boot_allocate_space>
f0107e45:	83 c4 10             	add    $0x10,%esp
f0107e48:	a3 00 5d 74 f0       	mov    %eax,0xf0745d00
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107e4d:	c7 45 d4 00 40 51 00 	movl   $0x514000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107e54:	83 ec 08             	sub    $0x8,%esp
f0107e57:	68 00 10 00 00       	push   $0x1000
f0107e5c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107e5f:	e8 fb 00 00 00       	call   f0107f5f <boot_allocate_space>
f0107e64:	83 c4 10             	add    $0x10,%esp
f0107e67:	a3 c0 55 74 f0       	mov    %eax,0xf07455c0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107e6c:	e8 05 05 00 00       	call   f0108376 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107e71:	83 ec 0c             	sub    $0xc,%esp
f0107e74:	68 c6 02 00 00       	push   $0x2c6
f0107e79:	e8 1b 86 01 00       	call   f0120499 <nearest_pow2_ceil>
f0107e7e:	83 c4 10             	add    $0x10,%esp
f0107e81:	83 ec 04             	sub    $0x4,%esp
f0107e84:	50                   	push   %eax
f0107e85:	68 c6 02 00 00       	push   $0x2c6
f0107e8a:	68 1c 78 12 f0       	push   $0xf012781c
f0107e8f:	e8 f7 90 ff ff       	call   f0100f8b <cprintf>
f0107e94:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f0107e97:	c7 45 d0 98 fd 0f 00 	movl   $0xffd98,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107e9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107ea1:	83 ec 08             	sub    $0x8,%esp
f0107ea4:	68 00 10 00 00       	push   $0x1000
f0107ea9:	50                   	push   %eax
f0107eaa:	e8 b0 00 00 00       	call   f0107f5f <boot_allocate_space>
f0107eaf:	83 c4 10             	add    $0x10,%esp
f0107eb2:	a3 10 cd 71 f0       	mov    %eax,0xf071cd10
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f0107eb7:	a1 10 cd 71 f0       	mov    0xf071cd10,%eax
f0107ebc:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107ebf:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f0107ec6:	77 17                	ja     f0107edf <initialize_kernel_VM+0x1db>
f0107ec8:	ff 75 cc             	pushl  -0x34(%ebp)
f0107ecb:	68 c8 77 12 f0       	push   $0xf01277c8
f0107ed0:	68 b1 00 00 00       	push   $0xb1
f0107ed5:	68 fc 77 12 f0       	push   $0xf01277fc
f0107eda:	e8 5a 84 ff ff       	call   f0100339 <_panic>
f0107edf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107ee2:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0107ee8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107eeb:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107ef0:	83 ec 0c             	sub    $0xc,%esp
f0107ef3:	6a 04                	push   $0x4
f0107ef5:	51                   	push   %ecx
f0107ef6:	52                   	push   %edx
f0107ef7:	68 00 00 c0 ee       	push   $0xeec00000
f0107efc:	50                   	push   %eax
f0107efd:	e8 d1 00 00 00       	call   f0107fd3 <boot_map_range>
f0107f02:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107f05:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107f0a:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107f0f:	8b 15 bc 5e 74 f0    	mov    0xf0745ebc,%edx
f0107f15:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0107f1b:	8b 12                	mov    (%edx),%edx
f0107f1d:	83 ca 05             	or     $0x5,%edx
f0107f20:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107f22:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0107f27:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107f2d:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0107f32:	83 ec 0c             	sub    $0xc,%esp
f0107f35:	6a 02                	push   $0x2
f0107f37:	6a 00                	push   $0x0
f0107f39:	52                   	push   %edx
f0107f3a:	68 00 00 00 f0       	push   $0xf0000000
f0107f3f:	50                   	push   %eax
f0107f40:	e8 8e 00 00 00       	call   f0107fd3 <boot_map_range>
f0107f45:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107f48:	e8 1f 95 01 00       	call   f012146c <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107f4d:	c7 05 d0 59 74 f0 19 	movl   $0x19,0xf07459d0
f0107f54:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107f57:	e8 e6 02 00 00       	call   f0108242 <turn_on_paging>
}
f0107f5c:	90                   	nop
f0107f5d:	c9                   	leave  
f0107f5e:	c3                   	ret    

f0107f5f <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107f5f:	55                   	push   %ebp
f0107f60:	89 e5                	mov    %esp,%ebp
f0107f62:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f0107f65:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0107f6a:	85 c0                	test   %eax,%eax
f0107f6c:	75 0a                	jne    f0107f78 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107f6e:	c7 05 b8 5e 74 f0 b0 	movl   $0xf0768ab0,0xf0745eb8
f0107f75:	8a 76 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107f78:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107f7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107f7e:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0107f83:	89 c2                	mov    %eax,%edx
f0107f85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f88:	01 d0                	add    %edx,%eax
f0107f8a:	48                   	dec    %eax
f0107f8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107f8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f91:	ba 00 00 00 00       	mov    $0x0,%edx
f0107f96:	f7 75 f4             	divl   -0xc(%ebp)
f0107f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107f9c:	29 d0                	sub    %edx,%eax
f0107f9e:	a3 b8 5e 74 f0       	mov    %eax,0xf0745eb8

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107fa3:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0107fa8:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0107fab:	8b 15 b8 5e 74 f0    	mov    0xf0745eb8,%edx
f0107fb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fb4:	01 d0                	add    %edx,%eax
f0107fb6:	a3 b8 5e 74 f0       	mov    %eax,0xf0745eb8

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0107fbb:	83 ec 04             	sub    $0x4,%esp
f0107fbe:	ff 75 08             	pushl  0x8(%ebp)
f0107fc1:	6a 00                	push   $0x0
f0107fc3:	ff 75 ec             	pushl  -0x14(%ebp)
f0107fc6:	e8 5e a1 01 00       	call   f0122129 <memset>
f0107fcb:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107fce:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0107fd1:	c9                   	leave  
f0107fd2:	c3                   	ret    

f0107fd3 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0107fd3:	55                   	push   %ebp
f0107fd4:	89 e5                	mov    %esp,%ebp
f0107fd6:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f0107fd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107fe0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107fe7:	eb 53                	jmp    f010803c <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f0107fe9:	83 ec 04             	sub    $0x4,%esp
f0107fec:	6a 01                	push   $0x1
f0107fee:	ff 75 0c             	pushl  0xc(%ebp)
f0107ff1:	ff 75 08             	pushl  0x8(%ebp)
f0107ff4:	e8 4e 00 00 00       	call   f0108047 <boot_get_page_table>
f0107ff9:	83 c4 10             	add    $0x10,%esp
f0107ffc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107fff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108002:	c1 e8 0c             	shr    $0xc,%eax
f0108005:	25 ff 03 00 00       	and    $0x3ff,%eax
f010800a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f010800d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108010:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108017:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010801a:	01 c2                	add    %eax,%edx
f010801c:	8b 45 18             	mov    0x18(%ebp),%eax
f010801f:	0b 45 14             	or     0x14(%ebp),%eax
f0108022:	83 c8 01             	or     $0x1,%eax
f0108025:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0108027:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f010802e:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108035:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010803c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010803f:	3b 45 10             	cmp    0x10(%ebp),%eax
f0108042:	72 a5                	jb     f0107fe9 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f0108044:	90                   	nop
f0108045:	c9                   	leave  
f0108046:	c3                   	ret    

f0108047 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0108047:	55                   	push   %ebp
f0108048:	89 e5                	mov    %esp,%ebp
f010804a:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f010804d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108050:	c1 e8 16             	shr    $0x16,%eax
f0108053:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f0108056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108059:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108060:	8b 45 08             	mov    0x8(%ebp),%eax
f0108063:	01 d0                	add    %edx,%eax
f0108065:	8b 00                	mov    (%eax),%eax
f0108067:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f010806a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010806d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108072:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f0108075:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108078:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010807b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010807e:	c1 e8 0c             	shr    $0xc,%eax
f0108081:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108084:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108089:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010808c:	72 17                	jb     f01080a5 <boot_get_page_table+0x5e>
f010808e:	ff 75 e8             	pushl  -0x18(%ebp)
f0108091:	68 44 78 12 f0       	push   $0xf0127844
f0108096:	68 33 01 00 00       	push   $0x133
f010809b:	68 fc 77 12 f0       	push   $0xf01277fc
f01080a0:	e8 94 82 ff ff       	call   f0100339 <_panic>
f01080a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01080a8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01080ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01080b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01080b4:	75 72                	jne    f0108128 <boot_get_page_table+0xe1>
	{
		if (create)
f01080b6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01080ba:	74 65                	je     f0108121 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01080bc:	83 ec 08             	sub    $0x8,%esp
f01080bf:	68 00 10 00 00       	push   $0x1000
f01080c4:	68 00 10 00 00       	push   $0x1000
f01080c9:	e8 91 fe ff ff       	call   f0107f5f <boot_allocate_space>
f01080ce:	83 c4 10             	add    $0x10,%esp
f01080d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01080d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01080d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01080da:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01080e1:	77 17                	ja     f01080fa <boot_get_page_table+0xb3>
f01080e3:	ff 75 dc             	pushl  -0x24(%ebp)
f01080e6:	68 c8 77 12 f0       	push   $0xf01277c8
f01080eb:	68 39 01 00 00       	push   $0x139
f01080f0:	68 fc 77 12 f0       	push   $0xf01277fc
f01080f5:	e8 3f 82 ff ff       	call   f0100339 <_panic>
f01080fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01080fd:	05 00 00 00 10       	add    $0x10000000,%eax
f0108102:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0108105:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108108:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010810f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108112:	01 d0                	add    %edx,%eax
f0108114:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108117:	83 ca 03             	or     $0x3,%edx
f010811a:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f010811c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010811f:	eb 0a                	jmp    f010812b <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0108121:	b8 00 00 00 00       	mov    $0x0,%eax
f0108126:	eb 03                	jmp    f010812b <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0108128:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f010812b:	c9                   	leave  
f010812c:	c3                   	ret    

f010812d <nvram_read>:


int nvram_read(int r)
{
f010812d:	55                   	push   %ebp
f010812e:	89 e5                	mov    %esp,%ebp
f0108130:	53                   	push   %ebx
f0108131:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0108134:	8b 45 08             	mov    0x8(%ebp),%eax
f0108137:	83 ec 0c             	sub    $0xc,%esp
f010813a:	50                   	push   %eax
f010813b:	e8 5f cc ff ff       	call   f0104d9f <mc146818_read>
f0108140:	83 c4 10             	add    $0x10,%esp
f0108143:	89 c3                	mov    %eax,%ebx
f0108145:	8b 45 08             	mov    0x8(%ebp),%eax
f0108148:	40                   	inc    %eax
f0108149:	83 ec 0c             	sub    $0xc,%esp
f010814c:	50                   	push   %eax
f010814d:	e8 4d cc ff ff       	call   f0104d9f <mc146818_read>
f0108152:	83 c4 10             	add    $0x10,%esp
f0108155:	c1 e0 08             	shl    $0x8,%eax
f0108158:	09 d8                	or     %ebx,%eax
}
f010815a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010815d:	c9                   	leave  
f010815e:	c3                   	ret    

f010815f <detect_memory>:

void detect_memory()
{
f010815f:	55                   	push   %ebp
f0108160:	89 e5                	mov    %esp,%ebp
f0108162:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0108165:	83 ec 0c             	sub    $0xc,%esp
f0108168:	6a 15                	push   $0x15
f010816a:	e8 be ff ff ff       	call   f010812d <nvram_read>
f010816f:	83 c4 10             	add    $0x10,%esp
f0108172:	c1 e0 0a             	shl    $0xa,%eax
f0108175:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108178:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010817b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108180:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0108183:	83 ec 0c             	sub    $0xc,%esp
f0108186:	6a 17                	push   $0x17
f0108188:	e8 a0 ff ff ff       	call   f010812d <nvram_read>
f010818d:	83 c4 10             	add    $0x10,%esp
f0108190:	c1 e0 0a             	shl    $0xa,%eax
f0108193:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108196:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108199:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010819e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f01081a1:	83 ec 0c             	sub    $0xc,%esp
f01081a4:	6a 34                	push   $0x34
f01081a6:	e8 82 ff ff ff       	call   f010812d <nvram_read>
f01081ab:	83 c4 10             	add    $0x10,%esp
f01081ae:	c1 e0 10             	shl    $0x10,%eax
f01081b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01081b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01081b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01081bc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f01081bf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01081c3:	74 18                	je     f01081dd <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f01081c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01081c8:	05 00 00 00 01       	add    $0x1000000,%eax
f01081cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f01081d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081d3:	2d 00 00 10 00       	sub    $0x100000,%eax
f01081d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01081db:	eb 19                	jmp    f01081f6 <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f01081dd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01081e1:	74 0d                	je     f01081f0 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f01081e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01081e6:	05 00 00 10 00       	add    $0x100000,%eax
f01081eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01081ee:	eb 06                	jmp    f01081f6 <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f01081f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01081f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f01081f6:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f01081fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108200:	c1 e8 0c             	shr    $0xc,%eax
f0108203:	a3 98 5a 74 f0       	mov    %eax,0xf0745a98

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0108208:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010820b:	c1 e8 0a             	shr    $0xa,%eax
f010820e:	83 ec 08             	sub    $0x8,%esp
f0108211:	50                   	push   %eax
f0108212:	68 74 78 12 f0       	push   $0xf0127874
f0108217:	e8 6f 8d ff ff       	call   f0100f8b <cprintf>
f010821c:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f010821f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108222:	c1 e8 0a             	shr    $0xa,%eax
f0108225:	89 c2                	mov    %eax,%edx
f0108227:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010822a:	c1 e8 0a             	shr    $0xa,%eax
f010822d:	83 ec 04             	sub    $0x4,%esp
f0108230:	52                   	push   %edx
f0108231:	50                   	push   %eax
f0108232:	68 97 78 12 f0       	push   $0xf0127897
f0108237:	e8 4f 8d ff ff       	call   f0100f8b <cprintf>
f010823c:	83 c4 10             	add    $0x10,%esp
}
f010823f:	90                   	nop
f0108240:	c9                   	leave  
f0108241:	c3                   	ret    

f0108242 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0108242:	55                   	push   %ebp
f0108243:	89 e5                	mov    %esp,%ebp
f0108245:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0108248:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f010824f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108256:	eb 24                	jmp    f010827c <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0108258:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f010825d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108260:	c1 e2 02             	shl    $0x2,%edx
f0108263:	01 c2                	add    %eax,%edx
f0108265:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f010826a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010826d:	c1 e1 02             	shl    $0x2,%ecx
f0108270:	01 c8                	add    %ecx,%eax
f0108272:	8b 00                	mov    (%eax),%eax
f0108274:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108276:	ff 45 f4             	incl   -0xc(%ebp)
f0108279:	ff 45 f0             	incl   -0x10(%ebp)
f010827c:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0108281:	c1 e8 16             	shr    $0x16,%eax
f0108284:	89 c2                	mov    %eax,%edx
f0108286:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108289:	39 c2                	cmp    %eax,%edx
f010828b:	77 cb                	ja     f0108258 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f010828d:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f0108292:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108295:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108298:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f010829b:	0f 20 c0             	mov    %cr0,%eax
f010829e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01082a1:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f01082a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f01082a7:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f01082ae:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f01082b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01082b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f01082b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01082bb:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f01082be:	e8 e7 f5 ff ff       	call   f01078aa <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f01082c3:	e8 1f f5 ff ff       	call   f01077e7 <mycpu>
f01082c8:	83 c0 74             	add    $0x74,%eax
f01082cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01082ce:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f01082d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01082d8:	48                   	dec    %eax
f01082d9:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f01082dd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01082e0:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f01082e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01082e7:	c1 e8 10             	shr    $0x10,%eax
f01082ea:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f01082ee:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f01082f1:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f01082f4:	e8 03 f6 ff ff       	call   f01078fc <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f01082f9:	b8 23 00 00 00       	mov    $0x23,%eax
f01082fe:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0108300:	b8 23 00 00 00       	mov    $0x23,%eax
f0108305:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0108307:	b8 10 00 00 00       	mov    $0x10,%eax
f010830c:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f010830e:	b8 10 00 00 00       	mov    $0x10,%eax
f0108313:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0108315:	b8 10 00 00 00       	mov    $0x10,%eax
f010831a:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f010831c:	ea 23 83 10 f0 08 00 	ljmp   $0x8,$0xf0108323
	asm volatile("lldt %%ax" :: "a" (0));
f0108323:	b8 00 00 00 00       	mov    $0x0,%eax
f0108328:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f010832b:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0108332:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108339:	eb 19                	jmp    f0108354 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f010833b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0108340:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108343:	c1 e2 02             	shl    $0x2,%edx
f0108346:	01 d0                	add    %edx,%eax
f0108348:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f010834e:	ff 45 ec             	incl   -0x14(%ebp)
f0108351:	ff 45 e8             	incl   -0x18(%ebp)
f0108354:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f0108359:	c1 e8 16             	shr    $0x16,%eax
f010835c:	89 c2                	mov    %eax,%edx
f010835e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108361:	39 c2                	cmp    %eax,%edx
f0108363:	77 d6                	ja     f010833b <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0108365:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f010836a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010836d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108370:	0f 22 d8             	mov    %eax,%cr3

}
f0108373:	90                   	nop
f0108374:	c9                   	leave  
f0108375:	c3                   	ret    

f0108376 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0108376:	55                   	push   %ebp
f0108377:	89 e5                	mov    %esp,%ebp
f0108379:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010837c:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0108381:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108384:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f010838b:	77 17                	ja     f01083a4 <setup_listing_to_all_page_tables_entries+0x2e>
f010838d:	ff 75 f4             	pushl  -0xc(%ebp)
f0108390:	68 c8 77 12 f0       	push   $0xf01277c8
f0108395:	68 cf 01 00 00       	push   $0x1cf
f010839a:	68 fc 77 12 f0       	push   $0xf01277fc
f010839f:	e8 95 7f ff ff       	call   f0100339 <_panic>
f01083a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083a7:	05 00 00 00 10       	add    $0x10000000,%eax
f01083ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f01083af:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01083b4:	05 fc 0e 00 00       	add    $0xefc,%eax
f01083b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01083bc:	83 ca 03             	or     $0x3,%edx
f01083bf:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f01083c1:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01083c6:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f01083cc:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01083d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01083d4:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f01083db:	77 17                	ja     f01083f4 <setup_listing_to_all_page_tables_entries+0x7e>
f01083dd:	ff 75 ec             	pushl  -0x14(%ebp)
f01083e0:	68 c8 77 12 f0       	push   $0xf01277c8
f01083e5:	68 d4 01 00 00       	push   $0x1d4
f01083ea:	68 fc 77 12 f0       	push   $0xf01277fc
f01083ef:	e8 45 7f ff ff       	call   f0100339 <_panic>
f01083f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01083f7:	05 00 00 00 10       	add    $0x10000000,%eax
f01083fc:	83 c8 05             	or     $0x5,%eax
f01083ff:	89 02                	mov    %eax,(%edx)

}
f0108401:	90                   	nop
f0108402:	c9                   	leave  
f0108403:	c3                   	ret    

f0108404 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108404:	55                   	push   %ebp
f0108405:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108407:	8b 45 08             	mov    0x8(%ebp),%eax
f010840a:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f0108410:	29 d0                	sub    %edx,%eax
f0108412:	c1 f8 03             	sar    $0x3,%eax
f0108415:	89 c2                	mov    %eax,%edx
f0108417:	89 d0                	mov    %edx,%eax
f0108419:	c1 e0 02             	shl    $0x2,%eax
f010841c:	01 d0                	add    %edx,%eax
f010841e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0108425:	01 c8                	add    %ecx,%eax
f0108427:	01 c0                	add    %eax,%eax
f0108429:	01 d0                	add    %edx,%eax
f010842b:	89 c1                	mov    %eax,%ecx
f010842d:	c1 e1 08             	shl    $0x8,%ecx
f0108430:	01 c8                	add    %ecx,%eax
f0108432:	89 c1                	mov    %eax,%ecx
f0108434:	c1 e1 10             	shl    $0x10,%ecx
f0108437:	01 c8                	add    %ecx,%eax
f0108439:	c1 e0 02             	shl    $0x2,%eax
f010843c:	01 d0                	add    %edx,%eax
}
f010843e:	5d                   	pop    %ebp
f010843f:	c3                   	ret    

f0108440 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108440:	55                   	push   %ebp
f0108441:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108443:	ff 75 08             	pushl  0x8(%ebp)
f0108446:	e8 b9 ff ff ff       	call   f0108404 <to_frame_number>
f010844b:	83 c4 04             	add    $0x4,%esp
f010844e:	c1 e0 0c             	shl    $0xc,%eax
}
f0108451:	c9                   	leave  
f0108452:	c3                   	ret    

f0108453 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0108453:	55                   	push   %ebp
f0108454:	89 e5                	mov    %esp,%ebp
f0108456:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0108459:	8b 45 08             	mov    0x8(%ebp),%eax
f010845c:	c1 e8 0c             	shr    $0xc,%eax
f010845f:	89 c2                	mov    %eax,%edx
f0108461:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108466:	39 c2                	cmp    %eax,%edx
f0108468:	72 14                	jb     f010847e <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f010846a:	83 ec 04             	sub    $0x4,%esp
f010846d:	68 b4 78 12 f0       	push   $0xf01278b4
f0108472:	6a 55                	push   $0x55
f0108474:	68 d9 78 12 f0       	push   $0xf01278d9
f0108479:	e8 bb 7e ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010847e:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f0108484:	8b 45 08             	mov    0x8(%ebp),%eax
f0108487:	c1 e8 0c             	shr    $0xc,%eax
f010848a:	89 c1                	mov    %eax,%ecx
f010848c:	89 c8                	mov    %ecx,%eax
f010848e:	c1 e0 02             	shl    $0x2,%eax
f0108491:	01 c8                	add    %ecx,%eax
f0108493:	c1 e0 03             	shl    $0x3,%eax
f0108496:	01 d0                	add    %edx,%eax
}
f0108498:	c9                   	leave  
f0108499:	c3                   	ret    

f010849a <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f010849a:	55                   	push   %ebp
f010849b:	89 e5                	mov    %esp,%ebp
f010849d:	83 ec 10             	sub    $0x10,%esp
f01084a0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f01084a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01084a9:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f01084ac:	90                   	nop
f01084ad:	c9                   	leave  
f01084ae:	c3                   	ret    

f01084af <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f01084af:	55                   	push   %ebp
f01084b0:	89 e5                	mov    %esp,%ebp
f01084b2:	53                   	push   %ebx
f01084b3:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f01084b6:	c7 05 a0 58 74 f0 00 	movl   $0x0,0xf07458a0
f01084bd:	00 00 00 
f01084c0:	c7 05 a4 58 74 f0 00 	movl   $0x0,0xf07458a4
f01084c7:	00 00 00 
f01084ca:	c7 05 ac 58 74 f0 00 	movl   $0x0,0xf07458ac
f01084d1:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f01084d4:	c7 05 b0 58 74 f0 00 	movl   $0x0,0xf07458b0
f01084db:	00 00 00 
f01084de:	c7 05 b4 58 74 f0 00 	movl   $0x0,0xf07458b4
f01084e5:	00 00 00 
f01084e8:	c7 05 bc 58 74 f0 00 	movl   $0x0,0xf07458bc
f01084ef:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f01084f2:	83 ec 08             	sub    $0x8,%esp
f01084f5:	68 f3 78 12 f0       	push   $0xf01278f3
f01084fa:	68 c0 58 74 f0       	push   $0xf07458c0
f01084ff:	e8 b5 82 00 00       	call   f01107b9 <init_spinlock>
f0108504:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108507:	a1 00 5d 74 f0       	mov    0xf0745d00,%eax
f010850c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0108512:	a1 00 5d 74 f0       	mov    0xf0745d00,%eax
f0108517:	83 c0 28             	add    $0x28,%eax
f010851a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0108520:	a1 00 5d 74 f0       	mov    0xf0745d00,%eax
f0108525:	83 c0 50             	add    $0x50,%eax
f0108528:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f010852e:	c7 05 94 5d 74 f0 00 	movl   $0xf0001000,0xf0745d94
f0108535:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108538:	c7 05 44 5f 74 f0 00 	movl   $0xf0002000,0xf0745f44
f010853f:	20 00 f0 
	i =0;
f0108542:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108549:	eb 1f                	jmp    f010856a <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f010854b:	8b 15 94 5d 74 f0    	mov    0xf0745d94,%edx
f0108551:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108554:	01 d0                	add    %edx,%eax
f0108556:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0108559:	8b 15 44 5f 74 f0    	mov    0xf0745f44,%edx
f010855f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108562:	01 d0                	add    %edx,%eax
f0108564:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0108567:	ff 45 f4             	incl   -0xc(%ebp)
f010856a:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0108571:	7e d8                	jle    f010854b <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0108573:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f010857a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010857d:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0108582:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108585:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108588:	ba 00 00 00 00       	mov    $0x0,%edx
f010858d:	f7 75 f0             	divl   -0x10(%ebp)
f0108590:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108593:	29 d0                	sub    %edx,%eax
f0108595:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108598:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f010859f:	e9 ef 00 00 00       	jmp    f0108693 <initialize_paging+0x1e4>
	{

		initialize_frame_info(&(frames_info[i]));
f01085a4:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01085aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01085ad:	89 d0                	mov    %edx,%eax
f01085af:	c1 e0 02             	shl    $0x2,%eax
f01085b2:	01 d0                	add    %edx,%eax
f01085b4:	c1 e0 03             	shl    $0x3,%eax
f01085b7:	01 c8                	add    %ecx,%eax
f01085b9:	83 ec 0c             	sub    $0xc,%esp
f01085bc:	50                   	push   %eax
f01085bd:	e8 c6 02 00 00       	call   f0108888 <initialize_frame_info>
f01085c2:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f01085c5:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01085cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01085ce:	89 d0                	mov    %edx,%eax
f01085d0:	c1 e0 02             	shl    $0x2,%eax
f01085d3:	01 d0                	add    %edx,%eax
f01085d5:	c1 e0 03             	shl    $0x3,%eax
f01085d8:	01 c8                	add    %ecx,%eax
f01085da:	85 c0                	test   %eax,%eax
f01085dc:	75 14                	jne    f01085f2 <initialize_paging+0x143>
f01085de:	83 ec 04             	sub    $0x4,%esp
f01085e1:	68 04 79 12 f0       	push   $0xf0127904
f01085e6:	6a 60                	push   $0x60
f01085e8:	68 27 79 12 f0       	push   $0xf0127927
f01085ed:	e8 47 7d ff ff       	call   f0100339 <_panic>
f01085f2:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01085f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01085fb:	89 d0                	mov    %edx,%eax
f01085fd:	c1 e0 02             	shl    $0x2,%eax
f0108600:	01 d0                	add    %edx,%eax
f0108602:	c1 e0 03             	shl    $0x3,%eax
f0108605:	01 c8                	add    %ecx,%eax
f0108607:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f010860d:	89 10                	mov    %edx,(%eax)
f010860f:	8b 00                	mov    (%eax),%eax
f0108611:	85 c0                	test   %eax,%eax
f0108613:	74 20                	je     f0108635 <initialize_paging+0x186>
f0108615:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f010861b:	8b 1d 00 5d 74 f0    	mov    0xf0745d00,%ebx
f0108621:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108624:	89 c8                	mov    %ecx,%eax
f0108626:	c1 e0 02             	shl    $0x2,%eax
f0108629:	01 c8                	add    %ecx,%eax
f010862b:	c1 e0 03             	shl    $0x3,%eax
f010862e:	01 d8                	add    %ebx,%eax
f0108630:	89 42 04             	mov    %eax,0x4(%edx)
f0108633:	eb 1a                	jmp    f010864f <initialize_paging+0x1a0>
f0108635:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f010863b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010863e:	89 d0                	mov    %edx,%eax
f0108640:	c1 e0 02             	shl    $0x2,%eax
f0108643:	01 d0                	add    %edx,%eax
f0108645:	c1 e0 03             	shl    $0x3,%eax
f0108648:	01 c8                	add    %ecx,%eax
f010864a:	a3 a4 58 74 f0       	mov    %eax,0xf07458a4
f010864f:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f0108655:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108658:	89 d0                	mov    %edx,%eax
f010865a:	c1 e0 02             	shl    $0x2,%eax
f010865d:	01 d0                	add    %edx,%eax
f010865f:	c1 e0 03             	shl    $0x3,%eax
f0108662:	01 c8                	add    %ecx,%eax
f0108664:	a3 a0 58 74 f0       	mov    %eax,0xf07458a0
f0108669:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f010866f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108672:	89 d0                	mov    %edx,%eax
f0108674:	c1 e0 02             	shl    $0x2,%eax
f0108677:	01 d0                	add    %edx,%eax
f0108679:	c1 e0 03             	shl    $0x3,%eax
f010867c:	01 c8                	add    %ecx,%eax
f010867e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108685:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f010868a:	40                   	inc    %eax
f010868b:	a3 ac 58 74 f0       	mov    %eax,0xf07458ac
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108690:	ff 45 f4             	incl   -0xc(%ebp)
f0108693:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108696:	85 c0                	test   %eax,%eax
f0108698:	79 05                	jns    f010869f <initialize_paging+0x1f0>
f010869a:	05 ff 0f 00 00       	add    $0xfff,%eax
f010869f:	c1 f8 0c             	sar    $0xc,%eax
f01086a2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01086a5:	0f 8f f9 fe ff ff    	jg     f01085a4 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01086ab:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f01086b2:	eb 1e                	jmp    f01086d2 <initialize_paging+0x223>
	{
		frames_info[i].references = 1;
f01086b4:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01086ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01086bd:	89 d0                	mov    %edx,%eax
f01086bf:	c1 e0 02             	shl    $0x2,%eax
f01086c2:	01 d0                	add    %edx,%eax
f01086c4:	c1 e0 03             	shl    $0x3,%eax
f01086c7:	01 c8                	add    %ecx,%eax
f01086c9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f01086cf:	ff 45 f4             	incl   -0xc(%ebp)
f01086d2:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f01086d9:	7e d9                	jle    f01086b4 <initialize_paging+0x205>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f01086db:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f01086e2:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f01086e7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01086ea:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01086f1:	77 14                	ja     f0108707 <initialize_paging+0x258>
f01086f3:	ff 75 e0             	pushl  -0x20(%ebp)
f01086f6:	68 44 79 12 f0       	push   $0xf0127944
f01086fb:	6a 68                	push   $0x68
f01086fd:	68 27 79 12 f0       	push   $0xf0127927
f0108702:	e8 32 7c ff ff       	call   f0100339 <_panic>
f0108707:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010870a:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108710:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108713:	01 d0                	add    %edx,%eax
f0108715:	48                   	dec    %eax
f0108716:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108719:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010871c:	ba 00 00 00 00       	mov    $0x0,%edx
f0108721:	f7 75 e4             	divl   -0x1c(%ebp)
f0108724:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108727:	29 d0                	sub    %edx,%eax
f0108729:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f010872c:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108733:	eb 1e                	jmp    f0108753 <initialize_paging+0x2a4>
	{
		frames_info[i].references = 1;
f0108735:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f010873b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010873e:	89 d0                	mov    %edx,%eax
f0108740:	c1 e0 02             	shl    $0x2,%eax
f0108743:	01 d0                	add    %edx,%eax
f0108745:	c1 e0 03             	shl    $0x3,%eax
f0108748:	01 c8                	add    %ecx,%eax
f010874a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108750:	ff 45 f4             	incl   -0xc(%ebp)
f0108753:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108756:	85 c0                	test   %eax,%eax
f0108758:	79 05                	jns    f010875f <initialize_paging+0x2b0>
f010875a:	05 ff 0f 00 00       	add    $0xfff,%eax
f010875f:	c1 f8 0c             	sar    $0xc,%eax
f0108762:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108765:	7f ce                	jg     f0108735 <initialize_paging+0x286>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108767:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010876a:	85 c0                	test   %eax,%eax
f010876c:	79 05                	jns    f0108773 <initialize_paging+0x2c4>
f010876e:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108773:	c1 f8 0c             	sar    $0xc,%eax
f0108776:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108779:	e9 ef 00 00 00       	jmp    f010886d <initialize_paging+0x3be>
	{
		initialize_frame_info(&(frames_info[i]));
f010877e:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f0108784:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108787:	89 d0                	mov    %edx,%eax
f0108789:	c1 e0 02             	shl    $0x2,%eax
f010878c:	01 d0                	add    %edx,%eax
f010878e:	c1 e0 03             	shl    $0x3,%eax
f0108791:	01 c8                	add    %ecx,%eax
f0108793:	83 ec 0c             	sub    $0xc,%esp
f0108796:	50                   	push   %eax
f0108797:	e8 ec 00 00 00       	call   f0108888 <initialize_frame_info>
f010879c:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010879f:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01087a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01087a8:	89 d0                	mov    %edx,%eax
f01087aa:	c1 e0 02             	shl    $0x2,%eax
f01087ad:	01 d0                	add    %edx,%eax
f01087af:	c1 e0 03             	shl    $0x3,%eax
f01087b2:	01 c8                	add    %ecx,%eax
f01087b4:	85 c0                	test   %eax,%eax
f01087b6:	75 14                	jne    f01087cc <initialize_paging+0x31d>
f01087b8:	83 ec 04             	sub    $0x4,%esp
f01087bb:	68 04 79 12 f0       	push   $0xf0127904
f01087c0:	6a 74                	push   $0x74
f01087c2:	68 27 79 12 f0       	push   $0xf0127927
f01087c7:	e8 6d 7b ff ff       	call   f0100339 <_panic>
f01087cc:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f01087d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01087d5:	89 d0                	mov    %edx,%eax
f01087d7:	c1 e0 02             	shl    $0x2,%eax
f01087da:	01 d0                	add    %edx,%eax
f01087dc:	c1 e0 03             	shl    $0x3,%eax
f01087df:	01 c8                	add    %ecx,%eax
f01087e1:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f01087e7:	89 10                	mov    %edx,(%eax)
f01087e9:	8b 00                	mov    (%eax),%eax
f01087eb:	85 c0                	test   %eax,%eax
f01087ed:	74 20                	je     f010880f <initialize_paging+0x360>
f01087ef:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f01087f5:	8b 1d 00 5d 74 f0    	mov    0xf0745d00,%ebx
f01087fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01087fe:	89 c8                	mov    %ecx,%eax
f0108800:	c1 e0 02             	shl    $0x2,%eax
f0108803:	01 c8                	add    %ecx,%eax
f0108805:	c1 e0 03             	shl    $0x3,%eax
f0108808:	01 d8                	add    %ebx,%eax
f010880a:	89 42 04             	mov    %eax,0x4(%edx)
f010880d:	eb 1a                	jmp    f0108829 <initialize_paging+0x37a>
f010880f:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f0108815:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108818:	89 d0                	mov    %edx,%eax
f010881a:	c1 e0 02             	shl    $0x2,%eax
f010881d:	01 d0                	add    %edx,%eax
f010881f:	c1 e0 03             	shl    $0x3,%eax
f0108822:	01 c8                	add    %ecx,%eax
f0108824:	a3 a4 58 74 f0       	mov    %eax,0xf07458a4
f0108829:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f010882f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108832:	89 d0                	mov    %edx,%eax
f0108834:	c1 e0 02             	shl    $0x2,%eax
f0108837:	01 d0                	add    %edx,%eax
f0108839:	c1 e0 03             	shl    $0x3,%eax
f010883c:	01 c8                	add    %ecx,%eax
f010883e:	a3 a0 58 74 f0       	mov    %eax,0xf07458a0
f0108843:	8b 0d 00 5d 74 f0    	mov    0xf0745d00,%ecx
f0108849:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010884c:	89 d0                	mov    %edx,%eax
f010884e:	c1 e0 02             	shl    $0x2,%eax
f0108851:	01 d0                	add    %edx,%eax
f0108853:	c1 e0 03             	shl    $0x3,%eax
f0108856:	01 c8                	add    %ecx,%eax
f0108858:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010885f:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f0108864:	40                   	inc    %eax
f0108865:	a3 ac 58 74 f0       	mov    %eax,0xf07458ac
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f010886a:	ff 45 f4             	incl   -0xc(%ebp)
f010886d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108870:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108875:	39 c2                	cmp    %eax,%edx
f0108877:	0f 82 01 ff ff ff    	jb     f010877e <initialize_paging+0x2cf>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010887d:	e8 02 b6 ff ff       	call   f0103e84 <initialize_disk_page_file>
}
f0108882:	90                   	nop
f0108883:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108886:	c9                   	leave  
f0108887:	c3                   	ret    

f0108888 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108888:	55                   	push   %ebp
f0108889:	89 e5                	mov    %esp,%ebp
f010888b:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010888e:	83 ec 04             	sub    $0x4,%esp
f0108891:	6a 28                	push   $0x28
f0108893:	6a 00                	push   $0x0
f0108895:	ff 75 08             	pushl  0x8(%ebp)
f0108898:	e8 8c 98 01 00       	call   f0122129 <memset>
f010889d:	83 c4 10             	add    $0x10,%esp
}
f01088a0:	90                   	nop
f01088a1:	c9                   	leave  
f01088a2:	c3                   	ret    

f01088a3 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f01088a3:	55                   	push   %ebp
f01088a4:	89 e5                	mov    %esp,%ebp
f01088a6:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01088a9:	83 ec 0c             	sub    $0xc,%esp
f01088ac:	68 c0 58 74 f0       	push   $0xf07458c0
f01088b1:	e8 4d 81 00 00       	call   f0110a03 <holding_spinlock>
f01088b6:	83 c4 10             	add    $0x10,%esp
f01088b9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01088bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01088c0:	75 10                	jne    f01088d2 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01088c2:	83 ec 0c             	sub    $0xc,%esp
f01088c5:	68 c0 58 74 f0       	push   $0xf07458c0
f01088ca:	e8 1b 7f 00 00       	call   f01107ea <acquire_spinlock>
f01088cf:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01088d2:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f01088d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01088db:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01088dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01088e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01088e7:	8b 00                	mov    (%eax),%eax
f01088e9:	85 c0                	test   %eax,%eax
f01088eb:	75 17                	jne    f0108904 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01088ed:	83 ec 04             	sub    $0x4,%esp
f01088f0:	68 78 79 12 f0       	push   $0xf0127978
f01088f5:	68 a2 00 00 00       	push   $0xa2
f01088fa:	68 27 79 12 f0       	push   $0xf0127927
f01088ff:	e8 35 7a ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0108904:	8b 45 08             	mov    0x8(%ebp),%eax
f0108907:	8b 00                	mov    (%eax),%eax
f0108909:	85 c0                	test   %eax,%eax
f010890b:	75 17                	jne    f0108924 <allocate_frame+0x81>
f010890d:	83 ec 04             	sub    $0x4,%esp
f0108910:	68 c5 79 12 f0       	push   $0xf01279c5
f0108915:	68 a8 00 00 00       	push   $0xa8
f010891a:	68 27 79 12 f0       	push   $0xf0127927
f010891f:	e8 15 7a ff ff       	call   f0100339 <_panic>
f0108924:	8b 45 08             	mov    0x8(%ebp),%eax
f0108927:	8b 00                	mov    (%eax),%eax
f0108929:	8b 00                	mov    (%eax),%eax
f010892b:	85 c0                	test   %eax,%eax
f010892d:	74 14                	je     f0108943 <allocate_frame+0xa0>
f010892f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108932:	8b 00                	mov    (%eax),%eax
f0108934:	8b 00                	mov    (%eax),%eax
f0108936:	8b 55 08             	mov    0x8(%ebp),%edx
f0108939:	8b 12                	mov    (%edx),%edx
f010893b:	8b 52 04             	mov    0x4(%edx),%edx
f010893e:	89 50 04             	mov    %edx,0x4(%eax)
f0108941:	eb 0d                	jmp    f0108950 <allocate_frame+0xad>
f0108943:	8b 45 08             	mov    0x8(%ebp),%eax
f0108946:	8b 00                	mov    (%eax),%eax
f0108948:	8b 40 04             	mov    0x4(%eax),%eax
f010894b:	a3 a4 58 74 f0       	mov    %eax,0xf07458a4
f0108950:	8b 45 08             	mov    0x8(%ebp),%eax
f0108953:	8b 00                	mov    (%eax),%eax
f0108955:	8b 40 04             	mov    0x4(%eax),%eax
f0108958:	85 c0                	test   %eax,%eax
f010895a:	74 13                	je     f010896f <allocate_frame+0xcc>
f010895c:	8b 45 08             	mov    0x8(%ebp),%eax
f010895f:	8b 00                	mov    (%eax),%eax
f0108961:	8b 40 04             	mov    0x4(%eax),%eax
f0108964:	8b 55 08             	mov    0x8(%ebp),%edx
f0108967:	8b 12                	mov    (%edx),%edx
f0108969:	8b 12                	mov    (%edx),%edx
f010896b:	89 10                	mov    %edx,(%eax)
f010896d:	eb 0c                	jmp    f010897b <allocate_frame+0xd8>
f010896f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108972:	8b 00                	mov    (%eax),%eax
f0108974:	8b 00                	mov    (%eax),%eax
f0108976:	a3 a0 58 74 f0       	mov    %eax,0xf07458a0
f010897b:	8b 45 08             	mov    0x8(%ebp),%eax
f010897e:	8b 00                	mov    (%eax),%eax
f0108980:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108986:	8b 45 08             	mov    0x8(%ebp),%eax
f0108989:	8b 00                	mov    (%eax),%eax
f010898b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108992:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f0108997:	48                   	dec    %eax
f0108998:	a3 ac 58 74 f0       	mov    %eax,0xf07458ac

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f010899d:	8b 45 08             	mov    0x8(%ebp),%eax
f01089a0:	8b 00                	mov    (%eax),%eax
f01089a2:	8a 40 14             	mov    0x14(%eax),%al
f01089a5:	84 c0                	test   %al,%al
f01089a7:	74 20                	je     f01089c9 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f01089a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01089ac:	8b 00                	mov    (%eax),%eax
f01089ae:	8b 50 10             	mov    0x10(%eax),%edx
f01089b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01089b4:	8b 00                	mov    (%eax),%eax
f01089b6:	8b 40 0c             	mov    0xc(%eax),%eax
f01089b9:	8b 40 64             	mov    0x64(%eax),%eax
f01089bc:	83 ec 08             	sub    $0x8,%esp
f01089bf:	52                   	push   %edx
f01089c0:	50                   	push   %eax
f01089c1:	e8 79 18 00 00       	call   f010a23f <pt_clear_page_table_entry>
f01089c6:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01089c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01089cc:	8b 00                	mov    (%eax),%eax
f01089ce:	83 ec 0c             	sub    $0xc,%esp
f01089d1:	50                   	push   %eax
f01089d2:	e8 b1 fe ff ff       	call   f0108888 <initialize_frame_info>
f01089d7:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01089da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01089de:	75 10                	jne    f01089f0 <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01089e0:	83 ec 0c             	sub    $0xc,%esp
f01089e3:	68 c0 58 74 f0       	push   $0xf07458c0
f01089e8:	e8 84 7e 00 00       	call   f0110871 <release_spinlock>
f01089ed:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01089f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01089f5:	c9                   	leave  
f01089f6:	c3                   	ret    

f01089f7 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f01089f7:	55                   	push   %ebp
f01089f8:	89 e5                	mov    %esp,%ebp
f01089fa:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01089fd:	83 ec 0c             	sub    $0xc,%esp
f0108a00:	68 c0 58 74 f0       	push   $0xf07458c0
f0108a05:	e8 f9 7f 00 00       	call   f0110a03 <holding_spinlock>
f0108a0a:	83 c4 10             	add    $0x10,%esp
f0108a0d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0108a10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a14:	75 10                	jne    f0108a26 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108a16:	83 ec 0c             	sub    $0xc,%esp
f0108a19:	68 c0 58 74 f0       	push   $0xf07458c0
f0108a1e:	e8 c7 7d 00 00       	call   f01107ea <acquire_spinlock>
f0108a23:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108a26:	83 ec 0c             	sub    $0xc,%esp
f0108a29:	ff 75 08             	pushl  0x8(%ebp)
f0108a2c:	e8 57 fe ff ff       	call   f0108888 <initialize_frame_info>
f0108a31:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108a34:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108a38:	75 17                	jne    f0108a51 <free_frame+0x5a>
f0108a3a:	83 ec 04             	sub    $0x4,%esp
f0108a3d:	68 04 79 12 f0       	push   $0xf0127904
f0108a42:	68 cf 00 00 00       	push   $0xcf
f0108a47:	68 27 79 12 f0       	push   $0xf0127927
f0108a4c:	e8 e8 78 ff ff       	call   f0100339 <_panic>
f0108a51:	8b 15 a0 58 74 f0    	mov    0xf07458a0,%edx
f0108a57:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a5a:	89 10                	mov    %edx,(%eax)
f0108a5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a5f:	8b 00                	mov    (%eax),%eax
f0108a61:	85 c0                	test   %eax,%eax
f0108a63:	74 0d                	je     f0108a72 <free_frame+0x7b>
f0108a65:	a1 a0 58 74 f0       	mov    0xf07458a0,%eax
f0108a6a:	8b 55 08             	mov    0x8(%ebp),%edx
f0108a6d:	89 50 04             	mov    %edx,0x4(%eax)
f0108a70:	eb 08                	jmp    f0108a7a <free_frame+0x83>
f0108a72:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a75:	a3 a4 58 74 f0       	mov    %eax,0xf07458a4
f0108a7a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a7d:	a3 a0 58 74 f0       	mov    %eax,0xf07458a0
f0108a82:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a85:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108a8c:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f0108a91:	40                   	inc    %eax
f0108a92:	a3 ac 58 74 f0       	mov    %eax,0xf07458ac
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f0108a97:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108a9b:	75 10                	jne    f0108aad <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108a9d:	83 ec 0c             	sub    $0xc,%esp
f0108aa0:	68 c0 58 74 f0       	push   $0xf07458c0
f0108aa5:	e8 c7 7d 00 00       	call   f0110871 <release_spinlock>
f0108aaa:	83 c4 10             	add    $0x10,%esp
	}
}
f0108aad:	90                   	nop
f0108aae:	c9                   	leave  
f0108aaf:	c3                   	ret    

f0108ab0 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0108ab0:	55                   	push   %ebp
f0108ab1:	89 e5                	mov    %esp,%ebp
f0108ab3:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0108ab6:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ab9:	8b 40 08             	mov    0x8(%eax),%eax
f0108abc:	48                   	dec    %eax
f0108abd:	8b 55 08             	mov    0x8(%ebp),%edx
f0108ac0:	66 89 42 08          	mov    %ax,0x8(%edx)
f0108ac4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ac7:	8b 40 08             	mov    0x8(%eax),%eax
f0108aca:	66 85 c0             	test   %ax,%ax
f0108acd:	75 0e                	jne    f0108add <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0108acf:	83 ec 0c             	sub    $0xc,%esp
f0108ad2:	ff 75 08             	pushl  0x8(%ebp)
f0108ad5:	e8 1d ff ff ff       	call   f01089f7 <free_frame>
f0108ada:	83 c4 10             	add    $0x10,%esp
}
f0108add:	90                   	nop
f0108ade:	c9                   	leave  
f0108adf:	c3                   	ret    

f0108ae0 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108ae0:	55                   	push   %ebp
f0108ae1:	89 e5                	mov    %esp,%ebp
f0108ae3:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ae9:	c1 e8 16             	shr    $0x16,%eax
f0108aec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108af3:	8b 45 08             	mov    0x8(%ebp),%eax
f0108af6:	01 d0                	add    %edx,%eax
f0108af8:	8b 00                	mov    (%eax),%eax
f0108afa:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0108afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b00:	83 e0 01             	and    $0x1,%eax
f0108b03:	85 c0                	test   %eax,%eax
f0108b05:	74 74                	je     f0108b7b <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108b07:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108b0e:	77 1d                	ja     f0108b2d <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108b10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b13:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108b18:	83 ec 0c             	sub    $0xc,%esp
f0108b1b:	50                   	push   %eax
f0108b1c:	e8 71 15 00 00       	call   f010a092 <kheap_virtual_address>
f0108b21:	83 c4 10             	add    $0x10,%esp
f0108b24:	89 c2                	mov    %eax,%edx
f0108b26:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b29:	89 10                	mov    %edx,(%eax)
f0108b2b:	eb 44                	jmp    f0108b71 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b30:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108b35:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108b38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b3b:	c1 e8 0c             	shr    $0xc,%eax
f0108b3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108b41:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108b46:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108b49:	72 17                	jb     f0108b62 <get_page_table+0x82>
f0108b4b:	ff 75 f0             	pushl  -0x10(%ebp)
f0108b4e:	68 e4 79 12 f0       	push   $0xf01279e4
f0108b53:	68 fb 00 00 00       	push   $0xfb
f0108b58:	68 27 79 12 f0       	push   $0xf0127927
f0108b5d:	e8 d7 77 ff ff       	call   f0100339 <_panic>
f0108b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108b65:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108b6a:	89 c2                	mov    %eax,%edx
f0108b6c:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b6f:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108b71:	b8 00 00 00 00       	mov    $0x0,%eax
f0108b76:	e9 b9 00 00 00       	jmp    f0108c34 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0108b7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b7f:	0f 84 a1 00 00 00    	je     f0108c26 <get_page_table+0x146>
f0108b85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b88:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f0108b8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108b8e:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108b91:	83 ec 0c             	sub    $0xc,%esp
f0108b94:	6a 00                	push   $0x0
f0108b96:	e8 be 71 00 00       	call   f010fd59 <fault_handler>
f0108b9b:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108b9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ba1:	c1 e8 16             	shr    $0x16,%eax
f0108ba4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108bab:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bae:	01 d0                	add    %edx,%eax
f0108bb0:	8b 00                	mov    (%eax),%eax
f0108bb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108bb5:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108bbc:	77 1d                	ja     f0108bdb <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108bc1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108bc6:	83 ec 0c             	sub    $0xc,%esp
f0108bc9:	50                   	push   %eax
f0108bca:	e8 c3 14 00 00       	call   f010a092 <kheap_virtual_address>
f0108bcf:	83 c4 10             	add    $0x10,%esp
f0108bd2:	89 c2                	mov    %eax,%edx
f0108bd4:	8b 45 10             	mov    0x10(%ebp),%eax
f0108bd7:	89 10                	mov    %edx,(%eax)
f0108bd9:	eb 44                	jmp    f0108c1f <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108bde:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108be3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108be6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108be9:	c1 e8 0c             	shr    $0xc,%eax
f0108bec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108bef:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108bf4:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108bf7:	72 17                	jb     f0108c10 <get_page_table+0x130>
f0108bf9:	ff 75 e8             	pushl  -0x18(%ebp)
f0108bfc:	68 e4 79 12 f0       	push   $0xf01279e4
f0108c01:	68 13 01 00 00       	push   $0x113
f0108c06:	68 27 79 12 f0       	push   $0xf0127927
f0108c0b:	e8 29 77 ff ff       	call   f0100339 <_panic>
f0108c10:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108c13:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108c18:	89 c2                	mov    %eax,%edx
f0108c1a:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c1d:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0108c1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0108c24:	eb 0e                	jmp    f0108c34 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108c26:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f0108c2f:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108c34:	c9                   	leave  
f0108c35:	c3                   	ret    

f0108c36 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108c36:	55                   	push   %ebp
f0108c37:	89 e5                	mov    %esp,%ebp
f0108c39:	53                   	push   %ebx
f0108c3a:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f0108c3d:	83 ec 0c             	sub    $0xc,%esp
f0108c40:	68 00 10 00 00       	push   $0x1000
f0108c45:	e8 20 10 00 00       	call   f0109c6a <kmalloc>
f0108c4a:	83 c4 10             	add    $0x10,%esp
f0108c4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f0108c50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c54:	75 17                	jne    f0108c6d <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108c56:	83 ec 04             	sub    $0x4,%esp
f0108c59:	68 13 7a 12 f0       	push   $0xf0127a13
f0108c5e:	68 33 01 00 00       	push   $0x133
f0108c63:	68 27 79 12 f0       	push   $0xf0127927
f0108c68:	e8 cc 76 ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0108c6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c70:	c1 e8 16             	shr    $0x16,%eax
f0108c73:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108c7a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c7d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f0108c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c83:	83 ec 0c             	sub    $0xc,%esp
f0108c86:	50                   	push   %eax
f0108c87:	e8 75 13 00 00       	call   f010a001 <kheap_physical_address>
f0108c8c:	83 c4 10             	add    $0x10,%esp
f0108c8f:	83 c8 07             	or     $0x7,%eax
f0108c92:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0108c94:	83 ec 04             	sub    $0x4,%esp
f0108c97:	68 00 10 00 00       	push   $0x1000
f0108c9c:	6a 00                	push   $0x0
f0108c9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0108ca1:	e8 83 94 01 00       	call   f0122129 <memset>
f0108ca6:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108ca9:	0f 20 d8             	mov    %cr3,%eax
f0108cac:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108caf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108cb2:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0108cb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108cb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108cbb:	c9                   	leave  
f0108cbc:	c3                   	ret    

f0108cbd <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108cbd:	55                   	push   %ebp
f0108cbe:	89 e5                	mov    %esp,%ebp
f0108cc0:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0108cc3:	83 ec 0c             	sub    $0xc,%esp
f0108cc6:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108cc9:	50                   	push   %eax
f0108cca:	e8 d4 fb ff ff       	call   f01088a3 <allocate_frame>
f0108ccf:	83 c4 10             	add    $0x10,%esp
f0108cd2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0108cd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108cd8:	83 ec 0c             	sub    $0xc,%esp
f0108cdb:	50                   	push   %eax
f0108cdc:	e8 5f f7 ff ff       	call   f0108440 <to_physical_address>
f0108ce1:	83 c4 10             	add    $0x10,%esp
f0108ce4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0108ce7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108cea:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108ced:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108cf0:	c1 e8 0c             	shr    $0xc,%eax
f0108cf3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108cf6:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108cfb:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108cfe:	72 17                	jb     f0108d17 <__static_cpt+0x5a>
f0108d00:	ff 75 ec             	pushl  -0x14(%ebp)
f0108d03:	68 e4 79 12 f0       	push   $0xf01279e4
f0108d08:	68 4e 01 00 00       	push   $0x14e
f0108d0d:	68 27 79 12 f0       	push   $0xf0127927
f0108d12:	e8 22 76 ff ff       	call   f0100339 <_panic>
f0108d17:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d1a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108d1f:	89 c2                	mov    %eax,%edx
f0108d21:	8b 45 10             	mov    0x10(%ebp),%eax
f0108d24:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108d26:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108d29:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f0108d2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d32:	c1 e8 16             	shr    $0x16,%eax
f0108d35:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108d3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d3f:	01 d0                	add    %edx,%eax
f0108d41:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108d44:	83 ca 07             	or     $0x7,%edx
f0108d47:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108d49:	8b 45 10             	mov    0x10(%ebp),%eax
f0108d4c:	8b 00                	mov    (%eax),%eax
f0108d4e:	83 ec 04             	sub    $0x4,%esp
f0108d51:	68 00 10 00 00       	push   $0x1000
f0108d56:	6a 00                	push   $0x0
f0108d58:	50                   	push   %eax
f0108d59:	e8 cb 93 01 00       	call   f0122129 <memset>
f0108d5e:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108d61:	0f 20 d8             	mov    %cr3,%eax
f0108d64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108d67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108d6a:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108d6d:	90                   	nop
f0108d6e:	c9                   	leave  
f0108d6f:	c3                   	ret    

f0108d70 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108d70:	55                   	push   %ebp
f0108d71:	89 e5                	mov    %esp,%ebp
f0108d73:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108d76:	ff 75 0c             	pushl  0xc(%ebp)
f0108d79:	e8 c2 f6 ff ff       	call   f0108440 <to_physical_address>
f0108d7e:	83 c4 04             	add    $0x4,%esp
f0108d81:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108d84:	83 ec 04             	sub    $0x4,%esp
f0108d87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108d8a:	50                   	push   %eax
f0108d8b:	ff 75 10             	pushl  0x10(%ebp)
f0108d8e:	ff 75 08             	pushl  0x8(%ebp)
f0108d91:	e8 4a fd ff ff       	call   f0108ae0 <get_page_table>
f0108d96:	83 c4 10             	add    $0x10,%esp
f0108d99:	83 f8 01             	cmp    $0x1,%eax
f0108d9c:	75 1b                	jne    f0108db9 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0108d9e:	83 ec 08             	sub    $0x8,%esp
f0108da1:	ff 75 10             	pushl  0x10(%ebp)
f0108da4:	ff 75 08             	pushl  0x8(%ebp)
f0108da7:	e8 8a fe ff ff       	call   f0108c36 <create_page_table>
f0108dac:	83 c4 10             	add    $0x10,%esp
f0108daf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0108db2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0108db9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108dbc:	8b 55 10             	mov    0x10(%ebp),%edx
f0108dbf:	c1 ea 0c             	shr    $0xc,%edx
f0108dc2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108dc8:	c1 e2 02             	shl    $0x2,%edx
f0108dcb:	01 d0                	add    %edx,%eax
f0108dcd:	8b 00                	mov    (%eax),%eax
f0108dcf:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108dd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108dd5:	83 e0 01             	and    $0x1,%eax
f0108dd8:	85 c0                	test   %eax,%eax
f0108dda:	74 25                	je     f0108e01 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f0108ddc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ddf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108de4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108de7:	75 07                	jne    f0108df0 <map_frame+0x80>
			return 0;
f0108de9:	b8 00 00 00 00       	mov    $0x0,%eax
f0108dee:	eb 71                	jmp    f0108e61 <map_frame+0xf1>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108df0:	83 ec 08             	sub    $0x8,%esp
f0108df3:	ff 75 10             	pushl  0x10(%ebp)
f0108df6:	ff 75 08             	pushl  0x8(%ebp)
f0108df9:	e8 db 00 00 00       	call   f0108ed9 <unmap_frame>
f0108dfe:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108e01:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108e04:	8b 40 08             	mov    0x8(%eax),%eax
f0108e07:	40                   	inc    %eax
f0108e08:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108e0b:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_frame_info->va=virtual_address;
f0108e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108e12:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e15:	89 50 18             	mov    %edx,0x18(%eax)
	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108e18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e1b:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e1e:	c1 ea 0c             	shr    $0xc,%edx
f0108e21:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108e27:	c1 e2 02             	shl    $0x2,%edx
f0108e2a:	01 d0                	add    %edx,%eax
f0108e2c:	8b 00                	mov    (%eax),%eax
f0108e2e:	25 00 0e 00 00       	and    $0xe00,%eax
f0108e33:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f0108e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108e39:	8b 55 10             	mov    0x10(%ebp),%edx
f0108e3c:	c1 ea 0c             	shr    $0xc,%edx
f0108e3f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108e45:	c1 e2 02             	shl    $0x2,%edx
f0108e48:	01 c2                	add    %eax,%edx
f0108e4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e4d:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108e50:	89 c1                	mov    %eax,%ecx
f0108e52:	8b 45 14             	mov    0x14(%ebp),%eax
f0108e55:	09 c8                	or     %ecx,%eax
f0108e57:	83 c8 01             	or     $0x1,%eax
f0108e5a:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108e5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108e61:	c9                   	leave  
f0108e62:	c3                   	ret    

f0108e63 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108e63:	55                   	push   %ebp
f0108e64:	89 e5                	mov    %esp,%ebp
f0108e66:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f0108e69:	83 ec 04             	sub    $0x4,%esp
f0108e6c:	ff 75 10             	pushl  0x10(%ebp)
f0108e6f:	ff 75 0c             	pushl  0xc(%ebp)
f0108e72:	ff 75 08             	pushl  0x8(%ebp)
f0108e75:	e8 66 fc ff ff       	call   f0108ae0 <get_page_table>
f0108e7a:	83 c4 10             	add    $0x10,%esp
f0108e7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108e80:	8b 45 10             	mov    0x10(%ebp),%eax
f0108e83:	8b 00                	mov    (%eax),%eax
f0108e85:	85 c0                	test   %eax,%eax
f0108e87:	74 49                	je     f0108ed2 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f0108e89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108e8c:	c1 e8 0c             	shr    $0xc,%eax
f0108e8f:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108e94:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0108e97:	8b 45 10             	mov    0x10(%ebp),%eax
f0108e9a:	8b 00                	mov    (%eax),%eax
f0108e9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108e9f:	c1 e2 02             	shl    $0x2,%edx
f0108ea2:	01 d0                	add    %edx,%eax
f0108ea4:	8b 00                	mov    (%eax),%eax
f0108ea6:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108ea9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108eb1:	85 c0                	test   %eax,%eax
f0108eb3:	74 16                	je     f0108ecb <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f0108eb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108eb8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ebd:	83 ec 0c             	sub    $0xc,%esp
f0108ec0:	50                   	push   %eax
f0108ec1:	e8 8d f5 ff ff       	call   f0108453 <to_frame_info>
f0108ec6:	83 c4 10             	add    $0x10,%esp
f0108ec9:	eb 0c                	jmp    f0108ed7 <get_frame_info+0x74>
		}
		return 0;
f0108ecb:	b8 00 00 00 00       	mov    $0x0,%eax
f0108ed0:	eb 05                	jmp    f0108ed7 <get_frame_info+0x74>
	}
	return 0;
f0108ed2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108ed7:	c9                   	leave  
f0108ed8:	c3                   	ret    

f0108ed9 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108ed9:	55                   	push   %ebp
f0108eda:	89 e5                	mov    %esp,%ebp
f0108edc:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108edf:	83 ec 04             	sub    $0x4,%esp
f0108ee2:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0108ee5:	50                   	push   %eax
f0108ee6:	ff 75 0c             	pushl  0xc(%ebp)
f0108ee9:	ff 75 08             	pushl  0x8(%ebp)
f0108eec:	e8 72 ff ff ff       	call   f0108e63 <get_frame_info>
f0108ef1:	83 c4 10             	add    $0x10,%esp
f0108ef4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f0108ef7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108efb:	0f 84 87 00 00 00    	je     f0108f88 <unmap_frame+0xaf>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108f01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f04:	8a 40 14             	mov    0x14(%eax),%al
f0108f07:	84 c0                	test   %al,%al
f0108f09:	74 1c                	je     f0108f27 <unmap_frame+0x4e>
f0108f0b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108f12:	77 13                	ja     f0108f27 <unmap_frame+0x4e>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108f14:	83 ec 08             	sub    $0x8,%esp
f0108f17:	ff 75 0c             	pushl  0xc(%ebp)
f0108f1a:	68 30 7a 12 f0       	push   $0xf0127a30
f0108f1f:	e8 67 80 ff ff       	call   f0100f8b <cprintf>
f0108f24:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0108f27:	83 ec 0c             	sub    $0xc,%esp
f0108f2a:	ff 75 f4             	pushl  -0xc(%ebp)
f0108f2d:	e8 7e fb ff ff       	call   f0108ab0 <decrement_references>
f0108f32:	83 c4 10             	add    $0x10,%esp
		ptr_frame_info->va=0;
f0108f35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f38:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108f3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f42:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f45:	c1 ea 0c             	shr    $0xc,%edx
f0108f48:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108f4e:	c1 e2 02             	shl    $0x2,%edx
f0108f51:	01 d0                	add    %edx,%eax
f0108f53:	8b 00                	mov    (%eax),%eax
f0108f55:	25 00 0e 00 00       	and    $0xe00,%eax
f0108f5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108f5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108f60:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108f63:	c1 ea 0c             	shr    $0xc,%edx
f0108f66:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108f6c:	c1 e2 02             	shl    $0x2,%edx
f0108f6f:	01 c2                	add    %eax,%edx
f0108f71:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f74:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f0108f76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108f79:	83 ec 08             	sub    $0x8,%esp
f0108f7c:	50                   	push   %eax
f0108f7d:	ff 75 08             	pushl  0x8(%ebp)
f0108f80:	e8 15 f5 ff ff       	call   f010849a <tlb_invalidate>
f0108f85:	83 c4 10             	add    $0x10,%esp
	}
}
f0108f88:	90                   	nop
f0108f89:	c9                   	leave  
f0108f8a:	c3                   	ret    

f0108f8b <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108f8b:	55                   	push   %ebp
f0108f8c:	89 e5                	mov    %esp,%ebp
f0108f8e:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108f91:	ff 75 0c             	pushl  0xc(%ebp)
f0108f94:	e8 a7 f4 ff ff       	call   f0108440 <to_physical_address>
f0108f99:	83 c4 04             	add    $0x4,%esp
f0108f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108f9f:	8b 45 10             	mov    0x10(%ebp),%eax
f0108fa2:	c1 e8 16             	shr    $0x16,%eax
f0108fa5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108fac:	8b 45 08             	mov    0x8(%ebp),%eax
f0108faf:	01 d0                	add    %edx,%eax
f0108fb1:	8b 00                	mov    (%eax),%eax
f0108fb3:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108fb6:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108fbd:	77 19                	ja     f0108fd8 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108fbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108fc2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108fc7:	83 ec 0c             	sub    $0xc,%esp
f0108fca:	50                   	push   %eax
f0108fcb:	e8 c2 10 00 00       	call   f010a092 <kheap_virtual_address>
f0108fd0:	83 c4 10             	add    $0x10,%esp
f0108fd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108fd6:	eb 40                	jmp    f0109018 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108fd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108fdb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108fe0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108fe3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108fe6:	c1 e8 0c             	shr    $0xc,%eax
f0108fe9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108fec:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0108ff1:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108ff4:	72 17                	jb     f010900d <loadtime_map_frame+0x82>
f0108ff6:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ff9:	68 e4 79 12 f0       	push   $0xf01279e4
f0108ffe:	68 f9 01 00 00       	push   $0x1f9
f0109003:	68 27 79 12 f0       	push   $0xf0127927
f0109008:	e8 2c 73 ff ff       	call   f0100339 <_panic>
f010900d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109010:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109015:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0109018:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010901c:	75 14                	jne    f0109032 <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f010901e:	83 ec 08             	sub    $0x8,%esp
f0109021:	ff 75 10             	pushl  0x10(%ebp)
f0109024:	ff 75 08             	pushl  0x8(%ebp)
f0109027:	e8 0a fc ff ff       	call   f0108c36 <create_page_table>
f010902c:	83 c4 10             	add    $0x10,%esp
f010902f:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f0109032:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109035:	8b 40 08             	mov    0x8(%eax),%eax
f0109038:	40                   	inc    %eax
f0109039:	8b 55 0c             	mov    0xc(%ebp),%edx
f010903c:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0109040:	8b 45 10             	mov    0x10(%ebp),%eax
f0109043:	c1 e8 0c             	shr    $0xc,%eax
f0109046:	25 ff 03 00 00       	and    $0x3ff,%eax
f010904b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109052:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109055:	01 c2                	add    %eax,%edx
f0109057:	8b 45 14             	mov    0x14(%ebp),%eax
f010905a:	0b 45 f0             	or     -0x10(%ebp),%eax
f010905d:	83 c8 01             	or     $0x1,%eax
f0109060:	89 02                	mov    %eax,(%edx)

	return 0;
f0109062:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109067:	c9                   	leave  
f0109068:	c3                   	ret    

f0109069 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0109069:	55                   	push   %ebp
f010906a:	89 e5                	mov    %esp,%ebp
f010906c:	57                   	push   %edi
f010906d:	56                   	push   %esi
f010906e:	53                   	push   %ebx
f010906f:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0109072:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0109079:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0109080:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0109087:	83 ec 0c             	sub    $0xc,%esp
f010908a:	68 c0 58 74 f0       	push   $0xf07458c0
f010908f:	e8 6f 79 00 00       	call   f0110a03 <holding_spinlock>
f0109094:	83 c4 10             	add    $0x10,%esp
f0109097:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f010909a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010909e:	75 10                	jne    f01090b0 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01090a0:	83 ec 0c             	sub    $0xc,%esp
f01090a3:	68 c0 58 74 f0       	push   $0xf07458c0
f01090a8:	e8 3d 77 00 00       	call   f01107ea <acquire_spinlock>
f01090ad:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01090b0:	a1 a0 58 74 f0       	mov    0xf07458a0,%eax
f01090b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01090b8:	eb 1a                	jmp    f01090d4 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01090ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01090bd:	8a 40 14             	mov    0x14(%eax),%al
f01090c0:	84 c0                	test   %al,%al
f01090c2:	74 05                	je     f01090c9 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01090c4:	ff 45 dc             	incl   -0x24(%ebp)
f01090c7:	eb 03                	jmp    f01090cc <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01090c9:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01090cc:	a1 a8 58 74 f0       	mov    0xf07458a8,%eax
f01090d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01090d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01090d8:	74 07                	je     f01090e1 <calculate_available_frames+0x78>
f01090da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01090dd:	8b 00                	mov    (%eax),%eax
f01090df:	eb 05                	jmp    f01090e6 <calculate_available_frames+0x7d>
f01090e1:	b8 00 00 00 00       	mov    $0x0,%eax
f01090e6:	a3 a8 58 74 f0       	mov    %eax,0xf07458a8
f01090eb:	a1 a8 58 74 f0       	mov    0xf07458a8,%eax
f01090f0:	85 c0                	test   %eax,%eax
f01090f2:	75 c6                	jne    f01090ba <calculate_available_frames+0x51>
f01090f4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01090f8:	75 c0                	jne    f01090ba <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f01090fa:	a1 bc 58 74 f0       	mov    0xf07458bc,%eax
f01090ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0109102:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109106:	75 10                	jne    f0109118 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0109108:	83 ec 0c             	sub    $0xc,%esp
f010910b:	68 c0 58 74 f0       	push   $0xf07458c0
f0109110:	e8 5c 77 00 00       	call   f0110871 <release_spinlock>
f0109115:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0109118:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010911b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f010911e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109121:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0109124:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109127:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f010912a:	8b 45 08             	mov    0x8(%ebp),%eax
f010912d:	89 c3                	mov    %eax,%ebx
f010912f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0109132:	ba 03 00 00 00       	mov    $0x3,%edx
f0109137:	89 df                	mov    %ebx,%edi
f0109139:	89 c6                	mov    %eax,%esi
f010913b:	89 d1                	mov    %edx,%ecx
f010913d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010913f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109142:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0109145:	5b                   	pop    %ebx
f0109146:	5e                   	pop    %esi
f0109147:	5f                   	pop    %edi
f0109148:	5d                   	pop    %ebp
f0109149:	c2 04 00             	ret    $0x4

f010914c <sharing_init>:

//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init() {
f010914c:	55                   	push   %ebp
f010914d:	89 e5                	mov    %esp,%ebp
f010914f:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list)
f0109152:	c7 05 60 57 74 f0 00 	movl   $0x0,0xf0745760
f0109159:	00 00 00 
f010915c:	c7 05 64 57 74 f0 00 	movl   $0x0,0xf0745764
f0109163:	00 00 00 
f0109166:	c7 05 6c 57 74 f0 00 	movl   $0x0,0xf074576c
f010916d:	00 00 00 
	;
	init_spinlock(&AllShares.shareslock, "shares lock");
f0109170:	83 ec 08             	sub    $0x8,%esp
f0109173:	68 60 7a 12 f0       	push   $0xf0127a60
f0109178:	68 70 57 74 f0       	push   $0xf0745770
f010917d:	e8 37 76 00 00       	call   f01107b9 <init_spinlock>
f0109182:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0109185:	90                   	nop
f0109186:	c9                   	leave  
f0109187:	c3                   	ret    

f0109188 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName) {
f0109188:	55                   	push   %ebp
f0109189:	89 e5                	mov    %esp,%ebp
f010918b:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f010918e:	83 ec 08             	sub    $0x8,%esp
f0109191:	ff 75 0c             	pushl  0xc(%ebp)
f0109194:	ff 75 08             	pushl  0x8(%ebp)
f0109197:	e8 89 01 00 00       	call   f0109325 <get_share>
f010919c:	83 c4 10             	add    $0x10,%esp
f010919f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f01091a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01091a6:	75 07                	jne    f01091af <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f01091a8:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f01091ad:	eb 06                	jmp    f01091b5 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f01091af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091b2:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f01091b5:	c9                   	leave  
f01091b6:	c3                   	ret    

f01091b7 <create_frames_storage>:
//==================================================================================//
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames) {
f01091b7:	55                   	push   %ebp
f01091b8:	89 e5                	mov    %esp,%ebp
f01091ba:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_frames_storage is not implemented yet");
	//Your Code is Here...
	if (numOfFrames < 0) {
f01091bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01091c1:	79 07                	jns    f01091ca <create_frames_storage+0x13>
		return NULL;
f01091c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01091c8:	eb 68                	jmp    f0109232 <create_frames_storage+0x7b>
	}
	struct FrameInfo *ss = NULL;
f01091ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 ListSZ = numOfFrames * sizeof(ss);
f01091d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d4:	c1 e0 02             	shl    $0x2,%eax
f01091d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct FrameInfo **framesListtt = (struct FrameInfo**) kmalloc(ListSZ);
f01091da:	83 ec 0c             	sub    $0xc,%esp
f01091dd:	ff 75 ec             	pushl  -0x14(%ebp)
f01091e0:	e8 85 0a 00 00       	call   f0109c6a <kmalloc>
f01091e5:	83 c4 10             	add    $0x10,%esp
f01091e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (framesListtt == NULL) {
f01091eb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01091ef:	75 15                	jne    f0109206 <create_frames_storage+0x4f>
		kfree((void*) framesListtt);
f01091f1:	83 ec 0c             	sub    $0xc,%esp
f01091f4:	ff 75 e8             	pushl  -0x18(%ebp)
f01091f7:	e8 d8 0c 00 00       	call   f0109ed4 <kfree>
f01091fc:	83 c4 10             	add    $0x10,%esp
		return NULL;
f01091ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0109204:	eb 2c                	jmp    f0109232 <create_frames_storage+0x7b>
	}
	for (int k = 0; k < numOfFrames; k++) {
f0109206:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010920d:	eb 18                	jmp    f0109227 <create_frames_storage+0x70>
		framesListtt[k] = 0;
f010920f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109212:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109219:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010921c:	01 d0                	add    %edx,%eax
f010921e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	struct FrameInfo **framesListtt = (struct FrameInfo**) kmalloc(ListSZ);
	if (framesListtt == NULL) {
		kfree((void*) framesListtt);
		return NULL;
	}
	for (int k = 0; k < numOfFrames; k++) {
f0109224:	ff 45 f4             	incl   -0xc(%ebp)
f0109227:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010922a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010922d:	7c e0                	jl     f010920f <create_frames_storage+0x58>
		framesListtt[k] = 0;
	}
	return framesListtt;
f010922f:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0109232:	c9                   	leave  
f0109233:	c3                   	ret    

f0109234 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size,
		uint8 isWritable) {
f0109234:	55                   	push   %ebp
f0109235:	89 e5                	mov    %esp,%ebp
f0109237:	83 ec 28             	sub    $0x28,%esp
f010923a:	8b 45 14             	mov    0x14(%ebp),%eax
f010923d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("create_share is not implemented yet");
	//Your Code is Here...
	if (shareName == NULL || size == 0) {
f0109240:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0109244:	74 06                	je     f010924c <create_share+0x18>
f0109246:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010924a:	75 0a                	jne    f0109256 <create_share+0x22>
		return NULL;
f010924c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109251:	e9 cd 00 00 00       	jmp    f0109323 <create_share+0xef>
	}
	struct Share * new_Shared_Obj = (struct Share *) kmalloc(
f0109256:	83 ec 0c             	sub    $0xc,%esp
f0109259:	6a 60                	push   $0x60
f010925b:	e8 0a 0a 00 00       	call   f0109c6a <kmalloc>
f0109260:	83 c4 10             	add    $0x10,%esp
f0109263:	89 45 f4             	mov    %eax,-0xc(%ebp)
			sizeof(struct Share));
	if (new_Shared_Obj == NULL) {
f0109266:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010926a:	75 18                	jne    f0109284 <create_share+0x50>
		kfree(new_Shared_Obj);
f010926c:	83 ec 0c             	sub    $0xc,%esp
f010926f:	ff 75 f4             	pushl  -0xc(%ebp)
f0109272:	e8 5d 0c 00 00       	call   f0109ed4 <kfree>
f0109277:	83 c4 10             	add    $0x10,%esp
		return NULL;
f010927a:	b8 00 00 00 00       	mov    $0x0,%eax
f010927f:	e9 9f 00 00 00       	jmp    f0109323 <create_share+0xef>
	}
	new_Shared_Obj->references = 1;
f0109284:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109287:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
	new_Shared_Obj->ID = (uint32) new_Shared_Obj & 0x7FFFFFFF;	//Masking
f010928e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109291:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
f0109296:	89 c2                	mov    %eax,%edx
f0109298:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010929b:	89 10                	mov    %edx,(%eax)
	new_Shared_Obj->ownerID = ownerID;
f010929d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092a0:	8b 55 08             	mov    0x8(%ebp),%edx
f01092a3:	89 50 04             	mov    %edx,0x4(%eax)
	strcpy(new_Shared_Obj->name, shareName);
f01092a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092a9:	83 c0 08             	add    $0x8,%eax
f01092ac:	83 ec 08             	sub    $0x8,%esp
f01092af:	ff 75 0c             	pushl  0xc(%ebp)
f01092b2:	50                   	push   %eax
f01092b3:	e8 d2 8c 01 00       	call   f0121f8a <strcpy>
f01092b8:	83 c4 10             	add    $0x10,%esp
	new_Shared_Obj->isWritable = isWritable;
f01092bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092be:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f01092c1:	88 50 50             	mov    %dl,0x50(%eax)
	new_Shared_Obj->size = size;
f01092c4:	8b 55 10             	mov    0x10(%ebp),%edx
f01092c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092ca:	89 50 48             	mov    %edx,0x48(%eax)
	uint32 FramesNumb = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f01092cd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01092d4:	8b 55 10             	mov    0x10(%ebp),%edx
f01092d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092da:	01 d0                	add    %edx,%eax
f01092dc:	48                   	dec    %eax
f01092dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01092e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01092e3:	ba 00 00 00 00       	mov    $0x0,%edx
f01092e8:	f7 75 f0             	divl   -0x10(%ebp)
f01092eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01092ee:	29 d0                	sub    %edx,%eax
f01092f0:	c1 e8 0c             	shr    $0xc,%eax
f01092f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	new_Shared_Obj->framesStorage = create_frames_storage(FramesNumb);
f01092f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01092f9:	83 ec 0c             	sub    $0xc,%esp
f01092fc:	50                   	push   %eax
f01092fd:	e8 b5 fe ff ff       	call   f01091b7 <create_frames_storage>
f0109302:	83 c4 10             	add    $0x10,%esp
f0109305:	89 c2                	mov    %eax,%edx
f0109307:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010930a:	89 50 54             	mov    %edx,0x54(%eax)
	if (new_Shared_Obj->framesStorage[0] != 0) {
f010930d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109310:	8b 40 54             	mov    0x54(%eax),%eax
f0109313:	8b 00                	mov    (%eax),%eax
f0109315:	85 c0                	test   %eax,%eax
f0109317:	74 07                	je     f0109320 <create_share+0xec>
		return NULL;
f0109319:	b8 00 00 00 00       	mov    $0x0,%eax
f010931e:	eb 03                	jmp    f0109323 <create_share+0xef>
	}
	return new_Shared_Obj;
f0109320:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109323:	c9                   	leave  
f0109324:	c3                   	ret    

f0109325 <get_share>:
//=============================
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name) {
f0109325:	55                   	push   %ebp
f0109326:	89 e5                	mov    %esp,%ebp
f0109328:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("get_share is not implemented yet");
	//Your Code is Here...
	if (name == NULL) {
f010932b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010932f:	75 0a                	jne    f010933b <get_share+0x16>
		return NULL;
f0109331:	b8 00 00 00 00       	mov    $0x0,%eax
f0109336:	e9 97 00 00 00       	jmp    f01093d2 <get_share+0xad>
	}
	acquire_spinlock(&(AllShares.shareslock));
f010933b:	83 ec 0c             	sub    $0xc,%esp
f010933e:	68 70 57 74 f0       	push   $0xf0745770
f0109343:	e8 a2 74 00 00       	call   f01107ea <acquire_spinlock>
f0109348:	83 c4 10             	add    $0x10,%esp
	struct Share* current_Shared_Obj;
	LIST_FOREACH(current_Shared_Obj, &(AllShares.shares_list))
f010934b:	a1 60 57 74 f0       	mov    0xf0745760,%eax
f0109350:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109353:	eb 41                	jmp    f0109396 <get_share+0x71>
	{
		if (current_Shared_Obj->ownerID == ownerID
f0109355:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109358:	8b 40 04             	mov    0x4(%eax),%eax
f010935b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010935e:	75 2e                	jne    f010938e <get_share+0x69>
				&& strcmp(current_Shared_Obj->name, name) == 0) {
f0109360:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109363:	83 c0 08             	add    $0x8,%eax
f0109366:	83 ec 08             	sub    $0x8,%esp
f0109369:	ff 75 0c             	pushl  0xc(%ebp)
f010936c:	50                   	push   %eax
f010936d:	e8 d5 8c 01 00       	call   f0122047 <strcmp>
f0109372:	83 c4 10             	add    $0x10,%esp
f0109375:	85 c0                	test   %eax,%eax
f0109377:	75 15                	jne    f010938e <get_share+0x69>
			release_spinlock(&(AllShares.shareslock));
f0109379:	83 ec 0c             	sub    $0xc,%esp
f010937c:	68 70 57 74 f0       	push   $0xf0745770
f0109381:	e8 eb 74 00 00       	call   f0110871 <release_spinlock>
f0109386:	83 c4 10             	add    $0x10,%esp
			return current_Shared_Obj;
f0109389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010938c:	eb 44                	jmp    f01093d2 <get_share+0xad>
	if (name == NULL) {
		return NULL;
	}
	acquire_spinlock(&(AllShares.shareslock));
	struct Share* current_Shared_Obj;
	LIST_FOREACH(current_Shared_Obj, &(AllShares.shares_list))
f010938e:	a1 68 57 74 f0       	mov    0xf0745768,%eax
f0109393:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109396:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010939a:	74 08                	je     f01093a4 <get_share+0x7f>
f010939c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010939f:	8b 40 58             	mov    0x58(%eax),%eax
f01093a2:	eb 05                	jmp    f01093a9 <get_share+0x84>
f01093a4:	b8 00 00 00 00       	mov    $0x0,%eax
f01093a9:	a3 68 57 74 f0       	mov    %eax,0xf0745768
f01093ae:	a1 68 57 74 f0       	mov    0xf0745768,%eax
f01093b3:	85 c0                	test   %eax,%eax
f01093b5:	75 9e                	jne    f0109355 <get_share+0x30>
f01093b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01093bb:	75 98                	jne    f0109355 <get_share+0x30>
				&& strcmp(current_Shared_Obj->name, name) == 0) {
			release_spinlock(&(AllShares.shareslock));
			return current_Shared_Obj;
		}
	}
	release_spinlock(&(AllShares.shareslock));
f01093bd:	83 ec 0c             	sub    $0xc,%esp
f01093c0:	68 70 57 74 f0       	push   $0xf0745770
f01093c5:	e8 a7 74 00 00       	call   f0110871 <release_spinlock>
f01093ca:	83 c4 10             	add    $0x10,%esp
	return NULL;
f01093cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01093d2:	c9                   	leave  
f01093d3:	c3                   	ret    

f01093d4 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size,
		uint8 isWritable, void* virtual_address) {
f01093d4:	55                   	push   %ebp
f01093d5:	89 e5                	mov    %esp,%ebp
f01093d7:	83 ec 48             	sub    $0x48,%esp
f01093da:	8b 45 14             	mov    0x14(%ebp),%eax
f01093dd:	88 45 c4             	mov    %al,-0x3c(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("createSharedObject is not implemented yet");
	//Your Code is Here...
	struct Env* myenv = get_cpu_proc(); //The calling environment
f01093e0:	e8 5f 2b 00 00       	call   f010bf44 <get_cpu_proc>
f01093e5:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (shareName == NULL || size == 0 || virtual_address == NULL) {
f01093e8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01093ec:	74 0c                	je     f01093fa <createSharedObject+0x26>
f01093ee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01093f2:	74 06                	je     f01093fa <createSharedObject+0x26>
f01093f4:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01093f8:	75 0a                	jne    f0109404 <createSharedObject+0x30>
		return E_NO_SHARE;
f01093fa:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f01093ff:	e9 f7 01 00 00       	jmp    f01095fb <createSharedObject+0x227>
	}
	struct Share * ss = get_share(ownerID, shareName);
f0109404:	83 ec 08             	sub    $0x8,%esp
f0109407:	ff 75 0c             	pushl  0xc(%ebp)
f010940a:	ff 75 08             	pushl  0x8(%ebp)
f010940d:	e8 13 ff ff ff       	call   f0109325 <get_share>
f0109412:	83 c4 10             	add    $0x10,%esp
f0109415:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ss != NULL) {
f0109418:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010941c:	74 0a                	je     f0109428 <createSharedObject+0x54>
		return E_SHARED_MEM_EXISTS;
f010941e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
f0109423:	e9 d3 01 00 00       	jmp    f01095fb <createSharedObject+0x227>
	}
	acquire_spinlock(&(AllShares.shareslock));
f0109428:	83 ec 0c             	sub    $0xc,%esp
f010942b:	68 70 57 74 f0       	push   $0xf0745770
f0109430:	e8 b5 73 00 00       	call   f01107ea <acquire_spinlock>
f0109435:	83 c4 10             	add    $0x10,%esp
	struct Share * shared_Objk = create_share(ownerID, shareName, size,
f0109438:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f010943c:	50                   	push   %eax
f010943d:	ff 75 10             	pushl  0x10(%ebp)
f0109440:	ff 75 0c             	pushl  0xc(%ebp)
f0109443:	ff 75 08             	pushl  0x8(%ebp)
f0109446:	e8 e9 fd ff ff       	call   f0109234 <create_share>
f010944b:	83 c4 10             	add    $0x10,%esp
f010944e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			isWritable);
	if (shared_Objk == NULL) {
f0109451:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109455:	75 28                	jne    f010947f <createSharedObject+0xab>
		kfree((void*) shared_Objk);
f0109457:	83 ec 0c             	sub    $0xc,%esp
f010945a:	ff 75 e8             	pushl  -0x18(%ebp)
f010945d:	e8 72 0a 00 00       	call   f0109ed4 <kfree>
f0109462:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&(AllShares.shareslock));
f0109465:	83 ec 0c             	sub    $0xc,%esp
f0109468:	68 70 57 74 f0       	push   $0xf0745770
f010946d:	e8 ff 73 00 00       	call   f0110871 <release_spinlock>
f0109472:	83 c4 10             	add    $0x10,%esp
		return E_NO_SHARE;
f0109475:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010947a:	e9 7c 01 00 00       	jmp    f01095fb <createSharedObject+0x227>
	}
	uint32 Frames_Numb = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
f010947f:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109486:	8b 55 10             	mov    0x10(%ebp),%edx
f0109489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010948c:	01 d0                	add    %edx,%eax
f010948e:	48                   	dec    %eax
f010948f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109492:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109495:	ba 00 00 00 00       	mov    $0x0,%edx
f010949a:	f7 75 e4             	divl   -0x1c(%ebp)
f010949d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094a0:	29 d0                	sub    %edx,%eax
f01094a2:	c1 e8 0c             	shr    $0xc,%eax
f01094a5:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (uint32 k = 0; k < Frames_Numb; k++) {
f01094a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01094af:	e9 c1 00 00 00       	jmp    f0109575 <createSharedObject+0x1a1>
		int allocate_return = allocate_frame(&(shared_Objk->framesStorage[k]));
f01094b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01094b7:	8b 40 54             	mov    0x54(%eax),%eax
f01094ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01094bd:	c1 e2 02             	shl    $0x2,%edx
f01094c0:	01 d0                	add    %edx,%eax
f01094c2:	83 ec 0c             	sub    $0xc,%esp
f01094c5:	50                   	push   %eax
f01094c6:	e8 d8 f3 ff ff       	call   f01088a3 <allocate_frame>
f01094cb:	83 c4 10             	add    $0x10,%esp
f01094ce:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (allocate_return != 0) {
f01094d1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01094d5:	74 28                	je     f01094ff <createSharedObject+0x12b>
			kfree((void*) shared_Objk);
f01094d7:	83 ec 0c             	sub    $0xc,%esp
f01094da:	ff 75 e8             	pushl  -0x18(%ebp)
f01094dd:	e8 f2 09 00 00       	call   f0109ed4 <kfree>
f01094e2:	83 c4 10             	add    $0x10,%esp
			release_spinlock(&(AllShares.shareslock));
f01094e5:	83 ec 0c             	sub    $0xc,%esp
f01094e8:	68 70 57 74 f0       	push   $0xf0745770
f01094ed:	e8 7f 73 00 00       	call   f0110871 <release_spinlock>
f01094f2:	83 c4 10             	add    $0x10,%esp
			return E_NO_SHARE;
f01094f5:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f01094fa:	e9 fc 00 00 00       	jmp    f01095fb <createSharedObject+0x227>
		}
		uint32 VA_of_map = ((uint32) virtual_address + k * PAGE_SIZE);
f01094ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109502:	c1 e0 0c             	shl    $0xc,%eax
f0109505:	89 c2                	mov    %eax,%edx
f0109507:	8b 45 18             	mov    0x18(%ebp),%eax
f010950a:	01 d0                	add    %edx,%eax
f010950c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		int map_perms = PERM_USER | PERM_WRITEABLE;
f010950f:	c7 45 d0 06 00 00 00 	movl   $0x6,-0x30(%ebp)
		struct FrameInfo * shared_frame_ptr = shared_Objk->framesStorage[k];
f0109516:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109519:	8b 40 54             	mov    0x54(%eax),%eax
f010951c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010951f:	c1 e2 02             	shl    $0x2,%edx
f0109522:	01 d0                	add    %edx,%eax
f0109524:	8b 00                	mov    (%eax),%eax
f0109526:	89 45 cc             	mov    %eax,-0x34(%ebp)
		int map_return = map_frame(myenv->env_page_directory, shared_frame_ptr,
f0109529:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010952c:	8b 40 64             	mov    0x64(%eax),%eax
f010952f:	ff 75 d0             	pushl  -0x30(%ebp)
f0109532:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109535:	ff 75 cc             	pushl  -0x34(%ebp)
f0109538:	50                   	push   %eax
f0109539:	e8 32 f8 ff ff       	call   f0108d70 <map_frame>
f010953e:	83 c4 10             	add    $0x10,%esp
f0109541:	89 45 c8             	mov    %eax,-0x38(%ebp)
				VA_of_map, map_perms);
		if (map_return != 0) {
f0109544:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0109548:	74 28                	je     f0109572 <createSharedObject+0x19e>
			kfree((void*) shared_Objk);
f010954a:	83 ec 0c             	sub    $0xc,%esp
f010954d:	ff 75 e8             	pushl  -0x18(%ebp)
f0109550:	e8 7f 09 00 00       	call   f0109ed4 <kfree>
f0109555:	83 c4 10             	add    $0x10,%esp
			release_spinlock(&(AllShares.shareslock));
f0109558:	83 ec 0c             	sub    $0xc,%esp
f010955b:	68 70 57 74 f0       	push   $0xf0745770
f0109560:	e8 0c 73 00 00       	call   f0110871 <release_spinlock>
f0109565:	83 c4 10             	add    $0x10,%esp
			return E_NO_SHARE;
f0109568:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f010956d:	e9 89 00 00 00       	jmp    f01095fb <createSharedObject+0x227>
		kfree((void*) shared_Objk);
		release_spinlock(&(AllShares.shareslock));
		return E_NO_SHARE;
	}
	uint32 Frames_Numb = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE;
	for (uint32 k = 0; k < Frames_Numb; k++) {
f0109572:	ff 45 f4             	incl   -0xc(%ebp)
f0109575:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109578:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010957b:	0f 82 33 ff ff ff    	jb     f01094b4 <createSharedObject+0xe0>
			release_spinlock(&(AllShares.shareslock));
			return E_NO_SHARE;
		}
	}

	LIST_INSERT_TAIL(&(AllShares.shares_list), shared_Objk);
f0109581:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109585:	75 17                	jne    f010959e <createSharedObject+0x1ca>
f0109587:	83 ec 04             	sub    $0x4,%esp
f010958a:	68 6c 7a 12 f0       	push   $0xf0127a6c
f010958f:	68 c2 00 00 00       	push   $0xc2
f0109594:	68 90 7a 12 f0       	push   $0xf0127a90
f0109599:	e8 9b 6d ff ff       	call   f0100339 <_panic>
f010959e:	8b 15 64 57 74 f0    	mov    0xf0745764,%edx
f01095a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095a7:	89 50 5c             	mov    %edx,0x5c(%eax)
f01095aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095ad:	8b 40 5c             	mov    0x5c(%eax),%eax
f01095b0:	85 c0                	test   %eax,%eax
f01095b2:	74 0d                	je     f01095c1 <createSharedObject+0x1ed>
f01095b4:	a1 64 57 74 f0       	mov    0xf0745764,%eax
f01095b9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01095bc:	89 50 58             	mov    %edx,0x58(%eax)
f01095bf:	eb 08                	jmp    f01095c9 <createSharedObject+0x1f5>
f01095c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095c4:	a3 60 57 74 f0       	mov    %eax,0xf0745760
f01095c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095cc:	a3 64 57 74 f0       	mov    %eax,0xf0745764
f01095d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095d4:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f01095db:	a1 6c 57 74 f0       	mov    0xf074576c,%eax
f01095e0:	40                   	inc    %eax
f01095e1:	a3 6c 57 74 f0       	mov    %eax,0xf074576c
	release_spinlock(&(AllShares.shareslock));
f01095e6:	83 ec 0c             	sub    $0xc,%esp
f01095e9:	68 70 57 74 f0       	push   $0xf0745770
f01095ee:	e8 7e 72 00 00       	call   f0110871 <release_spinlock>
f01095f3:	83 c4 10             	add    $0x10,%esp
	return shared_Objk->ID;
f01095f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01095f9:	8b 00                	mov    (%eax),%eax
}
f01095fb:	c9                   	leave  
f01095fc:	c3                   	ret    

f01095fd <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address) {
f01095fd:	55                   	push   %ebp
f01095fe:	89 e5                	mov    %esp,%ebp
f0109600:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("getSharedObject is not implemented yet");
	//Your Code is Here...
	struct Env* myenv = get_cpu_proc(); //The calling environment
f0109603:	e8 3c 29 00 00       	call   f010bf44 <get_cpu_proc>
f0109608:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Share * shared_Objk = get_share(ownerID, shareName);
f010960b:	83 ec 08             	sub    $0x8,%esp
f010960e:	ff 75 0c             	pushl  0xc(%ebp)
f0109611:	ff 75 08             	pushl  0x8(%ebp)
f0109614:	e8 0c fd ff ff       	call   f0109325 <get_share>
f0109619:	83 c4 10             	add    $0x10,%esp
f010961c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (shared_Objk == NULL) {
f010961f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109623:	75 0a                	jne    f010962f <getSharedObject+0x32>
		return E_SHARED_MEM_NOT_EXISTS;
f0109625:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010962a:	e9 d3 00 00 00       	jmp    f0109702 <getSharedObject+0x105>
	}
	uint32 map_perms;
	if (shared_Objk->isWritable) {
f010962f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109632:	8a 40 50             	mov    0x50(%eax),%al
f0109635:	84 c0                	test   %al,%al
f0109637:	74 09                	je     f0109642 <getSharedObject+0x45>
		map_perms = PERM_WRITEABLE | PERM_USER;
f0109639:	c7 45 f4 06 00 00 00 	movl   $0x6,-0xc(%ebp)
f0109640:	eb 07                	jmp    f0109649 <getSharedObject+0x4c>
	} else {
		map_perms = PERM_USER;
f0109642:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
	}
	uint32 Frames_Numb = ROUNDUP(shared_Objk->size, PAGE_SIZE) / PAGE_SIZE;
f0109649:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0109650:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109653:	8b 40 48             	mov    0x48(%eax),%eax
f0109656:	89 c2                	mov    %eax,%edx
f0109658:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010965b:	01 d0                	add    %edx,%eax
f010965d:	48                   	dec    %eax
f010965e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0109661:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109664:	ba 00 00 00 00       	mov    $0x0,%edx
f0109669:	f7 75 e4             	divl   -0x1c(%ebp)
f010966c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010966f:	29 d0                	sub    %edx,%eax
f0109671:	85 c0                	test   %eax,%eax
f0109673:	79 05                	jns    f010967a <getSharedObject+0x7d>
f0109675:	05 ff 0f 00 00       	add    $0xfff,%eax
f010967a:	c1 f8 0c             	sar    $0xc,%eax
f010967d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	for (uint32 s = 0; s < Frames_Numb; s++) {
f0109680:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109687:	eb 5d                	jmp    f01096e6 <getSharedObject+0xe9>
		struct FrameInfo * shared_frame_ptr = shared_Objk->framesStorage[s];
f0109689:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010968c:	8b 40 54             	mov    0x54(%eax),%eax
f010968f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109692:	c1 e2 02             	shl    $0x2,%edx
f0109695:	01 d0                	add    %edx,%eax
f0109697:	8b 00                	mov    (%eax),%eax
f0109699:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32 VA_of_map = ((uint32) virtual_address + (s * PAGE_SIZE));
f010969c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010969f:	c1 e0 0c             	shl    $0xc,%eax
f01096a2:	89 c2                	mov    %eax,%edx
f01096a4:	8b 45 10             	mov    0x10(%ebp),%eax
f01096a7:	01 d0                	add    %edx,%eax
f01096a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		int map_return = map_frame(myenv->env_page_directory, shared_frame_ptr,
f01096ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01096af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096b2:	8b 40 64             	mov    0x64(%eax),%eax
f01096b5:	52                   	push   %edx
f01096b6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01096b9:	ff 75 d8             	pushl  -0x28(%ebp)
f01096bc:	50                   	push   %eax
f01096bd:	e8 ae f6 ff ff       	call   f0108d70 <map_frame>
f01096c2:	83 c4 10             	add    $0x10,%esp
f01096c5:	89 45 d0             	mov    %eax,-0x30(%ebp)
				VA_of_map, map_perms);
		if (map_return != 0) {
f01096c8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01096cc:	74 15                	je     f01096e3 <getSharedObject+0xe6>
			kfree((void*) shared_Objk);
f01096ce:	83 ec 0c             	sub    $0xc,%esp
f01096d1:	ff 75 e8             	pushl  -0x18(%ebp)
f01096d4:	e8 fb 07 00 00       	call   f0109ed4 <kfree>
f01096d9:	83 c4 10             	add    $0x10,%esp

			return E_NO_SHARE;
f01096dc:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
f01096e1:	eb 1f                	jmp    f0109702 <getSharedObject+0x105>
		map_perms = PERM_WRITEABLE | PERM_USER;
	} else {
		map_perms = PERM_USER;
	}
	uint32 Frames_Numb = ROUNDUP(shared_Objk->size, PAGE_SIZE) / PAGE_SIZE;
	for (uint32 s = 0; s < Frames_Numb; s++) {
f01096e3:	ff 45 f0             	incl   -0x10(%ebp)
f01096e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096e9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01096ec:	72 9b                	jb     f0109689 <getSharedObject+0x8c>
			kfree((void*) shared_Objk);

			return E_NO_SHARE;
		}
	}
	shared_Objk->references += 1;
f01096ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01096f1:	8b 40 4c             	mov    0x4c(%eax),%eax
f01096f4:	8d 50 01             	lea    0x1(%eax),%edx
f01096f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01096fa:	89 50 4c             	mov    %edx,0x4c(%eax)
	return shared_Objk->ID;
f01096fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109700:	8b 00                	mov    (%eax),%eax
}
f0109702:	c9                   	leave  
f0109703:	c3                   	ret    

f0109704 <free_share>:
//==========================
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare) {
f0109704:	55                   	push   %ebp
f0109705:	89 e5                	mov    %esp,%ebp
f0109707:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_share is not implemented yet");
	//Your Code is Here...
	if (ptrShare == NULL) {
f010970a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010970e:	0f 84 ca 00 00 00    	je     f01097de <free_share+0xda>
		return;
	}
	acquire_spinlock((&(AllShares.shareslock)));
f0109714:	83 ec 0c             	sub    $0xc,%esp
f0109717:	68 70 57 74 f0       	push   $0xf0745770
f010971c:	e8 c9 70 00 00       	call   f01107ea <acquire_spinlock>
f0109721:	83 c4 10             	add    $0x10,%esp
	LIST_REMOVE((&(AllShares.shares_list)), ptrShare);
f0109724:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109728:	75 17                	jne    f0109741 <free_share+0x3d>
f010972a:	83 ec 04             	sub    $0x4,%esp
f010972d:	68 b1 7a 12 f0       	push   $0xf0127ab1
f0109732:	68 fc 00 00 00       	push   $0xfc
f0109737:	68 90 7a 12 f0       	push   $0xf0127a90
f010973c:	e8 f8 6b ff ff       	call   f0100339 <_panic>
f0109741:	8b 45 08             	mov    0x8(%ebp),%eax
f0109744:	8b 40 58             	mov    0x58(%eax),%eax
f0109747:	85 c0                	test   %eax,%eax
f0109749:	74 11                	je     f010975c <free_share+0x58>
f010974b:	8b 45 08             	mov    0x8(%ebp),%eax
f010974e:	8b 40 58             	mov    0x58(%eax),%eax
f0109751:	8b 55 08             	mov    0x8(%ebp),%edx
f0109754:	8b 52 5c             	mov    0x5c(%edx),%edx
f0109757:	89 50 5c             	mov    %edx,0x5c(%eax)
f010975a:	eb 0b                	jmp    f0109767 <free_share+0x63>
f010975c:	8b 45 08             	mov    0x8(%ebp),%eax
f010975f:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109762:	a3 64 57 74 f0       	mov    %eax,0xf0745764
f0109767:	8b 45 08             	mov    0x8(%ebp),%eax
f010976a:	8b 40 5c             	mov    0x5c(%eax),%eax
f010976d:	85 c0                	test   %eax,%eax
f010976f:	74 11                	je     f0109782 <free_share+0x7e>
f0109771:	8b 45 08             	mov    0x8(%ebp),%eax
f0109774:	8b 40 5c             	mov    0x5c(%eax),%eax
f0109777:	8b 55 08             	mov    0x8(%ebp),%edx
f010977a:	8b 52 58             	mov    0x58(%edx),%edx
f010977d:	89 50 58             	mov    %edx,0x58(%eax)
f0109780:	eb 0b                	jmp    f010978d <free_share+0x89>
f0109782:	8b 45 08             	mov    0x8(%ebp),%eax
f0109785:	8b 40 58             	mov    0x58(%eax),%eax
f0109788:	a3 60 57 74 f0       	mov    %eax,0xf0745760
f010978d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109790:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
f0109797:	8b 45 08             	mov    0x8(%ebp),%eax
f010979a:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
f01097a1:	a1 6c 57 74 f0       	mov    0xf074576c,%eax
f01097a6:	48                   	dec    %eax
f01097a7:	a3 6c 57 74 f0       	mov    %eax,0xf074576c
	release_spinlock((&(AllShares.shareslock)));
f01097ac:	83 ec 0c             	sub    $0xc,%esp
f01097af:	68 70 57 74 f0       	push   $0xf0745770
f01097b4:	e8 b8 70 00 00       	call   f0110871 <release_spinlock>
f01097b9:	83 c4 10             	add    $0x10,%esp
	kfree((void*) (ptrShare->framesStorage));
f01097bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01097bf:	8b 40 54             	mov    0x54(%eax),%eax
f01097c2:	83 ec 0c             	sub    $0xc,%esp
f01097c5:	50                   	push   %eax
f01097c6:	e8 09 07 00 00       	call   f0109ed4 <kfree>
f01097cb:	83 c4 10             	add    $0x10,%esp
	kfree((void*) ptrShare);
f01097ce:	83 ec 0c             	sub    $0xc,%esp
f01097d1:	ff 75 08             	pushl  0x8(%ebp)
f01097d4:	e8 fb 06 00 00       	call   f0109ed4 <kfree>
f01097d9:	83 c4 10             	add    $0x10,%esp
f01097dc:	eb 01                	jmp    f01097df <free_share+0xdb>
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_share is not implemented yet");
	//Your Code is Here...
	if (ptrShare == NULL) {
		return;
f01097de:	90                   	nop
	release_spinlock((&(AllShares.shareslock)));
	kfree((void*) (ptrShare->framesStorage));
	kfree((void*) ptrShare);


}
f01097df:	c9                   	leave  
f01097e0:	c3                   	ret    

f01097e1 <freeSharedObject>:
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA) {
f01097e1:	55                   	push   %ebp
f01097e2:	89 e5                	mov    %esp,%ebp
f01097e4:	83 ec 48             	sub    $0x48,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("freeSharedObject is not implemented yet");
	//Your Code is Here...
	struct Env* myenv = get_cpu_proc();
f01097e7:	e8 58 27 00 00       	call   f010bf44 <get_cpu_proc>
f01097ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct Share *sharedObj = NULL;
f01097ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&(AllShares.shareslock));
f01097f6:	83 ec 0c             	sub    $0xc,%esp
f01097f9:	68 70 57 74 f0       	push   $0xf0745770
f01097fe:	e8 e7 6f 00 00       	call   f01107ea <acquire_spinlock>
f0109803:	83 c4 10             	add    $0x10,%esp
	struct Share* current_Shared_Obj;
	LIST_FOREACH(current_Shared_Obj, &(AllShares.shares_list))
f0109806:	a1 60 57 74 f0       	mov    0xf0745760,%eax
f010980b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010980e:	eb 2a                	jmp    f010983a <freeSharedObject+0x59>
	{
		if (current_Shared_Obj->ID == sharedObjectID) {
f0109810:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109813:	8b 00                	mov    (%eax),%eax
f0109815:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109818:	75 18                	jne    f0109832 <freeSharedObject+0x51>
			release_spinlock(&(AllShares.shareslock));
f010981a:	83 ec 0c             	sub    $0xc,%esp
f010981d:	68 70 57 74 f0       	push   $0xf0745770
f0109822:	e8 4a 70 00 00       	call   f0110871 <release_spinlock>
f0109827:	83 c4 10             	add    $0x10,%esp
			sharedObj = current_Shared_Obj;
f010982a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010982d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0109830:	eb 2f                	jmp    f0109861 <freeSharedObject+0x80>
	//Your Code is Here...
	struct Env* myenv = get_cpu_proc();
	struct Share *sharedObj = NULL;
	acquire_spinlock(&(AllShares.shareslock));
	struct Share* current_Shared_Obj;
	LIST_FOREACH(current_Shared_Obj, &(AllShares.shares_list))
f0109832:	a1 68 57 74 f0       	mov    0xf0745768,%eax
f0109837:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010983a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010983e:	74 08                	je     f0109848 <freeSharedObject+0x67>
f0109840:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109843:	8b 40 58             	mov    0x58(%eax),%eax
f0109846:	eb 05                	jmp    f010984d <freeSharedObject+0x6c>
f0109848:	b8 00 00 00 00       	mov    $0x0,%eax
f010984d:	a3 68 57 74 f0       	mov    %eax,0xf0745768
f0109852:	a1 68 57 74 f0       	mov    0xf0745768,%eax
f0109857:	85 c0                	test   %eax,%eax
f0109859:	75 b5                	jne    f0109810 <freeSharedObject+0x2f>
f010985b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010985f:	75 af                	jne    f0109810 <freeSharedObject+0x2f>
			sharedObj = current_Shared_Obj;
			break;
		}
	}

	if (sharedObj == NULL) {
f0109861:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109865:	75 1a                	jne    f0109881 <freeSharedObject+0xa0>
		release_spinlock(&(AllShares.shareslock));
f0109867:	83 ec 0c             	sub    $0xc,%esp
f010986a:	68 70 57 74 f0       	push   $0xf0745770
f010986f:	e8 fd 6f 00 00       	call   f0110871 <release_spinlock>
f0109874:	83 c4 10             	add    $0x10,%esp
		return E_SHARED_MEM_NOT_EXISTS;
f0109877:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010987c:	e9 3b 01 00 00       	jmp    f01099bc <freeSharedObject+0x1db>
	}
	uint32 Frames_Numb = ROUNDUP(sharedObj->size, PAGE_SIZE) / PAGE_SIZE;
f0109881:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f0109888:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010988b:	8b 40 48             	mov    0x48(%eax),%eax
f010988e:	89 c2                	mov    %eax,%edx
f0109890:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109893:	01 d0                	add    %edx,%eax
f0109895:	48                   	dec    %eax
f0109896:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109899:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010989c:	ba 00 00 00 00       	mov    $0x0,%edx
f01098a1:	f7 75 dc             	divl   -0x24(%ebp)
f01098a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01098a7:	29 d0                	sub    %edx,%eax
f01098a9:	85 c0                	test   %eax,%eax
f01098ab:	79 05                	jns    f01098b2 <freeSharedObject+0xd1>
f01098ad:	05 ff 0f 00 00       	add    $0xfff,%eax
f01098b2:	c1 f8 0c             	sar    $0xc,%eax
f01098b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 start=(uint32) startVA;
f01098b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01098bb:	89 45 d0             	mov    %eax,-0x30(%ebp)

	for (uint32 s = 0; s < Frames_Numb; s++) {
f01098be:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01098c5:	e9 ae 00 00 00       	jmp    f0109978 <freeSharedObject+0x197>
		uint32 VA_of_map = ( start + (s * PAGE_SIZE));
f01098ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01098cd:	c1 e0 0c             	shl    $0xc,%eax
f01098d0:	89 c2                	mov    %eax,%edx
f01098d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01098d5:	01 d0                	add    %edx,%eax
f01098d7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint32 *ptrtable = NULL;
f01098da:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
		struct FrameInfo *frame = get_frame_info(myenv->env_page_directory,VA_of_map,&ptrtable);
f01098e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01098e4:	8b 40 64             	mov    0x64(%eax),%eax
f01098e7:	83 ec 04             	sub    $0x4,%esp
f01098ea:	8d 55 c0             	lea    -0x40(%ebp),%edx
f01098ed:	52                   	push   %edx
f01098ee:	ff 75 cc             	pushl  -0x34(%ebp)
f01098f1:	50                   	push   %eax
f01098f2:	e8 6c f5 ff ff       	call   f0108e63 <get_frame_info>
f01098f7:	83 c4 10             	add    $0x10,%esp
f01098fa:	89 45 c8             	mov    %eax,-0x38(%ebp)
		unmap_frame(myenv->env_page_directory, VA_of_map);
f01098fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109900:	8b 40 64             	mov    0x64(%eax),%eax
f0109903:	83 ec 08             	sub    $0x8,%esp
f0109906:	ff 75 cc             	pushl  -0x34(%ebp)
f0109909:	50                   	push   %eax
f010990a:	e8 ca f5 ff ff       	call   f0108ed9 <unmap_frame>
f010990f:	83 c4 10             	add    $0x10,%esp
		int isempty = 1;
f0109912:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
		for (uint32 i = 0; i < 1024; i++) {
f0109919:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0109920:	eb 20                	jmp    f0109942 <freeSharedObject+0x161>
			if (ptrtable[i] & PERM_PRESENT) {
f0109922:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109925:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0109928:	c1 e2 02             	shl    $0x2,%edx
f010992b:	01 d0                	add    %edx,%eax
f010992d:	8b 00                	mov    (%eax),%eax
f010992f:	83 e0 01             	and    $0x1,%eax
f0109932:	85 c0                	test   %eax,%eax
f0109934:	74 09                	je     f010993f <freeSharedObject+0x15e>
				isempty = 0;
f0109936:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				break;
f010993d:	eb 0c                	jmp    f010994b <freeSharedObject+0x16a>
		uint32 VA_of_map = ( start + (s * PAGE_SIZE));
		uint32 *ptrtable = NULL;
		struct FrameInfo *frame = get_frame_info(myenv->env_page_directory,VA_of_map,&ptrtable);
		unmap_frame(myenv->env_page_directory, VA_of_map);
		int isempty = 1;
		for (uint32 i = 0; i < 1024; i++) {
f010993f:	ff 45 e4             	incl   -0x1c(%ebp)
f0109942:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f0109949:	76 d7                	jbe    f0109922 <freeSharedObject+0x141>
			if (ptrtable[i] & PERM_PRESENT) {
				isempty = 0;
				break;
			}
		}
		if (isempty) {
f010994b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010994f:	74 24                	je     f0109975 <freeSharedObject+0x194>
			kfree((void*)ptrtable);
f0109951:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109954:	83 ec 0c             	sub    $0xc,%esp
f0109957:	50                   	push   %eax
f0109958:	e8 77 05 00 00       	call   f0109ed4 <kfree>
f010995d:	83 c4 10             	add    $0x10,%esp
			pd_clear_page_dir_entry(myenv->env_page_directory,
f0109960:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109963:	8b 40 64             	mov    0x64(%eax),%eax
f0109966:	83 ec 08             	sub    $0x8,%esp
f0109969:	ff 75 cc             	pushl  -0x34(%ebp)
f010996c:	50                   	push   %eax
f010996d:	e8 c9 09 00 00       	call   f010a33b <pd_clear_page_dir_entry>
f0109972:	83 c4 10             	add    $0x10,%esp
		return E_SHARED_MEM_NOT_EXISTS;
	}
	uint32 Frames_Numb = ROUNDUP(sharedObj->size, PAGE_SIZE) / PAGE_SIZE;
	uint32 start=(uint32) startVA;

	for (uint32 s = 0; s < Frames_Numb; s++) {
f0109975:	ff 45 ec             	incl   -0x14(%ebp)
f0109978:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010997b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010997e:	0f 82 46 ff ff ff    	jb     f01098ca <freeSharedObject+0xe9>
			kfree((void*)ptrtable);
			pd_clear_page_dir_entry(myenv->env_page_directory,
					(uint32) VA_of_map);
		}
	}
	sharedObj->references--;
f0109984:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109987:	8b 40 4c             	mov    0x4c(%eax),%eax
f010998a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010998d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109990:	89 50 4c             	mov    %edx,0x4c(%eax)
	if (sharedObj->references == 0) {
f0109993:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109996:	8b 40 4c             	mov    0x4c(%eax),%eax
f0109999:	85 c0                	test   %eax,%eax
f010999b:	75 0e                	jne    f01099ab <freeSharedObject+0x1ca>
		free_share(sharedObj);
f010999d:	83 ec 0c             	sub    $0xc,%esp
f01099a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01099a3:	e8 5c fd ff ff       	call   f0109704 <free_share>
f01099a8:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01099ab:	0f 20 d8             	mov    %cr3,%eax
f01099ae:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01099b1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01099b4:	0f 22 d8             	mov    %eax,%cr3
	}

	tlbflush();
	return 0;
f01099b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01099bc:	c9                   	leave  
f01099bd:	c3                   	ret    

f01099be <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f01099be:	55                   	push   %ebp
f01099bf:	89 e5                	mov    %esp,%ebp
f01099c1:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f01099c6:	83 f8 01             	cmp    $0x1,%eax
f01099c9:	75 04                	jne    f01099cf <isKHeapPlacementStrategyFIRSTFIT+0x11>
f01099cb:	b0 01                	mov    $0x1,%al
f01099cd:	eb 02                	jmp    f01099d1 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f01099cf:	b0 00                	mov    $0x0,%al
f01099d1:	5d                   	pop    %ebp
f01099d2:	c3                   	ret    

f01099d3 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01099d3:	55                   	push   %ebp
f01099d4:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01099d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01099d9:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f01099df:	29 d0                	sub    %edx,%eax
f01099e1:	c1 f8 03             	sar    $0x3,%eax
f01099e4:	89 c2                	mov    %eax,%edx
f01099e6:	89 d0                	mov    %edx,%eax
f01099e8:	c1 e0 02             	shl    $0x2,%eax
f01099eb:	01 d0                	add    %edx,%eax
f01099ed:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01099f4:	01 c8                	add    %ecx,%eax
f01099f6:	01 c0                	add    %eax,%eax
f01099f8:	01 d0                	add    %edx,%eax
f01099fa:	89 c1                	mov    %eax,%ecx
f01099fc:	c1 e1 08             	shl    $0x8,%ecx
f01099ff:	01 c8                	add    %ecx,%eax
f0109a01:	89 c1                	mov    %eax,%ecx
f0109a03:	c1 e1 10             	shl    $0x10,%ecx
f0109a06:	01 c8                	add    %ecx,%eax
f0109a08:	c1 e0 02             	shl    $0x2,%eax
f0109a0b:	01 d0                	add    %edx,%eax
}
f0109a0d:	5d                   	pop    %ebp
f0109a0e:	c3                   	ret    

f0109a0f <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0109a0f:	55                   	push   %ebp
f0109a10:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109a12:	ff 75 08             	pushl  0x8(%ebp)
f0109a15:	e8 b9 ff ff ff       	call   f01099d3 <to_frame_number>
f0109a1a:	83 c4 04             	add    $0x4,%esp
f0109a1d:	c1 e0 0c             	shl    $0xc,%eax
}
f0109a20:	c9                   	leave  
f0109a21:	c3                   	ret    

f0109a22 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0109a22:	55                   	push   %ebp
f0109a23:	89 e5                	mov    %esp,%ebp
f0109a25:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0109a28:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a2b:	c1 e8 0c             	shr    $0xc,%eax
f0109a2e:	89 c2                	mov    %eax,%edx
f0109a30:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0109a35:	39 c2                	cmp    %eax,%edx
f0109a37:	72 14                	jb     f0109a4d <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0109a39:	83 ec 04             	sub    $0x4,%esp
f0109a3c:	68 d0 7a 12 f0       	push   $0xf0127ad0
f0109a41:	6a 55                	push   $0x55
f0109a43:	68 f5 7a 12 f0       	push   $0xf0127af5
f0109a48:	e8 ec 68 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0109a4d:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f0109a53:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a56:	c1 e8 0c             	shr    $0xc,%eax
f0109a59:	89 c1                	mov    %eax,%ecx
f0109a5b:	89 c8                	mov    %ecx,%eax
f0109a5d:	c1 e0 02             	shl    $0x2,%eax
f0109a60:	01 c8                	add    %ecx,%eax
f0109a62:	c1 e0 03             	shl    $0x3,%eax
f0109a65:	01 d0                	add    %edx,%eax
}
f0109a67:	c9                   	leave  
f0109a68:	c3                   	ret    

f0109a69 <initialize_kheap_dynamic_allocator>:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

struct sleeplock k_lock;

int initialize_kheap_dynamic_allocator(uint32 daStart,uint32 initSizeToAllocate, uint32 daLimit) {
f0109a69:	55                   	push   %ebp
f0109a6a:	89 e5                	mov    %esp,%ebp
f0109a6c:	83 ec 28             	sub    $0x28,%esp
	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	//panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");

	// check if the daStart + initSizeToAllocate will fit in the defined limit
	if (daStart + initSizeToAllocate > daLimit) {
f0109a6f:	8b 55 08             	mov    0x8(%ebp),%edx
f0109a72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109a75:	01 d0                	add    %edx,%eax
f0109a77:	3b 45 10             	cmp    0x10(%ebp),%eax
f0109a7a:	76 14                	jbe    f0109a90 <initialize_kheap_dynamic_allocator+0x27>
		panic("Initial size exceeds the limit");
f0109a7c:	83 ec 04             	sub    $0x4,%esp
f0109a7f:	68 10 7b 12 f0       	push   $0xf0127b10
f0109a84:	6a 18                	push   $0x18
f0109a86:	68 2f 7b 12 f0       	push   $0xf0127b2f
f0109a8b:	e8 a9 68 ff ff       	call   f0100339 <_panic>
	}

	// calc no of physical pages required
	uint32 pagesToAllocate = ROUNDUP(initSizeToAllocate, PAGE_SIZE) / PAGE_SIZE; // no. of pages
f0109a90:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0109a97:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109a9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109a9d:	01 d0                	add    %edx,%eax
f0109a9f:	48                   	dec    %eax
f0109aa0:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109aa3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109aa6:	ba 00 00 00 00       	mov    $0x0,%edx
f0109aab:	f7 75 ec             	divl   -0x14(%ebp)
f0109aae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109ab1:	29 d0                	sub    %edx,%eax
f0109ab3:	c1 e8 0c             	shr    $0xc,%eax
f0109ab6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	void *currentAddress = (void *) daStart;
f0109ab9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109abc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//loop over required no. of pages
	for (uint32 i = 0; i < pagesToAllocate; i++) {
f0109abf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0109ac6:	eb 61                	jmp    f0109b29 <initialize_kheap_dynamic_allocator+0xc0>
		//allocate frame
		struct FrameInfo *frame_info;
		if (allocate_frame(&frame_info) != 0) {
f0109ac8:	83 ec 0c             	sub    $0xc,%esp
f0109acb:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0109ace:	50                   	push   %eax
f0109acf:	e8 cf ed ff ff       	call   f01088a3 <allocate_frame>
f0109ad4:	83 c4 10             	add    $0x10,%esp
f0109ad7:	85 c0                	test   %eax,%eax
f0109ad9:	74 14                	je     f0109aef <initialize_kheap_dynamic_allocator+0x86>
			panic("Failed to allocate a frame for kernel heap");
f0109adb:	83 ec 04             	sub    $0x4,%esp
f0109ade:	68 40 7b 12 f0       	push   $0xf0127b40
f0109ae3:	6a 25                	push   $0x25
f0109ae5:	68 2f 7b 12 f0       	push   $0xf0127b2f
f0109aea:	e8 4a 68 ff ff       	call   f0100339 <_panic>
		}
		//map frame to va
		if (map_frame(ptr_page_directory, frame_info, (uint32) currentAddress,
f0109aef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0109af2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109af5:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109afa:	6a 03                	push   $0x3
f0109afc:	51                   	push   %ecx
f0109afd:	52                   	push   %edx
f0109afe:	50                   	push   %eax
f0109aff:	e8 6c f2 ff ff       	call   f0108d70 <map_frame>
f0109b04:	83 c4 10             	add    $0x10,%esp
f0109b07:	85 c0                	test   %eax,%eax
f0109b09:	74 14                	je     f0109b1f <initialize_kheap_dynamic_allocator+0xb6>
				PERM_PRESENT | PERM_WRITEABLE) != 0) {
			panic("Failed to map frame into kernel heap");
f0109b0b:	83 ec 04             	sub    $0x4,%esp
f0109b0e:	68 6c 7b 12 f0       	push   $0xf0127b6c
f0109b13:	6a 2a                	push   $0x2a
f0109b15:	68 2f 7b 12 f0       	push   $0xf0127b2f
f0109b1a:	e8 1a 68 ff ff       	call   f0100339 <_panic>
		}
		currentAddress += PAGE_SIZE;
f0109b1f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
	uint32 pagesToAllocate = ROUNDUP(initSizeToAllocate, PAGE_SIZE) / PAGE_SIZE; // no. of pages

	void *currentAddress = (void *) daStart;

	//loop over required no. of pages
	for (uint32 i = 0; i < pagesToAllocate; i++) {
f0109b26:	ff 45 f0             	incl   -0x10(%ebp)
f0109b29:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109b2c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109b2f:	72 97                	jb     f0109ac8 <initialize_kheap_dynamic_allocator+0x5f>
			panic("Failed to map frame into kernel heap");
		}
		currentAddress += PAGE_SIZE;
	}

	init_sleeplock(&k_lock,"Kernel Side Sleep Lock");
f0109b31:	83 ec 08             	sub    $0x8,%esp
f0109b34:	68 91 7b 12 f0       	push   $0xf0127b91
f0109b39:	68 c0 44 76 f0       	push   $0xf07644c0
f0109b3e:	e8 01 6f 00 00       	call   f0110a44 <init_sleeplock>
f0109b43:	83 c4 10             	add    $0x10,%esp
	kheapStart = daStart;  //starting address of heap
f0109b46:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b49:	a3 04 5d 74 f0       	mov    %eax,0xf0745d04
	kheapBreak = daStart + initSizeToAllocate; //initial end of the heap
f0109b4e:	8b 55 08             	mov    0x8(%ebp),%edx
f0109b51:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109b54:	01 d0                	add    %edx,%eax
f0109b56:	a3 a0 5a 74 f0       	mov    %eax,0xf0745aa0
	kheapHardLimit = daLimit; //max allowed addr for heap
f0109b5b:	8b 45 10             	mov    0x10(%ebp),%eax
f0109b5e:	a3 dc 59 74 f0       	mov    %eax,0xf07459dc

	initialize_dynamic_allocator(daStart, initSizeToAllocate);
f0109b63:	83 ec 08             	sub    $0x8,%esp
f0109b66:	ff 75 0c             	pushl  0xc(%ebp)
f0109b69:	ff 75 08             	pushl  0x8(%ebp)
f0109b6c:	e8 99 8f 01 00       	call   f0122b0a <initialize_dynamic_allocator>
f0109b71:	83 c4 10             	add    $0x10,%esp
	return 0;
f0109b74:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109b79:	c9                   	leave  
f0109b7a:	c3                   	ret    

f0109b7b <sbrk>:

void* sbrk(int numOfPages) {
f0109b7b:	55                   	push   %ebp
f0109b7c:	89 e5                	mov    %esp,%ebp
f0109b7e:	83 ec 18             	sub    $0x18,%esp
	//return (void*)-1 ;
	//====================================================
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	//panic("sbrk() is not implemented yet...!!");
	acquire_sleeplock(&k_lock);
f0109b81:	83 ec 0c             	sub    $0xc,%esp
f0109b84:	68 c0 44 76 f0       	push   $0xf07644c0
f0109b89:	e8 7a 6f 00 00       	call   f0110b08 <acquire_sleeplock>
f0109b8e:	83 c4 10             	add    $0x10,%esp
	if (numOfPages == 0) {
f0109b91:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109b95:	75 1a                	jne    f0109bb1 <sbrk+0x36>
		release_sleeplock(&k_lock);
f0109b97:	83 ec 0c             	sub    $0xc,%esp
f0109b9a:	68 c0 44 76 f0       	push   $0xf07644c0
f0109b9f:	e8 bf 6f 00 00       	call   f0110b63 <release_sleeplock>
f0109ba4:	83 c4 10             	add    $0x10,%esp
		return (void *) kheapBreak; // Return current break
f0109ba7:	a1 a0 5a 74 f0       	mov    0xf0745aa0,%eax
f0109bac:	e9 b7 00 00 00       	jmp    f0109c68 <sbrk+0xed>
	}

	uint32 newBreak = kheapBreak + (numOfPages * PAGE_SIZE);
f0109bb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bb4:	c1 e0 0c             	shl    $0xc,%eax
f0109bb7:	89 c2                	mov    %eax,%edx
f0109bb9:	a1 a0 5a 74 f0       	mov    0xf0745aa0,%eax
f0109bbe:	01 d0                	add    %edx,%eax
f0109bc0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	// Check if it exceeds the heap limit
	if (newBreak > kheapHardLimit) {
f0109bc3:	a1 dc 59 74 f0       	mov    0xf07459dc,%eax
f0109bc8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0109bcb:	76 1a                	jbe    f0109be7 <sbrk+0x6c>
		release_sleeplock(&k_lock);
f0109bcd:	83 ec 0c             	sub    $0xc,%esp
f0109bd0:	68 c0 44 76 f0       	push   $0xf07644c0
f0109bd5:	e8 89 6f 00 00       	call   f0110b63 <release_sleeplock>
f0109bda:	83 c4 10             	add    $0x10,%esp
		return (void *) -1; // Failed to allocate memory
f0109bdd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109be2:	e9 81 00 00 00       	jmp    f0109c68 <sbrk+0xed>
	}

	void *oldBreak = (void *) kheapBreak;
f0109be7:	a1 a0 5a 74 f0       	mov    0xf0745aa0,%eax
f0109bec:	89 45 ec             	mov    %eax,-0x14(%ebp)
	// Allocate new pages
	for (uint32 addr = kheapBreak; addr < newBreak; addr += PAGE_SIZE)
f0109bef:	a1 a0 5a 74 f0       	mov    0xf0745aa0,%eax
f0109bf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109bf7:	eb 4c                	jmp    f0109c45 <sbrk+0xca>
	{
		struct FrameInfo *frame;
		if (allocate_frame(&frame) != 0 || map_frame(ptr_page_directory, frame, addr, PERM_PRESENT | PERM_WRITEABLE) != 0) {
f0109bf9:	83 ec 0c             	sub    $0xc,%esp
f0109bfc:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0109bff:	50                   	push   %eax
f0109c00:	e8 9e ec ff ff       	call   f01088a3 <allocate_frame>
f0109c05:	83 c4 10             	add    $0x10,%esp
f0109c08:	85 c0                	test   %eax,%eax
f0109c0a:	75 1b                	jne    f0109c27 <sbrk+0xac>
f0109c0c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0109c0f:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109c14:	6a 03                	push   $0x3
f0109c16:	ff 75 f4             	pushl  -0xc(%ebp)
f0109c19:	52                   	push   %edx
f0109c1a:	50                   	push   %eax
f0109c1b:	e8 50 f1 ff ff       	call   f0108d70 <map_frame>
f0109c20:	83 c4 10             	add    $0x10,%esp
f0109c23:	85 c0                	test   %eax,%eax
f0109c25:	74 17                	je     f0109c3e <sbrk+0xc3>
			release_sleeplock(&k_lock);
f0109c27:	83 ec 0c             	sub    $0xc,%esp
f0109c2a:	68 c0 44 76 f0       	push   $0xf07644c0
f0109c2f:	e8 2f 6f 00 00       	call   f0110b63 <release_sleeplock>
f0109c34:	83 c4 10             	add    $0x10,%esp
			return (void *) -1; // Allocation or mapping failed
f0109c37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0109c3c:	eb 2a                	jmp    f0109c68 <sbrk+0xed>
		return (void *) -1; // Failed to allocate memory
	}

	void *oldBreak = (void *) kheapBreak;
	// Allocate new pages
	for (uint32 addr = kheapBreak; addr < newBreak; addr += PAGE_SIZE)
f0109c3e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0109c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c48:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0109c4b:	72 ac                	jb     f0109bf9 <sbrk+0x7e>
			release_sleeplock(&k_lock);
			return (void *) -1; // Allocation or mapping failed
		}
	}
	// Update the break pointer
	kheapBreak = newBreak;
f0109c4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c50:	a3 a0 5a 74 f0       	mov    %eax,0xf0745aa0
	release_sleeplock(&k_lock);
f0109c55:	83 ec 0c             	sub    $0xc,%esp
f0109c58:	68 c0 44 76 f0       	push   $0xf07644c0
f0109c5d:	e8 01 6f 00 00       	call   f0110b63 <release_sleeplock>
f0109c62:	83 c4 10             	add    $0x10,%esp
	return oldBreak; // Return old break
f0109c65:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0109c68:	c9                   	leave  
f0109c69:	c3                   	ret    

f0109c6a <kmalloc>:
//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator

void* kmalloc(unsigned int size) {
f0109c6a:	55                   	push   %ebp
f0109c6b:	89 e5                	mov    %esp,%ebp
f0109c6d:	83 ec 68             	sub    $0x68,%esp
	// Write your code here, remove the panic and write your code
	//kpanic_into_prompt("kmalloc() is not implemented yet...!!");

	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

	if (size == 0) {
f0109c70:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109c74:	75 0a                	jne    f0109c80 <kmalloc+0x16>
		return NULL;
f0109c76:	b8 00 00 00 00       	mov    $0x0,%eax
f0109c7b:	e9 52 02 00 00       	jmp    f0109ed2 <kmalloc+0x268>
	}
	// Handle small allocations using the block allocator
	if (size <= DYN_ALLOC_MAX_BLOCK_SIZE) {
f0109c80:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0109c87:	77 26                	ja     f0109caf <kmalloc+0x45>
		if (isKHeapPlacementStrategyFIRSTFIT()) {
f0109c89:	e8 30 fd ff ff       	call   f01099be <isKHeapPlacementStrategyFIRSTFIT>
f0109c8e:	84 c0                	test   %al,%al
f0109c90:	74 13                	je     f0109ca5 <kmalloc+0x3b>
			return alloc_block_FF((uint32) size);
f0109c92:	83 ec 0c             	sub    $0xc,%esp
f0109c95:	ff 75 08             	pushl  0x8(%ebp)
f0109c98:	e8 6f 91 01 00       	call   f0122e0c <alloc_block_FF>
f0109c9d:	83 c4 10             	add    $0x10,%esp
f0109ca0:	e9 2d 02 00 00       	jmp    f0109ed2 <kmalloc+0x268>
		} else {
			return NULL;
f0109ca5:	b8 00 00 00 00       	mov    $0x0,%eax
f0109caa:	e9 23 02 00 00       	jmp    f0109ed2 <kmalloc+0x268>
		}
	}

	// Handle large allocations using page allocator
	uint32 pagesToAllocate = ROUNDUP(size, PAGE_SIZE) / PAGE_SIZE; // no. of pages
f0109caf:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0109cb6:	8b 55 08             	mov    0x8(%ebp),%edx
f0109cb9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109cbc:	01 d0                	add    %edx,%eax
f0109cbe:	48                   	dec    %eax
f0109cbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109cc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109cc5:	ba 00 00 00 00       	mov    $0x0,%edx
f0109cca:	f7 75 e0             	divl   -0x20(%ebp)
f0109ccd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109cd0:	29 d0                	sub    %edx,%eax
f0109cd2:	c1 e8 0c             	shr    $0xc,%eax
f0109cd5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 currentAddr = kheapHardLimit + PAGE_SIZE;
f0109cd8:	a1 dc 59 74 f0       	mov    0xf07459dc,%eax
f0109cdd:	05 00 10 00 00       	add    $0x1000,%eax
f0109ce2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 kheapSize = KERNEL_HEAP_MAX - currentAddr;
f0109ce5:	b8 00 f0 ff ff       	mov    $0xfffff000,%eax
f0109cea:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f0109ced:	89 45 d0             	mov    %eax,-0x30(%ebp)

	if (size > kheapSize) {
f0109cf0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cf3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0109cf6:	76 0a                	jbe    f0109d02 <kmalloc+0x98>
		return NULL;
f0109cf8:	b8 00 00 00 00       	mov    $0x0,%eax
f0109cfd:	e9 d0 01 00 00       	jmp    f0109ed2 <kmalloc+0x268>
	}

	int freeSpace = 0;
f0109d02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int count = 0;
f0109d09:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int start = -1;
f0109d10:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	acquire_sleeplock(&k_lock);
f0109d17:	83 ec 0c             	sub    $0xc,%esp
f0109d1a:	68 c0 44 76 f0       	push   $0xf07644c0
f0109d1f:	e8 e4 6d 00 00       	call   f0110b08 <acquire_sleeplock>
f0109d24:	83 c4 10             	add    $0x10,%esp
	for (uint32 i = currentAddr; i < KERNEL_HEAP_MAX; i += PAGE_SIZE)
f0109d27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109d2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109d2d:	e9 86 00 00 00       	jmp    f0109db8 <kmalloc+0x14e>
	{
		uint32 *pageTable = NULL;
f0109d32:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		struct FrameInfo *frame_info = get_frame_info(ptr_page_directory, i,
f0109d39:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109d3e:	83 ec 04             	sub    $0x4,%esp
f0109d41:	8d 55 a4             	lea    -0x5c(%ebp),%edx
f0109d44:	52                   	push   %edx
f0109d45:	ff 75 e8             	pushl  -0x18(%ebp)
f0109d48:	50                   	push   %eax
f0109d49:	e8 15 f1 ff ff       	call   f0108e63 <get_frame_info>
f0109d4e:	83 c4 10             	add    $0x10,%esp
f0109d51:	89 45 cc             	mov    %eax,-0x34(%ebp)
				&pageTable);
		if (frame_info == 0) {
f0109d54:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0109d58:	75 49                	jne    f0109da3 <kmalloc+0x139>
			freeSpace += PAGE_SIZE;
f0109d5a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
			count++;
f0109d61:	ff 45 f0             	incl   -0x10(%ebp)
			if (freeSpace == ROUNDUP(size, PAGE_SIZE)) {
f0109d64:	c7 45 c8 00 10 00 00 	movl   $0x1000,-0x38(%ebp)
f0109d6b:	8b 55 08             	mov    0x8(%ebp),%edx
f0109d6e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0109d71:	01 d0                	add    %edx,%eax
f0109d73:	48                   	dec    %eax
f0109d74:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0109d77:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109d7a:	ba 00 00 00 00       	mov    $0x0,%edx
f0109d7f:	f7 75 c8             	divl   -0x38(%ebp)
f0109d82:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109d85:	29 d0                	sub    %edx,%eax
f0109d87:	89 c2                	mov    %eax,%edx
f0109d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d8c:	39 c2                	cmp    %eax,%edx
f0109d8e:	75 21                	jne    f0109db1 <kmalloc+0x147>
				start = i - ((count - 1) * PAGE_SIZE);
f0109d90:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d93:	48                   	dec    %eax
f0109d94:	c1 e0 0c             	shl    $0xc,%eax
f0109d97:	89 c2                	mov    %eax,%edx
f0109d99:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109d9c:	29 d0                	sub    %edx,%eax
f0109d9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109da1:	eb 22                	jmp    f0109dc5 <kmalloc+0x15b>
				break;
			}
		} else {
			freeSpace = 0;
f0109da3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			count = 0;
f0109daa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	int freeSpace = 0;
	int count = 0;
	int start = -1;
	acquire_sleeplock(&k_lock);
	for (uint32 i = currentAddr; i < KERNEL_HEAP_MAX; i += PAGE_SIZE)
f0109db1:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
f0109db8:	81 7d e8 ff ef ff ff 	cmpl   $0xffffefff,-0x18(%ebp)
f0109dbf:	0f 86 6d ff ff ff    	jbe    f0109d32 <kmalloc+0xc8>
		} else {
			freeSpace = 0;
			count = 0;
		}
	}
	if (start == -1|| count < pagesToAllocate || freeSpace < ROUNDUP(size, PAGE_SIZE)) {
f0109dc5:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f0109dc9:	74 34                	je     f0109dff <kmalloc+0x195>
f0109dcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109dce:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0109dd1:	72 2c                	jb     f0109dff <kmalloc+0x195>
f0109dd3:	c7 45 c0 00 10 00 00 	movl   $0x1000,-0x40(%ebp)
f0109dda:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ddd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109de0:	01 d0                	add    %edx,%eax
f0109de2:	48                   	dec    %eax
f0109de3:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0109de6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109de9:	ba 00 00 00 00       	mov    $0x0,%edx
f0109dee:	f7 75 c0             	divl   -0x40(%ebp)
f0109df1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0109df4:	29 d0                	sub    %edx,%eax
f0109df6:	89 c2                	mov    %eax,%edx
f0109df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109dfb:	39 c2                	cmp    %eax,%edx
f0109dfd:	76 1a                	jbe    f0109e19 <kmalloc+0x1af>
		release_sleeplock(&k_lock);
f0109dff:	83 ec 0c             	sub    $0xc,%esp
f0109e02:	68 c0 44 76 f0       	push   $0xf07644c0
f0109e07:	e8 57 6d 00 00       	call   f0110b63 <release_sleeplock>
f0109e0c:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0109e0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0109e14:	e9 b9 00 00 00       	jmp    f0109ed2 <kmalloc+0x268>
	}
	for (uint32 j = start; j < start + ROUNDUP(size, PAGE_SIZE); j += PAGE_SIZE)
f0109e19:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109e1f:	eb 6b                	jmp    f0109e8c <kmalloc+0x222>
	{
		struct FrameInfo *frame_info_ptr = NULL;
f0109e21:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		int ret = allocate_frame(&frame_info_ptr);
f0109e28:	83 ec 0c             	sub    $0xc,%esp
f0109e2b:	8d 45 a0             	lea    -0x60(%ebp),%eax
f0109e2e:	50                   	push   %eax
f0109e2f:	e8 6f ea ff ff       	call   f01088a3 <allocate_frame>
f0109e34:	83 c4 10             	add    $0x10,%esp
f0109e37:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ret = map_frame(ptr_page_directory, frame_info_ptr, j,
f0109e3a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0109e3d:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109e42:	6a 03                	push   $0x3
f0109e44:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109e47:	52                   	push   %edx
f0109e48:	50                   	push   %eax
f0109e49:	e8 22 ef ff ff       	call   f0108d70 <map_frame>
f0109e4e:	83 c4 10             	add    $0x10,%esp
f0109e51:	89 45 b0             	mov    %eax,-0x50(%ebp)
				PERM_PRESENT | PERM_WRITEABLE);
		if (j == start) {
f0109e54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e57:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0109e5a:	75 29                	jne    f0109e85 <kmalloc+0x21b>
			frame_info_ptr->size = ROUNDUP(size, PAGE_SIZE);
f0109e5c:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0109e5f:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
f0109e66:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e69:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0109e6c:	01 d0                	add    %edx,%eax
f0109e6e:	48                   	dec    %eax
f0109e6f:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0109e72:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0109e75:	ba 00 00 00 00       	mov    $0x0,%edx
f0109e7a:	f7 75 ac             	divl   -0x54(%ebp)
f0109e7d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0109e80:	29 d0                	sub    %edx,%eax
f0109e82:	89 41 1c             	mov    %eax,0x1c(%ecx)
	}
	if (start == -1|| count < pagesToAllocate || freeSpace < ROUNDUP(size, PAGE_SIZE)) {
		release_sleeplock(&k_lock);
		return NULL;
	}
	for (uint32 j = start; j < start + ROUNDUP(size, PAGE_SIZE); j += PAGE_SIZE)
f0109e85:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f0109e8c:	c7 45 b8 00 10 00 00 	movl   $0x1000,-0x48(%ebp)
f0109e93:	8b 55 08             	mov    0x8(%ebp),%edx
f0109e96:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0109e99:	01 d0                	add    %edx,%eax
f0109e9b:	48                   	dec    %eax
f0109e9c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0109e9f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ea2:	ba 00 00 00 00       	mov    $0x0,%edx
f0109ea7:	f7 75 b8             	divl   -0x48(%ebp)
f0109eaa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109ead:	29 d0                	sub    %edx,%eax
f0109eaf:	89 c2                	mov    %eax,%edx
f0109eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109eb4:	01 d0                	add    %edx,%eax
f0109eb6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0109eb9:	0f 87 62 ff ff ff    	ja     f0109e21 <kmalloc+0x1b7>
				PERM_PRESENT | PERM_WRITEABLE);
		if (j == start) {
			frame_info_ptr->size = ROUNDUP(size, PAGE_SIZE);
		}
	}
	release_sleeplock(&k_lock);
f0109ebf:	83 ec 0c             	sub    $0xc,%esp
f0109ec2:	68 c0 44 76 f0       	push   $0xf07644c0
f0109ec7:	e8 97 6c 00 00       	call   f0110b63 <release_sleeplock>
f0109ecc:	83 c4 10             	add    $0x10,%esp
	return (void *) start;
f0109ecf:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0109ed2:	c9                   	leave  
f0109ed3:	c3                   	ret    

f0109ed4 <kfree>:

void kfree(void* virtual_address) {
f0109ed4:	55                   	push   %ebp
f0109ed5:	89 e5                	mov    %esp,%ebp
f0109ed7:	83 ec 28             	sub    $0x28,%esp
	// Write your code here, remove the panic and write your code
	//panic("kfree() is not implemented yet...!!");
	//you need to get the size of the given allocation using its address
	//refer to the project presentation and documentation for details

	if (virtual_address == NULL) {
f0109eda:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0109ede:	0f 84 1a 01 00 00    	je     f0109ffe <kfree+0x12a>
		return;
	}

	if ((uint32) virtual_address
f0109ee4:	8b 55 08             	mov    0x8(%ebp),%edx
			< kheapStart|| (uint32)virtual_address > KERNEL_HEAP_MAX) {
f0109ee7:	a1 04 5d 74 f0       	mov    0xf0745d04,%eax

	if (virtual_address == NULL) {
		return;
	}

	if ((uint32) virtual_address
f0109eec:	39 c2                	cmp    %eax,%edx
f0109eee:	72 0a                	jb     f0109efa <kfree+0x26>
			< kheapStart|| (uint32)virtual_address > KERNEL_HEAP_MAX) {
f0109ef0:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ef3:	3d 00 f0 ff ff       	cmp    $0xfffff000,%eax
f0109ef8:	76 17                	jbe    f0109f11 <kfree+0x3d>
		panic("INVALID VIRTUAL ADDRESS!!");
f0109efa:	83 ec 04             	sub    $0x4,%esp
f0109efd:	68 a8 7b 12 f0       	push   $0xf0127ba8
f0109f02:	68 b9 00 00 00       	push   $0xb9
f0109f07:	68 2f 7b 12 f0       	push   $0xf0127b2f
f0109f0c:	e8 28 64 ff ff       	call   f0100339 <_panic>
	}

	if ((uint32) virtual_address >= kheapStart
f0109f11:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f14:	a1 04 5d 74 f0       	mov    0xf0745d04,%eax
f0109f19:	39 c2                	cmp    %eax,%edx
f0109f1b:	72 1f                	jb     f0109f3c <kfree+0x68>
			&& (uint32) virtual_address < kheapBreak) {
f0109f1d:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f20:	a1 a0 5a 74 f0       	mov    0xf0745aa0,%eax
f0109f25:	39 c2                	cmp    %eax,%edx
f0109f27:	73 13                	jae    f0109f3c <kfree+0x68>
		free_block(virtual_address);
f0109f29:	83 ec 0c             	sub    $0xc,%esp
f0109f2c:	ff 75 08             	pushl  0x8(%ebp)
f0109f2f:	e8 a1 95 01 00       	call   f01234d5 <free_block>
f0109f34:	83 c4 10             	add    $0x10,%esp
		return;
f0109f37:	e9 c3 00 00 00       	jmp    f0109fff <kfree+0x12b>
	}

	acquire_sleeplock(&k_lock);
f0109f3c:	83 ec 0c             	sub    $0xc,%esp
f0109f3f:	68 c0 44 76 f0       	push   $0xf07644c0
f0109f44:	e8 bf 6b 00 00       	call   f0110b08 <acquire_sleeplock>
f0109f49:	83 c4 10             	add    $0x10,%esp

	uint32 *pageTable = NULL;
f0109f4c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct FrameInfo *frame_info = get_frame_info(ptr_page_directory,
f0109f53:	8b 55 08             	mov    0x8(%ebp),%edx
f0109f56:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109f5b:	83 ec 04             	sub    $0x4,%esp
f0109f5e:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
f0109f61:	51                   	push   %ecx
f0109f62:	52                   	push   %edx
f0109f63:	50                   	push   %eax
f0109f64:	e8 fa ee ff ff       	call   f0108e63 <get_frame_info>
f0109f69:	83 c4 10             	add    $0x10,%esp
f0109f6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
			(uint32) virtual_address, &pageTable);
	uint32 frameSize = frame_info->size;
f0109f6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f72:	8b 40 1c             	mov    0x1c(%eax),%eax
f0109f75:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (frameSize == 0) {
f0109f78:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109f7c:	75 12                	jne    f0109f90 <kfree+0xbc>
		release_sleeplock(&k_lock);
f0109f7e:	83 ec 0c             	sub    $0xc,%esp
f0109f81:	68 c0 44 76 f0       	push   $0xf07644c0
f0109f86:	e8 d8 6b 00 00       	call   f0110b63 <release_sleeplock>
f0109f8b:	83 c4 10             	add    $0x10,%esp
		return;
f0109f8e:	eb 6f                	jmp    f0109fff <kfree+0x12b>
	}
	for (uint32 i = (uint32) virtual_address;
f0109f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f93:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109f96:	eb 3d                	jmp    f0109fd5 <kfree+0x101>
			i < (uint32) virtual_address + frameSize; i += PAGE_SIZE)
			{
		uint32 *page_table = NULL;
f0109f98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		struct FrameInfo *frame_info = get_frame_info(ptr_page_directory, i, &page_table);
f0109f9f:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109fa4:	83 ec 04             	sub    $0x4,%esp
f0109fa7:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0109faa:	52                   	push   %edx
f0109fab:	ff 75 f4             	pushl  -0xc(%ebp)
f0109fae:	50                   	push   %eax
f0109faf:	e8 af ee ff ff       	call   f0108e63 <get_frame_info>
f0109fb4:	83 c4 10             	add    $0x10,%esp
f0109fb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		unmap_frame(ptr_page_directory, i);
f0109fba:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0109fbf:	83 ec 08             	sub    $0x8,%esp
f0109fc2:	ff 75 f4             	pushl  -0xc(%ebp)
f0109fc5:	50                   	push   %eax
f0109fc6:	e8 0e ef ff ff       	call   f0108ed9 <unmap_frame>
f0109fcb:	83 c4 10             	add    $0x10,%esp
	if (frameSize == 0) {
		release_sleeplock(&k_lock);
		return;
	}
	for (uint32 i = (uint32) virtual_address;
			i < (uint32) virtual_address + frameSize; i += PAGE_SIZE)
f0109fce:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0109fd5:	8b 55 08             	mov    0x8(%ebp),%edx
f0109fd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109fdb:	01 d0                	add    %edx,%eax

	if (frameSize == 0) {
		release_sleeplock(&k_lock);
		return;
	}
	for (uint32 i = (uint32) virtual_address;
f0109fdd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109fe0:	77 b6                	ja     f0109f98 <kfree+0xc4>
			{
		uint32 *page_table = NULL;
		struct FrameInfo *frame_info = get_frame_info(ptr_page_directory, i, &page_table);
		unmap_frame(ptr_page_directory, i);
	}
	frame_info->size = 0;
f0109fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fe5:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	release_sleeplock(&k_lock);
f0109fec:	83 ec 0c             	sub    $0xc,%esp
f0109fef:	68 c0 44 76 f0       	push   $0xf07644c0
f0109ff4:	e8 6a 6b 00 00       	call   f0110b63 <release_sleeplock>
f0109ff9:	83 c4 10             	add    $0x10,%esp
f0109ffc:	eb 01                	jmp    f0109fff <kfree+0x12b>
	//panic("kfree() is not implemented yet...!!");
	//you need to get the size of the given allocation using its address
	//refer to the project presentation and documentation for details

	if (virtual_address == NULL) {
		return;
f0109ffe:	90                   	nop
		struct FrameInfo *frame_info = get_frame_info(ptr_page_directory, i, &page_table);
		unmap_frame(ptr_page_directory, i);
	}
	frame_info->size = 0;
	release_sleeplock(&k_lock);
}
f0109fff:	c9                   	leave  
f010a000:	c3                   	ret    

f010a001 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int virtual_address) {
f010a001:	55                   	push   %ebp
f010a002:	89 e5                	mov    %esp,%ebp
f010a004:	83 ec 28             	sub    $0x28,%esp
	//return the physical address corresponding to given virtual_address
	//refer to the project presentation and documentation for details

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	acquire_sleeplock(&k_lock);
f010a007:	83 ec 0c             	sub    $0xc,%esp
f010a00a:	68 c0 44 76 f0       	push   $0xf07644c0
f010a00f:	e8 f4 6a 00 00       	call   f0110b08 <acquire_sleeplock>
f010a014:	83 c4 10             	add    $0x10,%esp
	unsigned int *ptr_page_table = NULL;
f010a017:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct FrameInfo * ptr_frame_info = get_frame_info(ptr_page_directory,
f010a01e:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f010a023:	83 ec 04             	sub    $0x4,%esp
f010a026:	8d 55 e4             	lea    -0x1c(%ebp),%edx
f010a029:	52                   	push   %edx
f010a02a:	ff 75 08             	pushl  0x8(%ebp)
f010a02d:	50                   	push   %eax
f010a02e:	e8 30 ee ff ff       	call   f0108e63 <get_frame_info>
f010a033:	83 c4 10             	add    $0x10,%esp
f010a036:	89 45 f4             	mov    %eax,-0xc(%ebp)
			virtual_address, &ptr_page_table);
	if (ptr_frame_info == NULL) {
f010a039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a03d:	75 17                	jne    f010a056 <kheap_physical_address+0x55>
		release_sleeplock(&k_lock);
f010a03f:	83 ec 0c             	sub    $0xc,%esp
f010a042:	68 c0 44 76 f0       	push   $0xf07644c0
f010a047:	e8 17 6b 00 00       	call   f0110b63 <release_sleeplock>
f010a04c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010a04f:	b8 00 00 00 00       	mov    $0x0,%eax
f010a054:	eb 3a                	jmp    f010a090 <kheap_physical_address+0x8f>
	}

	unsigned int physical_frame_base = to_physical_address(ptr_frame_info);
f010a056:	83 ec 0c             	sub    $0xc,%esp
f010a059:	ff 75 f4             	pushl  -0xc(%ebp)
f010a05c:	e8 ae f9 ff ff       	call   f0109a0f <to_physical_address>
f010a061:	83 c4 10             	add    $0x10,%esp
f010a064:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned int page_offset = virtual_address & 0xFFF; // Lower 12 bits
f010a067:	8b 45 08             	mov    0x8(%ebp),%eax
f010a06a:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a06f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned int physical_address = physical_frame_base + page_offset;
f010a072:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a075:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a078:	01 d0                	add    %edx,%eax
f010a07a:	89 45 e8             	mov    %eax,-0x18(%ebp)

	release_sleeplock(&k_lock);
f010a07d:	83 ec 0c             	sub    $0xc,%esp
f010a080:	68 c0 44 76 f0       	push   $0xf07644c0
f010a085:	e8 d9 6a 00 00       	call   f0110b63 <release_sleeplock>
f010a08a:	83 c4 10             	add    $0x10,%esp
	return physical_address;
f010a08d:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f010a090:	c9                   	leave  
f010a091:	c3                   	ret    

f010a092 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address) {
f010a092:	55                   	push   %ebp
f010a093:	89 e5                	mov    %esp,%ebp
f010a095:	83 ec 18             	sub    $0x18,%esp
	//return the virtual address corresponding to given physical_address
	//refer to the project presentation and documentation for details

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================

	acquire_sleeplock(&k_lock);
f010a098:	83 ec 0c             	sub    $0xc,%esp
f010a09b:	68 c0 44 76 f0       	push   $0xf07644c0
f010a0a0:	e8 63 6a 00 00       	call   f0110b08 <acquire_sleeplock>
f010a0a5:	83 c4 10             	add    $0x10,%esp
	unsigned int *ptr_page_table = NULL;
f010a0a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct FrameInfo * ptr_frame_info = to_frame_info(physical_address);
f010a0af:	83 ec 0c             	sub    $0xc,%esp
f010a0b2:	ff 75 08             	pushl  0x8(%ebp)
f010a0b5:	e8 68 f9 ff ff       	call   f0109a22 <to_frame_info>
f010a0ba:	83 c4 10             	add    $0x10,%esp
f010a0bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ptr_frame_info->va == 0 || ptr_frame_info == NULL) {
f010a0c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0c3:	8b 40 18             	mov    0x18(%eax),%eax
f010a0c6:	85 c0                	test   %eax,%eax
f010a0c8:	74 06                	je     f010a0d0 <kheap_virtual_address+0x3e>
f010a0ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a0ce:	75 17                	jne    f010a0e7 <kheap_virtual_address+0x55>
		release_sleeplock(&k_lock);
f010a0d0:	83 ec 0c             	sub    $0xc,%esp
f010a0d3:	68 c0 44 76 f0       	push   $0xf07644c0
f010a0d8:	e8 86 6a 00 00       	call   f0110b63 <release_sleeplock>
f010a0dd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010a0e0:	b8 00 00 00 00       	mov    $0x0,%eax
f010a0e5:	eb 2c                	jmp    f010a113 <kheap_virtual_address+0x81>
	}
	unsigned int page_offset = physical_address & 0xFFF; // Lower 12 bits
f010a0e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ea:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a0ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned int virtual_address = ptr_frame_info->va + page_offset;
f010a0f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0f5:	8b 50 18             	mov    0x18(%eax),%edx
f010a0f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a0fb:	01 d0                	add    %edx,%eax
f010a0fd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	release_sleeplock(&k_lock);
f010a100:	83 ec 0c             	sub    $0xc,%esp
f010a103:	68 c0 44 76 f0       	push   $0xf07644c0
f010a108:	e8 56 6a 00 00       	call   f0110b63 <release_sleeplock>
f010a10d:	83 c4 10             	add    $0x10,%esp
	return virtual_address;
f010a110:	8b 45 e8             	mov    -0x18(%ebp),%eax

}
f010a113:	c9                   	leave  
f010a114:	c3                   	ret    

f010a115 <krealloc>:
//	On failure, returns a null pointer, and the old virtual_address remains valid.

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size) {
f010a115:	55                   	push   %ebp
f010a116:	89 e5                	mov    %esp,%ebp
f010a118:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	// Write your code here, remove the panic and write your code
	//return NULL;
	panic("krealloc() is not implemented yet...!!");
f010a11b:	83 ec 04             	sub    $0x4,%esp
f010a11e:	68 c4 7b 12 f0       	push   $0xf0127bc4
f010a123:	68 1b 01 00 00       	push   $0x11b
f010a128:	68 2f 7b 12 f0       	push   $0xf0127b2f
f010a12d:	e8 07 62 ff ff       	call   f0100339 <_panic>

f010a132 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f010a132:	55                   	push   %ebp
f010a133:	89 e5                	mov    %esp,%ebp
f010a135:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a138:	83 ec 04             	sub    $0x4,%esp
f010a13b:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a13e:	50                   	push   %eax
f010a13f:	ff 75 0c             	pushl  0xc(%ebp)
f010a142:	ff 75 08             	pushl  0x8(%ebp)
f010a145:	e8 96 e9 ff ff       	call   f0108ae0 <get_page_table>
f010a14a:	83 c4 10             	add    $0x10,%esp
f010a14d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010a150:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a153:	85 c0                	test   %eax,%eax
f010a155:	74 64                	je     f010a1bb <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010a157:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a15a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a15d:	c1 ea 0c             	shr    $0xc,%edx
f010a160:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a166:	c1 e2 02             	shl    $0x2,%edx
f010a169:	01 c2                	add    %eax,%edx
f010a16b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a16e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a171:	c1 e9 0c             	shr    $0xc,%ecx
f010a174:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a17a:	c1 e1 02             	shl    $0x2,%ecx
f010a17d:	01 c8                	add    %ecx,%eax
f010a17f:	8b 00                	mov    (%eax),%eax
f010a181:	0b 45 10             	or     0x10(%ebp),%eax
f010a184:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010a186:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a189:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a18c:	c1 ea 0c             	shr    $0xc,%edx
f010a18f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a195:	c1 e2 02             	shl    $0x2,%edx
f010a198:	01 d0                	add    %edx,%eax
f010a19a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a19d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010a1a0:	c1 e9 0c             	shr    $0xc,%ecx
f010a1a3:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a1a9:	c1 e1 02             	shl    $0x2,%ecx
f010a1ac:	01 ca                	add    %ecx,%edx
f010a1ae:	8b 12                	mov    (%edx),%edx
f010a1b0:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010a1b3:	f7 d1                	not    %ecx
f010a1b5:	21 ca                	and    %ecx,%edx
f010a1b7:	89 10                	mov    %edx,(%eax)
f010a1b9:	eb 27                	jmp    f010a1e2 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f010a1bb:	83 ec 08             	sub    $0x8,%esp
f010a1be:	ff 75 0c             	pushl  0xc(%ebp)
f010a1c1:	68 ec 7b 12 f0       	push   $0xf0127bec
f010a1c6:	e8 c0 6d ff ff       	call   f0100f8b <cprintf>
f010a1cb:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a1ce:	83 ec 04             	sub    $0x4,%esp
f010a1d1:	68 14 7c 12 f0       	push   $0xf0127c14
f010a1d6:	6a 1c                	push   $0x1c
f010a1d8:	68 88 7c 12 f0       	push   $0xf0127c88
f010a1dd:	e8 57 61 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a1e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a1e5:	83 ec 08             	sub    $0x8,%esp
f010a1e8:	50                   	push   %eax
f010a1e9:	6a 00                	push   $0x0
f010a1eb:	e8 aa e2 ff ff       	call   f010849a <tlb_invalidate>
f010a1f0:	83 c4 10             	add    $0x10,%esp
}
f010a1f3:	90                   	nop
f010a1f4:	c9                   	leave  
f010a1f5:	c3                   	ret    

f010a1f6 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010a1f6:	55                   	push   %ebp
f010a1f7:	89 e5                	mov    %esp,%ebp
f010a1f9:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a1fc:	83 ec 04             	sub    $0x4,%esp
f010a1ff:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a202:	50                   	push   %eax
f010a203:	ff 75 0c             	pushl  0xc(%ebp)
f010a206:	ff 75 08             	pushl  0x8(%ebp)
f010a209:	e8 d2 e8 ff ff       	call   f0108ae0 <get_page_table>
f010a20e:	83 c4 10             	add    $0x10,%esp
f010a211:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f010a214:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a217:	85 c0                	test   %eax,%eax
f010a219:	74 1d                	je     f010a238 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f010a21b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a21e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a221:	c1 ea 0c             	shr    $0xc,%edx
f010a224:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a22a:	c1 e2 02             	shl    $0x2,%edx
f010a22d:	01 d0                	add    %edx,%eax
f010a22f:	8b 00                	mov    (%eax),%eax
f010a231:	25 ff 0f 00 00       	and    $0xfff,%eax
f010a236:	eb 05                	jmp    f010a23d <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f010a238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f010a23d:	c9                   	leave  
f010a23e:	c3                   	ret    

f010a23f <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f010a23f:	55                   	push   %ebp
f010a240:	89 e5                	mov    %esp,%ebp
f010a242:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010a245:	83 ec 04             	sub    $0x4,%esp
f010a248:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010a24b:	50                   	push   %eax
f010a24c:	ff 75 0c             	pushl  0xc(%ebp)
f010a24f:	ff 75 08             	pushl  0x8(%ebp)
f010a252:	e8 89 e8 ff ff       	call   f0108ae0 <get_page_table>
f010a257:	83 c4 10             	add    $0x10,%esp
f010a25a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010a25d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a260:	85 c0                	test   %eax,%eax
f010a262:	74 46                	je     f010a2aa <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f010a264:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a267:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a26a:	c1 ea 0c             	shr    $0xc,%edx
f010a26d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a273:	c1 e2 02             	shl    $0x2,%edx
f010a276:	01 d0                	add    %edx,%eax
f010a278:	8b 00                	mov    (%eax),%eax
f010a27a:	83 ec 04             	sub    $0x4,%esp
f010a27d:	50                   	push   %eax
f010a27e:	ff 75 0c             	pushl  0xc(%ebp)
f010a281:	68 a4 7c 12 f0       	push   $0xf0127ca4
f010a286:	e8 00 6d ff ff       	call   f0100f8b <cprintf>
f010a28b:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010a28e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a291:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a294:	c1 ea 0c             	shr    $0xc,%edx
f010a297:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a29d:	c1 e2 02             	shl    $0x2,%edx
f010a2a0:	01 d0                	add    %edx,%eax
f010a2a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a2a8:	eb 14                	jmp    f010a2be <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010a2aa:	83 ec 04             	sub    $0x4,%esp
f010a2ad:	68 cc 7c 12 f0       	push   $0xf0127ccc
f010a2b2:	6a 47                	push   $0x47
f010a2b4:	68 88 7c 12 f0       	push   $0xf0127c88
f010a2b9:	e8 7b 60 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a2be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a2c1:	83 ec 08             	sub    $0x8,%esp
f010a2c4:	50                   	push   %eax
f010a2c5:	6a 00                	push   $0x0
f010a2c7:	e8 ce e1 ff ff       	call   f010849a <tlb_invalidate>
f010a2cc:	83 c4 10             	add    $0x10,%esp
}
f010a2cf:	90                   	nop
f010a2d0:	c9                   	leave  
f010a2d1:	c3                   	ret    

f010a2d2 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010a2d2:	55                   	push   %ebp
f010a2d3:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f010a2d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a2d8:	c1 e8 16             	shr    $0x16,%eax
f010a2db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a2e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2e5:	01 d0                	add    %edx,%eax
f010a2e7:	8b 00                	mov    (%eax),%eax
f010a2e9:	83 e0 20             	and    $0x20,%eax
f010a2ec:	85 c0                	test   %eax,%eax
f010a2ee:	0f 95 c0             	setne  %al
f010a2f1:	0f b6 c0             	movzbl %al,%eax
}
f010a2f4:	5d                   	pop    %ebp
f010a2f5:	c3                   	ret    

f010a2f6 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f010a2f6:	55                   	push   %ebp
f010a2f7:	89 e5                	mov    %esp,%ebp
f010a2f9:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f010a2fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a2ff:	c1 e8 16             	shr    $0x16,%eax
f010a302:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a309:	8b 45 08             	mov    0x8(%ebp),%eax
f010a30c:	01 d0                	add    %edx,%eax
f010a30e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a311:	c1 ea 16             	shr    $0x16,%edx
f010a314:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f010a31b:	8b 55 08             	mov    0x8(%ebp),%edx
f010a31e:	01 ca                	add    %ecx,%edx
f010a320:	8b 12                	mov    (%edx),%edx
f010a322:	83 e2 df             	and    $0xffffffdf,%edx
f010a325:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010a327:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a32a:	83 ec 08             	sub    $0x8,%esp
f010a32d:	50                   	push   %eax
f010a32e:	6a 00                	push   $0x0
f010a330:	e8 65 e1 ff ff       	call   f010849a <tlb_invalidate>
f010a335:	83 c4 10             	add    $0x10,%esp
}
f010a338:	90                   	nop
f010a339:	c9                   	leave  
f010a33a:	c3                   	ret    

f010a33b <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f010a33b:	55                   	push   %ebp
f010a33c:	89 e5                	mov    %esp,%ebp
f010a33e:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f010a341:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a344:	c1 e8 16             	shr    $0x16,%eax
f010a347:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a34e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a351:	01 d0                	add    %edx,%eax
f010a353:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010a359:	0f 20 d8             	mov    %cr3,%eax
f010a35c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010a35f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a362:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010a365:	90                   	nop
f010a366:	c9                   	leave  
f010a367:	c3                   	ret    

f010a368 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010a368:	55                   	push   %ebp
f010a369:	89 e5                	mov    %esp,%ebp
f010a36b:	83 ec 18             	sub    $0x18,%esp
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("env_page_ws_list_create_element is not implemented yet");
	//Your Code is Here...
	// Allocate memory for the WorkingSetElement
	    struct WorkingSetElement* new_element = (struct WorkingSetElement*)kmalloc(sizeof(struct WorkingSetElement));
f010a36e:	83 ec 0c             	sub    $0xc,%esp
f010a371:	6a 18                	push   $0x18
f010a373:	e8 f2 f8 ff ff       	call   f0109c6a <kmalloc>
f010a378:	83 c4 10             	add    $0x10,%esp
f010a37b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	    // Check if the allocation was successful
	    if (new_element == NULL) {
f010a37e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a382:	75 14                	jne    f010a398 <env_page_ws_list_create_element+0x30>
	        panic("Failed to allocate memory for a new WorkingSetElement");
f010a384:	83 ec 04             	sub    $0x4,%esp
f010a387:	68 44 7d 12 f0       	push   $0xf0127d44
f010a38c:	6a 1d                	push   $0x1d
f010a38e:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a393:	e8 a1 5f ff ff       	call   f0100339 <_panic>
	    }

	    // Initialize the fields of the new element
	    new_element->virtual_address = virtual_address;
f010a398:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a39b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a39e:	89 10                	mov    %edx,(%eax)
	    return new_element;
f010a3a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010a3a3:	c9                   	leave  
f010a3a4:	c3                   	ret    

f010a3a5 <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a3a5:	55                   	push   %ebp
f010a3a6:	89 e5                	mov    %esp,%ebp
f010a3a8:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a3ab:	83 ec 0c             	sub    $0xc,%esp
f010a3ae:	6a 02                	push   $0x2
f010a3b0:	e8 bf 58 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010a3b5:	83 c4 10             	add    $0x10,%esp
f010a3b8:	85 c0                	test   %eax,%eax
f010a3ba:	0f 84 e5 03 00 00    	je     f010a7a5 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010a3c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010a3c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a3ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d1:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a3d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a3da:	e9 3b 02 00 00       	jmp    f010a61a <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a3df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3e2:	8b 00                	mov    (%eax),%eax
f010a3e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a3e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a3ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3ef:	89 c2                	mov    %eax,%edx
f010a3f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a3f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010a3f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a3fa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3ff:	39 c2                	cmp    %eax,%edx
f010a401:	0f 85 07 02 00 00    	jne    f010a60e <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010a407:	8b 45 08             	mov    0x8(%ebp),%eax
f010a40a:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a410:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a413:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a416:	8b 10                	mov    (%eax),%edx
f010a418:	8b 45 08             	mov    0x8(%ebp),%eax
f010a41b:	8b 40 64             	mov    0x64(%eax),%eax
f010a41e:	83 ec 08             	sub    $0x8,%esp
f010a421:	52                   	push   %edx
f010a422:	50                   	push   %eax
f010a423:	e8 b1 ea ff ff       	call   f0108ed9 <unmap_frame>
f010a428:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a42b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a42f:	75 14                	jne    f010a445 <env_page_ws_invalidate+0xa0>
f010a431:	83 ec 04             	sub    $0x4,%esp
f010a434:	68 9b 7d 12 f0       	push   $0xf0127d9b
f010a439:	6a 32                	push   $0x32
f010a43b:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a440:	e8 f4 5e ff ff       	call   f0100339 <_panic>
f010a445:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a448:	8b 40 10             	mov    0x10(%eax),%eax
f010a44b:	85 c0                	test   %eax,%eax
f010a44d:	74 11                	je     f010a460 <env_page_ws_invalidate+0xbb>
f010a44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a452:	8b 40 10             	mov    0x10(%eax),%eax
f010a455:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a458:	8b 52 14             	mov    0x14(%edx),%edx
f010a45b:	89 50 14             	mov    %edx,0x14(%eax)
f010a45e:	eb 0f                	jmp    f010a46f <env_page_ws_invalidate+0xca>
f010a460:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a463:	8b 50 14             	mov    0x14(%eax),%edx
f010a466:	8b 45 08             	mov    0x8(%ebp),%eax
f010a469:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a46f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a472:	8b 40 14             	mov    0x14(%eax),%eax
f010a475:	85 c0                	test   %eax,%eax
f010a477:	74 11                	je     f010a48a <env_page_ws_invalidate+0xe5>
f010a479:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a47c:	8b 40 14             	mov    0x14(%eax),%eax
f010a47f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a482:	8b 52 10             	mov    0x10(%edx),%edx
f010a485:	89 50 10             	mov    %edx,0x10(%eax)
f010a488:	eb 0f                	jmp    f010a499 <env_page_ws_invalidate+0xf4>
f010a48a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a48d:	8b 50 10             	mov    0x10(%eax),%edx
f010a490:	8b 45 08             	mov    0x8(%ebp),%eax
f010a493:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a499:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a49c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a4a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a4a6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a4ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4b0:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a4b6:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a4b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4bc:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a4c2:	83 ec 0c             	sub    $0xc,%esp
f010a4c5:	ff 75 f0             	pushl  -0x10(%ebp)
f010a4c8:	e8 07 fa ff ff       	call   f0109ed4 <kfree>
f010a4cd:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a4d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a4d4:	0f 84 2b 01 00 00    	je     f010a605 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a4da:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a4de:	75 14                	jne    f010a4f4 <env_page_ws_invalidate+0x14f>
f010a4e0:	83 ec 04             	sub    $0x4,%esp
f010a4e3:	68 9b 7d 12 f0       	push   $0xf0127d9b
f010a4e8:	6a 38                	push   $0x38
f010a4ea:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a4ef:	e8 45 5e ff ff       	call   f0100339 <_panic>
f010a4f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a4f7:	8b 40 10             	mov    0x10(%eax),%eax
f010a4fa:	85 c0                	test   %eax,%eax
f010a4fc:	74 11                	je     f010a50f <env_page_ws_invalidate+0x16a>
f010a4fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a501:	8b 40 10             	mov    0x10(%eax),%eax
f010a504:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a507:	8b 52 14             	mov    0x14(%edx),%edx
f010a50a:	89 50 14             	mov    %edx,0x14(%eax)
f010a50d:	eb 0f                	jmp    f010a51e <env_page_ws_invalidate+0x179>
f010a50f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a512:	8b 50 14             	mov    0x14(%eax),%edx
f010a515:	8b 45 08             	mov    0x8(%ebp),%eax
f010a518:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a51e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a521:	8b 40 14             	mov    0x14(%eax),%eax
f010a524:	85 c0                	test   %eax,%eax
f010a526:	74 11                	je     f010a539 <env_page_ws_invalidate+0x194>
f010a528:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a52b:	8b 40 14             	mov    0x14(%eax),%eax
f010a52e:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a531:	8b 52 10             	mov    0x10(%edx),%edx
f010a534:	89 50 10             	mov    %edx,0x10(%eax)
f010a537:	eb 0f                	jmp    f010a548 <env_page_ws_invalidate+0x1a3>
f010a539:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a53c:	8b 50 10             	mov    0x10(%eax),%edx
f010a53f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a542:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a548:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a54b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a552:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a555:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a55c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a55f:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a565:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a568:	8b 45 08             	mov    0x8(%ebp),%eax
f010a56b:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a571:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a575:	75 14                	jne    f010a58b <env_page_ws_invalidate+0x1e6>
f010a577:	83 ec 04             	sub    $0x4,%esp
f010a57a:	68 bc 7d 12 f0       	push   $0xf0127dbc
f010a57f:	6a 39                	push   $0x39
f010a581:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a586:	e8 ae 5d ff ff       	call   f0100339 <_panic>
f010a58b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a58e:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010a594:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a597:	89 50 14             	mov    %edx,0x14(%eax)
f010a59a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a59d:	8b 40 14             	mov    0x14(%eax),%eax
f010a5a0:	85 c0                	test   %eax,%eax
f010a5a2:	74 11                	je     f010a5b5 <env_page_ws_invalidate+0x210>
f010a5a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5a7:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a5ad:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a5b0:	89 50 10             	mov    %edx,0x10(%eax)
f010a5b3:	eb 0c                	jmp    f010a5c1 <env_page_ws_invalidate+0x21c>
f010a5b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a5bb:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010a5c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a5c7:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a5cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a5d0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a5d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5da:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a5e0:	8d 50 01             	lea    0x1(%eax),%edx
f010a5e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e6:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a5ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a5ef:	8b 10                	mov    (%eax),%edx
f010a5f1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5f4:	8b 40 64             	mov    0x64(%eax),%eax
f010a5f7:	6a 00                	push   $0x0
f010a5f9:	6a 01                	push   $0x1
f010a5fb:	52                   	push   %edx
f010a5fc:	50                   	push   %eax
f010a5fd:	e8 30 fb ff ff       	call   f010a132 <pt_set_page_permissions>
f010a602:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a605:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a60c:	eb 43                	jmp    f010a651 <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a60e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a611:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a617:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a61a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a61e:	74 08                	je     f010a628 <env_page_ws_invalidate+0x283>
f010a620:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a623:	8b 40 10             	mov    0x10(%eax),%eax
f010a626:	eb 05                	jmp    f010a62d <env_page_ws_invalidate+0x288>
f010a628:	b8 00 00 00 00       	mov    $0x0,%eax
f010a62d:	8b 55 08             	mov    0x8(%ebp),%edx
f010a630:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010a636:	8b 45 08             	mov    0x8(%ebp),%eax
f010a639:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a63f:	85 c0                	test   %eax,%eax
f010a641:	0f 85 98 fd ff ff    	jne    f010a3df <env_page_ws_invalidate+0x3a>
f010a647:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a64b:	0f 85 8e fd ff ff    	jne    f010a3df <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a651:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a655:	0f 85 a4 02 00 00    	jne    f010a8ff <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a65b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a662:	8b 45 08             	mov    0x8(%ebp),%eax
f010a665:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a66b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a66e:	e9 f6 00 00 00       	jmp    f010a769 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a673:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a676:	8b 00                	mov    (%eax),%eax
f010a678:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a67b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a67e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a683:	89 c2                	mov    %eax,%edx
f010a685:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a688:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a68b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a68e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a693:	39 c2                	cmp    %eax,%edx
f010a695:	0f 85 c2 00 00 00    	jne    f010a75d <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a69b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a69e:	8b 10                	mov    (%eax),%edx
f010a6a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6a3:	8b 40 64             	mov    0x64(%eax),%eax
f010a6a6:	83 ec 08             	sub    $0x8,%esp
f010a6a9:	52                   	push   %edx
f010a6aa:	50                   	push   %eax
f010a6ab:	e8 29 e8 ff ff       	call   f0108ed9 <unmap_frame>
f010a6b0:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a6b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a6b7:	75 14                	jne    f010a6cd <env_page_ws_invalidate+0x328>
f010a6b9:	83 ec 04             	sub    $0x4,%esp
f010a6bc:	68 9b 7d 12 f0       	push   $0xf0127d9b
f010a6c1:	6a 49                	push   $0x49
f010a6c3:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a6c8:	e8 6c 5c ff ff       	call   f0100339 <_panic>
f010a6cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a6d0:	8b 40 10             	mov    0x10(%eax),%eax
f010a6d3:	85 c0                	test   %eax,%eax
f010a6d5:	74 11                	je     f010a6e8 <env_page_ws_invalidate+0x343>
f010a6d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a6da:	8b 40 10             	mov    0x10(%eax),%eax
f010a6dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a6e0:	8b 52 14             	mov    0x14(%edx),%edx
f010a6e3:	89 50 14             	mov    %edx,0x14(%eax)
f010a6e6:	eb 0f                	jmp    f010a6f7 <env_page_ws_invalidate+0x352>
f010a6e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a6eb:	8b 50 14             	mov    0x14(%eax),%edx
f010a6ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6f1:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a6f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a6fa:	8b 40 14             	mov    0x14(%eax),%eax
f010a6fd:	85 c0                	test   %eax,%eax
f010a6ff:	74 11                	je     f010a712 <env_page_ws_invalidate+0x36d>
f010a701:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a704:	8b 40 14             	mov    0x14(%eax),%eax
f010a707:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a70a:	8b 52 10             	mov    0x10(%edx),%edx
f010a70d:	89 50 10             	mov    %edx,0x10(%eax)
f010a710:	eb 0f                	jmp    f010a721 <env_page_ws_invalidate+0x37c>
f010a712:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a715:	8b 50 10             	mov    0x10(%eax),%edx
f010a718:	8b 45 08             	mov    0x8(%ebp),%eax
f010a71b:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010a721:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a724:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a72b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a72e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a735:	8b 45 08             	mov    0x8(%ebp),%eax
f010a738:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a73e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a741:	8b 45 08             	mov    0x8(%ebp),%eax
f010a744:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)

					kfree(ptr_WS_element);
f010a74a:	83 ec 0c             	sub    $0xc,%esp
f010a74d:	ff 75 f0             	pushl  -0x10(%ebp)
f010a750:	e8 7f f7 ff ff       	call   f0109ed4 <kfree>
f010a755:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a758:	e9 a2 01 00 00       	jmp    f010a8ff <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a75d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a760:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a766:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a769:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a76d:	74 08                	je     f010a777 <env_page_ws_invalidate+0x3d2>
f010a76f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a772:	8b 40 10             	mov    0x10(%eax),%eax
f010a775:	eb 05                	jmp    f010a77c <env_page_ws_invalidate+0x3d7>
f010a777:	b8 00 00 00 00       	mov    $0x0,%eax
f010a77c:	8b 55 08             	mov    0x8(%ebp),%edx
f010a77f:	89 82 7c 05 00 00    	mov    %eax,0x57c(%edx)
f010a785:	8b 45 08             	mov    0x8(%ebp),%eax
f010a788:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a78e:	85 c0                	test   %eax,%eax
f010a790:	0f 85 dd fe ff ff    	jne    f010a673 <env_page_ws_invalidate+0x2ce>
f010a796:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a79a:	0f 85 d3 fe ff ff    	jne    f010a673 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a7a0:	e9 5a 01 00 00       	jmp    f010a8ff <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a7a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7a8:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a7ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a7b1:	e9 10 01 00 00       	jmp    f010a8c6 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a7b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7b9:	8b 00                	mov    (%eax),%eax
f010a7bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a7be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a7c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a7c6:	89 c2                	mov    %eax,%edx
f010a7c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a7cb:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a7ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a7d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a7d6:	39 c2                	cmp    %eax,%edx
f010a7d8:	0f 85 dc 00 00 00    	jne    f010a8ba <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a7de:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a7e1:	8b 10                	mov    (%eax),%edx
f010a7e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7e6:	8b 40 64             	mov    0x64(%eax),%eax
f010a7e9:	83 ec 08             	sub    $0x8,%esp
f010a7ec:	52                   	push   %edx
f010a7ed:	50                   	push   %eax
f010a7ee:	e8 e6 e6 ff ff       	call   f0108ed9 <unmap_frame>
f010a7f3:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a7f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7f9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010a7ff:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a802:	75 0f                	jne    f010a813 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a804:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a807:	8b 50 10             	mov    0x10(%eax),%edx
f010a80a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a80d:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a813:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a817:	75 14                	jne    f010a82d <env_page_ws_invalidate+0x488>
f010a819:	83 ec 04             	sub    $0x4,%esp
f010a81c:	68 9b 7d 12 f0       	push   $0xf0127d9b
f010a821:	6a 5f                	push   $0x5f
f010a823:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010a828:	e8 0c 5b ff ff       	call   f0100339 <_panic>
f010a82d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a830:	8b 40 10             	mov    0x10(%eax),%eax
f010a833:	85 c0                	test   %eax,%eax
f010a835:	74 11                	je     f010a848 <env_page_ws_invalidate+0x4a3>
f010a837:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a83a:	8b 40 10             	mov    0x10(%eax),%eax
f010a83d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a840:	8b 52 14             	mov    0x14(%edx),%edx
f010a843:	89 50 14             	mov    %edx,0x14(%eax)
f010a846:	eb 0f                	jmp    f010a857 <env_page_ws_invalidate+0x4b2>
f010a848:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a84b:	8b 50 14             	mov    0x14(%eax),%edx
f010a84e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a851:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a857:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a85a:	8b 40 14             	mov    0x14(%eax),%eax
f010a85d:	85 c0                	test   %eax,%eax
f010a85f:	74 11                	je     f010a872 <env_page_ws_invalidate+0x4cd>
f010a861:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a864:	8b 40 14             	mov    0x14(%eax),%eax
f010a867:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a86a:	8b 52 10             	mov    0x10(%edx),%edx
f010a86d:	89 50 10             	mov    %edx,0x10(%eax)
f010a870:	eb 0f                	jmp    f010a881 <env_page_ws_invalidate+0x4dc>
f010a872:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a875:	8b 50 10             	mov    0x10(%eax),%edx
f010a878:	8b 45 08             	mov    0x8(%ebp),%eax
f010a87b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010a881:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a884:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a88b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a88e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a895:	8b 45 08             	mov    0x8(%ebp),%eax
f010a898:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010a89e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a8a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8a4:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)

				kfree(wse);
f010a8aa:	83 ec 0c             	sub    $0xc,%esp
f010a8ad:	ff 75 ec             	pushl  -0x14(%ebp)
f010a8b0:	e8 1f f6 ff ff       	call   f0109ed4 <kfree>
f010a8b5:	83 c4 10             	add    $0x10,%esp

				break;
f010a8b8:	eb 45                	jmp    f010a8ff <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a8ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8bd:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a8c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a8c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a8ca:	74 08                	je     f010a8d4 <env_page_ws_invalidate+0x52f>
f010a8cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8cf:	8b 40 10             	mov    0x10(%eax),%eax
f010a8d2:	eb 05                	jmp    f010a8d9 <env_page_ws_invalidate+0x534>
f010a8d4:	b8 00 00 00 00       	mov    $0x0,%eax
f010a8d9:	8b 55 08             	mov    0x8(%ebp),%edx
f010a8dc:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010a8e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8e5:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010a8eb:	85 c0                	test   %eax,%eax
f010a8ed:	0f 85 c3 fe ff ff    	jne    f010a7b6 <env_page_ws_invalidate+0x411>
f010a8f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a8f7:	0f 85 b9 fe ff ff    	jne    f010a7b6 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a8fd:	eb 00                	jmp    f010a8ff <env_page_ws_invalidate+0x55a>
f010a8ff:	90                   	nop
f010a900:	c9                   	leave  
f010a901:	c3                   	ret    

f010a902 <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a902:	55                   	push   %ebp
f010a903:	89 e5                	mov    %esp,%ebp
f010a905:	53                   	push   %ebx
f010a906:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a909:	83 ec 0c             	sub    $0xc,%esp
f010a90c:	6a 02                	push   $0x2
f010a90e:	e8 61 53 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010a913:	83 c4 10             	add    $0x10,%esp
f010a916:	85 c0                	test   %eax,%eax
f010a918:	0f 84 fe 00 00 00    	je     f010aa1c <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a91e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a925:	83 ec 0c             	sub    $0xc,%esp
f010a928:	68 df 7d 12 f0       	push   $0xf0127ddf
f010a92d:	e8 59 66 ff ff       	call   f0100f8b <cprintf>
f010a932:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a935:	8b 45 08             	mov    0x8(%ebp),%eax
f010a938:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a93e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a941:	eb 2c                	jmp    f010a96f <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a943:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a946:	8b 10                	mov    (%eax),%edx
f010a948:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a94b:	8d 48 01             	lea    0x1(%eax),%ecx
f010a94e:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a951:	83 ec 04             	sub    $0x4,%esp
f010a954:	52                   	push   %edx
f010a955:	50                   	push   %eax
f010a956:	68 f9 7d 12 f0       	push   $0xf0127df9
f010a95b:	e8 2b 66 ff ff       	call   f0100f8b <cprintf>
f010a960:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a963:	8b 45 08             	mov    0x8(%ebp),%eax
f010a966:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a96c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a96f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a973:	74 08                	je     f010a97d <env_page_ws_print+0x7b>
f010a975:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a978:	8b 40 10             	mov    0x10(%eax),%eax
f010a97b:	eb 05                	jmp    f010a982 <env_page_ws_print+0x80>
f010a97d:	b8 00 00 00 00       	mov    $0x0,%eax
f010a982:	8b 55 08             	mov    0x8(%ebp),%edx
f010a985:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010a98b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a98e:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a994:	85 c0                	test   %eax,%eax
f010a996:	75 ab                	jne    f010a943 <env_page_ws_print+0x41>
f010a998:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a99c:	75 a5                	jne    f010a943 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a99e:	83 ec 0c             	sub    $0xc,%esp
f010a9a1:	68 01 7e 12 f0       	push   $0xf0127e01
f010a9a6:	e8 e0 65 ff ff       	call   f0100f8b <cprintf>
f010a9ab:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a9ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9b1:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a9b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a9ba:	eb 2c                	jmp    f010a9e8 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a9bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a9bf:	8b 10                	mov    (%eax),%edx
f010a9c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9c4:	8d 48 01             	lea    0x1(%eax),%ecx
f010a9c7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a9ca:	83 ec 04             	sub    $0x4,%esp
f010a9cd:	52                   	push   %edx
f010a9ce:	50                   	push   %eax
f010a9cf:	68 f9 7d 12 f0       	push   $0xf0127df9
f010a9d4:	e8 b2 65 ff ff       	call   f0100f8b <cprintf>
f010a9d9:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a9dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9df:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010a9e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a9e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a9ec:	74 08                	je     f010a9f6 <env_page_ws_print+0xf4>
f010a9ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a9f1:	8b 40 10             	mov    0x10(%eax),%eax
f010a9f4:	eb 05                	jmp    f010a9fb <env_page_ws_print+0xf9>
f010a9f6:	b8 00 00 00 00       	mov    $0x0,%eax
f010a9fb:	8b 55 08             	mov    0x8(%ebp),%edx
f010a9fe:	89 82 7c 05 00 00    	mov    %eax,0x57c(%edx)
f010aa04:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa07:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010aa0d:	85 c0                	test   %eax,%eax
f010aa0f:	75 ab                	jne    f010a9bc <env_page_ws_print+0xba>
f010aa11:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010aa15:	75 a5                	jne    f010a9bc <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010aa17:	e9 5a 01 00 00       	jmp    f010ab76 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010aa1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010aa23:	83 ec 0c             	sub    $0xc,%esp
f010aa26:	68 1c 7e 12 f0       	push   $0xf0127e1c
f010aa2b:	e8 5b 65 ff ff       	call   f0100f8b <cprintf>
f010aa30:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010aa33:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010aa3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa3d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010aa43:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010aa46:	e9 d1 00 00 00       	jmp    f010ab1c <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010aa4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aa4e:	8b 00                	mov    (%eax),%eax
f010aa50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010aa53:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aa56:	8b 40 08             	mov    0x8(%eax),%eax
f010aa59:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010aa5c:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa5f:	8b 40 64             	mov    0x64(%eax),%eax
f010aa62:	83 ec 08             	sub    $0x8,%esp
f010aa65:	ff 75 e4             	pushl  -0x1c(%ebp)
f010aa68:	50                   	push   %eax
f010aa69:	e8 88 f7 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f010aa6e:	83 c4 10             	add    $0x10,%esp
f010aa71:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010aa74:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aa77:	83 e0 40             	and    $0x40,%eax
f010aa7a:	85 c0                	test   %eax,%eax
f010aa7c:	0f 95 c0             	setne  %al
f010aa7f:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010aa82:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aa85:	83 e0 20             	and    $0x20,%eax
f010aa88:	85 c0                	test   %eax,%eax
f010aa8a:	0f 95 c0             	setne  %al
f010aa8d:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010aa90:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010aa93:	25 00 02 00 00       	and    $0x200,%eax
f010aa98:	85 c0                	test   %eax,%eax
f010aa9a:	0f 95 c0             	setne  %al
f010aa9d:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010aaa0:	83 ec 04             	sub    $0x4,%esp
f010aaa3:	ff 75 e4             	pushl  -0x1c(%ebp)
f010aaa6:	ff 75 ec             	pushl  -0x14(%ebp)
f010aaa9:	68 26 7e 12 f0       	push   $0xf0127e26
f010aaae:	e8 d8 64 ff ff       	call   f0100f8b <cprintf>
f010aab3:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010aab6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010aab9:	8b 58 0c             	mov    0xc(%eax),%ebx
f010aabc:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010aac0:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010aac4:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010aac8:	83 ec 08             	sub    $0x8,%esp
f010aacb:	53                   	push   %ebx
f010aacc:	ff 75 e0             	pushl  -0x20(%ebp)
f010aacf:	51                   	push   %ecx
f010aad0:	52                   	push   %edx
f010aad1:	50                   	push   %eax
f010aad2:	68 30 7e 12 f0       	push   $0xf0127e30
f010aad7:	e8 af 64 ff ff       	call   f0100f8b <cprintf>
f010aadc:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010aadf:	8b 45 08             	mov    0x8(%ebp),%eax
f010aae2:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010aae8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010aaeb:	75 10                	jne    f010aafd <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010aaed:	83 ec 0c             	sub    $0xc,%esp
f010aaf0:	68 77 7e 12 f0       	push   $0xf0127e77
f010aaf5:	e8 91 64 ff ff       	call   f0100f8b <cprintf>
f010aafa:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010aafd:	83 ec 0c             	sub    $0xc,%esp
f010ab00:	68 7c 7e 12 f0       	push   $0xf0127e7c
f010ab05:	e8 81 64 ff ff       	call   f0100f8b <cprintf>
f010ab0a:	83 c4 10             	add    $0x10,%esp
			i++;
f010ab0d:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ab10:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab13:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ab19:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010ab1c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010ab20:	74 08                	je     f010ab2a <env_page_ws_print+0x228>
f010ab22:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ab25:	8b 40 10             	mov    0x10(%eax),%eax
f010ab28:	eb 05                	jmp    f010ab2f <env_page_ws_print+0x22d>
f010ab2a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ab2f:	8b 55 08             	mov    0x8(%ebp),%edx
f010ab32:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010ab38:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab3b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ab41:	85 c0                	test   %eax,%eax
f010ab43:	0f 85 02 ff ff ff    	jne    f010aa4b <env_page_ws_print+0x149>
f010ab49:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010ab4d:	0f 85 f8 fe ff ff    	jne    f010aa4b <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010ab53:	eb 13                	jmp    f010ab68 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010ab55:	83 ec 0c             	sub    $0xc,%esp
f010ab58:	68 7e 7e 12 f0       	push   $0xf0127e7e
f010ab5d:	e8 29 64 ff ff       	call   f0100f8b <cprintf>
f010ab62:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010ab65:	ff 45 ec             	incl   -0x14(%ebp)
f010ab68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab6b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ab71:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010ab74:	77 df                	ja     f010ab55 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010ab76:	90                   	nop
f010ab77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ab7a:	c9                   	leave  
f010ab7b:	c3                   	ret    

f010ab7c <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010ab7c:	55                   	push   %ebp
f010ab7d:	89 e5                	mov    %esp,%ebp
f010ab7f:	53                   	push   %ebx
f010ab80:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010ab83:	83 ec 0c             	sub    $0xc,%esp
f010ab86:	68 90 7e 12 f0       	push   $0xf0127e90
f010ab8b:	e8 fb 63 ff ff       	call   f0100f8b <cprintf>
f010ab90:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010ab93:	83 ec 0c             	sub    $0xc,%esp
f010ab96:	68 c5 7e 12 f0       	push   $0xf0127ec5
f010ab9b:	e8 eb 63 ff ff       	call   f0100f8b <cprintf>
f010aba0:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010aba3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010abaa:	e9 16 01 00 00       	jmp    f010acc5 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010abaf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010abb5:	89 d0                	mov    %edx,%eax
f010abb7:	01 c0                	add    %eax,%eax
f010abb9:	01 d0                	add    %edx,%eax
f010abbb:	c1 e0 03             	shl    $0x3,%eax
f010abbe:	01 c8                	add    %ecx,%eax
f010abc0:	05 b4 00 00 00       	add    $0xb4,%eax
f010abc5:	8a 00                	mov    (%eax),%al
f010abc7:	84 c0                	test   %al,%al
f010abc9:	74 43                	je     f010ac0e <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010abcb:	83 ec 0c             	sub    $0xc,%esp
f010abce:	68 d0 7e 12 f0       	push   $0xf0127ed0
f010abd3:	e8 b3 63 ff ff       	call   f0100f8b <cprintf>
f010abd8:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010abdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010abde:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010abe4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010abe7:	75 10                	jne    f010abf9 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010abe9:	83 ec 0c             	sub    $0xc,%esp
f010abec:	68 df 7e 12 f0       	push   $0xf0127edf
f010abf1:	e8 95 63 ff ff       	call   f0100f8b <cprintf>
f010abf6:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010abf9:	83 ec 0c             	sub    $0xc,%esp
f010abfc:	68 7c 7e 12 f0       	push   $0xf0127e7c
f010ac01:	e8 85 63 ff ff       	call   f0100f8b <cprintf>
f010ac06:	83 c4 10             	add    $0x10,%esp
			continue;
f010ac09:	e9 b4 00 00 00       	jmp    f010acc2 <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010ac0e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac11:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac14:	89 d0                	mov    %edx,%eax
f010ac16:	01 c0                	add    %eax,%eax
f010ac18:	01 d0                	add    %edx,%eax
f010ac1a:	c1 e0 03             	shl    $0x3,%eax
f010ac1d:	01 c8                	add    %ecx,%eax
f010ac1f:	05 b0 00 00 00       	add    $0xb0,%eax
f010ac24:	8b 00                	mov    (%eax),%eax
f010ac26:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010ac29:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac2f:	89 d0                	mov    %edx,%eax
f010ac31:	01 c0                	add    %eax,%eax
f010ac33:	01 d0                	add    %edx,%eax
f010ac35:	c1 e0 03             	shl    $0x3,%eax
f010ac38:	01 c8                	add    %ecx,%eax
f010ac3a:	05 b0 00 00 00       	add    $0xb0,%eax
f010ac3f:	8b 00                	mov    (%eax),%eax
f010ac41:	83 ec 04             	sub    $0x4,%esp
f010ac44:	50                   	push   %eax
f010ac45:	ff 75 f4             	pushl  -0xc(%ebp)
f010ac48:	68 e5 7e 12 f0       	push   $0xf0127ee5
f010ac4d:	e8 39 63 ff ff       	call   f0100f8b <cprintf>
f010ac52:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010ac55:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac58:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ac5b:	89 d0                	mov    %edx,%eax
f010ac5d:	01 c0                	add    %eax,%eax
f010ac5f:	01 d0                	add    %edx,%eax
f010ac61:	c1 e0 03             	shl    $0x3,%eax
f010ac64:	01 c8                	add    %ecx,%eax
f010ac66:	05 b8 00 00 00       	add    $0xb8,%eax
f010ac6b:	8b 18                	mov    (%eax),%ebx
f010ac6d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac70:	8b 40 64             	mov    0x64(%eax),%eax
f010ac73:	83 ec 08             	sub    $0x8,%esp
f010ac76:	ff 75 f0             	pushl  -0x10(%ebp)
f010ac79:	50                   	push   %eax
f010ac7a:	e8 53 f6 ff ff       	call   f010a2d2 <pd_is_table_used>
f010ac7f:	83 c4 10             	add    $0x10,%esp
f010ac82:	83 ec 04             	sub    $0x4,%esp
f010ac85:	53                   	push   %ebx
f010ac86:	50                   	push   %eax
f010ac87:	68 fc 7e 12 f0       	push   $0xf0127efc
f010ac8c:	e8 fa 62 ff ff       	call   f0100f8b <cprintf>
f010ac91:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010ac94:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac97:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010ac9d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010aca0:	75 10                	jne    f010acb2 <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010aca2:	83 ec 0c             	sub    $0xc,%esp
f010aca5:	68 77 7e 12 f0       	push   $0xf0127e77
f010acaa:	e8 dc 62 ff ff       	call   f0100f8b <cprintf>
f010acaf:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010acb2:	83 ec 0c             	sub    $0xc,%esp
f010acb5:	68 7c 7e 12 f0       	push   $0xf0127e7c
f010acba:	e8 cc 62 ff ff       	call   f0100f8b <cprintf>
f010acbf:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010acc2:	ff 45 f4             	incl   -0xc(%ebp)
f010acc5:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010acc9:	0f 86 e0 fe ff ff    	jbe    f010abaf <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010accf:	90                   	nop
f010acd0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010acd3:	c9                   	leave  
f010acd4:	c3                   	ret    

f010acd5 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010acd5:	55                   	push   %ebp
f010acd6:	89 e5                	mov    %esp,%ebp
f010acd8:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010acdb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010ace2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010ace9:	eb 22                	jmp    f010ad0d <env_table_ws_get_size+0x38>
f010aceb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010acee:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010acf1:	89 d0                	mov    %edx,%eax
f010acf3:	01 c0                	add    %eax,%eax
f010acf5:	01 d0                	add    %edx,%eax
f010acf7:	c1 e0 03             	shl    $0x3,%eax
f010acfa:	01 c8                	add    %ecx,%eax
f010acfc:	05 b4 00 00 00       	add    $0xb4,%eax
f010ad01:	8a 00                	mov    (%eax),%al
f010ad03:	84 c0                	test   %al,%al
f010ad05:	75 03                	jne    f010ad0a <env_table_ws_get_size+0x35>
f010ad07:	ff 45 f8             	incl   -0x8(%ebp)
f010ad0a:	ff 45 fc             	incl   -0x4(%ebp)
f010ad0d:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010ad11:	7e d8                	jle    f010aceb <env_table_ws_get_size+0x16>
	return counter;
f010ad13:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010ad16:	c9                   	leave  
f010ad17:	c3                   	ret    

f010ad18 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010ad18:	55                   	push   %ebp
f010ad19:	89 e5                	mov    %esp,%ebp
f010ad1b:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010ad1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010ad25:	eb 4e                	jmp    f010ad75 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010ad27:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad2d:	89 d0                	mov    %edx,%eax
f010ad2f:	01 c0                	add    %eax,%eax
f010ad31:	01 d0                	add    %edx,%eax
f010ad33:	c1 e0 03             	shl    $0x3,%eax
f010ad36:	01 c8                	add    %ecx,%eax
f010ad38:	05 b0 00 00 00       	add    $0xb0,%eax
f010ad3d:	8b 00                	mov    (%eax),%eax
f010ad3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ad42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ad45:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ad4a:	89 c2                	mov    %eax,%edx
f010ad4c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ad52:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ad55:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010ad5a:	39 c2                	cmp    %eax,%edx
f010ad5c:	75 14                	jne    f010ad72 <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010ad5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad61:	83 ec 08             	sub    $0x8,%esp
f010ad64:	50                   	push   %eax
f010ad65:	ff 75 08             	pushl  0x8(%ebp)
f010ad68:	e8 bc 00 00 00       	call   f010ae29 <env_table_ws_clear_entry>
f010ad6d:	83 c4 10             	add    $0x10,%esp
			break;
f010ad70:	eb 09                	jmp    f010ad7b <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010ad72:	ff 45 f4             	incl   -0xc(%ebp)
f010ad75:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010ad79:	7e ac                	jle    f010ad27 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010ad7b:	90                   	nop
f010ad7c:	c9                   	leave  
f010ad7d:	c3                   	ret    

f010ad7e <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010ad7e:	55                   	push   %ebp
f010ad7f:	89 e5                	mov    %esp,%ebp
f010ad81:	53                   	push   %ebx
f010ad82:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ad85:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ad89:	76 19                	jbe    f010ada4 <env_table_ws_set_entry+0x26>
f010ad8b:	68 20 7f 12 f0       	push   $0xf0127f20
f010ad90:	68 51 7f 12 f0       	push   $0xf0127f51
f010ad95:	68 42 01 00 00       	push   $0x142
f010ad9a:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010ad9f:	e8 95 55 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010ada4:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010adab:	76 19                	jbe    f010adc6 <env_table_ws_set_entry+0x48>
f010adad:	68 68 7f 12 f0       	push   $0xf0127f68
f010adb2:	68 51 7f 12 f0       	push   $0xf0127f51
f010adb7:	68 43 01 00 00       	push   $0x143
f010adbc:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010adc1:	e8 73 55 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010adc6:	8b 45 10             	mov    0x10(%ebp),%eax
f010adc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010adcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010adcf:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010add4:	89 c1                	mov    %eax,%ecx
f010add6:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010add9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010addc:	89 d0                	mov    %edx,%eax
f010adde:	01 c0                	add    %eax,%eax
f010ade0:	01 d0                	add    %edx,%eax
f010ade2:	c1 e0 03             	shl    $0x3,%eax
f010ade5:	01 d8                	add    %ebx,%eax
f010ade7:	05 b0 00 00 00       	add    $0xb0,%eax
f010adec:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010adee:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010adf1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010adf4:	89 d0                	mov    %edx,%eax
f010adf6:	01 c0                	add    %eax,%eax
f010adf8:	01 d0                	add    %edx,%eax
f010adfa:	c1 e0 03             	shl    $0x3,%eax
f010adfd:	01 c8                	add    %ecx,%eax
f010adff:	05 b4 00 00 00       	add    $0xb4,%eax
f010ae04:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f010ae07:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae0a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ae0d:	89 d0                	mov    %edx,%eax
f010ae0f:	01 c0                	add    %eax,%eax
f010ae11:	01 d0                	add    %edx,%eax
f010ae13:	c1 e0 03             	shl    $0x3,%eax
f010ae16:	01 c8                	add    %ecx,%eax
f010ae18:	05 b8 00 00 00       	add    $0xb8,%eax
f010ae1d:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010ae23:	90                   	nop
}
f010ae24:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ae27:	c9                   	leave  
f010ae28:	c3                   	ret    

f010ae29 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010ae29:	55                   	push   %ebp
f010ae2a:	89 e5                	mov    %esp,%ebp
f010ae2c:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ae2f:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ae33:	76 19                	jbe    f010ae4e <env_table_ws_clear_entry+0x25>
f010ae35:	68 20 7f 12 f0       	push   $0xf0127f20
f010ae3a:	68 51 7f 12 f0       	push   $0xf0127f51
f010ae3f:	68 4e 01 00 00       	push   $0x14e
f010ae44:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010ae49:	e8 eb 54 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010ae4e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae51:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ae54:	89 d0                	mov    %edx,%eax
f010ae56:	01 c0                	add    %eax,%eax
f010ae58:	01 d0                	add    %edx,%eax
f010ae5a:	c1 e0 03             	shl    $0x3,%eax
f010ae5d:	01 c8                	add    %ecx,%eax
f010ae5f:	05 b0 00 00 00       	add    $0xb0,%eax
f010ae64:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010ae6a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae6d:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ae70:	89 d0                	mov    %edx,%eax
f010ae72:	01 c0                	add    %eax,%eax
f010ae74:	01 d0                	add    %edx,%eax
f010ae76:	c1 e0 03             	shl    $0x3,%eax
f010ae79:	01 c8                	add    %ecx,%eax
f010ae7b:	05 b4 00 00 00       	add    $0xb4,%eax
f010ae80:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010ae83:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae86:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ae89:	89 d0                	mov    %edx,%eax
f010ae8b:	01 c0                	add    %eax,%eax
f010ae8d:	01 d0                	add    %edx,%eax
f010ae8f:	c1 e0 03             	shl    $0x3,%eax
f010ae92:	01 c8                	add    %ecx,%eax
f010ae94:	05 b8 00 00 00       	add    $0xb8,%eax
f010ae99:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010ae9f:	90                   	nop
f010aea0:	c9                   	leave  
f010aea1:	c3                   	ret    

f010aea2 <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aea2:	55                   	push   %ebp
f010aea3:	89 e5                	mov    %esp,%ebp
f010aea5:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aea8:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aeac:	76 19                	jbe    f010aec7 <env_table_ws_get_virtual_address+0x25>
f010aeae:	68 20 7f 12 f0       	push   $0xf0127f20
f010aeb3:	68 51 7f 12 f0       	push   $0xf0127f51
f010aeb8:	68 56 01 00 00       	push   $0x156
f010aebd:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010aec2:	e8 72 54 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aec7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aeca:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aecd:	89 d0                	mov    %edx,%eax
f010aecf:	01 c0                	add    %eax,%eax
f010aed1:	01 d0                	add    %edx,%eax
f010aed3:	c1 e0 03             	shl    $0x3,%eax
f010aed6:	01 c8                	add    %ecx,%eax
f010aed8:	05 b0 00 00 00       	add    $0xb0,%eax
f010aedd:	8b 00                	mov    (%eax),%eax
f010aedf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aee2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aee5:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aeea:	c9                   	leave  
f010aeeb:	c3                   	ret    

f010aeec <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aeec:	55                   	push   %ebp
f010aeed:	89 e5                	mov    %esp,%ebp
f010aeef:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aef2:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aef6:	76 19                	jbe    f010af11 <env_table_ws_get_time_stamp+0x25>
f010aef8:	68 20 7f 12 f0       	push   $0xf0127f20
f010aefd:	68 51 7f 12 f0       	push   $0xf0127f51
f010af02:	68 5d 01 00 00       	push   $0x15d
f010af07:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010af0c:	e8 28 54 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010af11:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af14:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af17:	89 d0                	mov    %edx,%eax
f010af19:	01 c0                	add    %eax,%eax
f010af1b:	01 d0                	add    %edx,%eax
f010af1d:	c1 e0 03             	shl    $0x3,%eax
f010af20:	01 c8                	add    %ecx,%eax
f010af22:	05 b8 00 00 00       	add    $0xb8,%eax
f010af27:	8b 00                	mov    (%eax),%eax
}
f010af29:	c9                   	leave  
f010af2a:	c3                   	ret    

f010af2b <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010af2b:	55                   	push   %ebp
f010af2c:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010af2e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af31:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af34:	89 d0                	mov    %edx,%eax
f010af36:	01 c0                	add    %eax,%eax
f010af38:	01 d0                	add    %edx,%eax
f010af3a:	c1 e0 03             	shl    $0x3,%eax
f010af3d:	01 c8                	add    %ecx,%eax
f010af3f:	05 b4 00 00 00       	add    $0xb4,%eax
f010af44:	8a 00                	mov    (%eax),%al
f010af46:	0f b6 c0             	movzbl %al,%eax
}
f010af49:	5d                   	pop    %ebp
f010af4a:	c3                   	ret    

f010af4b <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010af4b:	55                   	push   %ebp
f010af4c:	89 e5                	mov    %esp,%ebp
f010af4e:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010af51:	83 ec 04             	sub    $0x4,%esp
f010af54:	68 9b 7f 12 f0       	push   $0xf0127f9b
f010af59:	68 6d 01 00 00       	push   $0x16d
f010af5e:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010af63:	e8 d1 53 ff ff       	call   f0100339 <_panic>

f010af68 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010af68:	55                   	push   %ebp
f010af69:	89 e5                	mov    %esp,%ebp
f010af6b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010af6e:	83 ec 04             	sub    $0x4,%esp
f010af71:	68 9b 7f 12 f0       	push   $0xf0127f9b
f010af76:	68 72 01 00 00       	push   $0x172
f010af7b:	68 7c 7d 12 f0       	push   $0xf0127d7c
f010af80:	e8 b4 53 ff ff       	call   f0100339 <_panic>

f010af85 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va,
		uint32 num_of_pages) {
f010af85:	55                   	push   %ebp
f010af86:	89 e5                	mov    %esp,%ebp
f010af88:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f010af8b:	83 ec 04             	sub    $0x4,%esp
f010af8e:	68 ac 7f 12 f0       	push   $0xf0127fac
f010af93:	6a 21                	push   $0x21
f010af95:	68 da 7f 12 f0       	push   $0xf0127fda
f010af9a:	e8 9a 53 ff ff       	call   f0100339 <_panic>

f010af9f <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va,
		uint32 size) {
f010af9f:	55                   	push   %ebp
f010afa0:	89 e5                	mov    %esp,%ebp
f010afa2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010afa5:	83 ec 04             	sub    $0x4,%esp
f010afa8:	68 f8 7f 12 f0       	push   $0xf0127ff8
f010afad:	6a 34                	push   $0x34
f010afaf:	68 da 7f 12 f0       	push   $0xf0127fda
f010afb4:	e8 80 53 ff ff       	call   f0100339 <_panic>

f010afb9 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va,
		uint32 size, uint32 perms) {
f010afb9:	55                   	push   %ebp
f010afba:	89 e5                	mov    %esp,%ebp
f010afbc:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010afbf:	83 ec 04             	sub    $0x4,%esp
f010afc2:	68 28 80 12 f0       	push   $0xf0128028
f010afc7:	6a 44                	push   $0x44
f010afc9:	68 da 7f 12 f0       	push   $0xf0127fda
f010afce:	e8 66 53 ff ff       	call   f0100339 <_panic>

f010afd3 <allocate_chunk>:
//===============================
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms) {
f010afd3:	55                   	push   %ebp
f010afd4:	89 e5                	mov    %esp,%ebp
f010afd6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f010afd9:	83 ec 04             	sub    $0x4,%esp
f010afdc:	68 54 80 12 f0       	push   $0xf0128054
f010afe1:	6a 51                	push   $0x51
f010afe3:	68 da 7f 12 f0       	push   $0xf0127fda
f010afe8:	e8 4c 53 ff ff       	call   f0100339 <_panic>

f010afed <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva,
		uint32 *num_tables, uint32 *num_pages) {
f010afed:	55                   	push   %ebp
f010afee:	89 e5                	mov    %esp,%ebp
f010aff0:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010aff3:	83 ec 04             	sub    $0x4,%esp
f010aff6:	68 84 80 12 f0       	push   $0xf0128084
f010affb:	6a 5b                	push   $0x5b
f010affd:	68 da 7f 12 f0       	push   $0xf0127fda
f010b002:	e8 32 53 ff ff       	call   f0100339 <_panic>

f010b007 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva,
		uint32 size) {
f010b007:	55                   	push   %ebp
f010b008:	89 e5                	mov    %esp,%ebp
f010b00a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f010b00d:	83 ec 04             	sub    $0x4,%esp
f010b010:	68 bc 80 12 f0       	push   $0xf01280bc
f010b015:	6a 68                	push   $0x68
f010b017:	68 da 7f 12 f0       	push   $0xf0127fda
f010b01c:	e8 18 53 ff ff       	call   f0100339 <_panic>

f010b021 <sys_sbrk>:
/// functions used for USER HEAP (malloc, free, ...)
//======================================================
//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages) {
f010b021:	55                   	push   %ebp
f010b022:	89 e5                	mov    %esp,%ebp
f010b024:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
	//return (void*)-1 ;
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f010b027:	e8 18 0f 00 00       	call   f010bf44 <get_cpu_proc>
f010b02c:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (numOfPages == 0) {
f010b02f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b033:	75 08                	jne    f010b03d <sys_sbrk+0x1c>
		return (void *) env->uheapBreak;
f010b035:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b038:	8b 40 78             	mov    0x78(%eax),%eax
f010b03b:	eb 53                	jmp    f010b090 <sys_sbrk+0x6f>
	}
	uint32 newBrk = env->uheapBreak + (numOfPages * PAGE_SIZE);
f010b03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b040:	8b 40 78             	mov    0x78(%eax),%eax
f010b043:	8b 55 08             	mov    0x8(%ebp),%edx
f010b046:	c1 e2 0c             	shl    $0xc,%edx
f010b049:	01 d0                	add    %edx,%eax
f010b04b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (newBrk > env->uheapHardLimit) {
f010b04e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b051:	8b 40 7c             	mov    0x7c(%eax),%eax
f010b054:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010b057:	73 07                	jae    f010b060 <sys_sbrk+0x3f>
		return (void*) -1;
f010b059:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010b05e:	eb 30                	jmp    f010b090 <sys_sbrk+0x6f>
	}
	void * oldBreak = (void*) env->uheapBreak;
f010b060:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b063:	8b 40 78             	mov    0x78(%eax),%eax
f010b066:	89 45 ec             	mov    %eax,-0x14(%ebp)
	allocate_user_mem(env, (uint32) oldBreak,
			(uint32) (numOfPages * PAGE_SIZE));
f010b069:	8b 45 08             	mov    0x8(%ebp),%eax
f010b06c:	c1 e0 0c             	shl    $0xc,%eax

	if (newBrk > env->uheapHardLimit) {
		return (void*) -1;
	}
	void * oldBreak = (void*) env->uheapBreak;
	allocate_user_mem(env, (uint32) oldBreak,
f010b06f:	89 c2                	mov    %eax,%edx
f010b071:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b074:	83 ec 04             	sub    $0x4,%esp
f010b077:	52                   	push   %edx
f010b078:	50                   	push   %eax
f010b079:	ff 75 f4             	pushl  -0xc(%ebp)
f010b07c:	e8 11 00 00 00       	call   f010b092 <allocate_user_mem>
f010b081:	83 c4 10             	add    $0x10,%esp
			(uint32) (numOfPages * PAGE_SIZE));
	env->uheapBreak = newBrk;
f010b084:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b087:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b08a:	89 50 78             	mov    %edx,0x78(%eax)

	return oldBreak;
f010b08d:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f010b090:	c9                   	leave  
f010b091:	c3                   	ret    

f010b092 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size) {
f010b092:	55                   	push   %ebp
f010b093:	89 e5                	mov    %esp,%ebp
f010b095:	83 ec 18             	sub    $0x18,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
	//panic("allocate_user_mem() is not implemented yet...!!");
	for (uint32 i = virtual_address; i < virtual_address + size; i += PAGE_SIZE)
f010b098:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b09b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b09e:	eb 62                	jmp    f010b102 <allocate_user_mem+0x70>
	{

		uint32 * pageTable = NULL;
f010b0a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		int ret = get_page_table(e->env_page_directory, i, &pageTable);
f010b0a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0aa:	8b 40 64             	mov    0x64(%eax),%eax
f010b0ad:	83 ec 04             	sub    $0x4,%esp
f010b0b0:	8d 55 ec             	lea    -0x14(%ebp),%edx
f010b0b3:	52                   	push   %edx
f010b0b4:	ff 75 f4             	pushl  -0xc(%ebp)
f010b0b7:	50                   	push   %eax
f010b0b8:	e8 23 da ff ff       	call   f0108ae0 <get_page_table>
f010b0bd:	83 c4 10             	add    $0x10,%esp
f010b0c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (ret == TABLE_NOT_EXIST) {
f010b0c3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010b0c7:	75 19                	jne    f010b0e2 <allocate_user_mem+0x50>
			if (create_page_table(e->env_page_directory, i) == NULL) {
f010b0c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0cc:	8b 40 64             	mov    0x64(%eax),%eax
f010b0cf:	83 ec 08             	sub    $0x8,%esp
f010b0d2:	ff 75 f4             	pushl  -0xc(%ebp)
f010b0d5:	50                   	push   %eax
f010b0d6:	e8 5b db ff ff       	call   f0108c36 <create_page_table>
f010b0db:	83 c4 10             	add    $0x10,%esp
f010b0de:	85 c0                	test   %eax,%eax
f010b0e0:	74 2f                	je     f010b111 <allocate_user_mem+0x7f>
				return;
			}
		}
		pt_set_page_permissions(e->env_page_directory, i, PERM_AVAILABLE, 0);
f010b0e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0e5:	8b 40 64             	mov    0x64(%eax),%eax
f010b0e8:	6a 00                	push   $0x0
f010b0ea:	68 00 0e 00 00       	push   $0xe00
f010b0ef:	ff 75 f4             	pushl  -0xc(%ebp)
f010b0f2:	50                   	push   %eax
f010b0f3:	e8 3a f0 ff ff       	call   f010a132 <pt_set_page_permissions>
f010b0f8:	83 c4 10             	add    $0x10,%esp
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
	//panic("allocate_user_mem() is not implemented yet...!!");
	for (uint32 i = virtual_address; i < virtual_address + size; i += PAGE_SIZE)
f010b0fb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b102:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b105:	8b 45 10             	mov    0x10(%ebp),%eax
f010b108:	01 d0                	add    %edx,%eax
f010b10a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b10d:	77 91                	ja     f010b0a0 <allocate_user_mem+0xe>
f010b10f:	eb 01                	jmp    f010b112 <allocate_user_mem+0x80>

		uint32 * pageTable = NULL;
		int ret = get_page_table(e->env_page_directory, i, &pageTable);
		if (ret == TABLE_NOT_EXIST) {
			if (create_page_table(e->env_page_directory, i) == NULL) {
				return;
f010b111:	90                   	nop
		}
		pt_set_page_permissions(e->env_page_directory, i, PERM_AVAILABLE, 0);

	}

}
f010b112:	c9                   	leave  
f010b113:	c3                   	ret    

f010b114 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================

void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size) {
f010b114:	55                   	push   %ebp
f010b115:	89 e5                	mov    %esp,%ebp
f010b117:	83 ec 18             	sub    $0x18,%esp

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
	//panic("free_user_mem() is not implemented yet...!!");
	//TODO: [PROJECT'24.MS2 - BONUS#3] [3] USER HEAP [KERNEL SIDE] - O(1) free_user_mem
	pt_set_page_permissions(e->env_page_directory, virtual_address, 0,
f010b11a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b11d:	8b 40 64             	mov    0x64(%eax),%eax
f010b120:	68 00 0e 00 00       	push   $0xe00
f010b125:	6a 00                	push   $0x0
f010b127:	ff 75 0c             	pushl  0xc(%ebp)
f010b12a:	50                   	push   %eax
f010b12b:	e8 02 f0 ff ff       	call   f010a132 <pt_set_page_permissions>
f010b130:	83 c4 10             	add    $0x10,%esp
			PERM_AVAILABLE);
	// Free ALL pages of the given range from the Page File
	pf_remove_env_page(e, virtual_address);
f010b133:	83 ec 08             	sub    $0x8,%esp
f010b136:	ff 75 0c             	pushl  0xc(%ebp)
f010b139:	ff 75 08             	pushl  0x8(%ebp)
f010b13c:	e8 76 96 ff ff       	call   f01047b7 <pf_remove_env_page>
f010b141:	83 c4 10             	add    $0x10,%esp
	// Free ONLY pages that are resident in the working set from the memory
	env_page_ws_invalidate(e, virtual_address);
f010b144:	83 ec 08             	sub    $0x8,%esp
f010b147:	ff 75 0c             	pushl  0xc(%ebp)
f010b14a:	ff 75 08             	pushl  0x8(%ebp)
f010b14d:	e8 53 f2 ff ff       	call   f010a3a5 <env_page_ws_invalidate>
f010b152:	83 c4 10             	add    $0x10,%esp
	if (e->isFirstTimeToBeMax) {
f010b155:	8b 45 08             	mov    0x8(%ebp),%eax
f010b158:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010b15e:	85 c0                	test   %eax,%eax
f010b160:	0f 84 88 01 00 00    	je     f010b2ee <free_user_mem+0x1da>
		struct WorkingSetElement * ss = NULL;
f010b166:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ss , &(e->page_WS_list))
f010b16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b170:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b176:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b179:	e9 36 01 00 00       	jmp    f010b2b4 <free_user_mem+0x1a0>
		{
			if (ss == e->page_last_WS_element) {
f010b17e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b181:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f010b187:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b18a:	0f 84 5d 01 00 00    	je     f010b2ed <free_user_mem+0x1d9>
				break;
			} else {
				LIST_REMOVE(&(e->page_WS_list), ss);
f010b190:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b194:	75 17                	jne    f010b1ad <free_user_mem+0x99>
f010b196:	83 ec 04             	sub    $0x4,%esp
f010b199:	68 f4 80 12 f0       	push   $0xf01280f4
f010b19e:	68 d9 00 00 00       	push   $0xd9
f010b1a3:	68 da 7f 12 f0       	push   $0xf0127fda
f010b1a8:	e8 8c 51 ff ff       	call   f0100339 <_panic>
f010b1ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1b0:	8b 40 10             	mov    0x10(%eax),%eax
f010b1b3:	85 c0                	test   %eax,%eax
f010b1b5:	74 11                	je     f010b1c8 <free_user_mem+0xb4>
f010b1b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1ba:	8b 40 10             	mov    0x10(%eax),%eax
f010b1bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1c0:	8b 52 14             	mov    0x14(%edx),%edx
f010b1c3:	89 50 14             	mov    %edx,0x14(%eax)
f010b1c6:	eb 0f                	jmp    f010b1d7 <free_user_mem+0xc3>
f010b1c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1cb:	8b 50 14             	mov    0x14(%eax),%edx
f010b1ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1d1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b1d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1da:	8b 40 14             	mov    0x14(%eax),%eax
f010b1dd:	85 c0                	test   %eax,%eax
f010b1df:	74 11                	je     f010b1f2 <free_user_mem+0xde>
f010b1e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1e4:	8b 40 14             	mov    0x14(%eax),%eax
f010b1e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1ea:	8b 52 10             	mov    0x10(%edx),%edx
f010b1ed:	89 50 10             	mov    %edx,0x10(%eax)
f010b1f0:	eb 0f                	jmp    f010b201 <free_user_mem+0xed>
f010b1f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1f5:	8b 50 10             	mov    0x10(%eax),%edx
f010b1f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1fb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b201:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b204:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b20b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b20e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b215:	8b 45 08             	mov    0x8(%ebp),%eax
f010b218:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010b21e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b221:	8b 45 08             	mov    0x8(%ebp),%eax
f010b224:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				LIST_INSERT_TAIL(&(e->page_WS_list), ss);
f010b22a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b22e:	75 17                	jne    f010b247 <free_user_mem+0x133>
f010b230:	83 ec 04             	sub    $0x4,%esp
f010b233:	68 14 81 12 f0       	push   $0xf0128114
f010b238:	68 da 00 00 00       	push   $0xda
f010b23d:	68 da 7f 12 f0       	push   $0xf0127fda
f010b242:	e8 f2 50 ff ff       	call   f0100339 <_panic>
f010b247:	8b 45 08             	mov    0x8(%ebp),%eax
f010b24a:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010b250:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b253:	89 50 14             	mov    %edx,0x14(%eax)
f010b256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b259:	8b 40 14             	mov    0x14(%eax),%eax
f010b25c:	85 c0                	test   %eax,%eax
f010b25e:	74 11                	je     f010b271 <free_user_mem+0x15d>
f010b260:	8b 45 08             	mov    0x8(%ebp),%eax
f010b263:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010b269:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b26c:	89 50 10             	mov    %edx,0x10(%eax)
f010b26f:	eb 0c                	jmp    f010b27d <free_user_mem+0x169>
f010b271:	8b 45 08             	mov    0x8(%ebp),%eax
f010b274:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b277:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010b27d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b280:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b283:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b289:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b28c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b293:	8b 45 08             	mov    0x8(%ebp),%eax
f010b296:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010b29c:	8d 50 01             	lea    0x1(%eax),%edx
f010b29f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2a2:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	pf_remove_env_page(e, virtual_address);
	// Free ONLY pages that are resident in the working set from the memory
	env_page_ws_invalidate(e, virtual_address);
	if (e->isFirstTimeToBeMax) {
		struct WorkingSetElement * ss = NULL;
		LIST_FOREACH(ss , &(e->page_WS_list))
f010b2a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2ab:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b2b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b2b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b2b8:	74 08                	je     f010b2c2 <free_user_mem+0x1ae>
f010b2ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b2bd:	8b 40 10             	mov    0x10(%eax),%eax
f010b2c0:	eb 05                	jmp    f010b2c7 <free_user_mem+0x1b3>
f010b2c2:	b8 00 00 00 00       	mov    $0x0,%eax
f010b2c7:	8b 55 08             	mov    0x8(%ebp),%edx
f010b2ca:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f010b2d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2d3:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010b2d9:	85 c0                	test   %eax,%eax
f010b2db:	0f 85 9d fe ff ff    	jne    f010b17e <free_user_mem+0x6a>
f010b2e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b2e5:	0f 85 93 fe ff ff    	jne    f010b17e <free_user_mem+0x6a>
				LIST_REMOVE(&(e->page_WS_list), ss);
				LIST_INSERT_TAIL(&(e->page_WS_list), ss);
			}
		}
	}
}
f010b2eb:	eb 01                	jmp    f010b2ee <free_user_mem+0x1da>
	if (e->isFirstTimeToBeMax) {
		struct WorkingSetElement * ss = NULL;
		LIST_FOREACH(ss , &(e->page_WS_list))
		{
			if (ss == e->page_last_WS_element) {
				break;
f010b2ed:	90                   	nop
				LIST_REMOVE(&(e->page_WS_list), ss);
				LIST_INSERT_TAIL(&(e->page_WS_list), ss);
			}
		}
	}
}
f010b2ee:	90                   	nop
f010b2ef:	c9                   	leave  
f010b2f0:	c3                   	ret    

f010b2f1 <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address,
		uint32 size) {
f010b2f1:	55                   	push   %ebp
f010b2f2:	89 e5                	mov    %esp,%ebp
f010b2f4:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010b2f7:	83 ec 04             	sub    $0x4,%esp
f010b2fa:	68 38 81 12 f0       	push   $0xf0128138
f010b2ff:	68 e6 00 00 00       	push   $0xe6
f010b304:	68 da 7f 12 f0       	push   $0xf0127fda
f010b309:	e8 2b 50 ff ff       	call   f0100339 <_panic>

f010b30e <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address,
		uint32 dst_virtual_address, uint32 size) {
f010b30e:	55                   	push   %ebp
f010b30f:	89 e5                	mov    %esp,%ebp
f010b311:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010b314:	83 ec 04             	sub    $0x4,%esp
f010b317:	68 78 81 12 f0       	push   $0xf0128178
f010b31c:	68 f0 00 00 00       	push   $0xf0
f010b321:	68 da 7f 12 f0       	push   $0xf0127fda
f010b326:	e8 0e 50 ff ff       	call   f0100339 <_panic>

f010b32b <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010b32b:	55                   	push   %ebp
f010b32c:	89 e5                	mov    %esp,%ebp
f010b32e:	53                   	push   %ebx
f010b32f:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010b332:	c7 45 f4 c5 02 00 00 	movl   $0x2c5,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010b339:	e9 78 01 00 00       	jmp    f010b4b6 <env_init+0x18b>
	{
		envs[iEnv].env_status = ENV_FREE;
f010b33e:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b344:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b347:	89 d0                	mov    %edx,%eax
f010b349:	c1 e0 02             	shl    $0x2,%eax
f010b34c:	01 d0                	add    %edx,%eax
f010b34e:	c1 e0 03             	shl    $0x3,%eax
f010b351:	01 d0                	add    %edx,%eax
f010b353:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b35a:	01 d0                	add    %edx,%eax
f010b35c:	c1 e0 02             	shl    $0x2,%eax
f010b35f:	01 c8                	add    %ecx,%eax
f010b361:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010b368:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b36e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b371:	89 d0                	mov    %edx,%eax
f010b373:	c1 e0 02             	shl    $0x2,%eax
f010b376:	01 d0                	add    %edx,%eax
f010b378:	c1 e0 03             	shl    $0x3,%eax
f010b37b:	01 d0                	add    %edx,%eax
f010b37d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b384:	01 d0                	add    %edx,%eax
f010b386:	c1 e0 02             	shl    $0x2,%eax
f010b389:	01 c8                	add    %ecx,%eax
f010b38b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010b392:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b398:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b39b:	89 d0                	mov    %edx,%eax
f010b39d:	c1 e0 02             	shl    $0x2,%eax
f010b3a0:	01 d0                	add    %edx,%eax
f010b3a2:	c1 e0 03             	shl    $0x3,%eax
f010b3a5:	01 d0                	add    %edx,%eax
f010b3a7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b3ae:	01 d0                	add    %edx,%eax
f010b3b0:	c1 e0 02             	shl    $0x2,%eax
f010b3b3:	01 c8                	add    %ecx,%eax
f010b3b5:	85 c0                	test   %eax,%eax
f010b3b7:	75 14                	jne    f010b3cd <env_init+0xa2>
f010b3b9:	83 ec 04             	sub    $0x4,%esp
f010b3bc:	68 a4 81 12 f0       	push   $0xf01281a4
f010b3c1:	6a 64                	push   $0x64
f010b3c3:	68 c7 81 12 f0       	push   $0xf01281c7
f010b3c8:	e8 6c 4f ff ff       	call   f0100339 <_panic>
f010b3cd:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b3d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b3d6:	89 d0                	mov    %edx,%eax
f010b3d8:	c1 e0 02             	shl    $0x2,%eax
f010b3db:	01 d0                	add    %edx,%eax
f010b3dd:	c1 e0 03             	shl    $0x3,%eax
f010b3e0:	01 d0                	add    %edx,%eax
f010b3e2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b3e9:	01 d0                	add    %edx,%eax
f010b3eb:	c1 e0 02             	shl    $0x2,%eax
f010b3ee:	01 c8                	add    %ecx,%eax
f010b3f0:	8b 15 14 cd 71 f0    	mov    0xf071cd14,%edx
f010b3f6:	89 50 08             	mov    %edx,0x8(%eax)
f010b3f9:	8b 40 08             	mov    0x8(%eax),%eax
f010b3fc:	85 c0                	test   %eax,%eax
f010b3fe:	74 2e                	je     f010b42e <env_init+0x103>
f010b400:	8b 0d 14 cd 71 f0    	mov    0xf071cd14,%ecx
f010b406:	8b 1d 10 cd 71 f0    	mov    0xf071cd10,%ebx
f010b40c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b40f:	89 d0                	mov    %edx,%eax
f010b411:	c1 e0 02             	shl    $0x2,%eax
f010b414:	01 d0                	add    %edx,%eax
f010b416:	c1 e0 03             	shl    $0x3,%eax
f010b419:	01 d0                	add    %edx,%eax
f010b41b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b422:	01 d0                	add    %edx,%eax
f010b424:	c1 e0 02             	shl    $0x2,%eax
f010b427:	01 d8                	add    %ebx,%eax
f010b429:	89 41 0c             	mov    %eax,0xc(%ecx)
f010b42c:	eb 28                	jmp    f010b456 <env_init+0x12b>
f010b42e:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b434:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b437:	89 d0                	mov    %edx,%eax
f010b439:	c1 e0 02             	shl    $0x2,%eax
f010b43c:	01 d0                	add    %edx,%eax
f010b43e:	c1 e0 03             	shl    $0x3,%eax
f010b441:	01 d0                	add    %edx,%eax
f010b443:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b44a:	01 d0                	add    %edx,%eax
f010b44c:	c1 e0 02             	shl    $0x2,%eax
f010b44f:	01 c8                	add    %ecx,%eax
f010b451:	a3 18 cd 71 f0       	mov    %eax,0xf071cd18
f010b456:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b45c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b45f:	89 d0                	mov    %edx,%eax
f010b461:	c1 e0 02             	shl    $0x2,%eax
f010b464:	01 d0                	add    %edx,%eax
f010b466:	c1 e0 03             	shl    $0x3,%eax
f010b469:	01 d0                	add    %edx,%eax
f010b46b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b472:	01 d0                	add    %edx,%eax
f010b474:	c1 e0 02             	shl    $0x2,%eax
f010b477:	01 c8                	add    %ecx,%eax
f010b479:	a3 14 cd 71 f0       	mov    %eax,0xf071cd14
f010b47e:	8b 0d 10 cd 71 f0    	mov    0xf071cd10,%ecx
f010b484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b487:	89 d0                	mov    %edx,%eax
f010b489:	c1 e0 02             	shl    $0x2,%eax
f010b48c:	01 d0                	add    %edx,%eax
f010b48e:	c1 e0 03             	shl    $0x3,%eax
f010b491:	01 d0                	add    %edx,%eax
f010b493:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010b49a:	01 d0                	add    %edx,%eax
f010b49c:	c1 e0 02             	shl    $0x2,%eax
f010b49f:	01 c8                	add    %ecx,%eax
f010b4a1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b4a8:	a1 20 cd 71 f0       	mov    0xf071cd20,%eax
f010b4ad:	40                   	inc    %eax
f010b4ae:	a3 20 cd 71 f0       	mov    %eax,0xf071cd20
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010b4b3:	ff 4d f4             	decl   -0xc(%ebp)
f010b4b6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b4ba:	0f 89 7e fe ff ff    	jns    f010b33e <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010b4c0:	90                   	nop
f010b4c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b4c4:	c9                   	leave  
f010b4c5:	c3                   	ret    

f010b4c6 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010b4c6:	55                   	push   %ebp
f010b4c7:	89 e5                	mov    %esp,%ebp
f010b4c9:	57                   	push   %edi
f010b4ca:	56                   	push   %esi
f010b4cb:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010b4d1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010b4d8:	83 ec 0c             	sub    $0xc,%esp
f010b4db:	ff 75 08             	pushl  0x8(%ebp)
f010b4de:	e8 81 1e 00 00       	call   f010d364 <get_user_program_info>
f010b4e3:	83 c4 10             	add    $0x10,%esp
f010b4e6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010b4e9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b4ed:	75 0a                	jne    f010b4f9 <env_create+0x33>
	{
		return NULL;
f010b4ef:	b8 00 00 00 00       	mov    $0x0,%eax
f010b4f4:	e9 aa 09 00 00       	jmp    f010bea3 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010b4f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b4fc:	8b 40 08             	mov    0x8(%eax),%eax
f010b4ff:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010b502:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010b509:	00 00 00 
	if(allocate_environment(&e) < 0)
f010b50c:	83 ec 0c             	sub    $0xc,%esp
f010b50f:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010b515:	50                   	push   %eax
f010b516:	e8 8f 0e 00 00       	call   f010c3aa <allocate_environment>
f010b51b:	83 c4 10             	add    $0x10,%esp
f010b51e:	85 c0                	test   %eax,%eax
f010b520:	79 0a                	jns    f010b52c <env_create+0x66>
	{
		return NULL;
f010b522:	b8 00 00 00 00       	mov    $0x0,%eax
f010b527:	e9 77 09 00 00       	jmp    f010bea3 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010b52c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b52f:	8b 00                	mov    (%eax),%eax
f010b531:	83 ec 0c             	sub    $0xc,%esp
f010b534:	50                   	push   %eax
f010b535:	e8 01 6a 01 00       	call   f0121f3b <strlen>
f010b53a:	83 c4 10             	add    $0x10,%esp
f010b53d:	83 f8 3f             	cmp    $0x3f,%eax
f010b540:	7f 1d                	jg     f010b55f <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010b542:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b545:	8b 00                	mov    (%eax),%eax
f010b547:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b54d:	83 c2 20             	add    $0x20,%edx
f010b550:	83 ec 08             	sub    $0x8,%esp
f010b553:	50                   	push   %eax
f010b554:	52                   	push   %edx
f010b555:	e8 30 6a 01 00       	call   f0121f8a <strcpy>
f010b55a:	83 c4 10             	add    $0x10,%esp
f010b55d:	eb 1d                	jmp    f010b57c <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b55f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b562:	8b 00                	mov    (%eax),%eax
f010b564:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010b56a:	83 c2 20             	add    $0x20,%edx
f010b56d:	83 ec 04             	sub    $0x4,%esp
f010b570:	6a 3f                	push   $0x3f
f010b572:	50                   	push   %eax
f010b573:	52                   	push   %edx
f010b574:	e8 3f 6a 01 00       	call   f0121fb8 <strncpy>
f010b579:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010b57c:	e8 f5 13 00 00       	call   f010c976 <create_user_directory>
f010b581:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b584:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b587:	83 ec 0c             	sub    $0xc,%esp
f010b58a:	50                   	push   %eax
f010b58b:	e8 71 ea ff ff       	call   f010a001 <kheap_physical_address>
f010b590:	83 c4 10             	add    $0x10,%esp
f010b593:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010b596:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b59c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b59f:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b5a5:	83 ec 0c             	sub    $0xc,%esp
f010b5a8:	6a 02                	push   $0x2
f010b5aa:	e8 c5 46 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010b5af:	83 c4 10             	add    $0x10,%esp
f010b5b2:	85 c0                	test   %eax,%eax
f010b5b4:	74 21                	je     f010b5d7 <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010b5b6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5bc:	8b 55 10             	mov    0x10(%ebp),%edx
f010b5bf:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b5c5:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5cb:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b5ce:	2b 55 10             	sub    0x10(%ebp),%edx
f010b5d1:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b5d7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b5db:	75 12                	jne    f010b5ef <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b5dd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5e3:	c7 80 90 05 00 00 0a 	movl   $0xa,0x590(%eax)
f010b5ea:	00 00 00 
f010b5ed:	eb 0f                	jmp    f010b5fe <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b5ef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b5f5:	8b 55 14             	mov    0x14(%ebp),%edx
f010b5f8:	89 90 90 05 00 00    	mov    %edx,0x590(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b5fe:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b604:	83 ec 04             	sub    $0x4,%esp
f010b607:	ff 75 bc             	pushl  -0x44(%ebp)
f010b60a:	ff 75 c0             	pushl  -0x40(%ebp)
f010b60d:	50                   	push   %eax
f010b60e:	e8 9b 14 00 00       	call   f010caae <initialize_environment>
f010b613:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010b616:	e8 8f c2 ff ff       	call   f01078aa <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b61b:	0f 20 d8             	mov    %cr3,%eax
f010b61e:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010b621:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b624:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010b627:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b62d:	8b 40 68             	mov    0x68(%eax),%eax
f010b630:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b636:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010b63c:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b63f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010b646:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b64d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b653:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b659:	48                   	dec    %eax
f010b65a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b65d:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010b664:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b667:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010b66d:	83 ec 08             	sub    $0x8,%esp
f010b670:	ff 75 c8             	pushl  -0x38(%ebp)
f010b673:	50                   	push   %eax
f010b674:	e8 fd 19 00 00       	call   f010d076 <PROGRAM_SEGMENT_FIRST>
f010b679:	83 c4 0c             	add    $0xc,%esp
f010b67c:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b682:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010b688:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b68d:	89 c7                	mov    %eax,%edi
f010b68f:	89 d6                	mov    %edx,%esi
f010b691:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b693:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010b699:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010b69c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b69f:	8b 40 10             	mov    0x10(%eax),%eax
f010b6a2:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b6a5:	75 07                	jne    f010b6ae <env_create+0x1e8>
f010b6a7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010b6ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b6b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b6b4:	e9 fa 02 00 00       	jmp    f010b9b3 <env_create+0x4ed>
		{
			segment_counter++;
f010b6b9:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b6bc:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010b6c3:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b6c6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b6cc:	83 ec 0c             	sub    $0xc,%esp
f010b6cf:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010b6d5:	52                   	push   %edx
f010b6d6:	ff 75 ec             	pushl  -0x14(%ebp)
f010b6d9:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b6df:	52                   	push   %edx
f010b6e0:	ff 75 f4             	pushl  -0xc(%ebp)
f010b6e3:	50                   	push   %eax
f010b6e4:	e8 7f 0d 00 00       	call   f010c468 <program_segment_alloc_map_copy_workingset>
f010b6e9:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b6ec:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010b6f2:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b6f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b6f8:	8b 00                	mov    (%eax),%eax
f010b6fa:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b6fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b700:	8b 40 0c             	mov    0xc(%eax),%eax
f010b703:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b706:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b709:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010b70c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010b70f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b714:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b717:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010b71e:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010b721:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b724:	01 d0                	add    %edx,%eax
f010b726:	48                   	dec    %eax
f010b727:	89 45 98             	mov    %eax,-0x68(%ebp)
f010b72a:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b72d:	ba 00 00 00 00       	mov    $0x0,%edx
f010b732:	f7 75 9c             	divl   -0x64(%ebp)
f010b735:	8b 45 98             	mov    -0x68(%ebp),%eax
f010b738:	29 d0                	sub    %edx,%eax
f010b73a:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b73d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b740:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010b743:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b746:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b749:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b74c:	8b 15 44 5f 74 f0    	mov    0xf0745f44,%edx
f010b752:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b755:	01 d0                	add    %edx,%eax
f010b757:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010b75a:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010b75e:	74 73                	je     f010b7d3 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b760:	a1 44 5f 74 f0       	mov    0xf0745f44,%eax
f010b765:	83 ec 04             	sub    $0x4,%esp
f010b768:	68 00 10 00 00       	push   $0x1000
f010b76d:	6a 00                	push   $0x0
f010b76f:	50                   	push   %eax
f010b770:	e8 b4 69 01 00       	call   f0122129 <memset>
f010b775:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b778:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b77b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b77e:	eb 13                	jmp    f010b793 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010b780:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b783:	8a 10                	mov    (%eax),%dl
f010b785:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b788:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b78a:	ff 45 dc             	incl   -0x24(%ebp)
f010b78d:	ff 45 e4             	incl   -0x1c(%ebp)
f010b790:	ff 45 e0             	incl   -0x20(%ebp)
f010b793:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b796:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010b799:	72 e5                	jb     f010b780 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b79b:	8b 15 44 5f 74 f0    	mov    0xf0745f44,%edx
f010b7a1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b7a7:	83 ec 04             	sub    $0x4,%esp
f010b7aa:	52                   	push   %edx
f010b7ab:	ff 75 a0             	pushl  -0x60(%ebp)
f010b7ae:	50                   	push   %eax
f010b7af:	e8 96 8c ff ff       	call   f010444a <pf_add_env_page>
f010b7b4:	83 c4 10             	add    $0x10,%esp
f010b7b7:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b7ba:	75 17                	jne    f010b7d3 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b7bc:	83 ec 04             	sub    $0x4,%esp
f010b7bf:	68 e4 81 12 f0       	push   $0xf01281e4
f010b7c4:	68 f4 00 00 00       	push   $0xf4
f010b7c9:	68 c7 81 12 f0       	push   $0xf01281c7
f010b7ce:	e8 66 4b ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b7d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7d6:	8b 50 04             	mov    0x4(%eax),%edx
f010b7d9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b7dc:	01 d0                	add    %edx,%eax
f010b7de:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b7e1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b7e4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b7e9:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b7ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b7ef:	8b 50 04             	mov    0x4(%eax),%edx
f010b7f2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b7f5:	01 d0                	add    %edx,%eax
f010b7f7:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b7fa:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b7fd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b800:	eb 43                	jmp    f010b845 <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b802:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010b805:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b80b:	83 ec 04             	sub    $0x4,%esp
f010b80e:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b811:	52                   	push   %edx
f010b812:	50                   	push   %eax
f010b813:	e8 32 8c ff ff       	call   f010444a <pf_add_env_page>
f010b818:	83 c4 10             	add    $0x10,%esp
f010b81b:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b81e:	75 17                	jne    f010b837 <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b820:	83 ec 04             	sub    $0x4,%esp
f010b823:	68 e4 81 12 f0       	push   $0xf01281e4
f010b828:	68 01 01 00 00       	push   $0x101
f010b82d:	68 c7 81 12 f0       	push   $0xf01281c7
f010b832:	e8 02 4b ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b837:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b83e:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010b845:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b848:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010b84b:	72 b5                	jb     f010b802 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b84d:	a1 44 5f 74 f0       	mov    0xf0745f44,%eax
f010b852:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b855:	83 ec 04             	sub    $0x4,%esp
f010b858:	68 00 10 00 00       	push   $0x1000
f010b85d:	6a 00                	push   $0x0
f010b85f:	ff 75 e0             	pushl  -0x20(%ebp)
f010b862:	e8 c2 68 01 00       	call   f0122129 <memset>
f010b867:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b86a:	8b 45 88             	mov    -0x78(%ebp),%eax
f010b86d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010b870:	eb 13                	jmp    f010b885 <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010b872:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b875:	8a 10                	mov    (%eax),%dl
f010b877:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b87a:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b87c:	ff 45 dc             	incl   -0x24(%ebp)
f010b87f:	ff 45 e4             	incl   -0x1c(%ebp)
f010b882:	ff 45 e0             	incl   -0x20(%ebp)
f010b885:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b888:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010b88b:	72 e5                	jb     f010b872 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b88d:	8b 15 44 5f 74 f0    	mov    0xf0745f44,%edx
f010b893:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b899:	83 ec 04             	sub    $0x4,%esp
f010b89c:	52                   	push   %edx
f010b89d:	ff 75 88             	pushl  -0x78(%ebp)
f010b8a0:	50                   	push   %eax
f010b8a1:	e8 a4 8b ff ff       	call   f010444a <pf_add_env_page>
f010b8a6:	83 c4 10             	add    $0x10,%esp
f010b8a9:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b8ac:	75 17                	jne    f010b8c5 <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b8ae:	83 ec 04             	sub    $0x4,%esp
f010b8b1:	68 e4 81 12 f0       	push   $0xf01281e4
f010b8b6:	68 10 01 00 00       	push   $0x110
f010b8bb:	68 c7 81 12 f0       	push   $0xf01281c7
f010b8c0:	e8 74 4a ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b8c5:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010b8cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8cf:	8b 50 04             	mov    0x4(%eax),%edx
f010b8d2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b8d5:	01 c2                	add    %eax,%edx
f010b8d7:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b8da:	01 d0                	add    %edx,%eax
f010b8dc:	48                   	dec    %eax
f010b8dd:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010b8e3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b8e9:	ba 00 00 00 00       	mov    $0x0,%edx
f010b8ee:	f7 75 80             	divl   -0x80(%ebp)
f010b8f1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b8f7:	29 d0                	sub    %edx,%eax
f010b8f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b8fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b8ff:	8b 50 08             	mov    0x8(%eax),%edx
f010b902:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b905:	01 d0                	add    %edx,%eax
f010b907:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010b90a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b910:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010b917:	eb 41                	jmp    f010b95a <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b919:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b91f:	83 ec 04             	sub    $0x4,%esp
f010b922:	6a 01                	push   $0x1
f010b924:	ff 75 d8             	pushl  -0x28(%ebp)
f010b927:	50                   	push   %eax
f010b928:	e8 ec 89 ff ff       	call   f0104319 <pf_add_empty_env_page>
f010b92d:	83 c4 10             	add    $0x10,%esp
f010b930:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b933:	75 17                	jne    f010b94c <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b935:	83 ec 04             	sub    $0x4,%esp
f010b938:	68 e4 81 12 f0       	push   $0xf01281e4
f010b93d:	68 1d 01 00 00       	push   $0x11d
f010b942:	68 c7 81 12 f0       	push   $0xf01281c7
f010b947:	e8 ed 49 ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b94c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010b953:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010b95a:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010b961:	10 00 00 
f010b964:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010b96a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b970:	01 d0                	add    %edx,%eax
f010b972:	48                   	dec    %eax
f010b973:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010b979:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b97f:	ba 00 00 00 00       	mov    $0x0,%edx
f010b984:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010b98a:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b990:	29 d0                	sub    %edx,%eax
f010b992:	89 c2                	mov    %eax,%edx
f010b994:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b997:	39 c2                	cmp    %eax,%edx
f010b999:	0f 87 7a ff ff ff    	ja     f010b919 <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b99f:	83 ec 08             	sub    $0x8,%esp
f010b9a2:	ff 75 c8             	pushl  -0x38(%ebp)
f010b9a5:	ff 75 f4             	pushl  -0xc(%ebp)
f010b9a8:	e8 be 15 00 00       	call   f010cf6b <PROGRAM_SEGMENT_NEXT>
f010b9ad:	83 c4 10             	add    $0x10,%esp
f010b9b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010b9b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b9b7:	0f 85 fc fc ff ff    	jne    f010b6b9 <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b9bd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9c3:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b9c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010b9cc:	eb 77                	jmp    f010ba45 <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010b9ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b9d1:	8b 00                	mov    (%eax),%eax
f010b9d3:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b9d9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b9df:	8b 40 64             	mov    0x64(%eax),%eax
f010b9e2:	83 ec 04             	sub    $0x4,%esp
f010b9e5:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010b9eb:	52                   	push   %edx
f010b9ec:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010b9f2:	50                   	push   %eax
f010b9f3:	e8 e8 d0 ff ff       	call   f0108ae0 <get_page_table>
f010b9f8:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b9fb:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010ba01:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010ba07:	c1 ea 0c             	shr    $0xc,%edx
f010ba0a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010ba10:	c1 e2 02             	shl    $0x2,%edx
f010ba13:	01 d0                	add    %edx,%eax
f010ba15:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010ba1b:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010ba21:	c1 e9 0c             	shr    $0xc,%ecx
f010ba24:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010ba2a:	c1 e1 02             	shl    $0x2,%ecx
f010ba2d:	01 ca                	add    %ecx,%edx
f010ba2f:	8b 12                	mov    (%edx),%edx
f010ba31:	83 e2 bf             	and    $0xffffffbf,%edx
f010ba34:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010ba36:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba3c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ba42:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010ba45:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba4b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ba4f:	74 08                	je     f010ba59 <env_create+0x593>
f010ba51:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010ba54:	8b 52 10             	mov    0x10(%edx),%edx
f010ba57:	eb 05                	jmp    f010ba5e <env_create+0x598>
f010ba59:	ba 00 00 00 00       	mov    $0x0,%edx
f010ba5e:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
f010ba64:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f010ba6a:	85 c0                	test   %eax,%eax
f010ba6c:	0f 85 5c ff ff ff    	jne    f010b9ce <env_create+0x508>
f010ba72:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010ba76:	0f 85 52 ff ff ff    	jne    f010b9ce <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010ba7c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010ba7f:	8b 50 08             	mov    0x8(%eax),%edx
f010ba82:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba88:	83 ec 08             	sub    $0x8,%esp
f010ba8b:	52                   	push   %edx
f010ba8c:	50                   	push   %eax
f010ba8d:	e8 99 14 00 00       	call   f010cf2b <set_environment_entry_point>
f010ba92:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010ba95:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ba9b:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010baa2:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010baa9:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010baac:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010bab3:	e9 42 03 00 00       	jmp    f010bdfa <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010bab8:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010babf:	00 00 00 
			allocate_frame(&pp);
f010bac2:	83 ec 0c             	sub    $0xc,%esp
f010bac5:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010bacb:	50                   	push   %eax
f010bacc:	e8 d2 cd ff ff       	call   f01088a3 <allocate_frame>
f010bad1:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010bad4:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010bada:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bae0:	8b 40 64             	mov    0x64(%eax),%eax
f010bae3:	6a 06                	push   $0x6
f010bae5:	ff 75 d0             	pushl  -0x30(%ebp)
f010bae8:	52                   	push   %edx
f010bae9:	50                   	push   %eax
f010baea:	e8 9c d4 ff ff       	call   f0108f8b <loadtime_map_frame>
f010baef:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010baf2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010baf5:	83 ec 04             	sub    $0x4,%esp
f010baf8:	68 00 10 00 00       	push   $0x1000
f010bafd:	6a 00                	push   $0x0
f010baff:	50                   	push   %eax
f010bb00:	e8 24 66 01 00       	call   f0122129 <memset>
f010bb05:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010bb08:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb0e:	83 ec 08             	sub    $0x8,%esp
f010bb11:	ff 75 d0             	pushl  -0x30(%ebp)
f010bb14:	50                   	push   %eax
f010bb15:	e8 4e e8 ff ff       	call   f010a368 <env_page_ws_list_create_element>
f010bb1a:	83 c4 10             	add    $0x10,%esp
f010bb1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010bb20:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bb24:	75 17                	jne    f010bb3d <env_create+0x677>
f010bb26:	83 ec 04             	sub    $0x4,%esp
f010bb29:	68 2c 82 12 f0       	push   $0xf012822c
f010bb2e:	68 5c 01 00 00       	push   $0x15c
f010bb33:	68 c7 81 12 f0       	push   $0xf01281c7
f010bb38:	e8 fc 47 ff ff       	call   f0100339 <_panic>
f010bb3d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb43:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010bb49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb4c:	89 50 14             	mov    %edx,0x14(%eax)
f010bb4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb52:	8b 40 14             	mov    0x14(%eax),%eax
f010bb55:	85 c0                	test   %eax,%eax
f010bb57:	74 14                	je     f010bb6d <env_create+0x6a7>
f010bb59:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb5f:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010bb65:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb68:	89 50 10             	mov    %edx,0x10(%eax)
f010bb6b:	eb 0f                	jmp    f010bb7c <env_create+0x6b6>
f010bb6d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb73:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb76:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010bb7c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb82:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bb85:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010bb8b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bb8e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bb95:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bb9b:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010bba1:	42                   	inc    %edx
f010bba2:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010bba8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbae:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010bbb4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbba:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010bbc0:	39 c2                	cmp    %eax,%edx
f010bbc2:	75 1a                	jne    f010bbde <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010bbc4:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbca:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010bbd0:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010bbd6:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010bbdc:	eb 10                	jmp    f010bbee <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010bbde:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bbe4:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010bbeb:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010bbee:	83 ec 0c             	sub    $0xc,%esp
f010bbf1:	6a 02                	push   $0x2
f010bbf3:	e8 7c 40 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010bbf8:	83 c4 10             	add    $0x10,%esp
f010bbfb:	85 c0                	test   %eax,%eax
f010bbfd:	0f 84 d3 01 00 00    	je     f010bdd6 <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010bc03:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bc07:	75 17                	jne    f010bc20 <env_create+0x75a>
f010bc09:	83 ec 04             	sub    $0x4,%esp
f010bc0c:	68 4f 82 12 f0       	push   $0xf012824f
f010bc11:	68 69 01 00 00       	push   $0x169
f010bc16:	68 c7 81 12 f0       	push   $0xf01281c7
f010bc1b:	e8 19 47 ff ff       	call   f0100339 <_panic>
f010bc20:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc23:	8b 40 10             	mov    0x10(%eax),%eax
f010bc26:	85 c0                	test   %eax,%eax
f010bc28:	74 11                	je     f010bc3b <env_create+0x775>
f010bc2a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc2d:	8b 40 10             	mov    0x10(%eax),%eax
f010bc30:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bc33:	8b 52 14             	mov    0x14(%edx),%edx
f010bc36:	89 50 14             	mov    %edx,0x14(%eax)
f010bc39:	eb 12                	jmp    f010bc4d <env_create+0x787>
f010bc3b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc41:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bc44:	8b 52 14             	mov    0x14(%edx),%edx
f010bc47:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010bc4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc50:	8b 40 14             	mov    0x14(%eax),%eax
f010bc53:	85 c0                	test   %eax,%eax
f010bc55:	74 11                	je     f010bc68 <env_create+0x7a2>
f010bc57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc5a:	8b 40 14             	mov    0x14(%eax),%eax
f010bc5d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bc60:	8b 52 10             	mov    0x10(%edx),%edx
f010bc63:	89 50 10             	mov    %edx,0x10(%eax)
f010bc66:	eb 12                	jmp    f010bc7a <env_create+0x7b4>
f010bc68:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc6e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bc71:	8b 52 10             	mov    0x10(%edx),%edx
f010bc74:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010bc7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc7d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010bc84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bc87:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bc8e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bc94:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010bc9a:	4a                   	dec    %edx
f010bc9b:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010bca1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bca7:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bcad:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bcb3:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010bcb9:	39 c2                	cmp    %eax,%edx
f010bcbb:	0f 83 8d 00 00 00    	jae    f010bd4e <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010bcc1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bcc5:	75 17                	jne    f010bcde <env_create+0x818>
f010bcc7:	83 ec 04             	sub    $0x4,%esp
f010bcca:	68 a4 81 12 f0       	push   $0xf01281a4
f010bccf:	68 6e 01 00 00       	push   $0x16e
f010bcd4:	68 c7 81 12 f0       	push   $0xf01281c7
f010bcd9:	e8 5b 46 ff ff       	call   f0100339 <_panic>
f010bcde:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bce4:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010bcea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bced:	89 50 10             	mov    %edx,0x10(%eax)
f010bcf0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bcf3:	8b 40 10             	mov    0x10(%eax),%eax
f010bcf6:	85 c0                	test   %eax,%eax
f010bcf8:	74 14                	je     f010bd0e <env_create+0x848>
f010bcfa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd00:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010bd06:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bd09:	89 50 14             	mov    %edx,0x14(%eax)
f010bd0c:	eb 0f                	jmp    f010bd1d <env_create+0x857>
f010bd0e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bd17:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010bd1d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd23:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bd26:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010bd2c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bd2f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bd36:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd3c:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010bd42:	42                   	inc    %edx
f010bd43:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010bd49:	e9 88 00 00 00       	jmp    f010bdd6 <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010bd4e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010bd52:	75 17                	jne    f010bd6b <env_create+0x8a5>
f010bd54:	83 ec 04             	sub    $0x4,%esp
f010bd57:	68 a4 81 12 f0       	push   $0xf01281a4
f010bd5c:	68 72 01 00 00       	push   $0x172
f010bd61:	68 c7 81 12 f0       	push   $0xf01281c7
f010bd66:	e8 ce 45 ff ff       	call   f0100339 <_panic>
f010bd6b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd71:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010bd77:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bd7a:	89 50 10             	mov    %edx,0x10(%eax)
f010bd7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bd80:	8b 40 10             	mov    0x10(%eax),%eax
f010bd83:	85 c0                	test   %eax,%eax
f010bd85:	74 14                	je     f010bd9b <env_create+0x8d5>
f010bd87:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bd8d:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010bd93:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bd96:	89 50 14             	mov    %edx,0x14(%eax)
f010bd99:	eb 0f                	jmp    f010bdaa <env_create+0x8e4>
f010bd9b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bda1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bda4:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010bdaa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bdb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010bdb3:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010bdb9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010bdbc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010bdc3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bdc9:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f010bdcf:	42                   	inc    %edx
f010bdd0:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010bdd6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010bddc:	83 ec 04             	sub    $0x4,%esp
f010bddf:	6a 01                	push   $0x1
f010bde1:	ff 75 d0             	pushl  -0x30(%ebp)
f010bde4:	50                   	push   %eax
f010bde5:	e8 2f 85 ff ff       	call   f0104319 <pf_add_empty_env_page>
f010bdea:	83 c4 10             	add    $0x10,%esp
f010bded:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010bdf3:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010bdfa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bdfd:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010be03:	0f 83 af fc ff ff    	jae    f010bab8 <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010be09:	83 ec 0c             	sub    $0xc,%esp
f010be0c:	6a 02                	push   $0x2
f010be0e:	e8 61 3e 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010be13:	83 c4 10             	add    $0x10,%esp
f010be16:	85 c0                	test   %eax,%eax
f010be18:	74 72                	je     f010be8c <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010be1a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010be21:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010be27:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010be2d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010be30:	eb 2b                	jmp    f010be5d <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010be32:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010be35:	8b 10                	mov    (%eax),%edx
f010be37:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010be3d:	8b 40 64             	mov    0x64(%eax),%eax
f010be40:	6a 01                	push   $0x1
f010be42:	6a 00                	push   $0x0
f010be44:	52                   	push   %edx
f010be45:	50                   	push   %eax
f010be46:	e8 e7 e2 ff ff       	call   f010a132 <pt_set_page_permissions>
f010be4b:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010be4e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010be54:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010be5a:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010be5d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010be63:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010be67:	74 08                	je     f010be71 <env_create+0x9ab>
f010be69:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010be6c:	8b 52 10             	mov    0x10(%edx),%edx
f010be6f:	eb 05                	jmp    f010be76 <env_create+0x9b0>
f010be71:	ba 00 00 00 00       	mov    $0x0,%edx
f010be76:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010be7c:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f010be82:	85 c0                	test   %eax,%eax
f010be84:	75 ac                	jne    f010be32 <env_create+0x96c>
f010be86:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010be8a:	75 a6                	jne    f010be32 <env_create+0x96c>
f010be8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010be8f:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010be92:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010be95:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010be98:	e8 5f ba ff ff       	call   f01078fc <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010be9d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010bea3:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010bea6:	5e                   	pop    %esi
f010bea7:	5f                   	pop    %edi
f010bea8:	5d                   	pop    %ebp
f010bea9:	c3                   	ret    

f010beaa <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010beaa:	55                   	push   %ebp
f010beab:	89 e5                	mov    %esp,%ebp
f010bead:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010beb0:	83 ec 0c             	sub    $0xc,%esp
f010beb3:	68 00 58 74 f0       	push   $0xf0745800
f010beb8:	e8 b4 49 00 00       	call   f0110871 <release_spinlock>
f010bebd:	83 c4 10             	add    $0x10,%esp

	if (first)
f010bec0:	a1 ac 39 18 f0       	mov    0xf01839ac,%eax
f010bec5:	85 c0                	test   %eax,%eax
f010bec7:	74 30                	je     f010bef9 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010bec9:	e8 76 00 00 00       	call   f010bf44 <get_cpu_proc>
f010bece:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010bed1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bed4:	8b 40 10             	mov    0x10(%eax),%eax
f010bed7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010beda:	83 c2 20             	add    $0x20,%edx
f010bedd:	83 ec 04             	sub    $0x4,%esp
f010bee0:	50                   	push   %eax
f010bee1:	52                   	push   %edx
f010bee2:	68 6d 82 12 f0       	push   $0xf012826d
f010bee7:	e8 9f 50 ff ff       	call   f0100f8b <cprintf>
f010beec:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010beef:	c7 05 ac 39 18 f0 00 	movl   $0x0,0xf01839ac
f010bef6:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010bef9:	90                   	nop
f010befa:	c9                   	leave  
f010befb:	c3                   	ret    

f010befc <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010befc:	55                   	push   %ebp
f010befd:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010beff:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010bf00:	5d                   	pop    %ebp
f010bf01:	c3                   	ret    

f010bf02 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010bf02:	55                   	push   %ebp
f010bf03:	89 e5                	mov    %esp,%ebp
f010bf05:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010bf08:	e8 37 00 00 00       	call   f010bf44 <get_cpu_proc>
f010bf0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010bf10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bf14:	75 19                	jne    f010bf2f <env_exit+0x2d>
f010bf16:	68 83 82 12 f0       	push   $0xf0128283
f010bf1b:	68 93 82 12 f0       	push   $0xf0128293
f010bf20:	68 ec 01 00 00       	push   $0x1ec
f010bf25:	68 c7 81 12 f0       	push   $0xf01281c7
f010bf2a:	e8 0a 44 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010bf2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf32:	8b 40 10             	mov    0x10(%eax),%eax
f010bf35:	83 ec 0c             	sub    $0xc,%esp
f010bf38:	50                   	push   %eax
f010bf39:	e8 7b 9b ff ff       	call   f0105ab9 <sched_exit_env>
f010bf3e:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010bf41:	90                   	nop
f010bf42:	c9                   	leave  
f010bf43:	c3                   	ret    

f010bf44 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010bf44:	55                   	push   %ebp
f010bf45:	89 e5                	mov    %esp,%ebp
f010bf47:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010bf4a:	e8 5b b9 ff ff       	call   f01078aa <pushcli>
	c = mycpu();
f010bf4f:	e8 93 b8 ff ff       	call   f01077e7 <mycpu>
f010bf54:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010bf57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf5a:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bf60:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bf63:	e8 94 b9 ff ff       	call   f01078fc <popcli>
	return p;
f010bf68:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bf6b:	c9                   	leave  
f010bf6c:	c3                   	ret    

f010bf6d <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bf6d:	55                   	push   %ebp
f010bf6e:	89 e5                	mov    %esp,%ebp
f010bf70:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bf73:	e8 32 b9 ff ff       	call   f01078aa <pushcli>
	c = mycpu();
f010bf78:	e8 6a b8 ff ff       	call   f01077e7 <mycpu>
f010bf7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bf80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf83:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf86:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bf8c:	e8 6b b9 ff ff       	call   f01078fc <popcli>
}
f010bf91:	90                   	nop
f010bf92:	c9                   	leave  
f010bf93:	c3                   	ret    

f010bf94 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bf94:	55                   	push   %ebp
f010bf95:	89 e5                	mov    %esp,%ebp
f010bf97:	53                   	push   %ebx
f010bf98:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010bf9b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bf9f:	75 16                	jne    f010bfb7 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010bfa1:	e8 9e ff ff ff       	call   f010bf44 <get_cpu_proc>
f010bfa6:	89 c2                	mov    %eax,%edx
f010bfa8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bfab:	89 10                	mov    %edx,(%eax)
		return 0;
f010bfad:	b8 00 00 00 00       	mov    $0x0,%eax
f010bfb2:	e9 a3 00 00 00       	jmp    f010c05a <envid2env+0xc6>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bfb7:	8b 1d 10 cd 71 f0    	mov    0xf071cd10,%ebx
f010bfbd:	83 ec 0c             	sub    $0xc,%esp
f010bfc0:	68 c6 02 00 00       	push   $0x2c6
f010bfc5:	e8 cf 44 01 00       	call   f0120499 <nearest_pow2_ceil>
f010bfca:	83 c4 10             	add    $0x10,%esp
f010bfcd:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bfd0:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfd3:	21 c2                	and    %eax,%edx
f010bfd5:	89 d0                	mov    %edx,%eax
f010bfd7:	c1 e0 02             	shl    $0x2,%eax
f010bfda:	01 d0                	add    %edx,%eax
f010bfdc:	c1 e0 03             	shl    $0x3,%eax
f010bfdf:	01 d0                	add    %edx,%eax
f010bfe1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010bfe8:	01 d0                	add    %edx,%eax
f010bfea:	c1 e0 02             	shl    $0x2,%eax
f010bfed:	01 d8                	add    %ebx,%eax
f010bfef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bff2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bff5:	8b 40 18             	mov    0x18(%eax),%eax
f010bff8:	85 c0                	test   %eax,%eax
f010bffa:	74 0b                	je     f010c007 <envid2env+0x73>
f010bffc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bfff:	8b 40 10             	mov    0x10(%eax),%eax
f010c002:	3b 45 08             	cmp    0x8(%ebp),%eax
f010c005:	74 10                	je     f010c017 <envid2env+0x83>
		*env_store = 0;
f010c007:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c00a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010c010:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010c015:	eb 43                	jmp    f010c05a <envid2env+0xc6>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010c017:	e8 28 ff ff ff       	call   f010bf44 <get_cpu_proc>
f010c01c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010c01f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010c023:	74 28                	je     f010c04d <envid2env+0xb9>
f010c025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c028:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010c02b:	74 20                	je     f010c04d <envid2env+0xb9>
f010c02d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c030:	8b 50 14             	mov    0x14(%eax),%edx
f010c033:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c036:	8b 40 10             	mov    0x10(%eax),%eax
f010c039:	39 c2                	cmp    %eax,%edx
f010c03b:	74 10                	je     f010c04d <envid2env+0xb9>
		*env_store = 0;
f010c03d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c040:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010c046:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010c04b:	eb 0d                	jmp    f010c05a <envid2env+0xc6>
	}

	*env_store = e;
f010c04d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c050:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c053:	89 10                	mov    %edx,(%eax)
	return 0;
f010c055:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c05a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c05d:	c9                   	leave  
f010c05e:	c3                   	ret    

f010c05f <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010c05f:	55                   	push   %ebp
f010c060:	89 e5                	mov    %esp,%ebp
f010c062:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010c065:	83 ec 0c             	sub    $0xc,%esp
f010c068:	68 00 58 74 f0       	push   $0xf0745800
f010c06d:	e8 78 47 00 00       	call   f01107ea <acquire_spinlock>
f010c072:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010c075:	e8 ca fe ff ff       	call   f010bf44 <get_cpu_proc>
f010c07a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010c07d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c081:	75 19                	jne    f010c09c <yield+0x3d>
f010c083:	68 a8 82 12 f0       	push   $0xf01282a8
f010c088:	68 93 82 12 f0       	push   $0xf0128293
f010c08d:	68 4b 02 00 00       	push   $0x24b
f010c092:	68 c7 81 12 f0       	push   $0xf01281c7
f010c097:	e8 9d 42 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010c09c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c09f:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010c0a6:	e8 13 00 00 00       	call   f010c0be <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010c0ab:	83 ec 0c             	sub    $0xc,%esp
f010c0ae:	68 00 58 74 f0       	push   $0xf0745800
f010c0b3:	e8 b9 47 00 00       	call   f0110871 <release_spinlock>
f010c0b8:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010c0bb:	90                   	nop
f010c0bc:	c9                   	leave  
f010c0bd:	c3                   	ret    

f010c0be <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010c0be:	55                   	push   %ebp
f010c0bf:	89 e5                	mov    %esp,%ebp
f010c0c1:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010c0c4:	e8 7b fe ff ff       	call   f010bf44 <get_cpu_proc>
f010c0c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010c0cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c0d0:	75 19                	jne    f010c0eb <sched+0x2d>
f010c0d2:	68 a8 82 12 f0       	push   $0xf01282a8
f010c0d7:	68 93 82 12 f0       	push   $0xf0128293
f010c0dc:	68 5f 02 00 00       	push   $0x25f
f010c0e1:	68 c7 81 12 f0       	push   $0xf01281c7
f010c0e6:	e8 4e 42 ff ff       	call   f0100339 <_panic>
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010c0eb:	83 ec 0c             	sub    $0xc,%esp
f010c0ee:	68 00 58 74 f0       	push   $0xf0745800
f010c0f3:	e8 0b 49 00 00       	call   f0110a03 <holding_spinlock>
f010c0f8:	83 c4 10             	add    $0x10,%esp
f010c0fb:	85 c0                	test   %eax,%eax
f010c0fd:	75 17                	jne    f010c116 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010c0ff:	83 ec 04             	sub    $0x4,%esp
f010c102:	68 b4 82 12 f0       	push   $0xf01282b4
f010c107:	68 62 02 00 00       	push   $0x262
f010c10c:	68 c7 81 12 f0       	push   $0xf01281c7
f010c111:	e8 23 42 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010c116:	e8 cc b6 ff ff       	call   f01077e7 <mycpu>
f010c11b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010c121:	83 f8 01             	cmp    $0x1,%eax
f010c124:	74 20                	je     f010c146 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010c126:	e8 bc b6 ff ff       	call   f01077e7 <mycpu>
f010c12b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010c131:	50                   	push   %eax
f010c132:	68 f6 82 12 f0       	push   $0xf01282f6
f010c137:	68 65 02 00 00       	push   $0x265
f010c13c:	68 c7 81 12 f0       	push   $0xf01281c7
f010c141:	e8 f3 41 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010c146:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c149:	8b 40 18             	mov    0x18(%eax),%eax
f010c14c:	83 f8 02             	cmp    $0x2,%eax
f010c14f:	75 17                	jne    f010c168 <sched+0xaa>
		panic("sched a running process");
f010c151:	83 ec 04             	sub    $0x4,%esp
f010c154:	68 0d 83 12 f0       	push   $0xf012830d
f010c159:	68 68 02 00 00       	push   $0x268
f010c15e:	68 c7 81 12 f0       	push   $0xf01281c7
f010c163:	e8 d1 41 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010c168:	9c                   	pushf  
f010c169:	58                   	pop    %eax
f010c16a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010c16d:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010c170:	25 00 02 00 00       	and    $0x200,%eax
f010c175:	85 c0                	test   %eax,%eax
f010c177:	74 17                	je     f010c190 <sched+0xd2>
		panic("sched is interruptible!");
f010c179:	83 ec 04             	sub    $0x4,%esp
f010c17c:	68 25 83 12 f0       	push   $0xf0128325
f010c181:	68 6a 02 00 00       	push   $0x26a
f010c186:	68 c7 81 12 f0       	push   $0xf01281c7
f010c18b:	e8 a9 41 ff ff       	call   f0100339 <_panic>

	intena = mycpu()->intena;
f010c190:	e8 52 b6 ff ff       	call   f01077e7 <mycpu>
f010c195:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010c19b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010c19e:	e8 44 b6 ff ff       	call   f01077e7 <mycpu>
f010c1a3:	8b 40 04             	mov    0x4(%eax),%eax
f010c1a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c1a9:	83 c2 04             	add    $0x4,%edx
f010c1ac:	83 ec 08             	sub    $0x8,%esp
f010c1af:	50                   	push   %eax
f010c1b0:	52                   	push   %edx
f010c1b1:	e8 ce 8b ff ff       	call   f0104d84 <context_switch>
f010c1b6:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010c1b9:	e8 29 b6 ff ff       	call   f01077e7 <mycpu>
f010c1be:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c1c1:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
//	cprintf("end of sched\n");
}
f010c1c7:	90                   	nop
f010c1c8:	c9                   	leave  
f010c1c9:	c3                   	ret    

f010c1ca <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010c1ca:	55                   	push   %ebp
f010c1cb:	89 e5                	mov    %esp,%ebp
f010c1cd:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010c1d0:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f010c1d5:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010c1d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010c1db:	0f 22 d8             	mov    %eax,%cr3
}
f010c1de:	90                   	nop
f010c1df:	c9                   	leave  
f010c1e0:	c3                   	ret    

f010c1e1 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010c1e1:	55                   	push   %ebp
f010c1e2:	89 e5                	mov    %esp,%ebp
f010c1e4:	53                   	push   %ebx
f010c1e5:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010c1e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c1ec:	75 17                	jne    f010c205 <switchuvm+0x24>
		panic("switchuvm: no process");
f010c1ee:	83 ec 04             	sub    $0x4,%esp
f010c1f1:	68 3d 83 12 f0       	push   $0xf012833d
f010c1f6:	68 81 02 00 00       	push   $0x281
f010c1fb:	68 c7 81 12 f0       	push   $0xf01281c7
f010c200:	e8 34 41 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010c205:	8b 45 08             	mov    0x8(%ebp),%eax
f010c208:	8b 40 70             	mov    0x70(%eax),%eax
f010c20b:	85 c0                	test   %eax,%eax
f010c20d:	75 17                	jne    f010c226 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010c20f:	83 ec 04             	sub    $0x4,%esp
f010c212:	68 53 83 12 f0       	push   $0xf0128353
f010c217:	68 83 02 00 00       	push   $0x283
f010c21c:	68 c7 81 12 f0       	push   $0xf01281c7
f010c221:	e8 13 41 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010c226:	8b 45 08             	mov    0x8(%ebp),%eax
f010c229:	8b 40 64             	mov    0x64(%eax),%eax
f010c22c:	85 c0                	test   %eax,%eax
f010c22e:	75 17                	jne    f010c247 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010c230:	83 ec 04             	sub    $0x4,%esp
f010c233:	68 68 83 12 f0       	push   $0xf0128368
f010c238:	68 85 02 00 00       	push   $0x285
f010c23d:	68 c7 81 12 f0       	push   $0xf01281c7
f010c242:	e8 f2 40 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010c247:	e8 5e b6 ff ff       	call   f01078aa <pushcli>
	struct cpu* c = mycpu();
f010c24c:	e8 96 b5 ff ff       	call   f01077e7 <mycpu>
f010c251:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010c254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c257:	8b 55 08             	mov    0x8(%ebp),%edx
f010c25a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c263:	83 c0 0c             	add    $0xc,%eax
f010c266:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c269:	83 c2 0c             	add    $0xc,%edx
f010c26c:	c1 ea 10             	shr    $0x10,%edx
f010c26f:	88 d3                	mov    %dl,%bl
f010c271:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c274:	83 c2 0c             	add    $0xc,%edx
f010c277:	c1 ea 18             	shr    $0x18,%edx
f010c27a:	88 d1                	mov    %dl,%cl
f010c27c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c27f:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c286:	68 00 
f010c288:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c28b:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c292:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c295:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c29b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c29e:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c2a4:	83 e2 f0             	and    $0xfffffff0,%edx
f010c2a7:	83 ca 09             	or     $0x9,%edx
f010c2aa:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c2b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2b3:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c2b9:	83 ca 10             	or     $0x10,%edx
f010c2bc:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c2c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2c5:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c2cb:	83 e2 9f             	and    $0xffffff9f,%edx
f010c2ce:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c2d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2d7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c2dd:	83 ca 80             	or     $0xffffff80,%edx
f010c2e0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c2e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2e9:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c2ef:	83 e2 f0             	and    $0xfffffff0,%edx
f010c2f2:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c2f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2fb:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c301:	83 e2 ef             	and    $0xffffffef,%edx
f010c304:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c30a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c30d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c313:	83 e2 df             	and    $0xffffffdf,%edx
f010c316:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c31c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c31f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c325:	83 ca 40             	or     $0x40,%edx
f010c328:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c32e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c331:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c337:	83 e2 7f             	and    $0x7f,%edx
f010c33a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c340:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c343:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c349:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c34c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c352:	83 e2 ef             	and    $0xffffffef,%edx
f010c355:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010c35b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c35e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c364:	8b 40 70             	mov    0x70(%eax),%eax
f010c367:	05 00 80 00 00       	add    $0x8000,%eax
f010c36c:	89 c2                	mov    %eax,%edx
f010c36e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c371:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c374:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c377:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010c37d:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c383:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c387:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010c38a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c38d:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010c393:	8b 40 68             	mov    0x68(%eax),%eax
f010c396:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010c399:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c39c:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010c39f:	e8 58 b5 ff ff       	call   f01078fc <popcli>
}
f010c3a4:	90                   	nop
f010c3a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c3a8:	c9                   	leave  
f010c3a9:	c3                   	ret    

f010c3aa <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010c3aa:	55                   	push   %ebp
f010c3ab:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010c3ad:	8b 15 14 cd 71 f0    	mov    0xf071cd14,%edx
f010c3b3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3b6:	89 10                	mov    %edx,(%eax)
f010c3b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3bb:	8b 00                	mov    (%eax),%eax
f010c3bd:	85 c0                	test   %eax,%eax
f010c3bf:	75 07                	jne    f010c3c8 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010c3c1:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010c3c6:	eb 11                	jmp    f010c3d9 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010c3c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3cb:	8b 00                	mov    (%eax),%eax
f010c3cd:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010c3d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c3d9:	5d                   	pop    %ebp
f010c3da:	c3                   	ret    

f010c3db <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010c3db:	55                   	push   %ebp
f010c3dc:	89 e5                	mov    %esp,%ebp
f010c3de:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010c3e1:	83 ec 04             	sub    $0x4,%esp
f010c3e4:	68 c4 05 00 00       	push   $0x5c4
f010c3e9:	6a 00                	push   $0x0
f010c3eb:	ff 75 08             	pushl  0x8(%ebp)
f010c3ee:	e8 36 5d 01 00       	call   f0122129 <memset>
f010c3f3:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010c3f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3f9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010c400:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c404:	75 17                	jne    f010c41d <free_environment+0x42>
f010c406:	83 ec 04             	sub    $0x4,%esp
f010c409:	68 a4 81 12 f0       	push   $0xf01281a4
f010c40e:	68 c0 02 00 00       	push   $0x2c0
f010c413:	68 c7 81 12 f0       	push   $0xf01281c7
f010c418:	e8 1c 3f ff ff       	call   f0100339 <_panic>
f010c41d:	8b 15 14 cd 71 f0    	mov    0xf071cd14,%edx
f010c423:	8b 45 08             	mov    0x8(%ebp),%eax
f010c426:	89 50 08             	mov    %edx,0x8(%eax)
f010c429:	8b 45 08             	mov    0x8(%ebp),%eax
f010c42c:	8b 40 08             	mov    0x8(%eax),%eax
f010c42f:	85 c0                	test   %eax,%eax
f010c431:	74 0d                	je     f010c440 <free_environment+0x65>
f010c433:	a1 14 cd 71 f0       	mov    0xf071cd14,%eax
f010c438:	8b 55 08             	mov    0x8(%ebp),%edx
f010c43b:	89 50 0c             	mov    %edx,0xc(%eax)
f010c43e:	eb 08                	jmp    f010c448 <free_environment+0x6d>
f010c440:	8b 45 08             	mov    0x8(%ebp),%eax
f010c443:	a3 18 cd 71 f0       	mov    %eax,0xf071cd18
f010c448:	8b 45 08             	mov    0x8(%ebp),%eax
f010c44b:	a3 14 cd 71 f0       	mov    %eax,0xf071cd14
f010c450:	8b 45 08             	mov    0x8(%ebp),%eax
f010c453:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c45a:	a1 20 cd 71 f0       	mov    0xf071cd20,%eax
f010c45f:	40                   	inc    %eax
f010c460:	a3 20 cd 71 f0       	mov    %eax,0xf071cd20
}
f010c465:	90                   	nop
f010c466:	c9                   	leave  
f010c467:	c3                   	ret    

f010c468 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010c468:	55                   	push   %ebp
f010c469:	89 e5                	mov    %esp,%ebp
f010c46b:	53                   	push   %ebx
f010c46c:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010c46f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c472:	8b 40 0c             	mov    0xc(%eax),%eax
f010c475:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010c478:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c47b:	8b 40 08             	mov    0x8(%eax),%eax
f010c47e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010c481:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010c488:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010c48b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c48e:	01 c2                	add    %eax,%edx
f010c490:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c493:	01 d0                	add    %edx,%eax
f010c495:	48                   	dec    %eax
f010c496:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c499:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c49c:	ba 00 00 00 00       	mov    $0x0,%edx
f010c4a1:	f7 75 dc             	divl   -0x24(%ebp)
f010c4a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c4a7:	29 d0                	sub    %edx,%eax
f010c4a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c4ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c4af:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c4b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c4b5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c4ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c4bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c4c4:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c4cb:	8b 45 10             	mov    0x10(%ebp),%eax
f010c4ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c4d4:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c4db:	0f 85 f5 03 00 00    	jne    f010c8d6 <program_segment_alloc_map_copy_workingset+0x46e>
f010c4e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e4:	83 c0 20             	add    $0x20,%eax
f010c4e7:	83 ec 08             	sub    $0x8,%esp
f010c4ea:	68 7c 83 12 f0       	push   $0xf012837c
f010c4ef:	50                   	push   %eax
f010c4f0:	e8 52 5b 01 00       	call   f0122047 <strcmp>
f010c4f5:	83 c4 10             	add    $0x10,%esp
f010c4f8:	85 c0                	test   %eax,%eax
f010c4fa:	0f 84 d6 03 00 00    	je     f010c8d6 <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c500:	8b 45 14             	mov    0x14(%ebp),%eax
f010c503:	83 f8 06             	cmp    $0x6,%eax
f010c506:	76 05                	jbe    f010c50d <program_segment_alloc_map_copy_workingset+0xa5>
f010c508:	b8 06 00 00 00       	mov    $0x6,%eax
f010c50d:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c510:	e9 c1 03 00 00       	jmp    f010c8d6 <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c515:	83 ec 0c             	sub    $0xc,%esp
f010c518:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c51b:	50                   	push   %eax
f010c51c:	e8 82 c3 ff ff       	call   f01088a3 <allocate_frame>
f010c521:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c524:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c527:	8b 45 08             	mov    0x8(%ebp),%eax
f010c52a:	8b 40 64             	mov    0x64(%eax),%eax
f010c52d:	6a 06                	push   $0x6
f010c52f:	ff 75 f4             	pushl  -0xc(%ebp)
f010c532:	52                   	push   %edx
f010c533:	50                   	push   %eax
f010c534:	e8 52 ca ff ff       	call   f0108f8b <loadtime_map_frame>
f010c539:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c53c:	83 ec 08             	sub    $0x8,%esp
f010c53f:	ff 75 f4             	pushl  -0xc(%ebp)
f010c542:	ff 75 08             	pushl  0x8(%ebp)
f010c545:	e8 1e de ff ff       	call   f010a368 <env_page_ws_list_create_element>
f010c54a:	83 c4 10             	add    $0x10,%esp
f010c54d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c550:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c553:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c55a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c55e:	75 17                	jne    f010c577 <program_segment_alloc_map_copy_workingset+0x10f>
f010c560:	83 ec 04             	sub    $0x4,%esp
f010c563:	68 2c 82 12 f0       	push   $0xf012822c
f010c568:	68 ea 02 00 00       	push   $0x2ea
f010c56d:	68 c7 81 12 f0       	push   $0xf01281c7
f010c572:	e8 c2 3d ff ff       	call   f0100339 <_panic>
f010c577:	8b 45 08             	mov    0x8(%ebp),%eax
f010c57a:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f010c580:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c583:	89 50 14             	mov    %edx,0x14(%eax)
f010c586:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c589:	8b 40 14             	mov    0x14(%eax),%eax
f010c58c:	85 c0                	test   %eax,%eax
f010c58e:	74 11                	je     f010c5a1 <program_segment_alloc_map_copy_workingset+0x139>
f010c590:	8b 45 08             	mov    0x8(%ebp),%eax
f010c593:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010c599:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c59c:	89 50 10             	mov    %edx,0x10(%eax)
f010c59f:	eb 0c                	jmp    f010c5ad <program_segment_alloc_map_copy_workingset+0x145>
f010c5a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5a4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c5a7:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c5ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c5b3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c5b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c5bc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c5c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c6:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c5cc:	8d 50 01             	lea    0x1(%eax),%edx
f010c5cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d2:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c5d8:	83 ec 0c             	sub    $0xc,%esp
f010c5db:	6a 02                	push   $0x2
f010c5dd:	e8 92 36 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010c5e2:	83 c4 10             	add    $0x10,%esp
f010c5e5:	85 c0                	test   %eax,%eax
f010c5e7:	0f 84 b3 01 00 00    	je     f010c7a0 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c5ed:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c5f1:	75 17                	jne    f010c60a <program_segment_alloc_map_copy_workingset+0x1a2>
f010c5f3:	83 ec 04             	sub    $0x4,%esp
f010c5f6:	68 4f 82 12 f0       	push   $0xf012824f
f010c5fb:	68 f6 02 00 00       	push   $0x2f6
f010c600:	68 c7 81 12 f0       	push   $0xf01281c7
f010c605:	e8 2f 3d ff ff       	call   f0100339 <_panic>
f010c60a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c60d:	8b 40 10             	mov    0x10(%eax),%eax
f010c610:	85 c0                	test   %eax,%eax
f010c612:	74 11                	je     f010c625 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c614:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c617:	8b 40 10             	mov    0x10(%eax),%eax
f010c61a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c61d:	8b 52 14             	mov    0x14(%edx),%edx
f010c620:	89 50 14             	mov    %edx,0x14(%eax)
f010c623:	eb 0f                	jmp    f010c634 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c625:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c628:	8b 50 14             	mov    0x14(%eax),%edx
f010c62b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c62e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c634:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c637:	8b 40 14             	mov    0x14(%eax),%eax
f010c63a:	85 c0                	test   %eax,%eax
f010c63c:	74 11                	je     f010c64f <program_segment_alloc_map_copy_workingset+0x1e7>
f010c63e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c641:	8b 40 14             	mov    0x14(%eax),%eax
f010c644:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c647:	8b 52 10             	mov    0x10(%edx),%edx
f010c64a:	89 50 10             	mov    %edx,0x10(%eax)
f010c64d:	eb 0f                	jmp    f010c65e <program_segment_alloc_map_copy_workingset+0x1f6>
f010c64f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c652:	8b 50 10             	mov    0x10(%eax),%edx
f010c655:	8b 45 08             	mov    0x8(%ebp),%eax
f010c658:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f010c65e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c661:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c668:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c66b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c672:	8b 45 08             	mov    0x8(%ebp),%eax
f010c675:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f010c67b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c67e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c681:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c687:	8b 45 08             	mov    0x8(%ebp),%eax
f010c68a:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010c690:	8b 45 08             	mov    0x8(%ebp),%eax
f010c693:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010c699:	48                   	dec    %eax
f010c69a:	39 c2                	cmp    %eax,%edx
f010c69c:	0f 83 80 00 00 00    	jae    f010c722 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c6a2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c6a6:	75 17                	jne    f010c6bf <program_segment_alloc_map_copy_workingset+0x257>
f010c6a8:	83 ec 04             	sub    $0x4,%esp
f010c6ab:	68 a4 81 12 f0       	push   $0xf01281a4
f010c6b0:	68 fa 02 00 00       	push   $0x2fa
f010c6b5:	68 c7 81 12 f0       	push   $0xf01281c7
f010c6ba:	e8 7a 3c ff ff       	call   f0100339 <_panic>
f010c6bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c2:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c6c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c6cb:	89 50 10             	mov    %edx,0x10(%eax)
f010c6ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c6d1:	8b 40 10             	mov    0x10(%eax),%eax
f010c6d4:	85 c0                	test   %eax,%eax
f010c6d6:	74 11                	je     f010c6e9 <program_segment_alloc_map_copy_workingset+0x281>
f010c6d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6db:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c6e1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c6e4:	89 50 14             	mov    %edx,0x14(%eax)
f010c6e7:	eb 0c                	jmp    f010c6f5 <program_segment_alloc_map_copy_workingset+0x28d>
f010c6e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ec:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c6ef:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010c6f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6f8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c6fb:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010c701:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c704:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c70b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c70e:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010c714:	8d 50 01             	lea    0x1(%eax),%edx
f010c717:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71a:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
f010c720:	eb 7e                	jmp    f010c7a0 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c722:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c726:	75 17                	jne    f010c73f <program_segment_alloc_map_copy_workingset+0x2d7>
f010c728:	83 ec 04             	sub    $0x4,%esp
f010c72b:	68 a4 81 12 f0       	push   $0xf01281a4
f010c730:	68 ff 02 00 00       	push   $0x2ff
f010c735:	68 c7 81 12 f0       	push   $0xf01281c7
f010c73a:	e8 fa 3b ff ff       	call   f0100339 <_panic>
f010c73f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c742:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010c748:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c74b:	89 50 10             	mov    %edx,0x10(%eax)
f010c74e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c751:	8b 40 10             	mov    0x10(%eax),%eax
f010c754:	85 c0                	test   %eax,%eax
f010c756:	74 11                	je     f010c769 <program_segment_alloc_map_copy_workingset+0x301>
f010c758:	8b 45 08             	mov    0x8(%ebp),%eax
f010c75b:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010c761:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c764:	89 50 14             	mov    %edx,0x14(%eax)
f010c767:	eb 0c                	jmp    f010c775 <program_segment_alloc_map_copy_workingset+0x30d>
f010c769:	8b 45 08             	mov    0x8(%ebp),%eax
f010c76c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c76f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010c775:	8b 45 08             	mov    0x8(%ebp),%eax
f010c778:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c77b:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c781:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c784:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c78b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c78e:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010c794:	8d 50 01             	lea    0x1(%eax),%edx
f010c797:	8b 45 08             	mov    0x8(%ebp),%eax
f010c79a:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c7a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7a3:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f010c7a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7ac:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010c7b2:	39 c2                	cmp    %eax,%edx
f010c7b4:	75 14                	jne    f010c7ca <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c7b6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b9:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c7bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c2:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f010c7c8:	eb 0d                	jmp    f010c7d7 <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c7ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7cd:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f010c7d4:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c7d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7da:	c1 e8 16             	shr    $0x16,%eax
f010c7dd:	89 c2                	mov    %eax,%edx
f010c7df:	8b 45 18             	mov    0x18(%ebp),%eax
f010c7e2:	8b 00                	mov    (%eax),%eax
f010c7e4:	39 c2                	cmp    %eax,%edx
f010c7e6:	0f 84 d3 00 00 00    	je     f010c8bf <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c7ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7ef:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c7f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c7f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c7fb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c7fe:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c803:	89 c1                	mov    %eax,%ecx
f010c805:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c808:	89 d0                	mov    %edx,%eax
f010c80a:	01 c0                	add    %eax,%eax
f010c80c:	01 d0                	add    %edx,%eax
f010c80e:	c1 e0 03             	shl    $0x3,%eax
f010c811:	01 d8                	add    %ebx,%eax
f010c813:	05 b0 00 00 00       	add    $0xb0,%eax
f010c818:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c81a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c81d:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c823:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c826:	89 d0                	mov    %edx,%eax
f010c828:	01 c0                	add    %eax,%eax
f010c82a:	01 d0                	add    %edx,%eax
f010c82c:	c1 e0 03             	shl    $0x3,%eax
f010c82f:	01 c8                	add    %ecx,%eax
f010c831:	05 b4 00 00 00       	add    $0xb4,%eax
f010c836:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c839:	8b 45 08             	mov    0x8(%ebp),%eax
f010c83c:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010c842:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c845:	89 d0                	mov    %edx,%eax
f010c847:	01 c0                	add    %eax,%eax
f010c849:	01 d0                	add    %edx,%eax
f010c84b:	c1 e0 03             	shl    $0x3,%eax
f010c84e:	01 c8                	add    %ecx,%eax
f010c850:	05 b8 00 00 00       	add    $0xb8,%eax
f010c855:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c85b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c85e:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c864:	8d 50 01             	lea    0x1(%eax),%edx
f010c867:	8b 45 08             	mov    0x8(%ebp),%eax
f010c86a:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c870:	8b 45 08             	mov    0x8(%ebp),%eax
f010c873:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c879:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c87e:	ba 00 00 00 00       	mov    $0x0,%edx
f010c883:	f7 f1                	div    %ecx
f010c885:	8b 45 08             	mov    0x8(%ebp),%eax
f010c888:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
			if (e->table_last_WS_index == 0)
f010c88e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c891:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010c897:	85 c0                	test   %eax,%eax
f010c899:	75 17                	jne    f010c8b2 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c89b:	83 ec 04             	sub    $0x4,%esp
f010c89e:	68 80 83 12 f0       	push   $0xf0128380
f010c8a3:	68 27 03 00 00       	push   $0x327
f010c8a8:	68 c7 81 12 f0       	push   $0xf01281c7
f010c8ad:	e8 87 3a ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c8b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8b5:	c1 e8 16             	shr    $0x16,%eax
f010c8b8:	89 c2                	mov    %eax,%edx
f010c8ba:	8b 45 18             	mov    0x18(%ebp),%eax
f010c8bd:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c8bf:	8b 45 10             	mov    0x10(%ebp),%eax
f010c8c2:	8b 00                	mov    (%eax),%eax
f010c8c4:	8d 50 01             	lea    0x1(%eax),%edx
f010c8c7:	8b 45 10             	mov    0x10(%ebp),%eax
f010c8ca:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c8cc:	ff 45 f0             	incl   -0x10(%ebp)
f010c8cf:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c8d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c8d9:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c8dc:	73 0c                	jae    f010c8ea <program_segment_alloc_map_copy_workingset+0x482>
f010c8de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c8e1:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c8e4:	0f 82 2b fc ff ff    	jb     f010c515 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c8ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c8ed:	8b 00                	mov    (%eax),%eax
f010c8ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c8f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c8f5:	8b 40 0c             	mov    0xc(%eax),%eax
f010c8f8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c8fb:	eb 10                	jmp    f010c90d <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c8fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c900:	8a 10                	mov    (%eax),%dl
f010c902:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c905:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c907:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c90a:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c90d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c910:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c913:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c916:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c91b:	89 c2                	mov    %eax,%edx
f010c91d:	8b 45 10             	mov    0x10(%ebp),%eax
f010c920:	8b 00                	mov    (%eax),%eax
f010c922:	c1 e0 0c             	shl    $0xc,%eax
f010c925:	01 c2                	add    %eax,%edx
f010c927:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c92a:	39 c2                	cmp    %eax,%edx
f010c92c:	76 1d                	jbe    f010c94b <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c92e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c931:	8b 50 04             	mov    0x4(%eax),%edx
f010c934:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c937:	01 c2                	add    %eax,%edx
f010c939:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c93c:	39 c2                	cmp    %eax,%edx
f010c93e:	77 bd                	ja     f010c8fd <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c940:	eb 09                	jmp    f010c94b <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c942:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c945:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c948:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c94b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c94e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c951:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c954:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c959:	89 c2                	mov    %eax,%edx
f010c95b:	8b 45 10             	mov    0x10(%ebp),%eax
f010c95e:	8b 00                	mov    (%eax),%eax
f010c960:	c1 e0 0c             	shl    $0xc,%eax
f010c963:	01 c2                	add    %eax,%edx
f010c965:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c968:	39 c2                	cmp    %eax,%edx
f010c96a:	77 d6                	ja     f010c942 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c96c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c971:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c974:	c9                   	leave  
f010c975:	c3                   	ret    

f010c976 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c976:	55                   	push   %ebp
f010c977:	89 e5                	mov    %esp,%ebp
f010c979:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c97c:	83 ec 0c             	sub    $0xc,%esp
f010c97f:	68 00 10 00 00       	push   $0x1000
f010c984:	e8 e1 d2 ff ff       	call   f0109c6a <kmalloc>
f010c989:	83 c4 10             	add    $0x10,%esp
f010c98c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c98f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c993:	75 17                	jne    f010c9ac <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c995:	83 ec 04             	sub    $0x4,%esp
f010c998:	68 23 84 12 f0       	push   $0xf0128423
f010c99d:	68 57 03 00 00       	push   $0x357
f010c9a2:	68 c7 81 12 f0       	push   $0xf01281c7
f010c9a7:	e8 8d 39 ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010c9ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c9af:	c9                   	leave  
f010c9b0:	c3                   	ret    

f010c9b1 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c9b1:	55                   	push   %ebp
f010c9b2:	89 e5                	mov    %esp,%ebp
f010c9b4:	83 ec 18             	sub    $0x18,%esp
	//allocate space for the user kernel stack.
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)
	//On failure: panic
	// Allocate memory for the entire stack (KERNEL_STACK_SIZE)
	    void* stack_base = kmalloc(KERNEL_STACK_SIZE);
f010c9b7:	83 ec 0c             	sub    $0xc,%esp
f010c9ba:	68 00 80 00 00       	push   $0x8000
f010c9bf:	e8 a6 d2 ff ff       	call   f0109c6a <kmalloc>
f010c9c4:	83 c4 10             	add    $0x10,%esp
f010c9c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    if (stack_base == NULL) {
f010c9ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c9ce:	75 17                	jne    f010c9e7 <create_user_kern_stack+0x36>
	        panic("create_user_kern_stack: Failed to allocate memory for the kernel stack!");
f010c9d0:	83 ec 04             	sub    $0x4,%esp
f010c9d3:	68 40 84 12 f0       	push   $0xf0128440
f010c9d8:	68 70 03 00 00       	push   $0x370
f010c9dd:	68 c7 81 12 f0       	push   $0xf01281c7
f010c9e2:	e8 52 39 ff ff       	call   f0100339 <_panic>
	    }

	    // Calculate the virtual address of the bottom (guard) page
	    uint32 guard_page_addr = (uint32)stack_base;
f010c9e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c9ea:	89 45 f0             	mov    %eax,-0x10(%ebp)

	    // Retrieve the page table for the guard page; create if necessary
	    uint32* page_table = NULL;
f010c9ed:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	    int result = get_page_table(ptr_user_page_directory, guard_page_addr, &page_table);  // create=1
f010c9f4:	83 ec 04             	sub    $0x4,%esp
f010c9f7:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010c9fa:	50                   	push   %eax
f010c9fb:	ff 75 f0             	pushl  -0x10(%ebp)
f010c9fe:	ff 75 08             	pushl  0x8(%ebp)
f010ca01:	e8 da c0 ff ff       	call   f0108ae0 <get_page_table>
f010ca06:	83 c4 10             	add    $0x10,%esp
f010ca09:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    if (result == E_NO_MEM) {
f010ca0c:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f010ca10:	75 17                	jne    f010ca29 <create_user_kern_stack+0x78>
	        panic("create_user_kern_stack: Failed to find or create page table!");
f010ca12:	83 ec 04             	sub    $0x4,%esp
f010ca15:	68 88 84 12 f0       	push   $0xf0128488
f010ca1a:	68 7a 03 00 00       	push   $0x37a
f010ca1f:	68 c7 81 12 f0       	push   $0xf01281c7
f010ca24:	e8 10 39 ff ff       	call   f0100339 <_panic>
	    }

	    // Mark the guard page as not present (clear the PERM_PRESENT bit)
	    page_table[PTX(guard_page_addr)] &= ~PERM_PRESENT;  // Unset the present bit
f010ca29:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ca2c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010ca2f:	c1 ea 0c             	shr    $0xc,%edx
f010ca32:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010ca38:	c1 e2 02             	shl    $0x2,%edx
f010ca3b:	01 d0                	add    %edx,%eax
f010ca3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ca40:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010ca43:	c1 e9 0c             	shr    $0xc,%ecx
f010ca46:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010ca4c:	c1 e1 02             	shl    $0x2,%ecx
f010ca4f:	01 ca                	add    %ecx,%edx
f010ca51:	8b 12                	mov    (%edx),%edx
f010ca53:	83 e2 fe             	and    $0xfffffffe,%edx
f010ca56:	89 10                	mov    %edx,(%eax)

	    // Return the base address of the allocated stack (including guard page)
	    return stack_base;
f010ca58:	8b 45 f4             	mov    -0xc(%ebp),%eax
	void* kstack = (void*) __cur_k_stk;
	__cur_k_stk += KERNEL_STACK_SIZE;
	return kstack ;
//	panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010ca5b:	c9                   	leave  
f010ca5c:	c3                   	ret    

f010ca5d <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010ca5d:	55                   	push   %ebp
f010ca5e:	89 e5                	mov    %esp,%ebp
f010ca60:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010ca63:	83 ec 04             	sub    $0x4,%esp
f010ca66:	68 c8 84 12 f0       	push   $0xf01284c8
f010ca6b:	68 96 03 00 00       	push   $0x396
f010ca70:	68 c7 81 12 f0       	push   $0xf01281c7
f010ca75:	e8 bf 38 ff ff       	call   f0100339 <_panic>

f010ca7a <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010ca7a:	55                   	push   %ebp
f010ca7b:	89 e5                	mov    %esp,%ebp
f010ca7d:	83 ec 08             	sub    $0x8,%esp
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");

	e->uheapStart = daStart;
f010ca80:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca83:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ca86:	89 50 74             	mov    %edx,0x74(%eax)
	e->uheapBreak = daStart;
f010ca89:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca8c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ca8f:	89 50 78             	mov    %edx,0x78(%eax)
	e->uheapHardLimit = daLimit;
f010ca92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca95:	8b 55 10             	mov    0x10(%ebp),%edx
f010ca98:	89 50 7c             	mov    %edx,0x7c(%eax)
	initialize_dynamic_allocator(daStart,0);
f010ca9b:	83 ec 08             	sub    $0x8,%esp
f010ca9e:	6a 00                	push   $0x0
f010caa0:	ff 75 0c             	pushl  0xc(%ebp)
f010caa3:	e8 62 60 01 00       	call   f0122b0a <initialize_dynamic_allocator>
f010caa8:	83 c4 10             	add    $0x10,%esp
}
f010caab:	90                   	nop
f010caac:	c9                   	leave  
f010caad:	c3                   	ret    

f010caae <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010caae:	55                   	push   %ebp
f010caaf:	89 e5                	mov    %esp,%ebp
f010cab1:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010cab4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cab7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010caba:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010cabd:	8b 45 08             	mov    0x8(%ebp),%eax
f010cac0:	8b 55 10             	mov    0x10(%ebp),%edx
f010cac3:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010cac6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cacd:	eb 17                	jmp    f010cae6 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010cacf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cad2:	8b 40 64             	mov    0x64(%eax),%eax
f010cad5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cad8:	c1 e2 02             	shl    $0x2,%edx
f010cadb:	01 d0                	add    %edx,%eax
f010cadd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010cae3:	ff 45 f4             	incl   -0xc(%ebp)
f010cae6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cae9:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010caee:	76 df                	jbe    f010cacf <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010caf0:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010caf7:	eb 22                	jmp    f010cb1b <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010caf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cafc:	8b 40 64             	mov    0x64(%eax),%eax
f010caff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cb02:	c1 e2 02             	shl    $0x2,%edx
f010cb05:	01 c2                	add    %eax,%edx
f010cb07:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f010cb0c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010cb0f:	c1 e1 02             	shl    $0x2,%ecx
f010cb12:	01 c8                	add    %ecx,%eax
f010cb14:	8b 00                	mov    (%eax),%eax
f010cb16:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010cb18:	ff 45 f4             	incl   -0xc(%ebp)
f010cb1b:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010cb22:	7e d5                	jle    f010caf9 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010cb24:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb27:	8b 40 64             	mov    0x64(%eax),%eax
f010cb2a:	83 ec 0c             	sub    $0xc,%esp
f010cb2d:	50                   	push   %eax
f010cb2e:	e8 7e fe ff ff       	call   f010c9b1 <create_user_kern_stack>
f010cb33:	83 c4 10             	add    $0x10,%esp
f010cb36:	89 c2                	mov    %eax,%edx
f010cb38:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb3b:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010cb3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb41:	8b 40 70             	mov    0x70(%eax),%eax
f010cb44:	05 00 80 00 00       	add    $0x8000,%eax
f010cb49:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010cb4c:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010cb50:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb53:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010cb56:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010cb58:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010cb5c:	ba 92 eb 10 f0       	mov    $0xf010eb92,%edx
f010cb61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb64:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010cb66:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010cb6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010cb70:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010cb73:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb76:	8b 40 04             	mov    0x4(%eax),%eax
f010cb79:	83 ec 04             	sub    $0x4,%esp
f010cb7c:	6a 20                	push   $0x20
f010cb7e:	6a 00                	push   $0x0
f010cb80:	50                   	push   %eax
f010cb81:	e8 a3 55 01 00       	call   f0122129 <memset>
f010cb86:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010cb89:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb8c:	8b 40 04             	mov    0x4(%eax),%eax
f010cb8f:	ba aa be 10 f0       	mov    $0xf010beaa,%edx
f010cb94:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010cb97:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb9a:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010cba1:	00 00 00 
f010cba4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cba7:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010cbae:	00 00 00 
f010cbb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010cbb4:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010cbbb:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010cbbe:	83 ec 0c             	sub    $0xc,%esp
f010cbc1:	6a 02                	push   $0x2
f010cbc3:	e8 ac 30 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010cbc8:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010cbcb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cbd2:	eb 54                	jmp    f010cc28 <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010cbd4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010cbd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cbda:	89 d0                	mov    %edx,%eax
f010cbdc:	01 c0                	add    %eax,%eax
f010cbde:	01 d0                	add    %edx,%eax
f010cbe0:	c1 e0 03             	shl    $0x3,%eax
f010cbe3:	01 c8                	add    %ecx,%eax
f010cbe5:	05 b0 00 00 00       	add    $0xb0,%eax
f010cbea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010cbf0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010cbf3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cbf6:	89 d0                	mov    %edx,%eax
f010cbf8:	01 c0                	add    %eax,%eax
f010cbfa:	01 d0                	add    %edx,%eax
f010cbfc:	c1 e0 03             	shl    $0x3,%eax
f010cbff:	01 c8                	add    %ecx,%eax
f010cc01:	05 b4 00 00 00       	add    $0xb4,%eax
f010cc06:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010cc09:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010cc0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc0f:	89 d0                	mov    %edx,%eax
f010cc11:	01 c0                	add    %eax,%eax
f010cc13:	01 d0                	add    %edx,%eax
f010cc15:	c1 e0 03             	shl    $0x3,%eax
f010cc18:	01 c8                	add    %ecx,%eax
f010cc1a:	05 b8 00 00 00       	add    $0xb8,%eax
f010cc1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010cc25:	ff 45 f4             	incl   -0xc(%ebp)
f010cc28:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010cc2c:	7e a6                	jle    f010cbd4 <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010cc2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc31:	c7 80 60 05 00 00 00 	movl   $0x0,0x560(%eax)
f010cc38:	00 00 00 

	e->pageFaultsCounter=0;
f010cc3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc3e:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010cc45:	00 00 00 
	e->tableFaultsCounter=0;
f010cc48:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc4b:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010cc52:	00 00 00 

	e->freeingFullWSCounter = 0;
f010cc55:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc58:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010cc5f:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010cc62:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc65:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010cc6c:	00 00 00 

	e->nModifiedPages=0;
f010cc6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc72:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010cc79:	00 00 00 
	e->nNotModifiedPages=0;
f010cc7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc7f:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010cc86:	00 00 00 
	e->nClocks = 0;
f010cc89:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc8c:	c7 80 c0 05 00 00 00 	movl   $0x0,0x5c0(%eax)
f010cc93:	00 00 00 

	//2020
	e->nPageIn = 0;
f010cc96:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc99:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010cca0:	00 00 00 
	e->nPageOut = 0;
f010cca3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cca6:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010ccad:	00 00 00 
	e->nNewPageAdded = 0;
f010ccb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccb3:	c7 80 bc 05 00 00 00 	movl   $0x0,0x5bc(%eax)
f010ccba:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010ccbd:	83 ec 04             	sub    $0x4,%esp
f010ccc0:	68 00 00 00 82       	push   $0x82000000
f010ccc5:	68 00 00 00 80       	push   $0x80000000
f010ccca:	ff 75 08             	pushl  0x8(%ebp)
f010cccd:	e8 a8 fd ff ff       	call   f010ca7a <initialize_uheap_dynamic_allocator>
f010ccd2:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010ccd5:	83 ec 0c             	sub    $0xc,%esp
f010ccd8:	ff 75 08             	pushl  0x8(%ebp)
f010ccdb:	e8 06 00 00 00       	call   f010cce6 <complete_environment_initialization>
f010cce0:	83 c4 10             	add    $0x10,%esp
}
f010cce3:	90                   	nop
f010cce4:	c9                   	leave  
f010cce5:	c3                   	ret    

f010cce6 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010cce6:	55                   	push   %ebp
f010cce7:	89 e5                	mov    %esp,%ebp
f010cce9:	53                   	push   %ebx
f010ccea:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010cced:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccf0:	8b 40 64             	mov    0x64(%eax),%eax
f010ccf3:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010ccf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ccfc:	8b 40 68             	mov    0x68(%eax),%eax
f010ccff:	83 c8 03             	or     $0x3,%eax
f010cd02:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010cd04:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd07:	8b 40 64             	mov    0x64(%eax),%eax
f010cd0a:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010cd10:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd13:	8b 40 68             	mov    0x68(%eax),%eax
f010cd16:	83 c8 05             	or     $0x5,%eax
f010cd19:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010cd1b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd1e:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010cd25:	00 00 00 
	e->disk_env_pgdir_PA= 0;
f010cd28:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd2b:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
f010cd32:	00 00 00 
	e->disk_env_tabledir = 0;
f010cd35:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd38:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010cd3f:	00 00 00 
	e->disk_env_tabledir_PA = 0;
f010cd42:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd45:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010cd4c:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010cd4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd52:	8b 58 10             	mov    0x10(%eax),%ebx
f010cd55:	83 ec 0c             	sub    $0xc,%esp
f010cd58:	68 c6 02 00 00       	push   $0x2c6
f010cd5d:	e8 6c 37 01 00       	call   f01204ce <log2_ceil>
f010cd62:	83 c4 10             	add    $0x10,%esp
f010cd65:	ba 01 00 00 00       	mov    $0x1,%edx
f010cd6a:	88 c1                	mov    %al,%cl
f010cd6c:	d3 e2                	shl    %cl,%edx
f010cd6e:	89 d0                	mov    %edx,%eax
f010cd70:	01 d8                	add    %ebx,%eax
f010cd72:	89 c3                	mov    %eax,%ebx
f010cd74:	83 ec 0c             	sub    $0xc,%esp
f010cd77:	68 c6 02 00 00       	push   $0x2c6
f010cd7c:	e8 18 37 01 00       	call   f0120499 <nearest_pow2_ceil>
f010cd81:	83 c4 10             	add    $0x10,%esp
f010cd84:	f7 d8                	neg    %eax
f010cd86:	21 d8                	and    %ebx,%eax
f010cd88:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010cd8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd8f:	7f 1e                	jg     f010cdaf <complete_environment_initialization+0xc9>
		generation = 1 << ENVGENSHIFT;
f010cd91:	83 ec 0c             	sub    $0xc,%esp
f010cd94:	68 c6 02 00 00       	push   $0x2c6
f010cd99:	e8 30 37 01 00       	call   f01204ce <log2_ceil>
f010cd9e:	83 c4 10             	add    $0x10,%esp
f010cda1:	ba 01 00 00 00       	mov    $0x1,%edx
f010cda6:	88 c1                	mov    %al,%cl
f010cda8:	d3 e2                	shl    %cl,%edx
f010cdaa:	89 d0                	mov    %edx,%eax
f010cdac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010cdaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdb2:	8b 15 10 cd 71 f0    	mov    0xf071cd10,%edx
f010cdb8:	29 d0                	sub    %edx,%eax
f010cdba:	c1 f8 02             	sar    $0x2,%eax
f010cdbd:	89 c1                	mov    %eax,%ecx
f010cdbf:	89 ca                	mov    %ecx,%edx
f010cdc1:	c1 e2 02             	shl    $0x2,%edx
f010cdc4:	01 ca                	add    %ecx,%edx
f010cdc6:	c1 e2 02             	shl    $0x2,%edx
f010cdc9:	01 ca                	add    %ecx,%edx
f010cdcb:	c1 e2 03             	shl    $0x3,%edx
f010cdce:	01 ca                	add    %ecx,%edx
f010cdd0:	89 d0                	mov    %edx,%eax
f010cdd2:	c1 e0 05             	shl    $0x5,%eax
f010cdd5:	29 d0                	sub    %edx,%eax
f010cdd7:	c1 e0 02             	shl    $0x2,%eax
f010cdda:	01 c8                	add    %ecx,%eax
f010cddc:	c1 e0 02             	shl    $0x2,%eax
f010cddf:	01 c8                	add    %ecx,%eax
f010cde1:	c1 e0 02             	shl    $0x2,%eax
f010cde4:	01 c8                	add    %ecx,%eax
f010cde6:	c1 e0 06             	shl    $0x6,%eax
f010cde9:	29 c8                	sub    %ecx,%eax
f010cdeb:	c1 e0 03             	shl    $0x3,%eax
f010cdee:	01 c8                	add    %ecx,%eax
f010cdf0:	c1 e0 04             	shl    $0x4,%eax
f010cdf3:	01 c8                	add    %ecx,%eax
f010cdf5:	0b 45 f4             	or     -0xc(%ebp),%eax
f010cdf8:	89 c2                	mov    %eax,%edx
f010cdfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010cdfd:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010ce00:	e8 3f f1 ff ff       	call   f010bf44 <get_cpu_proc>
f010ce05:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010ce08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ce0c:	75 0c                	jne    f010ce1a <complete_environment_initialization+0x134>
		e->env_parent_id = 0;//no parent;
f010ce0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce11:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ce18:	eb 0c                	jmp    f010ce26 <complete_environment_initialization+0x140>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010ce1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ce1d:	8b 50 10             	mov    0x10(%eax),%edx
f010ce20:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce23:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010ce26:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce29:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010ce30:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce33:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010ce3a:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010ce3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce40:	8b 00                	mov    (%eax),%eax
f010ce42:	83 ec 04             	sub    $0x4,%esp
f010ce45:	6a 44                	push   $0x44
f010ce47:	6a 00                	push   $0x0
f010ce49:	50                   	push   %eax
f010ce4a:	e8 da 52 01 00       	call   f0122129 <memset>
f010ce4f:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010ce52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce55:	8b 00                	mov    (%eax),%eax
f010ce57:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010ce5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce60:	8b 00                	mov    (%eax),%eax
f010ce62:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010ce68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce6b:	8b 00                	mov    (%eax),%eax
f010ce6d:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010ce73:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce76:	8b 00                	mov    (%eax),%eax
f010ce78:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010ce7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce82:	8b 00                	mov    (%eax),%eax
f010ce84:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010ce8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce8d:	8b 00                	mov    (%eax),%eax
f010ce8f:	8b 55 08             	mov    0x8(%ebp),%edx
f010ce92:	8b 12                	mov    (%edx),%edx
f010ce94:	8b 52 38             	mov    0x38(%edx),%edx
f010ce97:	80 ce 02             	or     $0x2,%dh
f010ce9a:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010ce9d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cea1:	75 17                	jne    f010ceba <complete_environment_initialization+0x1d4>
f010cea3:	83 ec 04             	sub    $0x4,%esp
f010cea6:	68 4f 82 12 f0       	push   $0xf012824f
f010ceab:	68 6f 04 00 00       	push   $0x46f
f010ceb0:	68 c7 81 12 f0       	push   $0xf01281c7
f010ceb5:	e8 7f 34 ff ff       	call   f0100339 <_panic>
f010ceba:	8b 45 08             	mov    0x8(%ebp),%eax
f010cebd:	8b 40 08             	mov    0x8(%eax),%eax
f010cec0:	85 c0                	test   %eax,%eax
f010cec2:	74 11                	je     f010ced5 <complete_environment_initialization+0x1ef>
f010cec4:	8b 45 08             	mov    0x8(%ebp),%eax
f010cec7:	8b 40 08             	mov    0x8(%eax),%eax
f010ceca:	8b 55 08             	mov    0x8(%ebp),%edx
f010cecd:	8b 52 0c             	mov    0xc(%edx),%edx
f010ced0:	89 50 0c             	mov    %edx,0xc(%eax)
f010ced3:	eb 0b                	jmp    f010cee0 <complete_environment_initialization+0x1fa>
f010ced5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ced8:	8b 40 0c             	mov    0xc(%eax),%eax
f010cedb:	a3 18 cd 71 f0       	mov    %eax,0xf071cd18
f010cee0:	8b 45 08             	mov    0x8(%ebp),%eax
f010cee3:	8b 40 0c             	mov    0xc(%eax),%eax
f010cee6:	85 c0                	test   %eax,%eax
f010cee8:	74 11                	je     f010cefb <complete_environment_initialization+0x215>
f010ceea:	8b 45 08             	mov    0x8(%ebp),%eax
f010ceed:	8b 40 0c             	mov    0xc(%eax),%eax
f010cef0:	8b 55 08             	mov    0x8(%ebp),%edx
f010cef3:	8b 52 08             	mov    0x8(%edx),%edx
f010cef6:	89 50 08             	mov    %edx,0x8(%eax)
f010cef9:	eb 0b                	jmp    f010cf06 <complete_environment_initialization+0x220>
f010cefb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cefe:	8b 40 08             	mov    0x8(%eax),%eax
f010cf01:	a3 14 cd 71 f0       	mov    %eax,0xf071cd14
f010cf06:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf09:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010cf10:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf13:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010cf1a:	a1 20 cd 71 f0       	mov    0xf071cd20,%eax
f010cf1f:	48                   	dec    %eax
f010cf20:	a3 20 cd 71 f0       	mov    %eax,0xf071cd20
	return ;
f010cf25:	90                   	nop
}
f010cf26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cf29:	c9                   	leave  
f010cf2a:	c3                   	ret    

f010cf2b <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010cf2b:	55                   	push   %ebp
f010cf2c:	89 e5                	mov    %esp,%ebp
f010cf2e:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cf31:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cf34:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cf37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf3a:	8b 00                	mov    (%eax),%eax
f010cf3c:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cf41:	74 17                	je     f010cf5a <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010cf43:	83 ec 04             	sub    $0x4,%esp
f010cf46:	68 fd 84 12 f0       	push   $0xf01284fd
f010cf4b:	68 7b 04 00 00       	push   $0x47b
f010cf50:	68 c7 81 12 f0       	push   $0xf01281c7
f010cf55:	e8 df 33 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010cf5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf5d:	8b 00                	mov    (%eax),%eax
f010cf5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf62:	8b 52 18             	mov    0x18(%edx),%edx
f010cf65:	89 50 30             	mov    %edx,0x30(%eax)
}
f010cf68:	90                   	nop
f010cf69:	c9                   	leave  
f010cf6a:	c3                   	ret    

f010cf6b <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010cf6b:	55                   	push   %ebp
f010cf6c:	89 e5                	mov    %esp,%ebp
f010cf6e:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010cf71:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf74:	8b 40 10             	mov    0x10(%eax),%eax
f010cf77:	8d 48 01             	lea    0x1(%eax),%ecx
f010cf7a:	8b 55 08             	mov    0x8(%ebp),%edx
f010cf7d:	89 4a 10             	mov    %ecx,0x10(%edx)
f010cf80:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cf83:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cf86:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cf89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cf8c:	8b 00                	mov    (%eax),%eax
f010cf8e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cf93:	74 17                	je     f010cfac <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010cf95:	83 ec 04             	sub    $0x4,%esp
f010cf98:	68 fd 84 12 f0       	push   $0xf01284fd
f010cf9d:	68 89 04 00 00       	push   $0x489
f010cfa2:	68 c7 81 12 f0       	push   $0xf01281c7
f010cfa7:	e8 8d 33 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cfac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cfaf:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cfb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cfb5:	01 d0                	add    %edx,%eax
f010cfb7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cfba:	eb 0f                	jmp    f010cfcb <PROGRAM_SEGMENT_NEXT+0x60>
f010cfbc:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfbf:	8b 40 10             	mov    0x10(%eax),%eax
f010cfc2:	8d 50 01             	lea    0x1(%eax),%edx
f010cfc5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfc8:	89 50 10             	mov    %edx,0x10(%eax)
f010cfcb:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfce:	8b 40 10             	mov    0x10(%eax),%eax
f010cfd1:	c1 e0 05             	shl    $0x5,%eax
f010cfd4:	89 c2                	mov    %eax,%edx
f010cfd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cfd9:	01 d0                	add    %edx,%eax
f010cfdb:	8b 00                	mov    (%eax),%eax
f010cfdd:	83 f8 01             	cmp    $0x1,%eax
f010cfe0:	74 13                	je     f010cff5 <PROGRAM_SEGMENT_NEXT+0x8a>
f010cfe2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfe5:	8b 50 10             	mov    0x10(%eax),%edx
f010cfe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cfeb:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cfee:	0f b7 c0             	movzwl %ax,%eax
f010cff1:	39 c2                	cmp    %eax,%edx
f010cff3:	72 c7                	jb     f010cfbc <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cff5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cff8:	8b 40 10             	mov    0x10(%eax),%eax
f010cffb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cffe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d001:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d004:	0f b7 c0             	movzwl %ax,%eax
f010d007:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010d00a:	7e 63                	jle    f010d06f <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010d00c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d00f:	c1 e0 05             	shl    $0x5,%eax
f010d012:	89 c2                	mov    %eax,%edx
f010d014:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d017:	01 d0                	add    %edx,%eax
f010d019:	8b 50 04             	mov    0x4(%eax),%edx
f010d01c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d01f:	01 c2                	add    %eax,%edx
f010d021:	8b 45 08             	mov    0x8(%ebp),%eax
f010d024:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010d026:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d029:	c1 e0 05             	shl    $0x5,%eax
f010d02c:	89 c2                	mov    %eax,%edx
f010d02e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d031:	01 d0                	add    %edx,%eax
f010d033:	8b 50 14             	mov    0x14(%eax),%edx
f010d036:	8b 45 08             	mov    0x8(%ebp),%eax
f010d039:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010d03c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d03f:	c1 e0 05             	shl    $0x5,%eax
f010d042:	89 c2                	mov    %eax,%edx
f010d044:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d047:	01 d0                	add    %edx,%eax
f010d049:	8b 50 10             	mov    0x10(%eax),%edx
f010d04c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d04f:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010d052:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d055:	c1 e0 05             	shl    $0x5,%eax
f010d058:	89 c2                	mov    %eax,%edx
f010d05a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d05d:	01 d0                	add    %edx,%eax
f010d05f:	8b 40 08             	mov    0x8(%eax),%eax
f010d062:	89 c2                	mov    %eax,%edx
f010d064:	8b 45 08             	mov    0x8(%ebp),%eax
f010d067:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010d06a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d06d:	eb 05                	jmp    f010d074 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010d06f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d074:	c9                   	leave  
f010d075:	c3                   	ret    

f010d076 <PROGRAM_SEGMENT_FIRST>:
//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010d076:	55                   	push   %ebp
f010d077:	89 e5                	mov    %esp,%ebp
f010d079:	57                   	push   %edi
f010d07a:	56                   	push   %esi
f010d07b:	53                   	push   %ebx
f010d07c:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010d07f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010d086:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d089:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010d08c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010d08f:	8b 00                	mov    (%eax),%eax
f010d091:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010d096:	74 17                	je     f010d0af <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010d098:	83 ec 04             	sub    $0x4,%esp
f010d09b:	68 fd 84 12 f0       	push   $0xf01284fd
f010d0a0:	68 a4 04 00 00       	push   $0x4a4
f010d0a5:	68 c7 81 12 f0       	push   $0xf01281c7
f010d0aa:	e8 8a 32 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010d0af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010d0b2:	8b 50 1c             	mov    0x1c(%eax),%edx
f010d0b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d0b8:	01 d0                	add    %edx,%eax
f010d0ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010d0bd:	eb 07                	jmp    f010d0c6 <PROGRAM_SEGMENT_FIRST+0x50>
f010d0bf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010d0c2:	40                   	inc    %eax
f010d0c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010d0c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010d0c9:	c1 e0 05             	shl    $0x5,%eax
f010d0cc:	89 c2                	mov    %eax,%edx
f010d0ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d0d1:	01 d0                	add    %edx,%eax
f010d0d3:	8b 00                	mov    (%eax),%eax
f010d0d5:	83 f8 01             	cmp    $0x1,%eax
f010d0d8:	74 10                	je     f010d0ea <PROGRAM_SEGMENT_FIRST+0x74>
f010d0da:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010d0dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010d0e0:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d0e3:	0f b7 c0             	movzwl %ax,%eax
f010d0e6:	39 c2                	cmp    %eax,%edx
f010d0e8:	72 d5                	jb     f010d0bf <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010d0ea:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010d0ed:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010d0f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010d0f3:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d0f6:	0f b7 c0             	movzwl %ax,%eax
f010d0f9:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010d0fc:	7e 68                	jle    f010d166 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010d0fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010d101:	c1 e0 05             	shl    $0x5,%eax
f010d104:	89 c2                	mov    %eax,%edx
f010d106:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d109:	01 d0                	add    %edx,%eax
f010d10b:	8b 50 04             	mov    0x4(%eax),%edx
f010d10e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d111:	01 d0                	add    %edx,%eax
f010d113:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010d116:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010d119:	c1 e0 05             	shl    $0x5,%eax
f010d11c:	89 c2                	mov    %eax,%edx
f010d11e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d121:	01 d0                	add    %edx,%eax
f010d123:	8b 40 14             	mov    0x14(%eax),%eax
f010d126:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010d129:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010d12c:	c1 e0 05             	shl    $0x5,%eax
f010d12f:	89 c2                	mov    %eax,%edx
f010d131:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d134:	01 d0                	add    %edx,%eax
f010d136:	8b 40 10             	mov    0x10(%eax),%eax
f010d139:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010d13c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010d13f:	c1 e0 05             	shl    $0x5,%eax
f010d142:	89 c2                	mov    %eax,%edx
f010d144:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d147:	01 d0                	add    %edx,%eax
f010d149:	8b 40 08             	mov    0x8(%eax),%eax
f010d14c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010d14f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d152:	89 c3                	mov    %eax,%ebx
f010d154:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010d157:	ba 05 00 00 00       	mov    $0x5,%edx
f010d15c:	89 df                	mov    %ebx,%edi
f010d15e:	89 c6                	mov    %eax,%esi
f010d160:	89 d1                	mov    %edx,%ecx
f010d162:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010d164:	eb 1c                	jmp    f010d182 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010d166:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010d16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d170:	89 c3                	mov    %eax,%ebx
f010d172:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010d175:	ba 05 00 00 00       	mov    $0x5,%edx
f010d17a:	89 df                	mov    %ebx,%edi
f010d17c:	89 c6                	mov    %eax,%esi
f010d17e:	89 d1                	mov    %edx,%ecx
f010d180:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010d182:	8b 45 08             	mov    0x8(%ebp),%eax
f010d185:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d188:	5b                   	pop    %ebx
f010d189:	5e                   	pop    %esi
f010d18a:	5f                   	pop    %edi
f010d18b:	5d                   	pop    %ebp
f010d18c:	c2 04 00             	ret    $0x4

f010d18f <cleanup_buffers>:
//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010d18f:	55                   	push   %ebp
f010d190:	89 e5                	mov    %esp,%ebp
f010d192:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010d195:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010d19c:	83 ec 0c             	sub    $0xc,%esp
f010d19f:	68 c0 58 74 f0       	push   $0xf07458c0
f010d1a4:	e8 41 36 00 00       	call   f01107ea <acquire_spinlock>
f010d1a9:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010d1ac:	a1 b0 58 74 f0       	mov    0xf07458b0,%eax
f010d1b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d1b4:	e9 c3 00 00 00       	jmp    f010d27c <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010d1b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d1bc:	8b 40 0c             	mov    0xc(%eax),%eax
f010d1bf:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d1c2:	0f 85 ac 00 00 00    	jne    f010d274 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010d1c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d1cb:	8b 50 10             	mov    0x10(%eax),%edx
f010d1ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d1d1:	8b 40 0c             	mov    0xc(%eax),%eax
f010d1d4:	8b 40 64             	mov    0x64(%eax),%eax
f010d1d7:	83 ec 08             	sub    $0x8,%esp
f010d1da:	52                   	push   %edx
f010d1db:	50                   	push   %eax
f010d1dc:	e8 5e d0 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f010d1e1:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010d1e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d1e8:	75 17                	jne    f010d201 <cleanup_buffers+0x72>
f010d1ea:	83 ec 04             	sub    $0x4,%esp
f010d1ed:	68 4f 82 12 f0       	push   $0xf012824f
f010d1f2:	68 ca 04 00 00       	push   $0x4ca
f010d1f7:	68 c7 81 12 f0       	push   $0xf01281c7
f010d1fc:	e8 38 31 ff ff       	call   f0100339 <_panic>
f010d201:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d204:	8b 00                	mov    (%eax),%eax
f010d206:	85 c0                	test   %eax,%eax
f010d208:	74 10                	je     f010d21a <cleanup_buffers+0x8b>
f010d20a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d20d:	8b 00                	mov    (%eax),%eax
f010d20f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d212:	8b 52 04             	mov    0x4(%edx),%edx
f010d215:	89 50 04             	mov    %edx,0x4(%eax)
f010d218:	eb 0b                	jmp    f010d225 <cleanup_buffers+0x96>
f010d21a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d21d:	8b 40 04             	mov    0x4(%eax),%eax
f010d220:	a3 b4 58 74 f0       	mov    %eax,0xf07458b4
f010d225:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d228:	8b 40 04             	mov    0x4(%eax),%eax
f010d22b:	85 c0                	test   %eax,%eax
f010d22d:	74 0f                	je     f010d23e <cleanup_buffers+0xaf>
f010d22f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d232:	8b 40 04             	mov    0x4(%eax),%eax
f010d235:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d238:	8b 12                	mov    (%edx),%edx
f010d23a:	89 10                	mov    %edx,(%eax)
f010d23c:	eb 0a                	jmp    f010d248 <cleanup_buffers+0xb9>
f010d23e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d241:	8b 00                	mov    (%eax),%eax
f010d243:	a3 b0 58 74 f0       	mov    %eax,0xf07458b0
f010d248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d24b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010d251:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d254:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010d25b:	a1 bc 58 74 f0       	mov    0xf07458bc,%eax
f010d260:	48                   	dec    %eax
f010d261:	a3 bc 58 74 f0       	mov    %eax,0xf07458bc

				free_frame(ptr_fi);
f010d266:	83 ec 0c             	sub    $0xc,%esp
f010d269:	ff 75 f4             	pushl  -0xc(%ebp)
f010d26c:	e8 86 b7 ff ff       	call   f01089f7 <free_frame>
f010d271:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010d274:	a1 b8 58 74 f0       	mov    0xf07458b8,%eax
f010d279:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d27c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d280:	74 07                	je     f010d289 <cleanup_buffers+0xfa>
f010d282:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d285:	8b 00                	mov    (%eax),%eax
f010d287:	eb 05                	jmp    f010d28e <cleanup_buffers+0xff>
f010d289:	b8 00 00 00 00       	mov    $0x0,%eax
f010d28e:	a3 b8 58 74 f0       	mov    %eax,0xf07458b8
f010d293:	a1 b8 58 74 f0       	mov    0xf07458b8,%eax
f010d298:	85 c0                	test   %eax,%eax
f010d29a:	0f 85 19 ff ff ff    	jne    f010d1b9 <cleanup_buffers+0x2a>
f010d2a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d2a4:	0f 85 0f ff ff ff    	jne    f010d1b9 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d2aa:	83 ec 0c             	sub    $0xc,%esp
f010d2ad:	68 c0 58 74 f0       	push   $0xf07458c0
f010d2b2:	e8 ba 35 00 00       	call   f0110871 <release_spinlock>
f010d2b7:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010d2ba:	90                   	nop
f010d2bb:	c9                   	leave  
f010d2bc:	c3                   	ret    

f010d2bd <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010d2bd:	55                   	push   %ebp
f010d2be:	89 e5                	mov    %esp,%ebp
f010d2c0:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010d2c3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010d2c7:	7e 06                	jle    f010d2cf <set_program_priority+0x12>
f010d2c9:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d2cd:	7e 14                	jle    f010d2e3 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010d2cf:	83 ec 04             	sub    $0x4,%esp
f010d2d2:	68 14 85 12 f0       	push   $0xf0128514
f010d2d7:	6a 10                	push   $0x10
f010d2d9:	68 38 85 12 f0       	push   $0xf0128538
f010d2de:	e8 56 30 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010d2e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d2e7:	74 78                	je     f010d361 <set_program_priority+0xa4>
		return;
	switch(priority)
f010d2e9:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010d2ed:	77 56                	ja     f010d345 <set_program_priority+0x88>
f010d2ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d2f2:	c1 e0 02             	shl    $0x2,%eax
f010d2f5:	05 74 85 12 f0       	add    $0xf0128574,%eax
f010d2fa:	8b 00                	mov    (%eax),%eax
f010d2fc:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010d2fe:	83 ec 08             	sub    $0x8,%esp
f010d301:	6a 01                	push   $0x1
f010d303:	ff 75 08             	pushl  0x8(%ebp)
f010d306:	e8 5d dc ff ff       	call   f010af68 <half_WS_Size>
f010d30b:	83 c4 10             	add    $0x10,%esp
			break;
f010d30e:	eb 35                	jmp    f010d345 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010d310:	83 ec 08             	sub    $0x8,%esp
f010d313:	6a 00                	push   $0x0
f010d315:	ff 75 08             	pushl  0x8(%ebp)
f010d318:	e8 4b dc ff ff       	call   f010af68 <half_WS_Size>
f010d31d:	83 c4 10             	add    $0x10,%esp
			break;
f010d320:	eb 23                	jmp    f010d345 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010d322:	83 ec 08             	sub    $0x8,%esp
f010d325:	6a 01                	push   $0x1
f010d327:	ff 75 08             	pushl  0x8(%ebp)
f010d32a:	e8 1c dc ff ff       	call   f010af4b <double_WS_Size>
f010d32f:	83 c4 10             	add    $0x10,%esp
			break;
f010d332:	eb 11                	jmp    f010d345 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010d334:	83 ec 08             	sub    $0x8,%esp
f010d337:	6a 00                	push   $0x0
f010d339:	ff 75 08             	pushl  0x8(%ebp)
f010d33c:	e8 0a dc ff ff       	call   f010af4b <double_WS_Size>
f010d341:	83 c4 10             	add    $0x10,%esp
			break;
f010d344:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010d345:	8b 45 08             	mov    0x8(%ebp),%eax
f010d348:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010d34e:	83 ec 08             	sub    $0x8,%esp
f010d351:	50                   	push   %eax
f010d352:	68 55 85 12 f0       	push   $0xf0128555
f010d357:	e8 2f 3c ff ff       	call   f0100f8b <cprintf>
f010d35c:	83 c4 10             	add    $0x10,%esp
f010d35f:	eb 01                	jmp    f010d362 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010d361:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010d362:	c9                   	leave  
f010d363:	c3                   	ret    

f010d364 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010d364:	55                   	push   %ebp
f010d365:	89 e5                	mov    %esp,%ebp
f010d367:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d36a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d371:	eb 29                	jmp    f010d39c <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010d373:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d376:	89 d0                	mov    %edx,%eax
f010d378:	01 c0                	add    %eax,%eax
f010d37a:	01 d0                	add    %edx,%eax
f010d37c:	c1 e0 02             	shl    $0x2,%eax
f010d37f:	05 c0 39 18 f0       	add    $0xf01839c0,%eax
f010d384:	8b 00                	mov    (%eax),%eax
f010d386:	83 ec 08             	sub    $0x8,%esp
f010d389:	50                   	push   %eax
f010d38a:	ff 75 08             	pushl  0x8(%ebp)
f010d38d:	e8 b5 4c 01 00       	call   f0122047 <strcmp>
f010d392:	83 c4 10             	add    $0x10,%esp
f010d395:	85 c0                	test   %eax,%eax
f010d397:	74 0f                	je     f010d3a8 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d399:	ff 45 f4             	incl   -0xc(%ebp)
f010d39c:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f010d3a1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d3a4:	7c cd                	jl     f010d373 <get_user_program_info+0xf>
f010d3a6:	eb 01                	jmp    f010d3a9 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010d3a8:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d3a9:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f010d3ae:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d3b1:	75 1a                	jne    f010d3cd <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010d3b3:	83 ec 08             	sub    $0x8,%esp
f010d3b6:	ff 75 08             	pushl  0x8(%ebp)
f010d3b9:	68 71 94 12 f0       	push   $0xf0129471
f010d3be:	e8 c8 3b ff ff       	call   f0100f8b <cprintf>
f010d3c3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d3c6:	b8 00 00 00 00       	mov    $0x0,%eax
f010d3cb:	eb 11                	jmp    f010d3de <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010d3cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d3d0:	89 d0                	mov    %edx,%eax
f010d3d2:	01 c0                	add    %eax,%eax
f010d3d4:	01 d0                	add    %edx,%eax
f010d3d6:	c1 e0 02             	shl    $0x2,%eax
f010d3d9:	05 c0 39 18 f0       	add    $0xf01839c0,%eax
}
f010d3de:	c9                   	leave  
f010d3df:	c3                   	ret    

f010d3e0 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010d3e0:	55                   	push   %ebp
f010d3e1:	89 e5                	mov    %esp,%ebp
f010d3e3:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d3e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d3ed:	eb 2d                	jmp    f010d41c <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010d3ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d3f2:	89 d0                	mov    %edx,%eax
f010d3f4:	01 c0                	add    %eax,%eax
f010d3f6:	01 d0                	add    %edx,%eax
f010d3f8:	c1 e0 02             	shl    $0x2,%eax
f010d3fb:	05 c0 39 18 f0       	add    $0xf01839c0,%eax
f010d400:	8b 00                	mov    (%eax),%eax
f010d402:	8b 55 08             	mov    0x8(%ebp),%edx
f010d405:	83 c2 20             	add    $0x20,%edx
f010d408:	83 ec 08             	sub    $0x8,%esp
f010d40b:	50                   	push   %eax
f010d40c:	52                   	push   %edx
f010d40d:	e8 35 4c 01 00       	call   f0122047 <strcmp>
f010d412:	83 c4 10             	add    $0x10,%esp
f010d415:	85 c0                	test   %eax,%eax
f010d417:	74 0f                	je     f010d428 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010d419:	ff 45 f4             	incl   -0xc(%ebp)
f010d41c:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f010d421:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d424:	7c c9                	jl     f010d3ef <get_user_program_info_by_env+0xf>
f010d426:	eb 01                	jmp    f010d429 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010d428:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010d429:	a1 6c 3d 18 f0       	mov    0xf0183d6c,%eax
f010d42e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010d431:	75 17                	jne    f010d44a <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010d433:	83 ec 0c             	sub    $0xc,%esp
f010d436:	68 8c 94 12 f0       	push   $0xf012948c
f010d43b:	e8 4b 3b ff ff       	call   f0100f8b <cprintf>
f010d440:	83 c4 10             	add    $0x10,%esp
		return 0;
f010d443:	b8 00 00 00 00       	mov    $0x0,%eax
f010d448:	eb 11                	jmp    f010d45b <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010d44a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d44d:	89 d0                	mov    %edx,%eax
f010d44f:	01 c0                	add    %eax,%eax
f010d451:	01 d0                	add    %edx,%eax
f010d453:	c1 e0 02             	shl    $0x2,%eax
f010d456:	05 c0 39 18 f0       	add    $0xf01839c0,%eax
}
f010d45b:	c9                   	leave  
f010d45c:	c3                   	ret    

f010d45d <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010d45d:	55                   	push   %ebp
f010d45e:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010d460:	8b 45 08             	mov    0x8(%ebp),%eax
f010d463:	83 f8 13             	cmp    $0x13,%eax
f010d466:	77 0c                	ja     f010d474 <trapname+0x17>
		return excnames[trapno];
f010d468:	8b 45 08             	mov    0x8(%ebp),%eax
f010d46b:	8b 04 85 80 98 12 f0 	mov    -0xfed6780(,%eax,4),%eax
f010d472:	eb 2c                	jmp    f010d4a0 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010d474:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010d478:	75 07                	jne    f010d481 <trapname+0x24>
		return "System call";
f010d47a:	b8 c0 94 12 f0       	mov    $0xf01294c0,%eax
f010d47f:	eb 1f                	jmp    f010d4a0 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010d481:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010d485:	75 07                	jne    f010d48e <trapname+0x31>
		return "Clock Interrupt";
f010d487:	b8 cc 94 12 f0       	mov    $0xf01294cc,%eax
f010d48c:	eb 12                	jmp    f010d4a0 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010d48e:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010d492:	75 07                	jne    f010d49b <trapname+0x3e>
		return "Keyboard Interrupt";
f010d494:	b8 dc 94 12 f0       	mov    $0xf01294dc,%eax
f010d499:	eb 05                	jmp    f010d4a0 <trapname+0x43>
	return "(unknown trap)";
f010d49b:	b8 ef 94 12 f0       	mov    $0xf01294ef,%eax
}
f010d4a0:	5d                   	pop    %ebp
f010d4a1:	c3                   	ret    

f010d4a2 <ts_init>:


void ts_init(void)
{
f010d4a2:	55                   	push   %ebp
f010d4a3:	89 e5                	mov    %esp,%ebp
f010d4a5:	53                   	push   %ebx
f010d4a6:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010d4a9:	e8 fc a3 ff ff       	call   f01078aa <pushcli>

	struct cpu* c = mycpu();
f010d4ae:	e8 34 a3 ff ff       	call   f01077e7 <mycpu>
f010d4b3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010d4b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d4b9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010d4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d4c3:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010d4c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d4cc:	83 c0 0c             	add    $0xc,%eax
f010d4cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d4d2:	83 c2 0c             	add    $0xc,%edx
f010d4d5:	c1 ea 10             	shr    $0x10,%edx
f010d4d8:	88 d3                	mov    %dl,%bl
f010d4da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d4dd:	83 c2 0c             	add    $0xc,%edx
f010d4e0:	c1 ea 18             	shr    $0x18,%edx
f010d4e3:	88 d1                	mov    %dl,%cl
f010d4e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d4e8:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d4ef:	68 00 
f010d4f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d4f4:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d4fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d4fe:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d504:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d507:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d50d:	83 e2 f0             	and    $0xfffffff0,%edx
f010d510:	83 ca 09             	or     $0x9,%edx
f010d513:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d519:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d51c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d522:	83 ca 10             	or     $0x10,%edx
f010d525:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d52b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d52e:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d534:	83 e2 9f             	and    $0xffffff9f,%edx
f010d537:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d53d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d540:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d546:	83 ca 80             	or     $0xffffff80,%edx
f010d549:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d54f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d552:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d558:	83 e2 f0             	and    $0xfffffff0,%edx
f010d55b:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d561:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d564:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d56a:	83 e2 ef             	and    $0xffffffef,%edx
f010d56d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d573:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d576:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d57c:	83 e2 df             	and    $0xffffffdf,%edx
f010d57f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d585:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d588:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d58e:	83 ca 40             	or     $0x40,%edx
f010d591:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d597:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d59a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d5a0:	83 e2 7f             	and    $0x7f,%edx
f010d5a3:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d5a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d5ac:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d5b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d5b5:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d5bb:	83 e2 ef             	and    $0xffffffef,%edx
f010d5be:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d5c4:	e8 33 a3 ff ff       	call   f01078fc <popcli>
f010d5c9:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d5cf:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d5d3:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d5d6:	90                   	nop
f010d5d7:	83 c4 14             	add    $0x14,%esp
f010d5da:	5b                   	pop    %ebx
f010d5db:	5d                   	pop    %ebp
f010d5dc:	c3                   	ret    

f010d5dd <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d5dd:	55                   	push   %ebp
f010d5de:	89 e5                	mov    %esp,%ebp
f010d5e0:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d5e3:	b8 8c ea 10 f0       	mov    $0xf010ea8c,%eax
f010d5e8:	66 a3 80 cd 71 f0    	mov    %ax,0xf071cd80
f010d5ee:	66 c7 05 82 cd 71 f0 	movw   $0x8,0xf071cd82
f010d5f5:	08 00 
f010d5f7:	a0 84 cd 71 f0       	mov    0xf071cd84,%al
f010d5fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5ff:	a2 84 cd 71 f0       	mov    %al,0xf071cd84
f010d604:	a0 84 cd 71 f0       	mov    0xf071cd84,%al
f010d609:	83 e0 1f             	and    $0x1f,%eax
f010d60c:	a2 84 cd 71 f0       	mov    %al,0xf071cd84
f010d611:	a0 85 cd 71 f0       	mov    0xf071cd85,%al
f010d616:	83 e0 f0             	and    $0xfffffff0,%eax
f010d619:	83 c8 0e             	or     $0xe,%eax
f010d61c:	a2 85 cd 71 f0       	mov    %al,0xf071cd85
f010d621:	a0 85 cd 71 f0       	mov    0xf071cd85,%al
f010d626:	83 e0 ef             	and    $0xffffffef,%eax
f010d629:	a2 85 cd 71 f0       	mov    %al,0xf071cd85
f010d62e:	a0 85 cd 71 f0       	mov    0xf071cd85,%al
f010d633:	83 e0 9f             	and    $0xffffff9f,%eax
f010d636:	a2 85 cd 71 f0       	mov    %al,0xf071cd85
f010d63b:	a0 85 cd 71 f0       	mov    0xf071cd85,%al
f010d640:	83 c8 80             	or     $0xffffff80,%eax
f010d643:	a2 85 cd 71 f0       	mov    %al,0xf071cd85
f010d648:	b8 8c ea 10 f0       	mov    $0xf010ea8c,%eax
f010d64d:	c1 e8 10             	shr    $0x10,%eax
f010d650:	66 a3 86 cd 71 f0    	mov    %ax,0xf071cd86
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d656:	b8 94 ea 10 f0       	mov    $0xf010ea94,%eax
f010d65b:	66 a3 b0 cd 71 f0    	mov    %ax,0xf071cdb0
f010d661:	66 c7 05 b2 cd 71 f0 	movw   $0x8,0xf071cdb2
f010d668:	08 00 
f010d66a:	a0 b4 cd 71 f0       	mov    0xf071cdb4,%al
f010d66f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d672:	a2 b4 cd 71 f0       	mov    %al,0xf071cdb4
f010d677:	a0 b4 cd 71 f0       	mov    0xf071cdb4,%al
f010d67c:	83 e0 1f             	and    $0x1f,%eax
f010d67f:	a2 b4 cd 71 f0       	mov    %al,0xf071cdb4
f010d684:	a0 b5 cd 71 f0       	mov    0xf071cdb5,%al
f010d689:	83 e0 f0             	and    $0xfffffff0,%eax
f010d68c:	83 c8 0e             	or     $0xe,%eax
f010d68f:	a2 b5 cd 71 f0       	mov    %al,0xf071cdb5
f010d694:	a0 b5 cd 71 f0       	mov    0xf071cdb5,%al
f010d699:	83 e0 ef             	and    $0xffffffef,%eax
f010d69c:	a2 b5 cd 71 f0       	mov    %al,0xf071cdb5
f010d6a1:	a0 b5 cd 71 f0       	mov    0xf071cdb5,%al
f010d6a6:	83 e0 9f             	and    $0xffffff9f,%eax
f010d6a9:	a2 b5 cd 71 f0       	mov    %al,0xf071cdb5
f010d6ae:	a0 b5 cd 71 f0       	mov    0xf071cdb5,%al
f010d6b3:	83 c8 80             	or     $0xffffff80,%eax
f010d6b6:	a2 b5 cd 71 f0       	mov    %al,0xf071cdb5
f010d6bb:	b8 94 ea 10 f0       	mov    $0xf010ea94,%eax
f010d6c0:	c1 e8 10             	shr    $0x10,%eax
f010d6c3:	66 a3 b6 cd 71 f0    	mov    %ax,0xf071cdb6
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d6c9:	b8 9c ea 10 f0       	mov    $0xf010ea9c,%eax
f010d6ce:	66 a3 40 ce 71 f0    	mov    %ax,0xf071ce40
f010d6d4:	66 c7 05 42 ce 71 f0 	movw   $0x8,0xf071ce42
f010d6db:	08 00 
f010d6dd:	a0 44 ce 71 f0       	mov    0xf071ce44,%al
f010d6e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6e5:	a2 44 ce 71 f0       	mov    %al,0xf071ce44
f010d6ea:	a0 44 ce 71 f0       	mov    0xf071ce44,%al
f010d6ef:	83 e0 1f             	and    $0x1f,%eax
f010d6f2:	a2 44 ce 71 f0       	mov    %al,0xf071ce44
f010d6f7:	a0 45 ce 71 f0       	mov    0xf071ce45,%al
f010d6fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6ff:	83 c8 0e             	or     $0xe,%eax
f010d702:	a2 45 ce 71 f0       	mov    %al,0xf071ce45
f010d707:	a0 45 ce 71 f0       	mov    0xf071ce45,%al
f010d70c:	83 e0 ef             	and    $0xffffffef,%eax
f010d70f:	a2 45 ce 71 f0       	mov    %al,0xf071ce45
f010d714:	a0 45 ce 71 f0       	mov    0xf071ce45,%al
f010d719:	83 c8 60             	or     $0x60,%eax
f010d71c:	a2 45 ce 71 f0       	mov    %al,0xf071ce45
f010d721:	a0 45 ce 71 f0       	mov    0xf071ce45,%al
f010d726:	83 c8 80             	or     $0xffffff80,%eax
f010d729:	a2 45 ce 71 f0       	mov    %al,0xf071ce45
f010d72e:	b8 9c ea 10 f0       	mov    $0xf010ea9c,%eax
f010d733:	c1 e8 10             	shr    $0x10,%eax
f010d736:	66 a3 46 ce 71 f0    	mov    %ax,0xf071ce46
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d73c:	b8 a6 ea 10 f0       	mov    $0xf010eaa6,%eax
f010d741:	66 a3 48 ce 71 f0    	mov    %ax,0xf071ce48
f010d747:	66 c7 05 4a ce 71 f0 	movw   $0x8,0xf071ce4a
f010d74e:	08 00 
f010d750:	a0 4c ce 71 f0       	mov    0xf071ce4c,%al
f010d755:	83 e0 e0             	and    $0xffffffe0,%eax
f010d758:	a2 4c ce 71 f0       	mov    %al,0xf071ce4c
f010d75d:	a0 4c ce 71 f0       	mov    0xf071ce4c,%al
f010d762:	83 e0 1f             	and    $0x1f,%eax
f010d765:	a2 4c ce 71 f0       	mov    %al,0xf071ce4c
f010d76a:	a0 4d ce 71 f0       	mov    0xf071ce4d,%al
f010d76f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d772:	83 c8 0e             	or     $0xe,%eax
f010d775:	a2 4d ce 71 f0       	mov    %al,0xf071ce4d
f010d77a:	a0 4d ce 71 f0       	mov    0xf071ce4d,%al
f010d77f:	83 e0 ef             	and    $0xffffffef,%eax
f010d782:	a2 4d ce 71 f0       	mov    %al,0xf071ce4d
f010d787:	a0 4d ce 71 f0       	mov    0xf071ce4d,%al
f010d78c:	83 c8 60             	or     $0x60,%eax
f010d78f:	a2 4d ce 71 f0       	mov    %al,0xf071ce4d
f010d794:	a0 4d ce 71 f0       	mov    0xf071ce4d,%al
f010d799:	83 c8 80             	or     $0xffffff80,%eax
f010d79c:	a2 4d ce 71 f0       	mov    %al,0xf071ce4d
f010d7a1:	b8 a6 ea 10 f0       	mov    $0xf010eaa6,%eax
f010d7a6:	c1 e8 10             	shr    $0x10,%eax
f010d7a9:	66 a3 4e ce 71 f0    	mov    %ax,0xf071ce4e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d7af:	b8 b0 ea 10 f0       	mov    $0xf010eab0,%eax
f010d7b4:	66 a3 c0 ce 71 f0    	mov    %ax,0xf071cec0
f010d7ba:	66 c7 05 c2 ce 71 f0 	movw   $0x8,0xf071cec2
f010d7c1:	08 00 
f010d7c3:	a0 c4 ce 71 f0       	mov    0xf071cec4,%al
f010d7c8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7cb:	a2 c4 ce 71 f0       	mov    %al,0xf071cec4
f010d7d0:	a0 c4 ce 71 f0       	mov    0xf071cec4,%al
f010d7d5:	83 e0 1f             	and    $0x1f,%eax
f010d7d8:	a2 c4 ce 71 f0       	mov    %al,0xf071cec4
f010d7dd:	a0 c5 ce 71 f0       	mov    0xf071cec5,%al
f010d7e2:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7e5:	83 c8 0e             	or     $0xe,%eax
f010d7e8:	a2 c5 ce 71 f0       	mov    %al,0xf071cec5
f010d7ed:	a0 c5 ce 71 f0       	mov    0xf071cec5,%al
f010d7f2:	83 e0 ef             	and    $0xffffffef,%eax
f010d7f5:	a2 c5 ce 71 f0       	mov    %al,0xf071cec5
f010d7fa:	a0 c5 ce 71 f0       	mov    0xf071cec5,%al
f010d7ff:	83 c8 60             	or     $0x60,%eax
f010d802:	a2 c5 ce 71 f0       	mov    %al,0xf071cec5
f010d807:	a0 c5 ce 71 f0       	mov    0xf071cec5,%al
f010d80c:	83 c8 80             	or     $0xffffff80,%eax
f010d80f:	a2 c5 ce 71 f0       	mov    %al,0xf071cec5
f010d814:	b8 b0 ea 10 f0       	mov    $0xf010eab0,%eax
f010d819:	c1 e8 10             	shr    $0x10,%eax
f010d81c:	66 a3 c6 ce 71 f0    	mov    %ax,0xf071cec6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d822:	b8 ba ea 10 f0       	mov    $0xf010eaba,%eax
f010d827:	66 a3 40 cd 71 f0    	mov    %ax,0xf071cd40
f010d82d:	66 c7 05 42 cd 71 f0 	movw   $0x8,0xf071cd42
f010d834:	08 00 
f010d836:	a0 44 cd 71 f0       	mov    0xf071cd44,%al
f010d83b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d83e:	a2 44 cd 71 f0       	mov    %al,0xf071cd44
f010d843:	a0 44 cd 71 f0       	mov    0xf071cd44,%al
f010d848:	83 e0 1f             	and    $0x1f,%eax
f010d84b:	a2 44 cd 71 f0       	mov    %al,0xf071cd44
f010d850:	a0 45 cd 71 f0       	mov    0xf071cd45,%al
f010d855:	83 e0 f0             	and    $0xfffffff0,%eax
f010d858:	83 c8 0e             	or     $0xe,%eax
f010d85b:	a2 45 cd 71 f0       	mov    %al,0xf071cd45
f010d860:	a0 45 cd 71 f0       	mov    0xf071cd45,%al
f010d865:	83 e0 ef             	and    $0xffffffef,%eax
f010d868:	a2 45 cd 71 f0       	mov    %al,0xf071cd45
f010d86d:	a0 45 cd 71 f0       	mov    0xf071cd45,%al
f010d872:	83 c8 60             	or     $0x60,%eax
f010d875:	a2 45 cd 71 f0       	mov    %al,0xf071cd45
f010d87a:	a0 45 cd 71 f0       	mov    0xf071cd45,%al
f010d87f:	83 c8 80             	or     $0xffffff80,%eax
f010d882:	a2 45 cd 71 f0       	mov    %al,0xf071cd45
f010d887:	b8 ba ea 10 f0       	mov    $0xf010eaba,%eax
f010d88c:	c1 e8 10             	shr    $0x10,%eax
f010d88f:	66 a3 46 cd 71 f0    	mov    %ax,0xf071cd46
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d895:	b8 c4 ea 10 f0       	mov    $0xf010eac4,%eax
f010d89a:	66 a3 48 cd 71 f0    	mov    %ax,0xf071cd48
f010d8a0:	66 c7 05 4a cd 71 f0 	movw   $0x8,0xf071cd4a
f010d8a7:	08 00 
f010d8a9:	a0 4c cd 71 f0       	mov    0xf071cd4c,%al
f010d8ae:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8b1:	a2 4c cd 71 f0       	mov    %al,0xf071cd4c
f010d8b6:	a0 4c cd 71 f0       	mov    0xf071cd4c,%al
f010d8bb:	83 e0 1f             	and    $0x1f,%eax
f010d8be:	a2 4c cd 71 f0       	mov    %al,0xf071cd4c
f010d8c3:	a0 4d cd 71 f0       	mov    0xf071cd4d,%al
f010d8c8:	83 c8 0f             	or     $0xf,%eax
f010d8cb:	a2 4d cd 71 f0       	mov    %al,0xf071cd4d
f010d8d0:	a0 4d cd 71 f0       	mov    0xf071cd4d,%al
f010d8d5:	83 e0 ef             	and    $0xffffffef,%eax
f010d8d8:	a2 4d cd 71 f0       	mov    %al,0xf071cd4d
f010d8dd:	a0 4d cd 71 f0       	mov    0xf071cd4d,%al
f010d8e2:	83 c8 60             	or     $0x60,%eax
f010d8e5:	a2 4d cd 71 f0       	mov    %al,0xf071cd4d
f010d8ea:	a0 4d cd 71 f0       	mov    0xf071cd4d,%al
f010d8ef:	83 c8 80             	or     $0xffffff80,%eax
f010d8f2:	a2 4d cd 71 f0       	mov    %al,0xf071cd4d
f010d8f7:	b8 c4 ea 10 f0       	mov    $0xf010eac4,%eax
f010d8fc:	c1 e8 10             	shr    $0x10,%eax
f010d8ff:	66 a3 4e cd 71 f0    	mov    %ax,0xf071cd4e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d905:	b8 ce ea 10 f0       	mov    $0xf010eace,%eax
f010d90a:	66 a3 50 cd 71 f0    	mov    %ax,0xf071cd50
f010d910:	66 c7 05 52 cd 71 f0 	movw   $0x8,0xf071cd52
f010d917:	08 00 
f010d919:	a0 54 cd 71 f0       	mov    0xf071cd54,%al
f010d91e:	83 e0 e0             	and    $0xffffffe0,%eax
f010d921:	a2 54 cd 71 f0       	mov    %al,0xf071cd54
f010d926:	a0 54 cd 71 f0       	mov    0xf071cd54,%al
f010d92b:	83 e0 1f             	and    $0x1f,%eax
f010d92e:	a2 54 cd 71 f0       	mov    %al,0xf071cd54
f010d933:	a0 55 cd 71 f0       	mov    0xf071cd55,%al
f010d938:	83 e0 f0             	and    $0xfffffff0,%eax
f010d93b:	83 c8 0e             	or     $0xe,%eax
f010d93e:	a2 55 cd 71 f0       	mov    %al,0xf071cd55
f010d943:	a0 55 cd 71 f0       	mov    0xf071cd55,%al
f010d948:	83 e0 ef             	and    $0xffffffef,%eax
f010d94b:	a2 55 cd 71 f0       	mov    %al,0xf071cd55
f010d950:	a0 55 cd 71 f0       	mov    0xf071cd55,%al
f010d955:	83 c8 60             	or     $0x60,%eax
f010d958:	a2 55 cd 71 f0       	mov    %al,0xf071cd55
f010d95d:	a0 55 cd 71 f0       	mov    0xf071cd55,%al
f010d962:	83 c8 80             	or     $0xffffff80,%eax
f010d965:	a2 55 cd 71 f0       	mov    %al,0xf071cd55
f010d96a:	b8 ce ea 10 f0       	mov    $0xf010eace,%eax
f010d96f:	c1 e8 10             	shr    $0x10,%eax
f010d972:	66 a3 56 cd 71 f0    	mov    %ax,0xf071cd56
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d978:	b8 d8 ea 10 f0       	mov    $0xf010ead8,%eax
f010d97d:	66 a3 58 cd 71 f0    	mov    %ax,0xf071cd58
f010d983:	66 c7 05 5a cd 71 f0 	movw   $0x8,0xf071cd5a
f010d98a:	08 00 
f010d98c:	a0 5c cd 71 f0       	mov    0xf071cd5c,%al
f010d991:	83 e0 e0             	and    $0xffffffe0,%eax
f010d994:	a2 5c cd 71 f0       	mov    %al,0xf071cd5c
f010d999:	a0 5c cd 71 f0       	mov    0xf071cd5c,%al
f010d99e:	83 e0 1f             	and    $0x1f,%eax
f010d9a1:	a2 5c cd 71 f0       	mov    %al,0xf071cd5c
f010d9a6:	a0 5d cd 71 f0       	mov    0xf071cd5d,%al
f010d9ab:	83 c8 0f             	or     $0xf,%eax
f010d9ae:	a2 5d cd 71 f0       	mov    %al,0xf071cd5d
f010d9b3:	a0 5d cd 71 f0       	mov    0xf071cd5d,%al
f010d9b8:	83 e0 ef             	and    $0xffffffef,%eax
f010d9bb:	a2 5d cd 71 f0       	mov    %al,0xf071cd5d
f010d9c0:	a0 5d cd 71 f0       	mov    0xf071cd5d,%al
f010d9c5:	83 c8 60             	or     $0x60,%eax
f010d9c8:	a2 5d cd 71 f0       	mov    %al,0xf071cd5d
f010d9cd:	a0 5d cd 71 f0       	mov    0xf071cd5d,%al
f010d9d2:	83 c8 80             	or     $0xffffff80,%eax
f010d9d5:	a2 5d cd 71 f0       	mov    %al,0xf071cd5d
f010d9da:	b8 d8 ea 10 f0       	mov    $0xf010ead8,%eax
f010d9df:	c1 e8 10             	shr    $0x10,%eax
f010d9e2:	66 a3 5e cd 71 f0    	mov    %ax,0xf071cd5e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d9e8:	b8 e2 ea 10 f0       	mov    $0xf010eae2,%eax
f010d9ed:	66 a3 60 cd 71 f0    	mov    %ax,0xf071cd60
f010d9f3:	66 c7 05 62 cd 71 f0 	movw   $0x8,0xf071cd62
f010d9fa:	08 00 
f010d9fc:	a0 64 cd 71 f0       	mov    0xf071cd64,%al
f010da01:	83 e0 e0             	and    $0xffffffe0,%eax
f010da04:	a2 64 cd 71 f0       	mov    %al,0xf071cd64
f010da09:	a0 64 cd 71 f0       	mov    0xf071cd64,%al
f010da0e:	83 e0 1f             	and    $0x1f,%eax
f010da11:	a2 64 cd 71 f0       	mov    %al,0xf071cd64
f010da16:	a0 65 cd 71 f0       	mov    0xf071cd65,%al
f010da1b:	83 c8 0f             	or     $0xf,%eax
f010da1e:	a2 65 cd 71 f0       	mov    %al,0xf071cd65
f010da23:	a0 65 cd 71 f0       	mov    0xf071cd65,%al
f010da28:	83 e0 ef             	and    $0xffffffef,%eax
f010da2b:	a2 65 cd 71 f0       	mov    %al,0xf071cd65
f010da30:	a0 65 cd 71 f0       	mov    0xf071cd65,%al
f010da35:	83 c8 60             	or     $0x60,%eax
f010da38:	a2 65 cd 71 f0       	mov    %al,0xf071cd65
f010da3d:	a0 65 cd 71 f0       	mov    0xf071cd65,%al
f010da42:	83 c8 80             	or     $0xffffff80,%eax
f010da45:	a2 65 cd 71 f0       	mov    %al,0xf071cd65
f010da4a:	b8 e2 ea 10 f0       	mov    $0xf010eae2,%eax
f010da4f:	c1 e8 10             	shr    $0x10,%eax
f010da52:	66 a3 66 cd 71 f0    	mov    %ax,0xf071cd66
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010da58:	b8 ec ea 10 f0       	mov    $0xf010eaec,%eax
f010da5d:	66 a3 68 cd 71 f0    	mov    %ax,0xf071cd68
f010da63:	66 c7 05 6a cd 71 f0 	movw   $0x8,0xf071cd6a
f010da6a:	08 00 
f010da6c:	a0 6c cd 71 f0       	mov    0xf071cd6c,%al
f010da71:	83 e0 e0             	and    $0xffffffe0,%eax
f010da74:	a2 6c cd 71 f0       	mov    %al,0xf071cd6c
f010da79:	a0 6c cd 71 f0       	mov    0xf071cd6c,%al
f010da7e:	83 e0 1f             	and    $0x1f,%eax
f010da81:	a2 6c cd 71 f0       	mov    %al,0xf071cd6c
f010da86:	a0 6d cd 71 f0       	mov    0xf071cd6d,%al
f010da8b:	83 e0 f0             	and    $0xfffffff0,%eax
f010da8e:	83 c8 0e             	or     $0xe,%eax
f010da91:	a2 6d cd 71 f0       	mov    %al,0xf071cd6d
f010da96:	a0 6d cd 71 f0       	mov    0xf071cd6d,%al
f010da9b:	83 e0 ef             	and    $0xffffffef,%eax
f010da9e:	a2 6d cd 71 f0       	mov    %al,0xf071cd6d
f010daa3:	a0 6d cd 71 f0       	mov    0xf071cd6d,%al
f010daa8:	83 c8 60             	or     $0x60,%eax
f010daab:	a2 6d cd 71 f0       	mov    %al,0xf071cd6d
f010dab0:	a0 6d cd 71 f0       	mov    0xf071cd6d,%al
f010dab5:	83 c8 80             	or     $0xffffff80,%eax
f010dab8:	a2 6d cd 71 f0       	mov    %al,0xf071cd6d
f010dabd:	b8 ec ea 10 f0       	mov    $0xf010eaec,%eax
f010dac2:	c1 e8 10             	shr    $0x10,%eax
f010dac5:	66 a3 6e cd 71 f0    	mov    %ax,0xf071cd6e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010dacb:	b8 f6 ea 10 f0       	mov    $0xf010eaf6,%eax
f010dad0:	66 a3 70 cd 71 f0    	mov    %ax,0xf071cd70
f010dad6:	66 c7 05 72 cd 71 f0 	movw   $0x8,0xf071cd72
f010dadd:	08 00 
f010dadf:	a0 74 cd 71 f0       	mov    0xf071cd74,%al
f010dae4:	83 e0 e0             	and    $0xffffffe0,%eax
f010dae7:	a2 74 cd 71 f0       	mov    %al,0xf071cd74
f010daec:	a0 74 cd 71 f0       	mov    0xf071cd74,%al
f010daf1:	83 e0 1f             	and    $0x1f,%eax
f010daf4:	a2 74 cd 71 f0       	mov    %al,0xf071cd74
f010daf9:	a0 75 cd 71 f0       	mov    0xf071cd75,%al
f010dafe:	83 e0 f0             	and    $0xfffffff0,%eax
f010db01:	83 c8 0e             	or     $0xe,%eax
f010db04:	a2 75 cd 71 f0       	mov    %al,0xf071cd75
f010db09:	a0 75 cd 71 f0       	mov    0xf071cd75,%al
f010db0e:	83 e0 ef             	and    $0xffffffef,%eax
f010db11:	a2 75 cd 71 f0       	mov    %al,0xf071cd75
f010db16:	a0 75 cd 71 f0       	mov    0xf071cd75,%al
f010db1b:	83 c8 60             	or     $0x60,%eax
f010db1e:	a2 75 cd 71 f0       	mov    %al,0xf071cd75
f010db23:	a0 75 cd 71 f0       	mov    0xf071cd75,%al
f010db28:	83 c8 80             	or     $0xffffff80,%eax
f010db2b:	a2 75 cd 71 f0       	mov    %al,0xf071cd75
f010db30:	b8 f6 ea 10 f0       	mov    $0xf010eaf6,%eax
f010db35:	c1 e8 10             	shr    $0x10,%eax
f010db38:	66 a3 76 cd 71 f0    	mov    %ax,0xf071cd76
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010db3e:	b8 00 eb 10 f0       	mov    $0xf010eb00,%eax
f010db43:	66 a3 78 cd 71 f0    	mov    %ax,0xf071cd78
f010db49:	66 c7 05 7a cd 71 f0 	movw   $0x8,0xf071cd7a
f010db50:	08 00 
f010db52:	a0 7c cd 71 f0       	mov    0xf071cd7c,%al
f010db57:	83 e0 e0             	and    $0xffffffe0,%eax
f010db5a:	a2 7c cd 71 f0       	mov    %al,0xf071cd7c
f010db5f:	a0 7c cd 71 f0       	mov    0xf071cd7c,%al
f010db64:	83 e0 1f             	and    $0x1f,%eax
f010db67:	a2 7c cd 71 f0       	mov    %al,0xf071cd7c
f010db6c:	a0 7d cd 71 f0       	mov    0xf071cd7d,%al
f010db71:	83 e0 f0             	and    $0xfffffff0,%eax
f010db74:	83 c8 0e             	or     $0xe,%eax
f010db77:	a2 7d cd 71 f0       	mov    %al,0xf071cd7d
f010db7c:	a0 7d cd 71 f0       	mov    0xf071cd7d,%al
f010db81:	83 e0 ef             	and    $0xffffffef,%eax
f010db84:	a2 7d cd 71 f0       	mov    %al,0xf071cd7d
f010db89:	a0 7d cd 71 f0       	mov    0xf071cd7d,%al
f010db8e:	83 c8 60             	or     $0x60,%eax
f010db91:	a2 7d cd 71 f0       	mov    %al,0xf071cd7d
f010db96:	a0 7d cd 71 f0       	mov    0xf071cd7d,%al
f010db9b:	83 c8 80             	or     $0xffffff80,%eax
f010db9e:	a2 7d cd 71 f0       	mov    %al,0xf071cd7d
f010dba3:	b8 00 eb 10 f0       	mov    $0xf010eb00,%eax
f010dba8:	c1 e8 10             	shr    $0x10,%eax
f010dbab:	66 a3 7e cd 71 f0    	mov    %ax,0xf071cd7e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010dbb1:	b8 06 eb 10 f0       	mov    $0xf010eb06,%eax
f010dbb6:	66 a3 90 cd 71 f0    	mov    %ax,0xf071cd90
f010dbbc:	66 c7 05 92 cd 71 f0 	movw   $0x8,0xf071cd92
f010dbc3:	08 00 
f010dbc5:	a0 94 cd 71 f0       	mov    0xf071cd94,%al
f010dbca:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbcd:	a2 94 cd 71 f0       	mov    %al,0xf071cd94
f010dbd2:	a0 94 cd 71 f0       	mov    0xf071cd94,%al
f010dbd7:	83 e0 1f             	and    $0x1f,%eax
f010dbda:	a2 94 cd 71 f0       	mov    %al,0xf071cd94
f010dbdf:	a0 95 cd 71 f0       	mov    0xf071cd95,%al
f010dbe4:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbe7:	83 c8 0e             	or     $0xe,%eax
f010dbea:	a2 95 cd 71 f0       	mov    %al,0xf071cd95
f010dbef:	a0 95 cd 71 f0       	mov    0xf071cd95,%al
f010dbf4:	83 e0 ef             	and    $0xffffffef,%eax
f010dbf7:	a2 95 cd 71 f0       	mov    %al,0xf071cd95
f010dbfc:	a0 95 cd 71 f0       	mov    0xf071cd95,%al
f010dc01:	83 c8 60             	or     $0x60,%eax
f010dc04:	a2 95 cd 71 f0       	mov    %al,0xf071cd95
f010dc09:	a0 95 cd 71 f0       	mov    0xf071cd95,%al
f010dc0e:	83 c8 80             	or     $0xffffff80,%eax
f010dc11:	a2 95 cd 71 f0       	mov    %al,0xf071cd95
f010dc16:	b8 06 eb 10 f0       	mov    $0xf010eb06,%eax
f010dc1b:	c1 e8 10             	shr    $0x10,%eax
f010dc1e:	66 a3 96 cd 71 f0    	mov    %ax,0xf071cd96
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010dc24:	b8 0a eb 10 f0       	mov    $0xf010eb0a,%eax
f010dc29:	66 a3 98 cd 71 f0    	mov    %ax,0xf071cd98
f010dc2f:	66 c7 05 9a cd 71 f0 	movw   $0x8,0xf071cd9a
f010dc36:	08 00 
f010dc38:	a0 9c cd 71 f0       	mov    0xf071cd9c,%al
f010dc3d:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc40:	a2 9c cd 71 f0       	mov    %al,0xf071cd9c
f010dc45:	a0 9c cd 71 f0       	mov    0xf071cd9c,%al
f010dc4a:	83 e0 1f             	and    $0x1f,%eax
f010dc4d:	a2 9c cd 71 f0       	mov    %al,0xf071cd9c
f010dc52:	a0 9d cd 71 f0       	mov    0xf071cd9d,%al
f010dc57:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc5a:	83 c8 0e             	or     $0xe,%eax
f010dc5d:	a2 9d cd 71 f0       	mov    %al,0xf071cd9d
f010dc62:	a0 9d cd 71 f0       	mov    0xf071cd9d,%al
f010dc67:	83 e0 ef             	and    $0xffffffef,%eax
f010dc6a:	a2 9d cd 71 f0       	mov    %al,0xf071cd9d
f010dc6f:	a0 9d cd 71 f0       	mov    0xf071cd9d,%al
f010dc74:	83 c8 60             	or     $0x60,%eax
f010dc77:	a2 9d cd 71 f0       	mov    %al,0xf071cd9d
f010dc7c:	a0 9d cd 71 f0       	mov    0xf071cd9d,%al
f010dc81:	83 c8 80             	or     $0xffffff80,%eax
f010dc84:	a2 9d cd 71 f0       	mov    %al,0xf071cd9d
f010dc89:	b8 0a eb 10 f0       	mov    $0xf010eb0a,%eax
f010dc8e:	c1 e8 10             	shr    $0x10,%eax
f010dc91:	66 a3 9e cd 71 f0    	mov    %ax,0xf071cd9e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010dc97:	b8 0e eb 10 f0       	mov    $0xf010eb0e,%eax
f010dc9c:	66 a3 a0 cd 71 f0    	mov    %ax,0xf071cda0
f010dca2:	66 c7 05 a2 cd 71 f0 	movw   $0x8,0xf071cda2
f010dca9:	08 00 
f010dcab:	a0 a4 cd 71 f0       	mov    0xf071cda4,%al
f010dcb0:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcb3:	a2 a4 cd 71 f0       	mov    %al,0xf071cda4
f010dcb8:	a0 a4 cd 71 f0       	mov    0xf071cda4,%al
f010dcbd:	83 e0 1f             	and    $0x1f,%eax
f010dcc0:	a2 a4 cd 71 f0       	mov    %al,0xf071cda4
f010dcc5:	a0 a5 cd 71 f0       	mov    0xf071cda5,%al
f010dcca:	83 e0 f0             	and    $0xfffffff0,%eax
f010dccd:	83 c8 0e             	or     $0xe,%eax
f010dcd0:	a2 a5 cd 71 f0       	mov    %al,0xf071cda5
f010dcd5:	a0 a5 cd 71 f0       	mov    0xf071cda5,%al
f010dcda:	83 e0 ef             	and    $0xffffffef,%eax
f010dcdd:	a2 a5 cd 71 f0       	mov    %al,0xf071cda5
f010dce2:	a0 a5 cd 71 f0       	mov    0xf071cda5,%al
f010dce7:	83 c8 60             	or     $0x60,%eax
f010dcea:	a2 a5 cd 71 f0       	mov    %al,0xf071cda5
f010dcef:	a0 a5 cd 71 f0       	mov    0xf071cda5,%al
f010dcf4:	83 c8 80             	or     $0xffffff80,%eax
f010dcf7:	a2 a5 cd 71 f0       	mov    %al,0xf071cda5
f010dcfc:	b8 0e eb 10 f0       	mov    $0xf010eb0e,%eax
f010dd01:	c1 e8 10             	shr    $0x10,%eax
f010dd04:	66 a3 a6 cd 71 f0    	mov    %ax,0xf071cda6
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010dd0a:	b8 12 eb 10 f0       	mov    $0xf010eb12,%eax
f010dd0f:	66 a3 a8 cd 71 f0    	mov    %ax,0xf071cda8
f010dd15:	66 c7 05 aa cd 71 f0 	movw   $0x8,0xf071cdaa
f010dd1c:	08 00 
f010dd1e:	a0 ac cd 71 f0       	mov    0xf071cdac,%al
f010dd23:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd26:	a2 ac cd 71 f0       	mov    %al,0xf071cdac
f010dd2b:	a0 ac cd 71 f0       	mov    0xf071cdac,%al
f010dd30:	83 e0 1f             	and    $0x1f,%eax
f010dd33:	a2 ac cd 71 f0       	mov    %al,0xf071cdac
f010dd38:	a0 ad cd 71 f0       	mov    0xf071cdad,%al
f010dd3d:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd40:	83 c8 0e             	or     $0xe,%eax
f010dd43:	a2 ad cd 71 f0       	mov    %al,0xf071cdad
f010dd48:	a0 ad cd 71 f0       	mov    0xf071cdad,%al
f010dd4d:	83 e0 ef             	and    $0xffffffef,%eax
f010dd50:	a2 ad cd 71 f0       	mov    %al,0xf071cdad
f010dd55:	a0 ad cd 71 f0       	mov    0xf071cdad,%al
f010dd5a:	83 c8 60             	or     $0x60,%eax
f010dd5d:	a2 ad cd 71 f0       	mov    %al,0xf071cdad
f010dd62:	a0 ad cd 71 f0       	mov    0xf071cdad,%al
f010dd67:	83 c8 80             	or     $0xffffff80,%eax
f010dd6a:	a2 ad cd 71 f0       	mov    %al,0xf071cdad
f010dd6f:	b8 12 eb 10 f0       	mov    $0xf010eb12,%eax
f010dd74:	c1 e8 10             	shr    $0x10,%eax
f010dd77:	66 a3 ae cd 71 f0    	mov    %ax,0xf071cdae
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010dd7d:	b8 16 eb 10 f0       	mov    $0xf010eb16,%eax
f010dd82:	66 a3 c0 cd 71 f0    	mov    %ax,0xf071cdc0
f010dd88:	66 c7 05 c2 cd 71 f0 	movw   $0x8,0xf071cdc2
f010dd8f:	08 00 
f010dd91:	a0 c4 cd 71 f0       	mov    0xf071cdc4,%al
f010dd96:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd99:	a2 c4 cd 71 f0       	mov    %al,0xf071cdc4
f010dd9e:	a0 c4 cd 71 f0       	mov    0xf071cdc4,%al
f010dda3:	83 e0 1f             	and    $0x1f,%eax
f010dda6:	a2 c4 cd 71 f0       	mov    %al,0xf071cdc4
f010ddab:	a0 c5 cd 71 f0       	mov    0xf071cdc5,%al
f010ddb0:	83 e0 f0             	and    $0xfffffff0,%eax
f010ddb3:	83 c8 0e             	or     $0xe,%eax
f010ddb6:	a2 c5 cd 71 f0       	mov    %al,0xf071cdc5
f010ddbb:	a0 c5 cd 71 f0       	mov    0xf071cdc5,%al
f010ddc0:	83 e0 ef             	and    $0xffffffef,%eax
f010ddc3:	a2 c5 cd 71 f0       	mov    %al,0xf071cdc5
f010ddc8:	a0 c5 cd 71 f0       	mov    0xf071cdc5,%al
f010ddcd:	83 c8 60             	or     $0x60,%eax
f010ddd0:	a2 c5 cd 71 f0       	mov    %al,0xf071cdc5
f010ddd5:	a0 c5 cd 71 f0       	mov    0xf071cdc5,%al
f010ddda:	83 c8 80             	or     $0xffffff80,%eax
f010dddd:	a2 c5 cd 71 f0       	mov    %al,0xf071cdc5
f010dde2:	b8 16 eb 10 f0       	mov    $0xf010eb16,%eax
f010dde7:	c1 e8 10             	shr    $0x10,%eax
f010ddea:	66 a3 c6 cd 71 f0    	mov    %ax,0xf071cdc6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010ddf0:	b8 1c eb 10 f0       	mov    $0xf010eb1c,%eax
f010ddf5:	66 a3 c8 cd 71 f0    	mov    %ax,0xf071cdc8
f010ddfb:	66 c7 05 ca cd 71 f0 	movw   $0x8,0xf071cdca
f010de02:	08 00 
f010de04:	a0 cc cd 71 f0       	mov    0xf071cdcc,%al
f010de09:	83 e0 e0             	and    $0xffffffe0,%eax
f010de0c:	a2 cc cd 71 f0       	mov    %al,0xf071cdcc
f010de11:	a0 cc cd 71 f0       	mov    0xf071cdcc,%al
f010de16:	83 e0 1f             	and    $0x1f,%eax
f010de19:	a2 cc cd 71 f0       	mov    %al,0xf071cdcc
f010de1e:	a0 cd cd 71 f0       	mov    0xf071cdcd,%al
f010de23:	83 e0 f0             	and    $0xfffffff0,%eax
f010de26:	83 c8 0e             	or     $0xe,%eax
f010de29:	a2 cd cd 71 f0       	mov    %al,0xf071cdcd
f010de2e:	a0 cd cd 71 f0       	mov    0xf071cdcd,%al
f010de33:	83 e0 ef             	and    $0xffffffef,%eax
f010de36:	a2 cd cd 71 f0       	mov    %al,0xf071cdcd
f010de3b:	a0 cd cd 71 f0       	mov    0xf071cdcd,%al
f010de40:	83 c8 60             	or     $0x60,%eax
f010de43:	a2 cd cd 71 f0       	mov    %al,0xf071cdcd
f010de48:	a0 cd cd 71 f0       	mov    0xf071cdcd,%al
f010de4d:	83 c8 80             	or     $0xffffff80,%eax
f010de50:	a2 cd cd 71 f0       	mov    %al,0xf071cdcd
f010de55:	b8 1c eb 10 f0       	mov    $0xf010eb1c,%eax
f010de5a:	c1 e8 10             	shr    $0x10,%eax
f010de5d:	66 a3 ce cd 71 f0    	mov    %ax,0xf071cdce
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010de63:	b8 20 eb 10 f0       	mov    $0xf010eb20,%eax
f010de68:	66 a3 d0 cd 71 f0    	mov    %ax,0xf071cdd0
f010de6e:	66 c7 05 d2 cd 71 f0 	movw   $0x8,0xf071cdd2
f010de75:	08 00 
f010de77:	a0 d4 cd 71 f0       	mov    0xf071cdd4,%al
f010de7c:	83 e0 e0             	and    $0xffffffe0,%eax
f010de7f:	a2 d4 cd 71 f0       	mov    %al,0xf071cdd4
f010de84:	a0 d4 cd 71 f0       	mov    0xf071cdd4,%al
f010de89:	83 e0 1f             	and    $0x1f,%eax
f010de8c:	a2 d4 cd 71 f0       	mov    %al,0xf071cdd4
f010de91:	a0 d5 cd 71 f0       	mov    0xf071cdd5,%al
f010de96:	83 e0 f0             	and    $0xfffffff0,%eax
f010de99:	83 c8 0e             	or     $0xe,%eax
f010de9c:	a2 d5 cd 71 f0       	mov    %al,0xf071cdd5
f010dea1:	a0 d5 cd 71 f0       	mov    0xf071cdd5,%al
f010dea6:	83 e0 ef             	and    $0xffffffef,%eax
f010dea9:	a2 d5 cd 71 f0       	mov    %al,0xf071cdd5
f010deae:	a0 d5 cd 71 f0       	mov    0xf071cdd5,%al
f010deb3:	83 c8 60             	or     $0x60,%eax
f010deb6:	a2 d5 cd 71 f0       	mov    %al,0xf071cdd5
f010debb:	a0 d5 cd 71 f0       	mov    0xf071cdd5,%al
f010dec0:	83 c8 80             	or     $0xffffff80,%eax
f010dec3:	a2 d5 cd 71 f0       	mov    %al,0xf071cdd5
f010dec8:	b8 20 eb 10 f0       	mov    $0xf010eb20,%eax
f010decd:	c1 e8 10             	shr    $0x10,%eax
f010ded0:	66 a3 d6 cd 71 f0    	mov    %ax,0xf071cdd6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010ded6:	b8 26 eb 10 f0       	mov    $0xf010eb26,%eax
f010dedb:	66 a3 d8 cd 71 f0    	mov    %ax,0xf071cdd8
f010dee1:	66 c7 05 da cd 71 f0 	movw   $0x8,0xf071cdda
f010dee8:	08 00 
f010deea:	a0 dc cd 71 f0       	mov    0xf071cddc,%al
f010deef:	83 e0 e0             	and    $0xffffffe0,%eax
f010def2:	a2 dc cd 71 f0       	mov    %al,0xf071cddc
f010def7:	a0 dc cd 71 f0       	mov    0xf071cddc,%al
f010defc:	83 e0 1f             	and    $0x1f,%eax
f010deff:	a2 dc cd 71 f0       	mov    %al,0xf071cddc
f010df04:	a0 dd cd 71 f0       	mov    0xf071cddd,%al
f010df09:	83 e0 f0             	and    $0xfffffff0,%eax
f010df0c:	83 c8 0e             	or     $0xe,%eax
f010df0f:	a2 dd cd 71 f0       	mov    %al,0xf071cddd
f010df14:	a0 dd cd 71 f0       	mov    0xf071cddd,%al
f010df19:	83 e0 ef             	and    $0xffffffef,%eax
f010df1c:	a2 dd cd 71 f0       	mov    %al,0xf071cddd
f010df21:	a0 dd cd 71 f0       	mov    0xf071cddd,%al
f010df26:	83 c8 60             	or     $0x60,%eax
f010df29:	a2 dd cd 71 f0       	mov    %al,0xf071cddd
f010df2e:	a0 dd cd 71 f0       	mov    0xf071cddd,%al
f010df33:	83 c8 80             	or     $0xffffff80,%eax
f010df36:	a2 dd cd 71 f0       	mov    %al,0xf071cddd
f010df3b:	b8 26 eb 10 f0       	mov    $0xf010eb26,%eax
f010df40:	c1 e8 10             	shr    $0x10,%eax
f010df43:	66 a3 de cd 71 f0    	mov    %ax,0xf071cdde

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010df49:	b8 2c eb 10 f0       	mov    $0xf010eb2c,%eax
f010df4e:	66 a3 50 ce 71 f0    	mov    %ax,0xf071ce50
f010df54:	66 c7 05 52 ce 71 f0 	movw   $0x8,0xf071ce52
f010df5b:	08 00 
f010df5d:	a0 54 ce 71 f0       	mov    0xf071ce54,%al
f010df62:	83 e0 e0             	and    $0xffffffe0,%eax
f010df65:	a2 54 ce 71 f0       	mov    %al,0xf071ce54
f010df6a:	a0 54 ce 71 f0       	mov    0xf071ce54,%al
f010df6f:	83 e0 1f             	and    $0x1f,%eax
f010df72:	a2 54 ce 71 f0       	mov    %al,0xf071ce54
f010df77:	a0 55 ce 71 f0       	mov    0xf071ce55,%al
f010df7c:	83 e0 f0             	and    $0xfffffff0,%eax
f010df7f:	83 c8 0e             	or     $0xe,%eax
f010df82:	a2 55 ce 71 f0       	mov    %al,0xf071ce55
f010df87:	a0 55 ce 71 f0       	mov    0xf071ce55,%al
f010df8c:	83 e0 ef             	and    $0xffffffef,%eax
f010df8f:	a2 55 ce 71 f0       	mov    %al,0xf071ce55
f010df94:	a0 55 ce 71 f0       	mov    0xf071ce55,%al
f010df99:	83 c8 60             	or     $0x60,%eax
f010df9c:	a2 55 ce 71 f0       	mov    %al,0xf071ce55
f010dfa1:	a0 55 ce 71 f0       	mov    0xf071ce55,%al
f010dfa6:	83 c8 80             	or     $0xffffff80,%eax
f010dfa9:	a2 55 ce 71 f0       	mov    %al,0xf071ce55
f010dfae:	b8 2c eb 10 f0       	mov    $0xf010eb2c,%eax
f010dfb3:	c1 e8 10             	shr    $0x10,%eax
f010dfb6:	66 a3 56 ce 71 f0    	mov    %ax,0xf071ce56
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010dfbc:	b8 32 eb 10 f0       	mov    $0xf010eb32,%eax
f010dfc1:	66 a3 58 ce 71 f0    	mov    %ax,0xf071ce58
f010dfc7:	66 c7 05 5a ce 71 f0 	movw   $0x8,0xf071ce5a
f010dfce:	08 00 
f010dfd0:	a0 5c ce 71 f0       	mov    0xf071ce5c,%al
f010dfd5:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfd8:	a2 5c ce 71 f0       	mov    %al,0xf071ce5c
f010dfdd:	a0 5c ce 71 f0       	mov    0xf071ce5c,%al
f010dfe2:	83 e0 1f             	and    $0x1f,%eax
f010dfe5:	a2 5c ce 71 f0       	mov    %al,0xf071ce5c
f010dfea:	a0 5d ce 71 f0       	mov    0xf071ce5d,%al
f010dfef:	83 e0 f0             	and    $0xfffffff0,%eax
f010dff2:	83 c8 0e             	or     $0xe,%eax
f010dff5:	a2 5d ce 71 f0       	mov    %al,0xf071ce5d
f010dffa:	a0 5d ce 71 f0       	mov    0xf071ce5d,%al
f010dfff:	83 e0 ef             	and    $0xffffffef,%eax
f010e002:	a2 5d ce 71 f0       	mov    %al,0xf071ce5d
f010e007:	a0 5d ce 71 f0       	mov    0xf071ce5d,%al
f010e00c:	83 c8 60             	or     $0x60,%eax
f010e00f:	a2 5d ce 71 f0       	mov    %al,0xf071ce5d
f010e014:	a0 5d ce 71 f0       	mov    0xf071ce5d,%al
f010e019:	83 c8 80             	or     $0xffffff80,%eax
f010e01c:	a2 5d ce 71 f0       	mov    %al,0xf071ce5d
f010e021:	b8 32 eb 10 f0       	mov    $0xf010eb32,%eax
f010e026:	c1 e8 10             	shr    $0x10,%eax
f010e029:	66 a3 5e ce 71 f0    	mov    %ax,0xf071ce5e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010e02f:	b8 38 eb 10 f0       	mov    $0xf010eb38,%eax
f010e034:	66 a3 60 ce 71 f0    	mov    %ax,0xf071ce60
f010e03a:	66 c7 05 62 ce 71 f0 	movw   $0x8,0xf071ce62
f010e041:	08 00 
f010e043:	a0 64 ce 71 f0       	mov    0xf071ce64,%al
f010e048:	83 e0 e0             	and    $0xffffffe0,%eax
f010e04b:	a2 64 ce 71 f0       	mov    %al,0xf071ce64
f010e050:	a0 64 ce 71 f0       	mov    0xf071ce64,%al
f010e055:	83 e0 1f             	and    $0x1f,%eax
f010e058:	a2 64 ce 71 f0       	mov    %al,0xf071ce64
f010e05d:	a0 65 ce 71 f0       	mov    0xf071ce65,%al
f010e062:	83 e0 f0             	and    $0xfffffff0,%eax
f010e065:	83 c8 0e             	or     $0xe,%eax
f010e068:	a2 65 ce 71 f0       	mov    %al,0xf071ce65
f010e06d:	a0 65 ce 71 f0       	mov    0xf071ce65,%al
f010e072:	83 e0 ef             	and    $0xffffffef,%eax
f010e075:	a2 65 ce 71 f0       	mov    %al,0xf071ce65
f010e07a:	a0 65 ce 71 f0       	mov    0xf071ce65,%al
f010e07f:	83 c8 60             	or     $0x60,%eax
f010e082:	a2 65 ce 71 f0       	mov    %al,0xf071ce65
f010e087:	a0 65 ce 71 f0       	mov    0xf071ce65,%al
f010e08c:	83 c8 80             	or     $0xffffff80,%eax
f010e08f:	a2 65 ce 71 f0       	mov    %al,0xf071ce65
f010e094:	b8 38 eb 10 f0       	mov    $0xf010eb38,%eax
f010e099:	c1 e8 10             	shr    $0x10,%eax
f010e09c:	66 a3 66 ce 71 f0    	mov    %ax,0xf071ce66
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010e0a2:	b8 3e eb 10 f0       	mov    $0xf010eb3e,%eax
f010e0a7:	66 a3 68 ce 71 f0    	mov    %ax,0xf071ce68
f010e0ad:	66 c7 05 6a ce 71 f0 	movw   $0x8,0xf071ce6a
f010e0b4:	08 00 
f010e0b6:	a0 6c ce 71 f0       	mov    0xf071ce6c,%al
f010e0bb:	83 e0 e0             	and    $0xffffffe0,%eax
f010e0be:	a2 6c ce 71 f0       	mov    %al,0xf071ce6c
f010e0c3:	a0 6c ce 71 f0       	mov    0xf071ce6c,%al
f010e0c8:	83 e0 1f             	and    $0x1f,%eax
f010e0cb:	a2 6c ce 71 f0       	mov    %al,0xf071ce6c
f010e0d0:	a0 6d ce 71 f0       	mov    0xf071ce6d,%al
f010e0d5:	83 e0 f0             	and    $0xfffffff0,%eax
f010e0d8:	83 c8 0e             	or     $0xe,%eax
f010e0db:	a2 6d ce 71 f0       	mov    %al,0xf071ce6d
f010e0e0:	a0 6d ce 71 f0       	mov    0xf071ce6d,%al
f010e0e5:	83 e0 ef             	and    $0xffffffef,%eax
f010e0e8:	a2 6d ce 71 f0       	mov    %al,0xf071ce6d
f010e0ed:	a0 6d ce 71 f0       	mov    0xf071ce6d,%al
f010e0f2:	83 c8 60             	or     $0x60,%eax
f010e0f5:	a2 6d ce 71 f0       	mov    %al,0xf071ce6d
f010e0fa:	a0 6d ce 71 f0       	mov    0xf071ce6d,%al
f010e0ff:	83 c8 80             	or     $0xffffff80,%eax
f010e102:	a2 6d ce 71 f0       	mov    %al,0xf071ce6d
f010e107:	b8 3e eb 10 f0       	mov    $0xf010eb3e,%eax
f010e10c:	c1 e8 10             	shr    $0x10,%eax
f010e10f:	66 a3 6e ce 71 f0    	mov    %ax,0xf071ce6e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010e115:	b8 44 eb 10 f0       	mov    $0xf010eb44,%eax
f010e11a:	66 a3 70 ce 71 f0    	mov    %ax,0xf071ce70
f010e120:	66 c7 05 72 ce 71 f0 	movw   $0x8,0xf071ce72
f010e127:	08 00 
f010e129:	a0 74 ce 71 f0       	mov    0xf071ce74,%al
f010e12e:	83 e0 e0             	and    $0xffffffe0,%eax
f010e131:	a2 74 ce 71 f0       	mov    %al,0xf071ce74
f010e136:	a0 74 ce 71 f0       	mov    0xf071ce74,%al
f010e13b:	83 e0 1f             	and    $0x1f,%eax
f010e13e:	a2 74 ce 71 f0       	mov    %al,0xf071ce74
f010e143:	a0 75 ce 71 f0       	mov    0xf071ce75,%al
f010e148:	83 e0 f0             	and    $0xfffffff0,%eax
f010e14b:	83 c8 0e             	or     $0xe,%eax
f010e14e:	a2 75 ce 71 f0       	mov    %al,0xf071ce75
f010e153:	a0 75 ce 71 f0       	mov    0xf071ce75,%al
f010e158:	83 e0 ef             	and    $0xffffffef,%eax
f010e15b:	a2 75 ce 71 f0       	mov    %al,0xf071ce75
f010e160:	a0 75 ce 71 f0       	mov    0xf071ce75,%al
f010e165:	83 c8 60             	or     $0x60,%eax
f010e168:	a2 75 ce 71 f0       	mov    %al,0xf071ce75
f010e16d:	a0 75 ce 71 f0       	mov    0xf071ce75,%al
f010e172:	83 c8 80             	or     $0xffffff80,%eax
f010e175:	a2 75 ce 71 f0       	mov    %al,0xf071ce75
f010e17a:	b8 44 eb 10 f0       	mov    $0xf010eb44,%eax
f010e17f:	c1 e8 10             	shr    $0x10,%eax
f010e182:	66 a3 76 ce 71 f0    	mov    %ax,0xf071ce76
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010e188:	b8 4a eb 10 f0       	mov    $0xf010eb4a,%eax
f010e18d:	66 a3 78 ce 71 f0    	mov    %ax,0xf071ce78
f010e193:	66 c7 05 7a ce 71 f0 	movw   $0x8,0xf071ce7a
f010e19a:	08 00 
f010e19c:	a0 7c ce 71 f0       	mov    0xf071ce7c,%al
f010e1a1:	83 e0 e0             	and    $0xffffffe0,%eax
f010e1a4:	a2 7c ce 71 f0       	mov    %al,0xf071ce7c
f010e1a9:	a0 7c ce 71 f0       	mov    0xf071ce7c,%al
f010e1ae:	83 e0 1f             	and    $0x1f,%eax
f010e1b1:	a2 7c ce 71 f0       	mov    %al,0xf071ce7c
f010e1b6:	a0 7d ce 71 f0       	mov    0xf071ce7d,%al
f010e1bb:	83 e0 f0             	and    $0xfffffff0,%eax
f010e1be:	83 c8 0e             	or     $0xe,%eax
f010e1c1:	a2 7d ce 71 f0       	mov    %al,0xf071ce7d
f010e1c6:	a0 7d ce 71 f0       	mov    0xf071ce7d,%al
f010e1cb:	83 e0 ef             	and    $0xffffffef,%eax
f010e1ce:	a2 7d ce 71 f0       	mov    %al,0xf071ce7d
f010e1d3:	a0 7d ce 71 f0       	mov    0xf071ce7d,%al
f010e1d8:	83 c8 60             	or     $0x60,%eax
f010e1db:	a2 7d ce 71 f0       	mov    %al,0xf071ce7d
f010e1e0:	a0 7d ce 71 f0       	mov    0xf071ce7d,%al
f010e1e5:	83 c8 80             	or     $0xffffff80,%eax
f010e1e8:	a2 7d ce 71 f0       	mov    %al,0xf071ce7d
f010e1ed:	b8 4a eb 10 f0       	mov    $0xf010eb4a,%eax
f010e1f2:	c1 e8 10             	shr    $0x10,%eax
f010e1f5:	66 a3 7e ce 71 f0    	mov    %ax,0xf071ce7e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010e1fb:	b8 50 eb 10 f0       	mov    $0xf010eb50,%eax
f010e200:	66 a3 80 ce 71 f0    	mov    %ax,0xf071ce80
f010e206:	66 c7 05 82 ce 71 f0 	movw   $0x8,0xf071ce82
f010e20d:	08 00 
f010e20f:	a0 84 ce 71 f0       	mov    0xf071ce84,%al
f010e214:	83 e0 e0             	and    $0xffffffe0,%eax
f010e217:	a2 84 ce 71 f0       	mov    %al,0xf071ce84
f010e21c:	a0 84 ce 71 f0       	mov    0xf071ce84,%al
f010e221:	83 e0 1f             	and    $0x1f,%eax
f010e224:	a2 84 ce 71 f0       	mov    %al,0xf071ce84
f010e229:	a0 85 ce 71 f0       	mov    0xf071ce85,%al
f010e22e:	83 e0 f0             	and    $0xfffffff0,%eax
f010e231:	83 c8 0e             	or     $0xe,%eax
f010e234:	a2 85 ce 71 f0       	mov    %al,0xf071ce85
f010e239:	a0 85 ce 71 f0       	mov    0xf071ce85,%al
f010e23e:	83 e0 ef             	and    $0xffffffef,%eax
f010e241:	a2 85 ce 71 f0       	mov    %al,0xf071ce85
f010e246:	a0 85 ce 71 f0       	mov    0xf071ce85,%al
f010e24b:	83 c8 60             	or     $0x60,%eax
f010e24e:	a2 85 ce 71 f0       	mov    %al,0xf071ce85
f010e253:	a0 85 ce 71 f0       	mov    0xf071ce85,%al
f010e258:	83 c8 80             	or     $0xffffff80,%eax
f010e25b:	a2 85 ce 71 f0       	mov    %al,0xf071ce85
f010e260:	b8 50 eb 10 f0       	mov    $0xf010eb50,%eax
f010e265:	c1 e8 10             	shr    $0x10,%eax
f010e268:	66 a3 86 ce 71 f0    	mov    %ax,0xf071ce86
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010e26e:	b8 56 eb 10 f0       	mov    $0xf010eb56,%eax
f010e273:	66 a3 88 ce 71 f0    	mov    %ax,0xf071ce88
f010e279:	66 c7 05 8a ce 71 f0 	movw   $0x8,0xf071ce8a
f010e280:	08 00 
f010e282:	a0 8c ce 71 f0       	mov    0xf071ce8c,%al
f010e287:	83 e0 e0             	and    $0xffffffe0,%eax
f010e28a:	a2 8c ce 71 f0       	mov    %al,0xf071ce8c
f010e28f:	a0 8c ce 71 f0       	mov    0xf071ce8c,%al
f010e294:	83 e0 1f             	and    $0x1f,%eax
f010e297:	a2 8c ce 71 f0       	mov    %al,0xf071ce8c
f010e29c:	a0 8d ce 71 f0       	mov    0xf071ce8d,%al
f010e2a1:	83 e0 f0             	and    $0xfffffff0,%eax
f010e2a4:	83 c8 0e             	or     $0xe,%eax
f010e2a7:	a2 8d ce 71 f0       	mov    %al,0xf071ce8d
f010e2ac:	a0 8d ce 71 f0       	mov    0xf071ce8d,%al
f010e2b1:	83 e0 ef             	and    $0xffffffef,%eax
f010e2b4:	a2 8d ce 71 f0       	mov    %al,0xf071ce8d
f010e2b9:	a0 8d ce 71 f0       	mov    0xf071ce8d,%al
f010e2be:	83 c8 60             	or     $0x60,%eax
f010e2c1:	a2 8d ce 71 f0       	mov    %al,0xf071ce8d
f010e2c6:	a0 8d ce 71 f0       	mov    0xf071ce8d,%al
f010e2cb:	83 c8 80             	or     $0xffffff80,%eax
f010e2ce:	a2 8d ce 71 f0       	mov    %al,0xf071ce8d
f010e2d3:	b8 56 eb 10 f0       	mov    $0xf010eb56,%eax
f010e2d8:	c1 e8 10             	shr    $0x10,%eax
f010e2db:	66 a3 8e ce 71 f0    	mov    %ax,0xf071ce8e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010e2e1:	b8 5c eb 10 f0       	mov    $0xf010eb5c,%eax
f010e2e6:	66 a3 90 ce 71 f0    	mov    %ax,0xf071ce90
f010e2ec:	66 c7 05 92 ce 71 f0 	movw   $0x8,0xf071ce92
f010e2f3:	08 00 
f010e2f5:	a0 94 ce 71 f0       	mov    0xf071ce94,%al
f010e2fa:	83 e0 e0             	and    $0xffffffe0,%eax
f010e2fd:	a2 94 ce 71 f0       	mov    %al,0xf071ce94
f010e302:	a0 94 ce 71 f0       	mov    0xf071ce94,%al
f010e307:	83 e0 1f             	and    $0x1f,%eax
f010e30a:	a2 94 ce 71 f0       	mov    %al,0xf071ce94
f010e30f:	a0 95 ce 71 f0       	mov    0xf071ce95,%al
f010e314:	83 e0 f0             	and    $0xfffffff0,%eax
f010e317:	83 c8 0e             	or     $0xe,%eax
f010e31a:	a2 95 ce 71 f0       	mov    %al,0xf071ce95
f010e31f:	a0 95 ce 71 f0       	mov    0xf071ce95,%al
f010e324:	83 e0 ef             	and    $0xffffffef,%eax
f010e327:	a2 95 ce 71 f0       	mov    %al,0xf071ce95
f010e32c:	a0 95 ce 71 f0       	mov    0xf071ce95,%al
f010e331:	83 c8 60             	or     $0x60,%eax
f010e334:	a2 95 ce 71 f0       	mov    %al,0xf071ce95
f010e339:	a0 95 ce 71 f0       	mov    0xf071ce95,%al
f010e33e:	83 c8 80             	or     $0xffffff80,%eax
f010e341:	a2 95 ce 71 f0       	mov    %al,0xf071ce95
f010e346:	b8 5c eb 10 f0       	mov    $0xf010eb5c,%eax
f010e34b:	c1 e8 10             	shr    $0x10,%eax
f010e34e:	66 a3 96 ce 71 f0    	mov    %ax,0xf071ce96
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010e354:	b8 62 eb 10 f0       	mov    $0xf010eb62,%eax
f010e359:	66 a3 98 ce 71 f0    	mov    %ax,0xf071ce98
f010e35f:	66 c7 05 9a ce 71 f0 	movw   $0x8,0xf071ce9a
f010e366:	08 00 
f010e368:	a0 9c ce 71 f0       	mov    0xf071ce9c,%al
f010e36d:	83 e0 e0             	and    $0xffffffe0,%eax
f010e370:	a2 9c ce 71 f0       	mov    %al,0xf071ce9c
f010e375:	a0 9c ce 71 f0       	mov    0xf071ce9c,%al
f010e37a:	83 e0 1f             	and    $0x1f,%eax
f010e37d:	a2 9c ce 71 f0       	mov    %al,0xf071ce9c
f010e382:	a0 9d ce 71 f0       	mov    0xf071ce9d,%al
f010e387:	83 e0 f0             	and    $0xfffffff0,%eax
f010e38a:	83 c8 0e             	or     $0xe,%eax
f010e38d:	a2 9d ce 71 f0       	mov    %al,0xf071ce9d
f010e392:	a0 9d ce 71 f0       	mov    0xf071ce9d,%al
f010e397:	83 e0 ef             	and    $0xffffffef,%eax
f010e39a:	a2 9d ce 71 f0       	mov    %al,0xf071ce9d
f010e39f:	a0 9d ce 71 f0       	mov    0xf071ce9d,%al
f010e3a4:	83 c8 60             	or     $0x60,%eax
f010e3a7:	a2 9d ce 71 f0       	mov    %al,0xf071ce9d
f010e3ac:	a0 9d ce 71 f0       	mov    0xf071ce9d,%al
f010e3b1:	83 c8 80             	or     $0xffffff80,%eax
f010e3b4:	a2 9d ce 71 f0       	mov    %al,0xf071ce9d
f010e3b9:	b8 62 eb 10 f0       	mov    $0xf010eb62,%eax
f010e3be:	c1 e8 10             	shr    $0x10,%eax
f010e3c1:	66 a3 9e ce 71 f0    	mov    %ax,0xf071ce9e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010e3c7:	b8 68 eb 10 f0       	mov    $0xf010eb68,%eax
f010e3cc:	66 a3 a0 ce 71 f0    	mov    %ax,0xf071cea0
f010e3d2:	66 c7 05 a2 ce 71 f0 	movw   $0x8,0xf071cea2
f010e3d9:	08 00 
f010e3db:	a0 a4 ce 71 f0       	mov    0xf071cea4,%al
f010e3e0:	83 e0 e0             	and    $0xffffffe0,%eax
f010e3e3:	a2 a4 ce 71 f0       	mov    %al,0xf071cea4
f010e3e8:	a0 a4 ce 71 f0       	mov    0xf071cea4,%al
f010e3ed:	83 e0 1f             	and    $0x1f,%eax
f010e3f0:	a2 a4 ce 71 f0       	mov    %al,0xf071cea4
f010e3f5:	a0 a5 ce 71 f0       	mov    0xf071cea5,%al
f010e3fa:	83 e0 f0             	and    $0xfffffff0,%eax
f010e3fd:	83 c8 0e             	or     $0xe,%eax
f010e400:	a2 a5 ce 71 f0       	mov    %al,0xf071cea5
f010e405:	a0 a5 ce 71 f0       	mov    0xf071cea5,%al
f010e40a:	83 e0 ef             	and    $0xffffffef,%eax
f010e40d:	a2 a5 ce 71 f0       	mov    %al,0xf071cea5
f010e412:	a0 a5 ce 71 f0       	mov    0xf071cea5,%al
f010e417:	83 c8 60             	or     $0x60,%eax
f010e41a:	a2 a5 ce 71 f0       	mov    %al,0xf071cea5
f010e41f:	a0 a5 ce 71 f0       	mov    0xf071cea5,%al
f010e424:	83 c8 80             	or     $0xffffff80,%eax
f010e427:	a2 a5 ce 71 f0       	mov    %al,0xf071cea5
f010e42c:	b8 68 eb 10 f0       	mov    $0xf010eb68,%eax
f010e431:	c1 e8 10             	shr    $0x10,%eax
f010e434:	66 a3 a6 ce 71 f0    	mov    %ax,0xf071cea6
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010e43a:	b8 6e eb 10 f0       	mov    $0xf010eb6e,%eax
f010e43f:	66 a3 a8 ce 71 f0    	mov    %ax,0xf071cea8
f010e445:	66 c7 05 aa ce 71 f0 	movw   $0x8,0xf071ceaa
f010e44c:	08 00 
f010e44e:	a0 ac ce 71 f0       	mov    0xf071ceac,%al
f010e453:	83 e0 e0             	and    $0xffffffe0,%eax
f010e456:	a2 ac ce 71 f0       	mov    %al,0xf071ceac
f010e45b:	a0 ac ce 71 f0       	mov    0xf071ceac,%al
f010e460:	83 e0 1f             	and    $0x1f,%eax
f010e463:	a2 ac ce 71 f0       	mov    %al,0xf071ceac
f010e468:	a0 ad ce 71 f0       	mov    0xf071cead,%al
f010e46d:	83 e0 f0             	and    $0xfffffff0,%eax
f010e470:	83 c8 0e             	or     $0xe,%eax
f010e473:	a2 ad ce 71 f0       	mov    %al,0xf071cead
f010e478:	a0 ad ce 71 f0       	mov    0xf071cead,%al
f010e47d:	83 e0 ef             	and    $0xffffffef,%eax
f010e480:	a2 ad ce 71 f0       	mov    %al,0xf071cead
f010e485:	a0 ad ce 71 f0       	mov    0xf071cead,%al
f010e48a:	83 c8 60             	or     $0x60,%eax
f010e48d:	a2 ad ce 71 f0       	mov    %al,0xf071cead
f010e492:	a0 ad ce 71 f0       	mov    0xf071cead,%al
f010e497:	83 c8 80             	or     $0xffffff80,%eax
f010e49a:	a2 ad ce 71 f0       	mov    %al,0xf071cead
f010e49f:	b8 6e eb 10 f0       	mov    $0xf010eb6e,%eax
f010e4a4:	c1 e8 10             	shr    $0x10,%eax
f010e4a7:	66 a3 ae ce 71 f0    	mov    %ax,0xf071ceae
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010e4ad:	b8 74 eb 10 f0       	mov    $0xf010eb74,%eax
f010e4b2:	66 a3 b0 ce 71 f0    	mov    %ax,0xf071ceb0
f010e4b8:	66 c7 05 b2 ce 71 f0 	movw   $0x8,0xf071ceb2
f010e4bf:	08 00 
f010e4c1:	a0 b4 ce 71 f0       	mov    0xf071ceb4,%al
f010e4c6:	83 e0 e0             	and    $0xffffffe0,%eax
f010e4c9:	a2 b4 ce 71 f0       	mov    %al,0xf071ceb4
f010e4ce:	a0 b4 ce 71 f0       	mov    0xf071ceb4,%al
f010e4d3:	83 e0 1f             	and    $0x1f,%eax
f010e4d6:	a2 b4 ce 71 f0       	mov    %al,0xf071ceb4
f010e4db:	a0 b5 ce 71 f0       	mov    0xf071ceb5,%al
f010e4e0:	83 e0 f0             	and    $0xfffffff0,%eax
f010e4e3:	83 c8 0e             	or     $0xe,%eax
f010e4e6:	a2 b5 ce 71 f0       	mov    %al,0xf071ceb5
f010e4eb:	a0 b5 ce 71 f0       	mov    0xf071ceb5,%al
f010e4f0:	83 e0 ef             	and    $0xffffffef,%eax
f010e4f3:	a2 b5 ce 71 f0       	mov    %al,0xf071ceb5
f010e4f8:	a0 b5 ce 71 f0       	mov    0xf071ceb5,%al
f010e4fd:	83 c8 60             	or     $0x60,%eax
f010e500:	a2 b5 ce 71 f0       	mov    %al,0xf071ceb5
f010e505:	a0 b5 ce 71 f0       	mov    0xf071ceb5,%al
f010e50a:	83 c8 80             	or     $0xffffff80,%eax
f010e50d:	a2 b5 ce 71 f0       	mov    %al,0xf071ceb5
f010e512:	b8 74 eb 10 f0       	mov    $0xf010eb74,%eax
f010e517:	c1 e8 10             	shr    $0x10,%eax
f010e51a:	66 a3 b6 ce 71 f0    	mov    %ax,0xf071ceb6
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e520:	b8 7a eb 10 f0       	mov    $0xf010eb7a,%eax
f010e525:	66 a3 b8 ce 71 f0    	mov    %ax,0xf071ceb8
f010e52b:	66 c7 05 ba ce 71 f0 	movw   $0x8,0xf071ceba
f010e532:	08 00 
f010e534:	a0 bc ce 71 f0       	mov    0xf071cebc,%al
f010e539:	83 e0 e0             	and    $0xffffffe0,%eax
f010e53c:	a2 bc ce 71 f0       	mov    %al,0xf071cebc
f010e541:	a0 bc ce 71 f0       	mov    0xf071cebc,%al
f010e546:	83 e0 1f             	and    $0x1f,%eax
f010e549:	a2 bc ce 71 f0       	mov    %al,0xf071cebc
f010e54e:	a0 bd ce 71 f0       	mov    0xf071cebd,%al
f010e553:	83 e0 f0             	and    $0xfffffff0,%eax
f010e556:	83 c8 0e             	or     $0xe,%eax
f010e559:	a2 bd ce 71 f0       	mov    %al,0xf071cebd
f010e55e:	a0 bd ce 71 f0       	mov    0xf071cebd,%al
f010e563:	83 e0 ef             	and    $0xffffffef,%eax
f010e566:	a2 bd ce 71 f0       	mov    %al,0xf071cebd
f010e56b:	a0 bd ce 71 f0       	mov    0xf071cebd,%al
f010e570:	83 c8 60             	or     $0x60,%eax
f010e573:	a2 bd ce 71 f0       	mov    %al,0xf071cebd
f010e578:	a0 bd ce 71 f0       	mov    0xf071cebd,%al
f010e57d:	83 c8 80             	or     $0xffffff80,%eax
f010e580:	a2 bd ce 71 f0       	mov    %al,0xf071cebd
f010e585:	b8 7a eb 10 f0       	mov    $0xf010eb7a,%eax
f010e58a:	c1 e8 10             	shr    $0x10,%eax
f010e58d:	66 a3 be ce 71 f0    	mov    %ax,0xf071cebe
f010e593:	c7 45 fc 40 cd 71 f0 	movl   $0xf071cd40,-0x4(%ebp)
f010e59a:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e5a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e5a4:	48                   	dec    %eax
f010e5a5:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e5a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e5ac:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e5b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e5b3:	c1 e8 10             	shr    $0x10,%eax
f010e5b6:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e5ba:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e5bd:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e5c0:	90                   	nop
f010e5c1:	c9                   	leave  
f010e5c2:	c3                   	ret    

f010e5c3 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e5c3:	55                   	push   %ebp
f010e5c4:	89 e5                	mov    %esp,%ebp
f010e5c6:	53                   	push   %ebx
f010e5c7:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e5ca:	83 ec 08             	sub    $0x8,%esp
f010e5cd:	ff 75 08             	pushl  0x8(%ebp)
f010e5d0:	68 fe 94 12 f0       	push   $0xf01294fe
f010e5d5:	e8 b1 29 ff ff       	call   f0100f8b <cprintf>
f010e5da:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e5dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5e0:	83 ec 0c             	sub    $0xc,%esp
f010e5e3:	50                   	push   %eax
f010e5e4:	e8 fd 00 00 00       	call   f010e6e6 <print_regs>
f010e5e9:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e5ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5ef:	8b 40 20             	mov    0x20(%eax),%eax
f010e5f2:	0f b7 c0             	movzwl %ax,%eax
f010e5f5:	83 ec 08             	sub    $0x8,%esp
f010e5f8:	50                   	push   %eax
f010e5f9:	68 10 95 12 f0       	push   $0xf0129510
f010e5fe:	e8 88 29 ff ff       	call   f0100f8b <cprintf>
f010e603:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e606:	8b 45 08             	mov    0x8(%ebp),%eax
f010e609:	8b 40 24             	mov    0x24(%eax),%eax
f010e60c:	0f b7 c0             	movzwl %ax,%eax
f010e60f:	83 ec 08             	sub    $0x8,%esp
f010e612:	50                   	push   %eax
f010e613:	68 23 95 12 f0       	push   $0xf0129523
f010e618:	e8 6e 29 ff ff       	call   f0100f8b <cprintf>
f010e61d:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e620:	8b 45 08             	mov    0x8(%ebp),%eax
f010e623:	8b 58 28             	mov    0x28(%eax),%ebx
f010e626:	8b 45 08             	mov    0x8(%ebp),%eax
f010e629:	8b 40 28             	mov    0x28(%eax),%eax
f010e62c:	83 ec 0c             	sub    $0xc,%esp
f010e62f:	50                   	push   %eax
f010e630:	e8 28 ee ff ff       	call   f010d45d <trapname>
f010e635:	83 c4 10             	add    $0x10,%esp
f010e638:	89 c2                	mov    %eax,%edx
f010e63a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e63d:	8b 40 28             	mov    0x28(%eax),%eax
f010e640:	53                   	push   %ebx
f010e641:	52                   	push   %edx
f010e642:	50                   	push   %eax
f010e643:	68 36 95 12 f0       	push   $0xf0129536
f010e648:	e8 3e 29 ff ff       	call   f0100f8b <cprintf>
f010e64d:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e650:	8b 45 08             	mov    0x8(%ebp),%eax
f010e653:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e656:	83 ec 08             	sub    $0x8,%esp
f010e659:	50                   	push   %eax
f010e65a:	68 4d 95 12 f0       	push   $0xf012954d
f010e65f:	e8 27 29 ff ff       	call   f0100f8b <cprintf>
f010e664:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e667:	8b 45 08             	mov    0x8(%ebp),%eax
f010e66a:	8b 40 30             	mov    0x30(%eax),%eax
f010e66d:	83 ec 08             	sub    $0x8,%esp
f010e670:	50                   	push   %eax
f010e671:	68 5c 95 12 f0       	push   $0xf012955c
f010e676:	e8 10 29 ff ff       	call   f0100f8b <cprintf>
f010e67b:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e67e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e681:	8b 40 34             	mov    0x34(%eax),%eax
f010e684:	0f b7 c0             	movzwl %ax,%eax
f010e687:	83 ec 08             	sub    $0x8,%esp
f010e68a:	50                   	push   %eax
f010e68b:	68 6b 95 12 f0       	push   $0xf012956b
f010e690:	e8 f6 28 ff ff       	call   f0100f8b <cprintf>
f010e695:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e698:	8b 45 08             	mov    0x8(%ebp),%eax
f010e69b:	8b 40 38             	mov    0x38(%eax),%eax
f010e69e:	83 ec 08             	sub    $0x8,%esp
f010e6a1:	50                   	push   %eax
f010e6a2:	68 7e 95 12 f0       	push   $0xf012957e
f010e6a7:	e8 df 28 ff ff       	call   f0100f8b <cprintf>
f010e6ac:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e6af:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6b2:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e6b5:	83 ec 08             	sub    $0x8,%esp
f010e6b8:	50                   	push   %eax
f010e6b9:	68 8d 95 12 f0       	push   $0xf012958d
f010e6be:	e8 c8 28 ff ff       	call   f0100f8b <cprintf>
f010e6c3:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e6c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6c9:	8b 40 40             	mov    0x40(%eax),%eax
f010e6cc:	0f b7 c0             	movzwl %ax,%eax
f010e6cf:	83 ec 08             	sub    $0x8,%esp
f010e6d2:	50                   	push   %eax
f010e6d3:	68 9c 95 12 f0       	push   $0xf012959c
f010e6d8:	e8 ae 28 ff ff       	call   f0100f8b <cprintf>
f010e6dd:	83 c4 10             	add    $0x10,%esp
}
f010e6e0:	90                   	nop
f010e6e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e6e4:	c9                   	leave  
f010e6e5:	c3                   	ret    

f010e6e6 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e6e6:	55                   	push   %ebp
f010e6e7:	89 e5                	mov    %esp,%ebp
f010e6e9:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e6ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6ef:	8b 00                	mov    (%eax),%eax
f010e6f1:	83 ec 08             	sub    $0x8,%esp
f010e6f4:	50                   	push   %eax
f010e6f5:	68 af 95 12 f0       	push   $0xf01295af
f010e6fa:	e8 8c 28 ff ff       	call   f0100f8b <cprintf>
f010e6ff:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e702:	8b 45 08             	mov    0x8(%ebp),%eax
f010e705:	8b 40 04             	mov    0x4(%eax),%eax
f010e708:	83 ec 08             	sub    $0x8,%esp
f010e70b:	50                   	push   %eax
f010e70c:	68 be 95 12 f0       	push   $0xf01295be
f010e711:	e8 75 28 ff ff       	call   f0100f8b <cprintf>
f010e716:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e719:	8b 45 08             	mov    0x8(%ebp),%eax
f010e71c:	8b 40 08             	mov    0x8(%eax),%eax
f010e71f:	83 ec 08             	sub    $0x8,%esp
f010e722:	50                   	push   %eax
f010e723:	68 cd 95 12 f0       	push   $0xf01295cd
f010e728:	e8 5e 28 ff ff       	call   f0100f8b <cprintf>
f010e72d:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e730:	8b 45 08             	mov    0x8(%ebp),%eax
f010e733:	8b 40 0c             	mov    0xc(%eax),%eax
f010e736:	83 ec 08             	sub    $0x8,%esp
f010e739:	50                   	push   %eax
f010e73a:	68 dc 95 12 f0       	push   $0xf01295dc
f010e73f:	e8 47 28 ff ff       	call   f0100f8b <cprintf>
f010e744:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e747:	8b 45 08             	mov    0x8(%ebp),%eax
f010e74a:	8b 40 10             	mov    0x10(%eax),%eax
f010e74d:	83 ec 08             	sub    $0x8,%esp
f010e750:	50                   	push   %eax
f010e751:	68 eb 95 12 f0       	push   $0xf01295eb
f010e756:	e8 30 28 ff ff       	call   f0100f8b <cprintf>
f010e75b:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e75e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e761:	8b 40 14             	mov    0x14(%eax),%eax
f010e764:	83 ec 08             	sub    $0x8,%esp
f010e767:	50                   	push   %eax
f010e768:	68 fa 95 12 f0       	push   $0xf01295fa
f010e76d:	e8 19 28 ff ff       	call   f0100f8b <cprintf>
f010e772:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e775:	8b 45 08             	mov    0x8(%ebp),%eax
f010e778:	8b 40 18             	mov    0x18(%eax),%eax
f010e77b:	83 ec 08             	sub    $0x8,%esp
f010e77e:	50                   	push   %eax
f010e77f:	68 09 96 12 f0       	push   $0xf0129609
f010e784:	e8 02 28 ff ff       	call   f0100f8b <cprintf>
f010e789:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e78c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e78f:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e792:	83 ec 08             	sub    $0x8,%esp
f010e795:	50                   	push   %eax
f010e796:	68 18 96 12 f0       	push   $0xf0129618
f010e79b:	e8 eb 27 ff ff       	call   f0100f8b <cprintf>
f010e7a0:	83 c4 10             	add    $0x10,%esp
}
f010e7a3:	90                   	nop
f010e7a4:	c9                   	leave  
f010e7a5:	c3                   	ret    

f010e7a6 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e7a6:	55                   	push   %ebp
f010e7a7:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e7a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e7af:	89 14 85 40 d5 71 f0 	mov    %edx,-0xf8e2ac0(,%eax,4)
}
f010e7b6:	90                   	nop
f010e7b7:	5d                   	pop    %ebp
f010e7b8:	c3                   	ret    

f010e7b9 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e7b9:	55                   	push   %ebp
f010e7ba:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e7bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7bf:	c7 04 85 40 d5 71 f0 	movl   $0x0,-0xf8e2ac0(,%eax,4)
f010e7c6:	00 00 00 00 
}
f010e7ca:	90                   	nop
f010e7cb:	5d                   	pop    %ebp
f010e7cc:	c3                   	ret    

f010e7cd <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e7cd:	55                   	push   %ebp
f010e7ce:	89 e5                	mov    %esp,%ebp
f010e7d0:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e7d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7d6:	8b 40 28             	mov    0x28(%eax),%eax
f010e7d9:	83 e8 20             	sub    $0x20,%eax
f010e7dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e7df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7e2:	8b 04 85 40 d5 71 f0 	mov    -0xf8e2ac0(,%eax,4),%eax
f010e7e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e7ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e7f0:	74 0e                	je     f010e800 <irq_dispatch+0x33>
	{
		handler(tf);
f010e7f2:	83 ec 0c             	sub    $0xc,%esp
f010e7f5:	ff 75 08             	pushl  0x8(%ebp)
f010e7f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7fb:	ff d0                	call   *%eax
f010e7fd:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e800:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e803:	0f b6 c0             	movzbl %al,%eax
f010e806:	83 ec 0c             	sub    $0xc,%esp
f010e809:	50                   	push   %eax
f010e80a:	e8 9f 8f ff ff       	call   f01077ae <pic_sendEOI>
f010e80f:	83 c4 10             	add    $0x10,%esp
}
f010e812:	90                   	nop
f010e813:	c9                   	leave  
f010e814:	c3                   	ret    

f010e815 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e815:	55                   	push   %ebp
f010e816:	89 e5                	mov    %esp,%ebp
f010e818:	57                   	push   %edi
f010e819:	56                   	push   %esi
f010e81a:	53                   	push   %ebx
f010e81b:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010e81e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e821:	8b 40 28             	mov    0x28(%eax),%eax
f010e824:	83 f8 0e             	cmp    $0xe,%eax
f010e827:	75 51                	jne    f010e87a <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e829:	a0 80 d5 71 f0       	mov    0xf071d580,%al
f010e82e:	84 c0                	test   %al,%al
f010e830:	74 1f                	je     f010e851 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e832:	8b 45 08             	mov    0x8(%ebp),%eax
f010e835:	8b 40 30             	mov    0x30(%eax),%eax
f010e838:	89 c2                	mov    %eax,%edx
f010e83a:	a0 80 d5 71 f0       	mov    0xf071d580,%al
f010e83f:	0f b6 c0             	movzbl %al,%eax
f010e842:	01 d0                	add    %edx,%eax
f010e844:	89 c2                	mov    %eax,%edx
f010e846:	8b 45 08             	mov    0x8(%ebp),%eax
f010e849:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e84c:	e9 0c 01 00 00       	jmp    f010e95d <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e851:	83 ec 0c             	sub    $0xc,%esp
f010e854:	6a 01                	push   $0x1
f010e856:	e8 19 14 00 00       	call   f010fc74 <isPageReplacmentAlgorithmLRU>
f010e85b:	83 c4 10             	add    $0x10,%esp
f010e85e:	85 c0                	test   %eax,%eax
f010e860:	74 05                	je     f010e867 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e862:	e8 b6 8a ff ff       	call   f010731d <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e867:	83 ec 0c             	sub    $0xc,%esp
f010e86a:	ff 75 08             	pushl  0x8(%ebp)
f010e86d:	e8 e7 14 00 00       	call   f010fd59 <fault_handler>
f010e872:	83 c4 10             	add    $0x10,%esp
f010e875:	e9 e3 00 00 00       	jmp    f010e95d <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e87a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e87d:	8b 40 28             	mov    0x28(%eax),%eax
f010e880:	83 f8 30             	cmp    $0x30,%eax
f010e883:	75 6e                	jne    f010e8f3 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e885:	8b 45 08             	mov    0x8(%ebp),%eax
f010e888:	8b 40 38             	mov    0x38(%eax),%eax
f010e88b:	25 00 02 00 00       	and    $0x200,%eax
f010e890:	85 c0                	test   %eax,%eax
f010e892:	74 06                	je     f010e89a <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e894:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e895:	e8 5b 66 ff ff       	call   f0104ef5 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e89a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e89d:	8b 78 04             	mov    0x4(%eax),%edi
f010e8a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8a3:	8b 30                	mov    (%eax),%esi
f010e8a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8a8:	8b 58 10             	mov    0x10(%eax),%ebx
f010e8ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8ae:	8b 48 18             	mov    0x18(%eax),%ecx
f010e8b1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8b4:	8b 50 14             	mov    0x14(%eax),%edx
f010e8b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8ba:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e8bd:	83 ec 08             	sub    $0x8,%esp
f010e8c0:	57                   	push   %edi
f010e8c1:	56                   	push   %esi
f010e8c2:	53                   	push   %ebx
f010e8c3:	51                   	push   %ecx
f010e8c4:	52                   	push   %edx
f010e8c5:	50                   	push   %eax
f010e8c6:	e8 64 0a 00 00       	call   f010f32f <syscall>
f010e8cb:	83 c4 20             	add    $0x20,%esp
f010e8ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e8d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e8d7:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e8da:	9c                   	pushf  
f010e8db:	58                   	pop    %eax
f010e8dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e8df:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e8e2:	25 00 02 00 00       	and    $0x200,%eax
f010e8e7:	85 c0                	test   %eax,%eax
f010e8e9:	74 72                	je     f010e95d <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e8eb:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e8ec:	e8 dc 65 ff ff       	call   f0104ecd <kclock_stop>
f010e8f1:	eb 6a                	jmp    f010e95d <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e8f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8f6:	8b 40 28             	mov    0x28(%eax),%eax
f010e8f9:	83 f8 08             	cmp    $0x8,%eax
f010e8fc:	75 17                	jne    f010e915 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e8fe:	83 ec 04             	sub    $0x4,%esp
f010e901:	68 27 96 12 f0       	push   $0xf0129627
f010e906:	68 22 01 00 00       	push   $0x122
f010e90b:	68 36 96 12 f0       	push   $0xf0129636
f010e910:	e8 24 1a ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e915:	83 ec 0c             	sub    $0xc,%esp
f010e918:	ff 75 08             	pushl  0x8(%ebp)
f010e91b:	e8 a3 fc ff ff       	call   f010e5c3 <print_trapframe>
f010e920:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e923:	8b 45 08             	mov    0x8(%ebp),%eax
f010e926:	8b 40 34             	mov    0x34(%eax),%eax
f010e929:	66 83 f8 08          	cmp    $0x8,%ax
f010e92d:	75 17                	jne    f010e946 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e92f:	83 ec 04             	sub    $0x4,%esp
f010e932:	68 47 96 12 f0       	push   $0xf0129647
f010e937:	68 2a 01 00 00       	push   $0x12a
f010e93c:	68 36 96 12 f0       	push   $0xf0129636
f010e941:	e8 f3 19 ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e946:	83 ec 04             	sub    $0x4,%esp
f010e949:	68 60 96 12 f0       	push   $0xf0129660
f010e94e:	68 2f 01 00 00       	push   $0x12f
f010e953:	68 36 96 12 f0       	push   $0xf0129636
f010e958:	e8 dc 19 ff ff       	call   f0100339 <_panic>
		}
	}
}
f010e95d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e960:	5b                   	pop    %ebx
f010e961:	5e                   	pop    %esi
f010e962:	5f                   	pop    %edi
f010e963:	5d                   	pop    %ebp
f010e964:	c3                   	ret    

f010e965 <trap>:

void trap(struct Trapframe *tf)
{
f010e965:	55                   	push   %ebp
f010e966:	89 e5                	mov    %esp,%ebp
f010e968:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e96b:	e8 5d 65 ff ff       	call   f0104ecd <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e970:	9c                   	pushf  
f010e971:	58                   	pop    %eax
f010e972:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010e975:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e978:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010e97b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e97e:	25 00 02 00 00       	and    $0x200,%eax
f010e983:	85 c0                	test   %eax,%eax
f010e985:	74 25                	je     f010e9ac <trap+0x47>
	{
		print_trapframe(tf);
f010e987:	83 ec 0c             	sub    $0xc,%esp
f010e98a:	ff 75 08             	pushl  0x8(%ebp)
f010e98d:	e8 31 fc ff ff       	call   f010e5c3 <print_trapframe>
f010e992:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e995:	83 ec 04             	sub    $0x4,%esp
f010e998:	68 80 96 12 f0       	push   $0xf0129680
f010e99d:	68 45 01 00 00       	push   $0x145
f010e9a2:	68 36 96 12 f0       	push   $0xf0129636
f010e9a7:	e8 8d 19 ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010e9ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e9b3:	e8 8c d5 ff ff       	call   f010bf44 <get_cpu_proc>
f010e9b8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e9bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9be:	8b 40 34             	mov    0x34(%eax),%eax
f010e9c1:	0f b7 c0             	movzwl %ax,%eax
f010e9c4:	83 e0 03             	and    $0x3,%eax
f010e9c7:	83 f8 03             	cmp    $0x3,%eax
f010e9ca:	75 54                	jne    f010ea20 <trap+0xbb>
	{
		//cprintf("status: %d\n",cur_env->env_status);
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e9cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e9d0:	74 0b                	je     f010e9dd <trap+0x78>
f010e9d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e9d5:	8b 40 18             	mov    0x18(%eax),%eax
f010e9d8:	83 f8 02             	cmp    $0x2,%eax
f010e9db:	74 19                	je     f010e9f6 <trap+0x91>
f010e9dd:	68 c4 96 12 f0       	push   $0xf01296c4
f010e9e2:	68 f2 96 12 f0       	push   $0xf01296f2
f010e9e7:	68 4e 01 00 00       	push   $0x14e
f010e9ec:	68 36 96 12 f0       	push   $0xf0129636
f010e9f1:	e8 43 19 ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010e9f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e9f9:	8b 00                	mov    (%eax),%eax
f010e9fb:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e9fe:	74 19                	je     f010ea19 <trap+0xb4>
f010ea00:	68 07 97 12 f0       	push   $0xf0129707
f010ea05:	68 f2 96 12 f0       	push   $0xf01296f2
f010ea0a:	68 50 01 00 00       	push   $0x150
f010ea0f:	68 36 96 12 f0       	push   $0xf0129636
f010ea14:	e8 20 19 ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010ea19:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010ea20:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea23:	8b 40 28             	mov    0x28(%eax),%eax
f010ea26:	83 f8 1f             	cmp    $0x1f,%eax
f010ea29:	76 1b                	jbe    f010ea46 <trap+0xe1>
f010ea2b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea2e:	8b 40 28             	mov    0x28(%eax),%eax
f010ea31:	83 f8 2f             	cmp    $0x2f,%eax
f010ea34:	77 10                	ja     f010ea46 <trap+0xe1>
	{
		irq_dispatch(tf);
f010ea36:	83 ec 0c             	sub    $0xc,%esp
f010ea39:	ff 75 08             	pushl  0x8(%ebp)
f010ea3c:	e8 8c fd ff ff       	call   f010e7cd <irq_dispatch>
f010ea41:	83 c4 10             	add    $0x10,%esp
f010ea44:	eb 0e                	jmp    f010ea54 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010ea46:	83 ec 0c             	sub    $0xc,%esp
f010ea49:	ff 75 08             	pushl  0x8(%ebp)
f010ea4c:	e8 c4 fd ff ff       	call   f010e815 <trap_dispatch>
f010ea51:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ea54:	9c                   	pushf  
f010ea55:	58                   	pop    %eax
f010ea56:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010ea59:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010ea5c:	25 00 02 00 00       	and    $0x200,%eax
f010ea61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010ea64:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010ea68:	74 19                	je     f010ea83 <trap+0x11e>
f010ea6a:	68 1d 97 12 f0       	push   $0xf012971d
f010ea6f:	68 f2 96 12 f0       	push   $0xf01296f2
f010ea74:	68 67 01 00 00       	push   $0x167
f010ea79:	68 36 96 12 f0       	push   $0xf0129636
f010ea7e:	e8 b6 18 ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010ea83:	e8 6d 64 ff ff       	call   f0104ef5 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010ea88:	90                   	nop
f010ea89:	c9                   	leave  
f010ea8a:	c3                   	ret    
f010ea8b:	90                   	nop

f010ea8c <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010ea8c:	6a 08                	push   $0x8
f010ea8e:	e9 ed 00 00 00       	jmp    f010eb80 <_alltraps>
f010ea93:	90                   	nop

f010ea94 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010ea94:	6a 0e                	push   $0xe
f010ea96:	e9 e5 00 00 00       	jmp    f010eb80 <_alltraps>
f010ea9b:	90                   	nop

f010ea9c <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010ea9c:	6a 00                	push   $0x0
f010ea9e:	6a 20                	push   $0x20
f010eaa0:	e9 db 00 00 00       	jmp    f010eb80 <_alltraps>
f010eaa5:	90                   	nop

f010eaa6 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010eaa6:	6a 00                	push   $0x0
f010eaa8:	6a 21                	push   $0x21
f010eaaa:	e9 d1 00 00 00       	jmp    f010eb80 <_alltraps>
f010eaaf:	90                   	nop

f010eab0 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010eab0:	6a 00                	push   $0x0
f010eab2:	6a 30                	push   $0x30
f010eab4:	e9 c7 00 00 00       	jmp    f010eb80 <_alltraps>
f010eab9:	90                   	nop

f010eaba <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010eaba:	6a 00                	push   $0x0
f010eabc:	6a 00                	push   $0x0
f010eabe:	e9 bd 00 00 00       	jmp    f010eb80 <_alltraps>
f010eac3:	90                   	nop

f010eac4 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010eac4:	6a 00                	push   $0x0
f010eac6:	6a 01                	push   $0x1
f010eac8:	e9 b3 00 00 00       	jmp    f010eb80 <_alltraps>
f010eacd:	90                   	nop

f010eace <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010eace:	6a 00                	push   $0x0
f010ead0:	6a 02                	push   $0x2
f010ead2:	e9 a9 00 00 00       	jmp    f010eb80 <_alltraps>
f010ead7:	90                   	nop

f010ead8 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010ead8:	6a 00                	push   $0x0
f010eada:	6a 03                	push   $0x3
f010eadc:	e9 9f 00 00 00       	jmp    f010eb80 <_alltraps>
f010eae1:	90                   	nop

f010eae2 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010eae2:	6a 00                	push   $0x0
f010eae4:	6a 04                	push   $0x4
f010eae6:	e9 95 00 00 00       	jmp    f010eb80 <_alltraps>
f010eaeb:	90                   	nop

f010eaec <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010eaec:	6a 00                	push   $0x0
f010eaee:	6a 05                	push   $0x5
f010eaf0:	e9 8b 00 00 00       	jmp    f010eb80 <_alltraps>
f010eaf5:	90                   	nop

f010eaf6 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010eaf6:	6a 00                	push   $0x0
f010eaf8:	6a 06                	push   $0x6
f010eafa:	e9 81 00 00 00       	jmp    f010eb80 <_alltraps>
f010eaff:	90                   	nop

f010eb00 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010eb00:	6a 00                	push   $0x0
f010eb02:	6a 07                	push   $0x7
f010eb04:	eb 7a                	jmp    f010eb80 <_alltraps>

f010eb06 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010eb06:	6a 0a                	push   $0xa
f010eb08:	eb 76                	jmp    f010eb80 <_alltraps>

f010eb0a <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010eb0a:	6a 0b                	push   $0xb
f010eb0c:	eb 72                	jmp    f010eb80 <_alltraps>

f010eb0e <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010eb0e:	6a 0c                	push   $0xc
f010eb10:	eb 6e                	jmp    f010eb80 <_alltraps>

f010eb12 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010eb12:	6a 0d                	push   $0xd
f010eb14:	eb 6a                	jmp    f010eb80 <_alltraps>

f010eb16 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010eb16:	6a 00                	push   $0x0
f010eb18:	6a 10                	push   $0x10
f010eb1a:	eb 64                	jmp    f010eb80 <_alltraps>

f010eb1c <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010eb1c:	6a 11                	push   $0x11
f010eb1e:	eb 60                	jmp    f010eb80 <_alltraps>

f010eb20 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010eb20:	6a 00                	push   $0x0
f010eb22:	6a 12                	push   $0x12
f010eb24:	eb 5a                	jmp    f010eb80 <_alltraps>

f010eb26 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010eb26:	6a 00                	push   $0x0
f010eb28:	6a 13                	push   $0x13
f010eb2a:	eb 54                	jmp    f010eb80 <_alltraps>

f010eb2c <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010eb2c:	6a 00                	push   $0x0
f010eb2e:	6a 22                	push   $0x22
f010eb30:	eb 4e                	jmp    f010eb80 <_alltraps>

f010eb32 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010eb32:	6a 00                	push   $0x0
f010eb34:	6a 23                	push   $0x23
f010eb36:	eb 48                	jmp    f010eb80 <_alltraps>

f010eb38 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010eb38:	6a 00                	push   $0x0
f010eb3a:	6a 24                	push   $0x24
f010eb3c:	eb 42                	jmp    f010eb80 <_alltraps>

f010eb3e <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010eb3e:	6a 00                	push   $0x0
f010eb40:	6a 25                	push   $0x25
f010eb42:	eb 3c                	jmp    f010eb80 <_alltraps>

f010eb44 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010eb44:	6a 00                	push   $0x0
f010eb46:	6a 26                	push   $0x26
f010eb48:	eb 36                	jmp    f010eb80 <_alltraps>

f010eb4a <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010eb4a:	6a 00                	push   $0x0
f010eb4c:	6a 27                	push   $0x27
f010eb4e:	eb 30                	jmp    f010eb80 <_alltraps>

f010eb50 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010eb50:	6a 00                	push   $0x0
f010eb52:	6a 28                	push   $0x28
f010eb54:	eb 2a                	jmp    f010eb80 <_alltraps>

f010eb56 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010eb56:	6a 00                	push   $0x0
f010eb58:	6a 29                	push   $0x29
f010eb5a:	eb 24                	jmp    f010eb80 <_alltraps>

f010eb5c <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010eb5c:	6a 00                	push   $0x0
f010eb5e:	6a 2a                	push   $0x2a
f010eb60:	eb 1e                	jmp    f010eb80 <_alltraps>

f010eb62 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010eb62:	6a 00                	push   $0x0
f010eb64:	6a 2b                	push   $0x2b
f010eb66:	eb 18                	jmp    f010eb80 <_alltraps>

f010eb68 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010eb68:	6a 00                	push   $0x0
f010eb6a:	6a 2c                	push   $0x2c
f010eb6c:	eb 12                	jmp    f010eb80 <_alltraps>

f010eb6e <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010eb6e:	6a 00                	push   $0x0
f010eb70:	6a 2d                	push   $0x2d
f010eb72:	eb 0c                	jmp    f010eb80 <_alltraps>

f010eb74 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010eb74:	6a 00                	push   $0x0
f010eb76:	6a 2e                	push   $0x2e
f010eb78:	eb 06                	jmp    f010eb80 <_alltraps>

f010eb7a <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010eb7a:	6a 00                	push   $0x0
f010eb7c:	6a 2f                	push   $0x2f
f010eb7e:	eb 00                	jmp    f010eb80 <_alltraps>

f010eb80 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010eb80:	1e                   	push   %ds
push 	%es
f010eb81:	06                   	push   %es
pushal
f010eb82:	60                   	pusha  

mov 	$(GD_KD), %ax
f010eb83:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010eb87:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010eb89:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010eb8b:	54                   	push   %esp
call 	trap
f010eb8c:	e8 d4 fd ff ff       	call   f010e965 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010eb91:	59                   	pop    %ecx

f010eb92 <trapret>:
.globl trapret
trapret:
popal
f010eb92:	61                   	popa   
pop 	%es
f010eb93:	07                   	pop    %es
pop 	%ds
f010eb94:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010eb95:	83 c4 08             	add    $0x8,%esp
iret
f010eb98:	cf                   	iret   

f010eb99 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010eb99:	55                   	push   %ebp
f010eb9a:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010eb9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb9f:	8b 15 00 5d 74 f0    	mov    0xf0745d00,%edx
f010eba5:	29 d0                	sub    %edx,%eax
f010eba7:	c1 f8 03             	sar    $0x3,%eax
f010ebaa:	89 c2                	mov    %eax,%edx
f010ebac:	89 d0                	mov    %edx,%eax
f010ebae:	c1 e0 02             	shl    $0x2,%eax
f010ebb1:	01 d0                	add    %edx,%eax
f010ebb3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ebba:	01 c8                	add    %ecx,%eax
f010ebbc:	01 c0                	add    %eax,%eax
f010ebbe:	01 d0                	add    %edx,%eax
f010ebc0:	89 c1                	mov    %eax,%ecx
f010ebc2:	c1 e1 08             	shl    $0x8,%ecx
f010ebc5:	01 c8                	add    %ecx,%eax
f010ebc7:	89 c1                	mov    %eax,%ecx
f010ebc9:	c1 e1 10             	shl    $0x10,%ecx
f010ebcc:	01 c8                	add    %ecx,%eax
f010ebce:	c1 e0 02             	shl    $0x2,%eax
f010ebd1:	01 d0                	add    %edx,%eax
}
f010ebd3:	5d                   	pop    %ebp
f010ebd4:	c3                   	ret    

f010ebd5 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010ebd5:	55                   	push   %ebp
f010ebd6:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010ebd8:	ff 75 08             	pushl  0x8(%ebp)
f010ebdb:	e8 b9 ff ff ff       	call   f010eb99 <to_frame_number>
f010ebe0:	83 c4 04             	add    $0x4,%esp
f010ebe3:	c1 e0 0c             	shl    $0xc,%eax
}
f010ebe6:	c9                   	leave  
f010ebe7:	c3                   	ret    

f010ebe8 <sys_cputs>:
/*******************************/

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName) {
f010ebe8:	55                   	push   %ebp
f010ebe9:	89 e5                	mov    %esp,%ebp
f010ebeb:	83 ec 18             	sub    $0x18,%esp
f010ebee:	8b 45 10             	mov    0x10(%ebp),%eax
f010ebf1:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010ebf4:	e8 b1 8c ff ff       	call   f01078aa <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010ebf9:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010ebfd:	74 23                	je     f010ec22 <sys_cputs+0x3a>
			cprintf("[%s %d] ", cur_env->prog_name, cur_env->env_id);
f010ebff:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ec04:	8b 40 10             	mov    0x10(%eax),%eax
f010ec07:	8b 15 c8 45 76 f0    	mov    0xf07645c8,%edx
f010ec0d:	83 c2 20             	add    $0x20,%edx
f010ec10:	83 ec 04             	sub    $0x4,%esp
f010ec13:	50                   	push   %eax
f010ec14:	52                   	push   %edx
f010ec15:	68 d0 98 12 f0       	push   $0xf01298d0
f010ec1a:	e8 6c 23 ff ff       	call   f0100f8b <cprintf>
f010ec1f:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s", len, s);
f010ec22:	83 ec 04             	sub    $0x4,%esp
f010ec25:	ff 75 08             	pushl  0x8(%ebp)
f010ec28:	ff 75 0c             	pushl  0xc(%ebp)
f010ec2b:	68 d9 98 12 f0       	push   $0xf01298d9
f010ec30:	e8 56 23 ff ff       	call   f0100f8b <cprintf>
f010ec35:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010ec38:	e8 bf 8c ff ff       	call   f01078fc <popcli>
}
f010ec3d:	90                   	nop
f010ec3e:	c9                   	leave  
f010ec3f:	c3                   	ret    

f010ec40 <sys_cputc>:

// Print a char to the system console.
static void sys_cputc(const char c) {
f010ec40:	55                   	push   %ebp
f010ec41:	89 e5                	mov    %esp,%ebp
f010ec43:	83 ec 18             	sub    $0x18,%esp
f010ec46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec49:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c", c);
f010ec4c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010ec50:	83 ec 08             	sub    $0x8,%esp
f010ec53:	50                   	push   %eax
f010ec54:	68 de 98 12 f0       	push   $0xf01298de
f010ec59:	e8 2d 23 ff ff       	call   f0100f8b <cprintf>
f010ec5e:	83 c4 10             	add    $0x10,%esp
}
f010ec61:	90                   	nop
f010ec62:	c9                   	leave  
f010ec63:	c3                   	ret    

f010ec64 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int sys_cgetc(void) {
f010ec64:	55                   	push   %ebp
f010ec65:	89 e5                	mov    %esp,%ebp
f010ec67:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ec6a:	9c                   	pushf  
f010ec6b:	58                   	pop    %eax
f010ec6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ec6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010ec72:	25 00 02 00 00       	and    $0x200,%eax
f010ec77:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010ec7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ec7e:	74 10                	je     f010ec90 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0) {
f010ec80:	e8 3f 21 ff ff       	call   f0100dc4 <cons_getc2>
f010ec85:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ec88:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec8c:	74 f2                	je     f010ec80 <sys_cgetc+0x1c>
f010ec8e:	eb 0e                	jmp    f010ec9e <sys_cgetc+0x3a>
	} else /*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0) {
f010ec90:	e8 d4 20 ff ff       	call   f0100d69 <cons_getc>
f010ec95:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ec98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec9c:	74 f2                	je     f010ec90 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010ec9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eca1:	c9                   	leave  
f010eca2:	c3                   	ret    

f010eca3 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void) {
f010eca3:	55                   	push   %ebp
f010eca4:	89 e5                	mov    %esp,%ebp
f010eca6:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010eca9:	e8 02 22 ff ff       	call   f0100eb0 <cons_lock>
}
f010ecae:	90                   	nop
f010ecaf:	c9                   	leave  
f010ecb0:	c3                   	ret    

f010ecb1 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void) {
f010ecb1:	55                   	push   %ebp
f010ecb2:	89 e5                	mov    %esp,%ebp
f010ecb4:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010ecb7:	e8 3b 22 ff ff       	call   f0100ef7 <cons_unlock>
}
f010ecbc:	90                   	nop
f010ecbd:	c9                   	leave  
f010ecbe:	c3                   	ret    

f010ecbf <__sys_allocate_page>:
//		or the caller doesn't have permission to change envid.
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm) {
f010ecbf:	55                   	push   %ebp
f010ecc0:	89 e5                	mov    %esp,%ebp
f010ecc2:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010ecc5:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ecca:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info;
	r = allocate_frame(&ptr_frame_info);
f010eccd:	83 ec 0c             	sub    $0xc,%esp
f010ecd0:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010ecd3:	50                   	push   %eax
f010ecd4:	e8 ca 9b ff ff       	call   f01088a3 <allocate_frame>
f010ecd9:	83 c4 10             	add    $0x10,%esp
f010ecdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010ecdf:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010ece3:	75 08                	jne    f010eced <__sys_allocate_page+0x2e>
		return r;
f010ece5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ece8:	e9 e9 00 00 00       	jmp    f010edd6 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32) va >= USER_TOP || (uint32) va % PAGE_SIZE != 0)
f010eced:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecf0:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010ecf5:	77 0c                	ja     f010ed03 <__sys_allocate_page+0x44>
f010ecf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecfa:	25 ff 0f 00 00       	and    $0xfff,%eax
f010ecff:	85 c0                	test   %eax,%eax
f010ed01:	74 0a                	je     f010ed0d <__sys_allocate_page+0x4e>
		return E_INVAL;
f010ed03:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010ed08:	e9 c9 00 00 00       	jmp    f010edd6 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010ed0d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed10:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010ed15:	83 f8 04             	cmp    $0x4,%eax
f010ed18:	74 0a                	je     f010ed24 <__sys_allocate_page+0x65>
		return E_INVAL;
f010ed1a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010ed1f:	e9 b2 00 00 00       	jmp    f010edd6 <__sys_allocate_page+0x117>

	uint32 physical_address = to_physical_address(ptr_frame_info);
f010ed24:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed27:	83 ec 0c             	sub    $0xc,%esp
f010ed2a:	50                   	push   %eax
f010ed2b:	e8 a5 fe ff ff       	call   f010ebd5 <to_physical_address>
f010ed30:	83 c4 10             	add    $0x10,%esp
f010ed33:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT,
f010ed36:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ed39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed3c:	8b 40 64             	mov    0x64(%eax),%eax
f010ed3f:	6a 02                	push   $0x2
f010ed41:	68 00 00 80 ef       	push   $0xef800000
f010ed46:	52                   	push   %edx
f010ed47:	50                   	push   %eax
f010ed48:	e8 23 a0 ff ff       	call   f0108d70 <map_frame>
f010ed4d:	83 c4 10             	add    $0x10,%esp
		PERM_WRITEABLE);
		memset((void*) USER_LIMIT, 0, PAGE_SIZE);
f010ed50:	83 ec 04             	sub    $0x4,%esp
f010ed53:	68 00 10 00 00       	push   $0x1000
f010ed58:	6a 00                	push   $0x0
f010ed5a:	68 00 00 80 ef       	push   $0xef800000
f010ed5f:	e8 c5 33 01 00       	call   f0122129 <memset>
f010ed64:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010ed67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ed6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed6d:	8b 40 08             	mov    0x8(%eax),%eax
f010ed70:	40                   	inc    %eax
f010ed71:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010ed75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed78:	8b 40 64             	mov    0x64(%eax),%eax
f010ed7b:	83 ec 08             	sub    $0x8,%esp
f010ed7e:	68 00 00 80 ef       	push   $0xef800000
f010ed83:	50                   	push   %eax
f010ed84:	e8 50 a1 ff ff       	call   f0108ed9 <unmap_frame>
f010ed89:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010ed8c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ed8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ed92:	8b 40 08             	mov    0x8(%eax),%eax
f010ed95:	48                   	dec    %eax
f010ed96:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32) va, perm);
f010ed9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ed9d:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010eda0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eda3:	8b 40 64             	mov    0x64(%eax),%eax
f010eda6:	ff 75 0c             	pushl  0xc(%ebp)
f010eda9:	51                   	push   %ecx
f010edaa:	52                   	push   %edx
f010edab:	50                   	push   %eax
f010edac:	e8 bf 9f ff ff       	call   f0108d70 <map_frame>
f010edb1:	83 c4 10             	add    $0x10,%esp
f010edb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM) {
f010edb7:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010edbb:	75 14                	jne    f010edd1 <__sys_allocate_page+0x112>
		decrement_references(ptr_frame_info);
f010edbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010edc0:	83 ec 0c             	sub    $0xc,%esp
f010edc3:	50                   	push   %eax
f010edc4:	e8 e7 9c ff ff       	call   f0108ab0 <decrement_references>
f010edc9:	83 c4 10             	add    $0x10,%esp
		return r;
f010edcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010edcf:	eb 05                	jmp    f010edd6 <__sys_allocate_page+0x117>
	}
	return 0;
f010edd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010edd6:	c9                   	leave  
f010edd7:	c3                   	ret    

f010edd8 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid,
		void *dstva, int perm) {
f010edd8:	55                   	push   %ebp
f010edd9:	89 e5                	mov    %esp,%ebp
f010eddb:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010edde:	83 ec 04             	sub    $0x4,%esp
f010ede1:	68 e1 98 12 f0       	push   $0xf01298e1
f010ede6:	68 cc 00 00 00       	push   $0xcc
f010edeb:	68 ff 98 12 f0       	push   $0xf01298ff
f010edf0:	e8 44 15 ff ff       	call   f0100339 <_panic>

f010edf5 <__sys_unmap_frame>:
//
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va) {
f010edf5:	55                   	push   %ebp
f010edf6:	89 e5                	mov    %esp,%ebp
f010edf8:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010edfb:	83 ec 04             	sub    $0x4,%esp
f010edfe:	68 14 99 12 f0       	push   $0xf0129914
f010ee03:	68 dc 00 00 00       	push   $0xdc
f010ee08:	68 ff 98 12 f0       	push   $0xf01298ff
f010ee0d:	e8 27 15 ff ff       	call   f0100339 <_panic>

f010ee12 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size) {
f010ee12:	55                   	push   %ebp
f010ee13:	89 e5                	mov    %esp,%ebp
f010ee15:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory,
f010ee18:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ee1d:	8b 40 64             	mov    0x64(%eax),%eax
f010ee20:	83 ec 04             	sub    $0x4,%esp
f010ee23:	ff 75 0c             	pushl  0xc(%ebp)
f010ee26:	ff 75 08             	pushl  0x8(%ebp)
f010ee29:	50                   	push   %eax
f010ee2a:	e8 d8 c1 ff ff       	call   f010b007 <calculate_required_frames>
f010ee2f:	83 c4 10             	add    $0x10,%esp
			start_virtual_address, size);
}
f010ee32:	c9                   	leave  
f010ee33:	c3                   	ret    

f010ee34 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames() {
f010ee34:	55                   	push   %ebp
f010ee35:	89 e5                	mov    %esp,%ebp
f010ee37:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ee3a:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ee3d:	83 ec 0c             	sub    $0xc,%esp
f010ee40:	50                   	push   %eax
f010ee41:	e8 23 a2 ff ff       	call   f0109069 <calculate_available_frames>
f010ee46:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010ee49:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ee4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ee4f:	01 d0                	add    %edx,%eax
}
f010ee51:	c9                   	leave  
f010ee52:	c3                   	ret    

f010ee53 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames() {
f010ee53:	55                   	push   %ebp
f010ee54:	89 e5                	mov    %esp,%ebp
f010ee56:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ee59:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ee5c:	83 ec 0c             	sub    $0xc,%esp
f010ee5f:	50                   	push   %eax
f010ee60:	e8 04 a2 ff ff       	call   f0109069 <calculate_available_frames>
f010ee65:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010ee68:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ee6b:	c9                   	leave  
f010ee6c:	c3                   	ret    

f010ee6d <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames() {
f010ee6d:	55                   	push   %ebp
f010ee6e:	89 e5                	mov    %esp,%ebp
f010ee70:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010ee73:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ee76:	83 ec 0c             	sub    $0xc,%esp
f010ee79:	50                   	push   %eax
f010ee7a:	e8 ea a1 ff ff       	call   f0109069 <calculate_available_frames>
f010ee7f:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010ee82:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010ee85:	c9                   	leave  
f010ee86:	c3                   	ret    

f010ee87 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag) {
f010ee87:	55                   	push   %ebp
f010ee88:	89 e5                	mov    %esp,%ebp
f010ee8a:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010ee8d:	83 ec 0c             	sub    $0xc,%esp
f010ee90:	ff 75 08             	pushl  0x8(%ebp)
f010ee93:	e8 3a 1e 01 00       	call   f0120cd2 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ee98:	83 c4 10             	add    $0x10,%esp
}
f010ee9b:	c9                   	leave  
f010ee9c:	c3                   	ret    

f010ee9d <sys_scarce_memory>:

void sys_scarce_memory(void) {
f010ee9d:	55                   	push   %ebp
f010ee9e:	89 e5                	mov    %esp,%ebp
f010eea0:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010eea3:	e8 55 1d 01 00       	call   f0120bfd <scarce_memory>
}
f010eea8:	90                   	nop
f010eea9:	c9                   	leave  
f010eeaa:	c3                   	ret    

f010eeab <sys_clearFFL>:

void sys_clearFFL() {
f010eeab:	55                   	push   %ebp
f010eeac:	89 e5                	mov    %esp,%ebp
f010eeae:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010eeb1:	83 ec 0c             	sub    $0xc,%esp
f010eeb4:	68 c0 58 74 f0       	push   $0xf07458c0
f010eeb9:	e8 2c 19 00 00       	call   f01107ea <acquire_spinlock>
f010eebe:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list);
f010eec1:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f010eec6:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI;
		for (int i = 0; i < size; i++) {
f010eec9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010eed0:	eb 12                	jmp    f010eee4 <sys_clearFFL+0x39>
			allocate_frame(&ptr_tmp_FI);
f010eed2:	83 ec 0c             	sub    $0xc,%esp
f010eed5:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010eed8:	50                   	push   %eax
f010eed9:	e8 c5 99 ff ff       	call   f01088a3 <allocate_frame>
f010eede:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list);
		struct FrameInfo* ptr_tmp_FI;
		for (int i = 0; i < size; i++) {
f010eee1:	ff 45 f4             	incl   -0xc(%ebp)
f010eee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eee7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010eeea:	7c e6                	jl     f010eed2 <sys_clearFFL+0x27>
			allocate_frame(&ptr_tmp_FI);
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010eeec:	83 ec 0c             	sub    $0xc,%esp
f010eeef:	68 c0 58 74 f0       	push   $0xf07458c0
f010eef4:	e8 78 19 00 00       	call   f0110871 <release_spinlock>
f010eef9:	83 c4 10             	add    $0x10,%esp
}
f010eefc:	90                   	nop
f010eefd:	c9                   	leave  
f010eefe:	c3                   	ret    

f010eeff <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void) {
f010eeff:	55                   	push   %ebp
f010ef00:	89 e5                	mov    %esp,%ebp
f010ef02:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010ef05:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ef0a:	83 ec 0c             	sub    $0xc,%esp
f010ef0d:	50                   	push   %eax
f010ef0e:	e8 ff 5a ff ff       	call   f0104a12 <pf_calculate_allocated_pages>
f010ef13:	83 c4 10             	add    $0x10,%esp
}
f010ef16:	c9                   	leave  
f010ef17:	c3                   	ret    

f010ef18 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size) {
f010ef18:	55                   	push   %ebp
f010ef19:	89 e5                	mov    %esp,%ebp
f010ef1b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation
	if (virtual_address == 0) {
f010ef1e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ef22:	75 05                	jne    f010ef29 <sys_free_user_mem+0x11>
		env_exit();
f010ef24:	e8 d9 cf ff ff       	call   f010bf02 <env_exit>
	}
	if (virtual_address < USER_HEAP_START || virtual_address >= USER_HEAP_MAX) {
f010ef29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef2c:	85 c0                	test   %eax,%eax
f010ef2e:	79 09                	jns    f010ef39 <sys_free_user_mem+0x21>
f010ef30:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010ef37:	76 05                	jbe    f010ef3e <sys_free_user_mem+0x26>
		env_exit();
f010ef39:	e8 c4 cf ff ff       	call   f010bf02 <env_exit>
	}
	if (isBufferingEnabled()) {
f010ef3e:	e8 f4 0d 00 00       	call   f010fd37 <isBufferingEnabled>
f010ef43:	84 c0                	test   %al,%al
f010ef45:	74 19                	je     f010ef60 <sys_free_user_mem+0x48>
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ef47:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ef4c:	83 ec 04             	sub    $0x4,%esp
f010ef4f:	ff 75 0c             	pushl  0xc(%ebp)
f010ef52:	ff 75 08             	pushl  0x8(%ebp)
f010ef55:	50                   	push   %eax
f010ef56:	e8 96 c3 ff ff       	call   f010b2f1 <__free_user_mem_with_buffering>
f010ef5b:	83 c4 10             	add    $0x10,%esp
	} else {
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ef5e:	eb 18                	jmp    f010ef78 <sys_free_user_mem+0x60>
		env_exit();
	}
	if (isBufferingEnabled()) {
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	} else {
		free_user_mem(cur_env, virtual_address, size);
f010ef60:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ef65:	83 ec 04             	sub    $0x4,%esp
f010ef68:	ff 75 0c             	pushl  0xc(%ebp)
f010ef6b:	ff 75 08             	pushl  0x8(%ebp)
f010ef6e:	50                   	push   %eax
f010ef6f:	e8 a0 c1 ff ff       	call   f010b114 <free_user_mem>
f010ef74:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ef77:	90                   	nop
}
f010ef78:	c9                   	leave  
f010ef79:	c3                   	ret    

f010ef7a <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size) {
f010ef7a:	55                   	push   %ebp
f010ef7b:	89 e5                	mov    %esp,%ebp
f010ef7d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	if (virtual_address == 0) {
f010ef80:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ef84:	75 05                	jne    f010ef8b <sys_allocate_user_mem+0x11>
		env_exit();
f010ef86:	e8 77 cf ff ff       	call   f010bf02 <env_exit>
	}
	if (virtual_address
			< cur_env->uheapStart|| virtual_address >= USER_HEAP_MAX) {
f010ef8b:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010ef90:	8b 40 74             	mov    0x74(%eax),%eax
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	if (virtual_address == 0) {
		env_exit();
	}
	if (virtual_address
f010ef93:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ef96:	77 09                	ja     f010efa1 <sys_allocate_user_mem+0x27>
			< cur_env->uheapStart|| virtual_address >= USER_HEAP_MAX) {
f010ef98:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010ef9f:	76 05                	jbe    f010efa6 <sys_allocate_user_mem+0x2c>
		env_exit();
f010efa1:	e8 5c cf ff ff       	call   f010bf02 <env_exit>
	}
	allocate_user_mem(cur_env, virtual_address, size);
f010efa6:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010efab:	83 ec 04             	sub    $0x4,%esp
f010efae:	ff 75 0c             	pushl  0xc(%ebp)
f010efb1:	ff 75 08             	pushl  0x8(%ebp)
f010efb4:	50                   	push   %eax
f010efb5:	e8 d8 c0 ff ff       	call   f010b092 <allocate_user_mem>
f010efba:	83 c4 10             	add    $0x10,%esp

	return;
f010efbd:	90                   	nop

}
f010efbe:	c9                   	leave  
f010efbf:	c3                   	ret    

f010efc0 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms) {
f010efc0:	55                   	push   %ebp
f010efc1:	89 e5                	mov    %esp,%ebp
f010efc3:	83 ec 08             	sub    $0x8,%esp

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010efc6:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010efcb:	8b 40 64             	mov    0x64(%eax),%eax
f010efce:	ff 75 10             	pushl  0x10(%ebp)
f010efd1:	ff 75 0c             	pushl  0xc(%ebp)
f010efd4:	ff 75 08             	pushl  0x8(%ebp)
f010efd7:	50                   	push   %eax
f010efd8:	e8 f6 bf ff ff       	call   f010afd3 <allocate_chunk>
f010efdd:	83 c4 10             	add    $0x10,%esp
	return;
f010efe0:	90                   	nop
}
f010efe1:	c9                   	leave  
f010efe2:	c3                   	ret    

f010efe3 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size) {
f010efe3:	55                   	push   %ebp
f010efe4:	89 e5                	mov    %esp,%ebp
f010efe6:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010efe9:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010efee:	ff 75 10             	pushl  0x10(%ebp)
f010eff1:	ff 75 0c             	pushl  0xc(%ebp)
f010eff4:	ff 75 08             	pushl  0x8(%ebp)
f010eff7:	50                   	push   %eax
f010eff8:	e8 11 c3 ff ff       	call   f010b30e <move_user_mem>
f010effd:	83 c4 10             	add    $0x10,%esp
	return;
f010f000:	90                   	nop
}
f010f001:	c9                   	leave  
f010f002:	c3                   	ret    

f010f003 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy() {
f010f003:	55                   	push   %ebp
f010f004:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy;
f010f006:	a1 e4 5c 74 f0       	mov    0xf0745ce4,%eax
}
f010f00b:	5d                   	pop    %ebp
f010f00c:	c3                   	ret    

f010f00d <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy) {
f010f00d:	55                   	push   %ebp
f010f00e:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010f010:	8b 45 08             	mov    0x8(%ebp),%eax
f010f013:	a3 e4 5c 74 f0       	mov    %eax,0xf0745ce4
}
f010f018:	90                   	nop
f010f019:	5d                   	pop    %ebp
f010f01a:	c3                   	ret    

f010f01b <sys_env_set_priority>:
/*******************************/
/* SEMAPHORES SYSTEM CALLS */
/*******************************/
//[PROJECT'24.MS3] ADD SUITABLE CODE HERE
void sys_env_set_priority(int32 envID, int priority)//EDITED
{
f010f01b:	55                   	push   %ebp
f010f01c:	89 e5                	mov    %esp,%ebp
f010f01e:	83 ec 08             	sub    $0x8,%esp
    env_set_priority(envID, priority);
f010f021:	83 ec 08             	sub    $0x8,%esp
f010f024:	ff 75 0c             	pushl  0xc(%ebp)
f010f027:	ff 75 08             	pushl  0x8(%ebp)
f010f02a:	e8 3e 79 ff ff       	call   f010696d <env_set_priority>
f010f02f:	83 c4 10             	add    $0x10,%esp
    return;
f010f032:	90                   	nop
}
f010f033:	c9                   	leave  
f010f034:	c3                   	ret    

f010f035 <sys_init_queue>:
void sys_init_queue(struct Env_Queue * queue) {
f010f035:	55                   	push   %ebp
f010f036:	89 e5                	mov    %esp,%ebp
f010f038:	83 ec 08             	sub    $0x8,%esp
	init_queue(queue);
f010f03b:	83 ec 0c             	sub    $0xc,%esp
f010f03e:	ff 75 08             	pushl  0x8(%ebp)
f010f041:	e8 36 61 ff ff       	call   f010517c <init_queue>
f010f046:	83 c4 10             	add    $0x10,%esp
}
f010f049:	90                   	nop
f010f04a:	c9                   	leave  
f010f04b:	c3                   	ret    

f010f04c <sys_block_process>:

void sys_block_process(struct Env_Queue * queue, uint32 *lock) {
f010f04c:	55                   	push   %ebp
f010f04d:	89 e5                	mov    %esp,%ebp
f010f04f:	83 ec 08             	sub    $0x8,%esp

	acquire_spinlock(&ProcessQueues.qlock);
f010f052:	83 ec 0c             	sub    $0xc,%esp
f010f055:	68 00 58 74 f0       	push   $0xf0745800
f010f05a:	e8 8b 17 00 00       	call   f01107ea <acquire_spinlock>
f010f05f:	83 c4 10             	add    $0x10,%esp
	// release the sempahore lock
	*lock = 0;
f010f062:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f065:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	// block the process status
	cur_env->env_status = ENV_BLOCKED;
f010f06b:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f070:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	// add the current process to the semaphore queue
	enqueue(queue, cur_env);
f010f077:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f07c:	83 ec 08             	sub    $0x8,%esp
f010f07f:	50                   	push   %eax
f010f080:	ff 75 08             	pushl  0x8(%ebp)
f010f083:	e8 35 61 ff ff       	call   f01051bd <enqueue>
f010f088:	83 c4 10             	add    $0x10,%esp
	// Invoke the scheduler to context switch into the next ready queue (if any)
	sched();
f010f08b:	e8 2e d0 ff ff       	call   f010c0be <sched>
	release_spinlock(&ProcessQueues.qlock);
f010f090:	83 ec 0c             	sub    $0xc,%esp
f010f093:	68 00 58 74 f0       	push   $0xf0745800
f010f098:	e8 d4 17 00 00       	call   f0110871 <release_spinlock>
f010f09d:	83 c4 10             	add    $0x10,%esp
}
f010f0a0:	90                   	nop
f010f0a1:	c9                   	leave  
f010f0a2:	c3                   	ret    

f010f0a3 <sys_unblock_process>:

void sys_unblock_process(struct Env_Queue * queue) {
f010f0a3:	55                   	push   %ebp
f010f0a4:	89 e5                	mov    %esp,%ebp
f010f0a6:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&ProcessQueues.qlock);
f010f0a9:	83 ec 0c             	sub    $0xc,%esp
f010f0ac:	68 00 58 74 f0       	push   $0xf0745800
f010f0b1:	e8 34 17 00 00       	call   f01107ea <acquire_spinlock>
f010f0b6:	83 c4 10             	add    $0x10,%esp
	// remove a process from the semaphore queue
	struct Env* waiting_process = dequeue(queue);
f010f0b9:	83 ec 0c             	sub    $0xc,%esp
f010f0bc:	ff 75 08             	pushl  0x8(%ebp)
f010f0bf:	e8 8a 61 ff ff       	call   f010524e <dequeue>
f010f0c4:	83 c4 10             	add    $0x10,%esp
f010f0c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (waiting_process != NULL) {
f010f0ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f0ce:	74 0e                	je     f010f0de <sys_unblock_process+0x3b>
		// Unblock the process
		sched_insert_ready(waiting_process);
f010f0d0:	83 ec 0c             	sub    $0xc,%esp
f010f0d3:	ff 75 f4             	pushl  -0xc(%ebp)
f010f0d6:	e8 1f 64 ff ff       	call   f01054fa <sched_insert_ready>
f010f0db:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock); // Release the spin lock of that was protecting the process queues
f010f0de:	83 ec 0c             	sub    $0xc,%esp
f010f0e1:	68 00 58 74 f0       	push   $0xf0745800
f010f0e6:	e8 86 17 00 00       	call   f0110871 <release_spinlock>
f010f0eb:	83 c4 10             	add    $0x10,%esp
}
f010f0ee:	90                   	nop
f010f0ef:	c9                   	leave  
f010f0f0:	c3                   	ret    

f010f0f1 <sys_createSharedObject>:
/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable,
		void* virtual_address) {
f010f0f1:	55                   	push   %ebp
f010f0f2:	89 e5                	mov    %esp,%ebp
f010f0f4:	83 ec 18             	sub    $0x18,%esp
f010f0f7:	8b 45 10             	mov    0x10(%ebp),%eax
f010f0fa:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable,
f010f0fd:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010f101:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f106:	8b 40 10             	mov    0x10(%eax),%eax
f010f109:	83 ec 0c             	sub    $0xc,%esp
f010f10c:	ff 75 14             	pushl  0x14(%ebp)
f010f10f:	52                   	push   %edx
f010f110:	ff 75 0c             	pushl  0xc(%ebp)
f010f113:	ff 75 08             	pushl  0x8(%ebp)
f010f116:	50                   	push   %eax
f010f117:	e8 b8 a2 ff ff       	call   f01093d4 <createSharedObject>
f010f11c:	83 c4 20             	add    $0x20,%esp
			virtual_address);
}
f010f11f:	c9                   	leave  
f010f120:	c3                   	ret    

f010f121 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName) {
f010f121:	55                   	push   %ebp
f010f122:	89 e5                	mov    %esp,%ebp
f010f124:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010f127:	83 ec 08             	sub    $0x8,%esp
f010f12a:	ff 75 0c             	pushl  0xc(%ebp)
f010f12d:	ff 75 08             	pushl  0x8(%ebp)
f010f130:	e8 53 a0 ff ff       	call   f0109188 <getSizeOfSharedObject>
f010f135:	83 c4 10             	add    $0x10,%esp
}
f010f138:	c9                   	leave  
f010f139:	c3                   	ret    

f010f13a <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address) {
f010f13a:	55                   	push   %ebp
f010f13b:	89 e5                	mov    %esp,%ebp
f010f13d:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010f140:	83 ec 04             	sub    $0x4,%esp
f010f143:	ff 75 10             	pushl  0x10(%ebp)
f010f146:	ff 75 0c             	pushl  0xc(%ebp)
f010f149:	ff 75 08             	pushl  0x8(%ebp)
f010f14c:	e8 ac a4 ff ff       	call   f01095fd <getSharedObject>
f010f151:	83 c4 10             	add    $0x10,%esp
}
f010f154:	c9                   	leave  
f010f155:	c3                   	ret    

f010f156 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA) {
f010f156:	55                   	push   %ebp
f010f157:	89 e5                	mov    %esp,%ebp
f010f159:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010f15c:	83 ec 08             	sub    $0x8,%esp
f010f15f:	ff 75 0c             	pushl  0xc(%ebp)
f010f162:	ff 75 08             	pushl  0x8(%ebp)
f010f165:	e8 77 a6 ff ff       	call   f01097e1 <freeSharedObject>
f010f16a:	83 c4 10             	add    $0x10,%esp
}
f010f16d:	c9                   	leave  
f010f16e:	c3                   	ret    

f010f16f <sys_getenvid>:
/*********************************/
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void) {
f010f16f:	55                   	push   %ebp
f010f170:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010f172:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f177:	8b 40 10             	mov    0x10(%eax),%eax
}
f010f17a:	5d                   	pop    %ebp
f010f17b:	c3                   	ret    

f010f17c <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void) {
f010f17c:	55                   	push   %ebp
f010f17d:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs);
f010f17f:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f184:	89 c2                	mov    %eax,%edx
f010f186:	a1 10 cd 71 f0       	mov    0xf071cd10,%eax
f010f18b:	29 c2                	sub    %eax,%edx
f010f18d:	89 d0                	mov    %edx,%eax
f010f18f:	c1 f8 02             	sar    $0x2,%eax
f010f192:	89 c1                	mov    %eax,%ecx
f010f194:	89 ca                	mov    %ecx,%edx
f010f196:	c1 e2 02             	shl    $0x2,%edx
f010f199:	01 ca                	add    %ecx,%edx
f010f19b:	c1 e2 02             	shl    $0x2,%edx
f010f19e:	01 ca                	add    %ecx,%edx
f010f1a0:	c1 e2 03             	shl    $0x3,%edx
f010f1a3:	01 ca                	add    %ecx,%edx
f010f1a5:	89 d0                	mov    %edx,%eax
f010f1a7:	c1 e0 05             	shl    $0x5,%eax
f010f1aa:	29 d0                	sub    %edx,%eax
f010f1ac:	c1 e0 02             	shl    $0x2,%eax
f010f1af:	01 c8                	add    %ecx,%eax
f010f1b1:	c1 e0 02             	shl    $0x2,%eax
f010f1b4:	01 c8                	add    %ecx,%eax
f010f1b6:	c1 e0 02             	shl    $0x2,%eax
f010f1b9:	01 c8                	add    %ecx,%eax
f010f1bb:	c1 e0 06             	shl    $0x6,%eax
f010f1be:	29 c8                	sub    %ecx,%eax
f010f1c0:	c1 e0 03             	shl    $0x3,%eax
f010f1c3:	01 c8                	add    %ecx,%eax
f010f1c5:	c1 e0 04             	shl    $0x4,%eax
f010f1c8:	01 c8                	add    %ecx,%eax
}
f010f1ca:	5d                   	pop    %ebp
f010f1cb:	c3                   	ret    

f010f1cc <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void) {
f010f1cc:	55                   	push   %ebp
f010f1cd:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010f1cf:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f1d4:	8b 40 14             	mov    0x14(%eax),%eax
}
f010f1d7:	5d                   	pop    %ebp
f010f1d8:	c3                   	ret    

f010f1d9 <sys_destroy_env>:
// if envid=0, destroy the currently running environment --> schedule the next (if any)
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid) {
f010f1d9:	55                   	push   %ebp
f010f1da:	89 e5                	mov    %esp,%ebp
f010f1dc:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0) {
f010f1df:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010f1e3:	75 0a                	jne    f010f1ef <sys_destroy_env+0x16>
		e = cur_env;
f010f1e5:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f1ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010f1ed:	eb 22                	jmp    f010f211 <sys_destroy_env+0x38>
	} else if ((r = envid2env(envid, &e, 0)) < 0) {
f010f1ef:	83 ec 04             	sub    $0x4,%esp
f010f1f2:	6a 00                	push   $0x0
f010f1f4:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010f1f7:	50                   	push   %eax
f010f1f8:	ff 75 08             	pushl  0x8(%ebp)
f010f1fb:	e8 94 cd ff ff       	call   f010bf94 <envid2env>
f010f200:	83 c4 10             	add    $0x10,%esp
f010f203:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010f206:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f20a:	79 05                	jns    f010f211 <sys_destroy_env+0x38>
		return r;
f010f20c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f20f:	eb 5e                	jmp    f010f26f <sys_destroy_env+0x96>
	}

	if (e == cur_env) {
f010f211:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f214:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f219:	39 c2                	cmp    %eax,%edx
f010f21b:	75 1b                	jne    f010f238 <sys_destroy_env+0x5f>
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010f21d:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f222:	8b 40 10             	mov    0x10(%eax),%eax
f010f225:	83 ec 08             	sub    $0x8,%esp
f010f228:	50                   	push   %eax
f010f229:	68 33 99 12 f0       	push   $0xf0129933
f010f22e:	e8 58 1d ff ff       	call   f0100f8b <cprintf>
f010f233:	83 c4 10             	add    $0x10,%esp
f010f236:	eb 20                	jmp    f010f258 <sys_destroy_env+0x7f>
	} else {
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010f238:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f23b:	8b 50 10             	mov    0x10(%eax),%edx
f010f23e:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f243:	8b 40 10             	mov    0x10(%eax),%eax
f010f246:	83 ec 04             	sub    $0x4,%esp
f010f249:	52                   	push   %edx
f010f24a:	50                   	push   %eax
f010f24b:	68 4e 99 12 f0       	push   $0xf012994e
f010f250:	e8 36 1d ff ff       	call   f0100f8b <cprintf>
f010f255:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010f258:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f25b:	8b 40 10             	mov    0x10(%eax),%eax
f010f25e:	83 ec 0c             	sub    $0xc,%esp
f010f261:	50                   	push   %eax
f010f262:	e8 e1 6a ff ff       	call   f0105d48 <sched_kill_env>
f010f267:	83 c4 10             	add    $0x10,%esp

	return 0;
f010f26a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f26f:	c9                   	leave  
f010f270:	c3                   	ret    

f010f271 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env() {
f010f271:	55                   	push   %ebp
f010f272:	89 e5                	mov    %esp,%ebp
f010f274:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010f277:	e8 86 cc ff ff       	call   f010bf02 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010f27c:	90                   	nop
f010f27d:	c9                   	leave  
f010f27e:	c3                   	ret    

f010f27f <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,
		unsigned int LRU_second_list_size,
		unsigned int percent_WS_pages_to_remove) {
f010f27f:	55                   	push   %ebp
f010f280:	89 e5                	mov    %esp,%ebp
f010f282:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env = env_create(programName, page_WS_size,
f010f285:	ff 75 14             	pushl  0x14(%ebp)
f010f288:	ff 75 10             	pushl  0x10(%ebp)
f010f28b:	ff 75 0c             	pushl  0xc(%ebp)
f010f28e:	ff 75 08             	pushl  0x8(%ebp)
f010f291:	e8 30 c2 ff ff       	call   f010b4c6 <env_create>
f010f296:	83 c4 10             	add    $0x10,%esp
f010f299:	89 45 f4             	mov    %eax,-0xc(%ebp)
			LRU_second_list_size, percent_WS_pages_to_remove);
	if (env == NULL) {
f010f29c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f2a0:	75 07                	jne    f010f2a9 <sys_create_env+0x2a>
		return E_ENV_CREATION_ERROR;
f010f2a2:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010f2a7:	eb 14                	jmp    f010f2bd <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010f2a9:	83 ec 0c             	sub    $0xc,%esp
f010f2ac:	ff 75 f4             	pushl  -0xc(%ebp)
f010f2af:	e8 f8 66 ff ff       	call   f01059ac <sched_new_env>
f010f2b4:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010f2b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f2ba:	8b 40 10             	mov    0x10(%eax),%eax
}
f010f2bd:	c9                   	leave  
f010f2be:	c3                   	ret    

f010f2bf <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId) {
f010f2bf:	55                   	push   %ebp
f010f2c0:	89 e5                	mov    %esp,%ebp
f010f2c2:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010f2c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010f2c8:	83 ec 0c             	sub    $0xc,%esp
f010f2cb:	50                   	push   %eax
f010f2cc:	e8 31 67 ff ff       	call   f0105a02 <sched_run_env>
f010f2d1:	83 c4 10             	add    $0x10,%esp
}
f010f2d4:	90                   	nop
f010f2d5:	c9                   	leave  
f010f2d6:	c3                   	ret    

f010f2d7 <sys_get_virtual_time>:
//====================================
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time() {
f010f2d7:	55                   	push   %ebp
f010f2d8:	89 e5                	mov    %esp,%ebp
f010f2da:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010f2dd:	0f 31                	rdtsc  
f010f2df:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010f2e2:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010f2e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f2e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f2eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f2ee:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010f2f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010f2f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f2f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f2fa:	89 01                	mov    %eax,(%ecx)
f010f2fc:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010f2ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010f302:	c9                   	leave  
f010f303:	c2 04 00             	ret    $0x4

f010f306 <sys_rcr2>:

uint32 sys_rcr2() {
f010f306:	55                   	push   %ebp
f010f307:	89 e5                	mov    %esp,%ebp
f010f309:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f30c:	0f 20 d0             	mov    %cr2,%eax
f010f30f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010f312:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010f315:	90                   	nop
}
f010f316:	c9                   	leave  
f010f317:	c3                   	ret    

f010f318 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength) {
f010f318:	55                   	push   %ebp
f010f319:	89 e5                	mov    %esp,%ebp
f010f31b:	83 ec 04             	sub    $0x4,%esp
f010f31e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f321:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010f324:	8a 45 fc             	mov    -0x4(%ebp),%al
f010f327:	a2 80 d5 71 f0       	mov    %al,0xf071d580
}
f010f32c:	90                   	nop
f010f32d:	c9                   	leave  
f010f32e:	c3                   	ret    

f010f32f <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4,
		uint32 a5) {
f010f32f:	55                   	push   %ebp
f010f330:	89 e5                	mov    %esp,%ebp
f010f332:	56                   	push   %esi
f010f333:	53                   	push   %ebx
f010f334:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010f337:	e8 08 cc ff ff       	call   f010bf44 <get_cpu_proc>
f010f33c:	a3 c8 45 76 f0       	mov    %eax,0xf07645c8
	assert(cur_env != NULL);
f010f341:	a1 c8 45 76 f0       	mov    0xf07645c8,%eax
f010f346:	85 c0                	test   %eax,%eax
f010f348:	75 19                	jne    f010f363 <syscall+0x34>
f010f34a:	68 66 99 12 f0       	push   $0xf0129966
f010f34f:	68 76 99 12 f0       	push   $0xf0129976
f010f354:	68 ef 01 00 00       	push   $0x1ef
f010f359:	68 ff 98 12 f0       	push   $0xf01298ff
f010f35e:	e8 d6 0f ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch (syscallno) {
f010f363:	83 7d 08 32          	cmpl   $0x32,0x8(%ebp)
f010f367:	0f 87 72 04 00 00    	ja     f010f7df <syscall+0x4b0>
f010f36d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f370:	c1 e0 02             	shl    $0x2,%eax
f010f373:	05 8c 99 12 f0       	add    $0xf012998c,%eax
f010f378:	8b 00                	mov    (%eax),%eax
f010f37a:	ff e0                	jmp    *%eax
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here

	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*) a1, a2, (uint8) a3);
f010f37c:	8b 45 14             	mov    0x14(%ebp),%eax
f010f37f:	0f b6 d0             	movzbl %al,%edx
f010f382:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f385:	83 ec 04             	sub    $0x4,%esp
f010f388:	52                   	push   %edx
f010f389:	ff 75 10             	pushl  0x10(%ebp)
f010f38c:	50                   	push   %eax
f010f38d:	e8 56 f8 ff ff       	call   f010ebe8 <sys_cputs>
f010f392:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f395:	b8 00 00 00 00       	mov    $0x0,%eax
f010f39a:	e9 45 04 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010f39f:	e8 c0 f8 ff ff       	call   f010ec64 <sys_cgetc>
f010f3a4:	e9 3b 04 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f3a9:	e8 f5 f8 ff ff       	call   f010eca3 <sys_lock_cons>
		return 0;
f010f3ae:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3b3:	e9 2c 04 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f3b8:	e8 f4 f8 ff ff       	call   f010ecb1 <sys_unlock_cons>
		return 0;
f010f3bd:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3c2:	e9 1d 04 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f3c7:	83 ec 08             	sub    $0x8,%esp
f010f3ca:	ff 75 10             	pushl  0x10(%ebp)
f010f3cd:	ff 75 0c             	pushl  0xc(%ebp)
f010f3d0:	e8 3d fa ff ff       	call   f010ee12 <sys_calculate_required_frames>
f010f3d5:	83 c4 10             	add    $0x10,%esp
f010f3d8:	e9 07 04 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f3dd:	e8 52 fa ff ff       	call   f010ee34 <sys_calculate_free_frames>
f010f3e2:	e9 fd 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f3e7:	e8 67 fa ff ff       	call   f010ee53 <sys_calculate_modified_frames>
f010f3ec:	e9 f3 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f3f1:	e8 77 fa ff ff       	call   f010ee6d <sys_calculate_notmod_frames>
f010f3f6:	e9 e9 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f3fb:	e8 ff fa ff ff       	call   f010eeff <sys_pf_calculate_allocated_pages>
f010f400:	e9 df 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f405:	83 ec 0c             	sub    $0xc,%esp
f010f408:	ff 75 0c             	pushl  0xc(%ebp)
f010f40b:	e8 77 fa ff ff       	call   f010ee87 <sys_calculate_pages_tobe_removed_ready_exit>
f010f410:	83 c4 10             	add    $0x10,%esp
f010f413:	e9 cc 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f418:	e8 80 fa ff ff       	call   f010ee9d <sys_scarce_memory>
		return 0;
f010f41d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f422:	e9 bd 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32) a2, a3);
f010f427:	83 ec 04             	sub    $0x4,%esp
f010f42a:	ff 75 14             	pushl  0x14(%ebp)
f010f42d:	ff 75 10             	pushl  0x10(%ebp)
f010f430:	ff 75 0c             	pushl  0xc(%ebp)
f010f433:	e8 88 fb ff ff       	call   f010efc0 <sys_allocate_chunk>
f010f438:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f43b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f440:	e9 9f 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*) a1, a2);
f010f445:	8b 55 10             	mov    0x10(%ebp),%edx
f010f448:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f44b:	83 ec 08             	sub    $0x8,%esp
f010f44e:	52                   	push   %edx
f010f44f:	50                   	push   %eax
f010f450:	e8 6a f8 ff ff       	call   f010ecbf <__sys_allocate_page>
f010f455:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f458:	b8 00 00 00 00       	mov    $0x0,%eax
f010f45d:	e9 82 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*) a2, a3, (void*) a4, a5);
f010f462:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f465:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f468:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f46b:	8b 55 10             	mov    0x10(%ebp),%edx
f010f46e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f471:	83 ec 0c             	sub    $0xc,%esp
f010f474:	56                   	push   %esi
f010f475:	53                   	push   %ebx
f010f476:	51                   	push   %ecx
f010f477:	52                   	push   %edx
f010f478:	50                   	push   %eax
f010f479:	e8 5a f9 ff ff       	call   f010edd8 <__sys_map_frame>
f010f47e:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f481:	b8 00 00 00 00       	mov    $0x0,%eax
f010f486:	e9 59 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*) a2);
f010f48b:	8b 55 10             	mov    0x10(%ebp),%edx
f010f48e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f491:	83 ec 08             	sub    $0x8,%esp
f010f494:	52                   	push   %edx
f010f495:	50                   	push   %eax
f010f496:	e8 5a f9 ff ff       	call   f010edf5 <__sys_unmap_frame>
f010f49b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f49e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4a3:	e9 3c 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_cputc:
		sys_cputc((const char) a1);
f010f4a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ab:	0f be c0             	movsbl %al,%eax
f010f4ae:	83 ec 0c             	sub    $0xc,%esp
f010f4b1:	50                   	push   %eax
f010f4b2:	e8 89 f7 ff ff       	call   f010ec40 <sys_cputc>
f010f4b7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4ba:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4bf:	e9 20 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char) a1);
f010f4c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4c7:	0f be c0             	movsbl %al,%eax
f010f4ca:	83 ec 0c             	sub    $0xc,%esp
f010f4cd:	50                   	push   %eax
f010f4ce:	e8 d8 f9 ff ff       	call   f010eeab <sys_clearFFL>
f010f4d3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4d6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4db:	e9 04 03 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*) a1, a2, a3, (void*) a4);
f010f4e0:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f4e3:	8b 45 14             	mov    0x14(%ebp),%eax
f010f4e6:	0f b6 d0             	movzbl %al,%edx
f010f4e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ec:	51                   	push   %ecx
f010f4ed:	52                   	push   %edx
f010f4ee:	ff 75 10             	pushl  0x10(%ebp)
f010f4f1:	50                   	push   %eax
f010f4f2:	e8 fa fb ff ff       	call   f010f0f1 <sys_createSharedObject>
f010f4f7:	83 c4 10             	add    $0x10,%esp
f010f4fa:	e9 e5 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32) a1, (char*) a2, (void*) a3);
f010f4ff:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f502:	8b 55 10             	mov    0x10(%ebp),%edx
f010f505:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f508:	83 ec 04             	sub    $0x4,%esp
f010f50b:	51                   	push   %ecx
f010f50c:	52                   	push   %edx
f010f50d:	50                   	push   %eax
f010f50e:	e8 27 fc ff ff       	call   f010f13a <sys_getSharedObject>
f010f513:	83 c4 10             	add    $0x10,%esp
f010f516:	e9 c9 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32) a1, (void *) a2);
f010f51b:	8b 55 10             	mov    0x10(%ebp),%edx
f010f51e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f521:	83 ec 08             	sub    $0x8,%esp
f010f524:	52                   	push   %edx
f010f525:	50                   	push   %eax
f010f526:	e8 2b fc ff ff       	call   f010f156 <sys_freeSharedObject>
f010f52b:	83 c4 10             	add    $0x10,%esp
f010f52e:	e9 b1 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32) a1, (char*) a2);
f010f533:	8b 55 10             	mov    0x10(%ebp),%edx
f010f536:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f539:	83 ec 08             	sub    $0x8,%esp
f010f53c:	52                   	push   %edx
f010f53d:	50                   	push   %eax
f010f53e:	e8 de fb ff ff       	call   f010f121 <sys_getSizeOfSharedObject>
f010f543:	83 c4 10             	add    $0x10,%esp
f010f546:	e9 99 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_create_env:
		return sys_create_env((char*) a1, (uint32) a2, (uint32) a3, (uint32) a4);
f010f54b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f54e:	ff 75 18             	pushl  0x18(%ebp)
f010f551:	ff 75 14             	pushl  0x14(%ebp)
f010f554:	ff 75 10             	pushl  0x10(%ebp)
f010f557:	50                   	push   %eax
f010f558:	e8 22 fd ff ff       	call   f010f27f <sys_create_env>
f010f55d:	83 c4 10             	add    $0x10,%esp
f010f560:	e9 7f 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_run_env:
		sys_run_env((int32) a1);
f010f565:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f568:	83 ec 0c             	sub    $0xc,%esp
f010f56b:	50                   	push   %eax
f010f56c:	e8 4e fd ff ff       	call   f010f2bf <sys_run_env>
f010f571:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f574:	b8 00 00 00 00       	mov    $0x0,%eax
f010f579:	e9 66 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f57e:	e8 f9 fb ff ff       	call   f010f17c <sys_getenvindex>
f010f583:	e9 5c 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f588:	e8 e2 fb ff ff       	call   f010f16f <sys_getenvid>
f010f58d:	e9 52 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f592:	e8 35 fc ff ff       	call   f010f1cc <sys_getparentenvid>
f010f597:	e9 48 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f59c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f59f:	83 ec 0c             	sub    $0xc,%esp
f010f5a2:	50                   	push   %eax
f010f5a3:	e8 31 fc ff ff       	call   f010f1d9 <sys_destroy_env>
f010f5a8:	83 c4 10             	add    $0x10,%esp
f010f5ab:	e9 34 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f5b0:	e8 bc fc ff ff       	call   f010f271 <sys_exit_env>
		return 0;
f010f5b5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5ba:	e9 25 02 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_get_virtual_time: {
		struct uint64 res = sys_get_virtual_time();
f010f5bf:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010f5c2:	83 ec 0c             	sub    $0xc,%esp
f010f5c5:	50                   	push   %eax
f010f5c6:	e8 0c fd ff ff       	call   f010f2d7 <sys_get_virtual_time>
f010f5cb:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*) a1);
f010f5ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*) a2);
f010f5d4:	8b 45 10             	mov    0x10(%ebp),%eax
f010f5d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010f5da:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f5dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f5e0:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f5e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f5e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f5e8:	89 10                	mov    %edx,(%eax)
		return 0;
f010f5ea:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5ef:	e9 f0 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f5f4:	83 ec 04             	sub    $0x4,%esp
f010f5f7:	ff 75 14             	pushl  0x14(%ebp)
f010f5fa:	ff 75 10             	pushl  0x10(%ebp)
f010f5fd:	ff 75 0c             	pushl  0xc(%ebp)
f010f600:	e8 de f9 ff ff       	call   f010efe3 <sys_move_user_mem>
f010f605:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f608:	b8 00 00 00 00       	mov    $0x0,%eax
f010f60d:	e9 d2 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f612:	e8 ef fc ff ff       	call   f010f306 <sys_rcr2>
f010f617:	e9 c8 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f61c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f61f:	0f b6 c0             	movzbl %al,%eax
f010f622:	83 ec 0c             	sub    $0xc,%esp
f010f625:	50                   	push   %eax
f010f626:	e8 ed fc ff ff       	call   f010f318 <sys_bypassPageFault>
f010f62b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f62e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f633:	e9 ac 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_rsttst:
		rsttst();
f010f638:	e8 74 0c 01 00       	call   f01202b1 <rsttst>
		return 0;
f010f63d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f642:	e9 9d 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
	case SYS_inctst:
		inctst();
f010f647:	e8 ad 0c 01 00       	call   f01202f9 <inctst>
		return 0;
f010f64c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f651:	e9 8e 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
	case SYS_chktst:
		chktst(a1);
f010f656:	83 ec 0c             	sub    $0xc,%esp
f010f659:	ff 75 0c             	pushl  0xc(%ebp)
f010f65c:	e8 da 0d 01 00       	call   f012043b <chktst>
f010f661:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f664:	b8 00 00 00 00       	mov    $0x0,%eax
f010f669:	e9 76 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
	case SYS_gettst:
		return gettst();
f010f66e:	e8 ba 0c 01 00       	call   f012032d <gettst>
f010f673:	e9 6c 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
	case SYS_testNum:
		tst(a1, a2, a3, (char) a4, a5);
f010f678:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f67b:	8b 45 18             	mov    0x18(%ebp),%eax
f010f67e:	0f be c0             	movsbl %al,%eax
f010f681:	83 ec 0c             	sub    $0xc,%esp
f010f684:	52                   	push   %edx
f010f685:	50                   	push   %eax
f010f686:	ff 75 14             	pushl  0x14(%ebp)
f010f689:	ff 75 10             	pushl  0x10(%ebp)
f010f68c:	ff 75 0c             	pushl  0xc(%ebp)
f010f68f:	e8 a3 0c 01 00       	call   f0120337 <tst>
f010f694:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f697:	b8 00 00 00 00       	mov    $0x0,%eax
f010f69c:	e9 43 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f6a1:	e8 5d f9 ff ff       	call   f010f003 <sys_get_heap_strategy>
f010f6a6:	e9 39 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f6ab:	83 ec 0c             	sub    $0xc,%esp
f010f6ae:	ff 75 0c             	pushl  0xc(%ebp)
f010f6b1:	e8 57 f9 ff ff       	call   f010f00d <sys_set_uheap_strategy>
f010f6b6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f6b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f6be:	e9 21 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*) a1, (uint32*) a2, (int) a3,
f010f6c3:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f6c6:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f6c9:	8b 55 10             	mov    0x10(%ebp),%edx
f010f6cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6cf:	53                   	push   %ebx
f010f6d0:	51                   	push   %ecx
f010f6d1:	52                   	push   %edx
f010f6d2:	50                   	push   %eax
f010f6d3:	e8 95 23 00 00       	call   f0111a6d <sys_check_LRU_lists>
f010f6d8:	83 c4 10             	add    $0x10,%esp
f010f6db:	e9 04 01 00 00       	jmp    f010f7e4 <syscall+0x4b5>
				(int) a4);

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*) a1, (int) a2);
f010f6e0:	8b 55 10             	mov    0x10(%ebp),%edx
f010f6e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6e6:	83 ec 08             	sub    $0x8,%esp
f010f6e9:	52                   	push   %edx
f010f6ea:	50                   	push   %eax
f010f6eb:	e8 3f 25 00 00       	call   f0111c2f <sys_check_LRU_lists_free>
f010f6f0:	83 c4 10             	add    $0x10,%esp
f010f6f3:	e9 ec 00 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*) a1, (int) a2, (uint32) a3, (bool) a4);
f010f6f8:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f6fb:	8b 55 10             	mov    0x10(%ebp),%edx
f010f6fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f701:	51                   	push   %ecx
f010f702:	ff 75 14             	pushl  0x14(%ebp)
f010f705:	52                   	push   %edx
f010f706:	50                   	push   %eax
f010f707:	e8 b0 26 00 00       	call   f0111dbc <sys_check_WS_list>
f010f70c:	83 c4 10             	add    $0x10,%esp
f010f70f:	e9 d0 00 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case SYS_utilities:
		sys_utilities((char*) a1, (int) a2);
f010f714:	8b 55 10             	mov    0x10(%ebp),%edx
f010f717:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f71a:	83 ec 08             	sub    $0x8,%esp
f010f71d:	52                   	push   %edx
f010f71e:	50                   	push   %eax
f010f71f:	e8 18 0f 01 00       	call   f012063c <sys_utilities>
f010f724:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f727:	b8 00 00 00 00       	mov    $0x0,%eax
f010f72c:	e9 b3 00 00 00       	jmp    f010f7e4 <syscall+0x4b5>

	case NSYSCALLS:
		return -E_INVAL;
f010f731:	b8 03 00 00 00       	mov    $0x3,%eax
f010f736:	e9 a9 00 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_sbrk:

		return (uint32) sys_sbrk((int) a1);
f010f73b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f73e:	83 ec 0c             	sub    $0xc,%esp
f010f741:	50                   	push   %eax
f010f742:	e8 da b8 ff ff       	call   f010b021 <sys_sbrk>
f010f747:	83 c4 10             	add    $0x10,%esp
f010f74a:	e9 95 00 00 00       	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_free_user_mem:
		sys_free_user_mem(a1, a2);
f010f74f:	83 ec 08             	sub    $0x8,%esp
f010f752:	ff 75 10             	pushl  0x10(%ebp)
f010f755:	ff 75 0c             	pushl  0xc(%ebp)
f010f758:	e8 bb f7 ff ff       	call   f010ef18 <sys_free_user_mem>
f010f75d:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f760:	b8 00 00 00 00       	mov    $0x0,%eax
f010f765:	eb 7d                	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_allocate_user_mem:
		sys_allocate_user_mem(a1, a2);
f010f767:	83 ec 08             	sub    $0x8,%esp
f010f76a:	ff 75 10             	pushl  0x10(%ebp)
f010f76d:	ff 75 0c             	pushl  0xc(%ebp)
f010f770:	e8 05 f8 ff ff       	call   f010ef7a <sys_allocate_user_mem>
f010f775:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f778:	b8 00 00 00 00       	mov    $0x0,%eax
f010f77d:	eb 65                	jmp    f010f7e4 <syscall+0x4b5>
		break;

	case SYS_init_queue:
		sys_init_queue((struct Env_Queue *) a1);
f010f77f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f782:	83 ec 0c             	sub    $0xc,%esp
f010f785:	50                   	push   %eax
f010f786:	e8 aa f8 ff ff       	call   f010f035 <sys_init_queue>
f010f78b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f78e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f793:	eb 4f                	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_block_process:
		sys_block_process((struct Env_Queue *) a1, (uint32*) a2);
f010f795:	8b 55 10             	mov    0x10(%ebp),%edx
f010f798:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f79b:	83 ec 08             	sub    $0x8,%esp
f010f79e:	52                   	push   %edx
f010f79f:	50                   	push   %eax
f010f7a0:	e8 a7 f8 ff ff       	call   f010f04c <sys_block_process>
f010f7a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f7a8:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7ad:	eb 35                	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_unblock_process:
		sys_unblock_process((struct Env_Queue *) a1);
f010f7af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7b2:	83 ec 0c             	sub    $0xc,%esp
f010f7b5:	50                   	push   %eax
f010f7b6:	e8 e8 f8 ff ff       	call   f010f0a3 <sys_unblock_process>
f010f7bb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f7be:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7c3:	eb 1f                	jmp    f010f7e4 <syscall+0x4b5>
		break;
	case SYS_env_set_priority://EDITED
	        sys_env_set_priority(a1, a2);
f010f7c5:	8b 55 10             	mov    0x10(%ebp),%edx
f010f7c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7cb:	83 ec 08             	sub    $0x8,%esp
f010f7ce:	52                   	push   %edx
f010f7cf:	50                   	push   %eax
f010f7d0:	e8 46 f8 ff ff       	call   f010f01b <sys_env_set_priority>
f010f7d5:	83 c4 10             	add    $0x10,%esp
	        return 0;
f010f7d8:	b8 00 00 00 00       	mov    $0x0,%eax
f010f7dd:	eb 05                	jmp    f010f7e4 <syscall+0x4b5>
	        break;
	}
	//panic("syscall not implemented");

	return -E_INVAL;
f010f7df:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f7e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f7e7:	5b                   	pop    %ebx
f010f7e8:	5e                   	pop    %esi
f010f7e9:	5d                   	pop    %ebp
f010f7ea:	c3                   	ret    

f010f7eb <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f7eb:	55                   	push   %ebp
f010f7ec:	89 e5                	mov    %esp,%ebp
f010f7ee:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f7f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7f4:	8b 00                	mov    (%eax),%eax
f010f7f6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f7f9:	8b 45 10             	mov    0x10(%ebp),%eax
f010f7fc:	8b 00                	mov    (%eax),%eax
f010f7fe:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f801:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f808:	e9 ca 00 00 00       	jmp    f010f8d7 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f80d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f810:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f813:	01 d0                	add    %edx,%eax
f010f815:	89 c2                	mov    %eax,%edx
f010f817:	c1 ea 1f             	shr    $0x1f,%edx
f010f81a:	01 d0                	add    %edx,%eax
f010f81c:	d1 f8                	sar    %eax
f010f81e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f821:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f824:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f827:	eb 03                	jmp    f010f82c <stab_binsearch+0x41>
			m--;
f010f829:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f82c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f82f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f832:	7c 1e                	jl     f010f852 <stab_binsearch+0x67>
f010f834:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f837:	89 d0                	mov    %edx,%eax
f010f839:	01 c0                	add    %eax,%eax
f010f83b:	01 d0                	add    %edx,%eax
f010f83d:	c1 e0 02             	shl    $0x2,%eax
f010f840:	89 c2                	mov    %eax,%edx
f010f842:	8b 45 08             	mov    0x8(%ebp),%eax
f010f845:	01 d0                	add    %edx,%eax
f010f847:	8a 40 04             	mov    0x4(%eax),%al
f010f84a:	0f b6 c0             	movzbl %al,%eax
f010f84d:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f850:	75 d7                	jne    f010f829 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f852:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f855:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f858:	7d 09                	jge    f010f863 <stab_binsearch+0x78>
			l = true_m + 1;
f010f85a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f85d:	40                   	inc    %eax
f010f85e:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f861:	eb 74                	jmp    f010f8d7 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f863:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f86a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f86d:	89 d0                	mov    %edx,%eax
f010f86f:	01 c0                	add    %eax,%eax
f010f871:	01 d0                	add    %edx,%eax
f010f873:	c1 e0 02             	shl    $0x2,%eax
f010f876:	89 c2                	mov    %eax,%edx
f010f878:	8b 45 08             	mov    0x8(%ebp),%eax
f010f87b:	01 d0                	add    %edx,%eax
f010f87d:	8b 40 08             	mov    0x8(%eax),%eax
f010f880:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f883:	73 11                	jae    f010f896 <stab_binsearch+0xab>
			*region_left = m;
f010f885:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f888:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f88b:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f88d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f890:	40                   	inc    %eax
f010f891:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f894:	eb 41                	jmp    f010f8d7 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f896:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f899:	89 d0                	mov    %edx,%eax
f010f89b:	01 c0                	add    %eax,%eax
f010f89d:	01 d0                	add    %edx,%eax
f010f89f:	c1 e0 02             	shl    $0x2,%eax
f010f8a2:	89 c2                	mov    %eax,%edx
f010f8a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8a7:	01 d0                	add    %edx,%eax
f010f8a9:	8b 40 08             	mov    0x8(%eax),%eax
f010f8ac:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f8af:	76 14                	jbe    f010f8c5 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f8b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f8b4:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f8b7:	8b 45 10             	mov    0x10(%ebp),%eax
f010f8ba:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f8bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f8bf:	48                   	dec    %eax
f010f8c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f8c3:	eb 12                	jmp    f010f8d7 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f8c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f8cb:	89 10                	mov    %edx,(%eax)
			l = m;
f010f8cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f8d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f8d3:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f8d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f8da:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f8dd:	0f 8e 2a ff ff ff    	jle    f010f80d <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f8e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f8e7:	75 0f                	jne    f010f8f8 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8ec:	8b 00                	mov    (%eax),%eax
f010f8ee:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f8f1:	8b 45 10             	mov    0x10(%ebp),%eax
f010f8f4:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f8f6:	eb 3d                	jmp    f010f935 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f8f8:	8b 45 10             	mov    0x10(%ebp),%eax
f010f8fb:	8b 00                	mov    (%eax),%eax
f010f8fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f900:	eb 03                	jmp    f010f905 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f902:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f905:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f908:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f90a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f90d:	7d 1e                	jge    f010f92d <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f90f:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f912:	89 d0                	mov    %edx,%eax
f010f914:	01 c0                	add    %eax,%eax
f010f916:	01 d0                	add    %edx,%eax
f010f918:	c1 e0 02             	shl    $0x2,%eax
f010f91b:	89 c2                	mov    %eax,%edx
f010f91d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f920:	01 d0                	add    %edx,%eax
f010f922:	8a 40 04             	mov    0x4(%eax),%al
f010f925:	0f b6 c0             	movzbl %al,%eax
f010f928:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f92b:	75 d5                	jne    f010f902 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f92d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f930:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f933:	89 10                	mov    %edx,(%eax)
	}
}
f010f935:	90                   	nop
f010f936:	c9                   	leave  
f010f937:	c3                   	ret    

f010f938 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f938:	55                   	push   %ebp
f010f939:	89 e5                	mov    %esp,%ebp
f010f93b:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f93e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f941:	c7 00 58 9a 12 f0    	movl   $0xf0129a58,(%eax)
	info->eip_line = 0;
f010f947:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f94a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f951:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f954:	c7 40 08 58 9a 12 f0 	movl   $0xf0129a58,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f95b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f95e:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f965:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f968:	8b 55 08             	mov    0x8(%ebp),%edx
f010f96b:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f96e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f971:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f978:	8b 45 08             	mov    0x8(%ebp),%eax
f010f97b:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f980:	76 1e                	jbe    f010f9a0 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f982:	c7 45 f4 74 3e 13 f0 	movl   $0xf0133e74,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f989:	c7 45 f0 d4 8f 16 f0 	movl   $0xf0168fd4,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f990:	c7 45 ec d5 8f 16 f0 	movl   $0xf0168fd5,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f997:	c7 45 e8 49 af 17 f0 	movl   $0xf017af49,-0x18(%ebp)
f010f99e:	eb 2a                	jmp    f010f9ca <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f9a0:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f9a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9aa:	8b 00                	mov    (%eax),%eax
f010f9ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f9af:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9b2:	8b 40 04             	mov    0x4(%eax),%eax
f010f9b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f9b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9bb:	8b 40 08             	mov    0x8(%eax),%eax
f010f9be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f9c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f9c4:	8b 40 0c             	mov    0xc(%eax),%eax
f010f9c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f9ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f9cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f9d0:	76 0a                	jbe    f010f9dc <debuginfo_eip+0xa4>
f010f9d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f9d5:	48                   	dec    %eax
f010f9d6:	8a 00                	mov    (%eax),%al
f010f9d8:	84 c0                	test   %al,%al
f010f9da:	74 0a                	je     f010f9e6 <debuginfo_eip+0xae>
		return -1;
f010f9dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f9e1:	e9 01 02 00 00       	jmp    f010fbe7 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f9e6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f9ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f9f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f9f3:	29 c2                	sub    %eax,%edx
f010f9f5:	89 d0                	mov    %edx,%eax
f010f9f7:	c1 f8 02             	sar    $0x2,%eax
f010f9fa:	89 c2                	mov    %eax,%edx
f010f9fc:	89 d0                	mov    %edx,%eax
f010f9fe:	c1 e0 02             	shl    $0x2,%eax
f010fa01:	01 d0                	add    %edx,%eax
f010fa03:	c1 e0 02             	shl    $0x2,%eax
f010fa06:	01 d0                	add    %edx,%eax
f010fa08:	c1 e0 02             	shl    $0x2,%eax
f010fa0b:	01 d0                	add    %edx,%eax
f010fa0d:	89 c1                	mov    %eax,%ecx
f010fa0f:	c1 e1 08             	shl    $0x8,%ecx
f010fa12:	01 c8                	add    %ecx,%eax
f010fa14:	89 c1                	mov    %eax,%ecx
f010fa16:	c1 e1 10             	shl    $0x10,%ecx
f010fa19:	01 c8                	add    %ecx,%eax
f010fa1b:	01 c0                	add    %eax,%eax
f010fa1d:	01 d0                	add    %edx,%eax
f010fa1f:	48                   	dec    %eax
f010fa20:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010fa23:	ff 75 08             	pushl  0x8(%ebp)
f010fa26:	6a 64                	push   $0x64
f010fa28:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010fa2b:	50                   	push   %eax
f010fa2c:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010fa2f:	50                   	push   %eax
f010fa30:	ff 75 f4             	pushl  -0xc(%ebp)
f010fa33:	e8 b3 fd ff ff       	call   f010f7eb <stab_binsearch>
f010fa38:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010fa3b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fa3e:	85 c0                	test   %eax,%eax
f010fa40:	75 0a                	jne    f010fa4c <debuginfo_eip+0x114>
		return -1;
f010fa42:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010fa47:	e9 9b 01 00 00       	jmp    f010fbe7 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010fa4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fa4f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010fa52:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fa55:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010fa58:	ff 75 08             	pushl  0x8(%ebp)
f010fa5b:	6a 24                	push   $0x24
f010fa5d:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010fa60:	50                   	push   %eax
f010fa61:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010fa64:	50                   	push   %eax
f010fa65:	ff 75 f4             	pushl  -0xc(%ebp)
f010fa68:	e8 7e fd ff ff       	call   f010f7eb <stab_binsearch>
f010fa6d:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010fa70:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010fa73:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fa76:	39 c2                	cmp    %eax,%edx
f010fa78:	0f 8f 86 00 00 00    	jg     f010fb04 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010fa7e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fa81:	89 c2                	mov    %eax,%edx
f010fa83:	89 d0                	mov    %edx,%eax
f010fa85:	01 c0                	add    %eax,%eax
f010fa87:	01 d0                	add    %edx,%eax
f010fa89:	c1 e0 02             	shl    $0x2,%eax
f010fa8c:	89 c2                	mov    %eax,%edx
f010fa8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fa91:	01 d0                	add    %edx,%eax
f010fa93:	8b 00                	mov    (%eax),%eax
f010fa95:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010fa98:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fa9b:	29 d1                	sub    %edx,%ecx
f010fa9d:	89 ca                	mov    %ecx,%edx
f010fa9f:	39 d0                	cmp    %edx,%eax
f010faa1:	73 22                	jae    f010fac5 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010faa3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010faa6:	89 c2                	mov    %eax,%edx
f010faa8:	89 d0                	mov    %edx,%eax
f010faaa:	01 c0                	add    %eax,%eax
f010faac:	01 d0                	add    %edx,%eax
f010faae:	c1 e0 02             	shl    $0x2,%eax
f010fab1:	89 c2                	mov    %eax,%edx
f010fab3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fab6:	01 d0                	add    %edx,%eax
f010fab8:	8b 10                	mov    (%eax),%edx
f010faba:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fabd:	01 c2                	add    %eax,%edx
f010fabf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fac2:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010fac5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fac8:	89 c2                	mov    %eax,%edx
f010faca:	89 d0                	mov    %edx,%eax
f010facc:	01 c0                	add    %eax,%eax
f010face:	01 d0                	add    %edx,%eax
f010fad0:	c1 e0 02             	shl    $0x2,%eax
f010fad3:	89 c2                	mov    %eax,%edx
f010fad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fad8:	01 d0                	add    %edx,%eax
f010fada:	8b 50 08             	mov    0x8(%eax),%edx
f010fadd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fae0:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010fae3:	8b 55 08             	mov    0x8(%ebp),%edx
f010fae6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fae9:	8b 40 10             	mov    0x10(%eax),%eax
f010faec:	29 c2                	sub    %eax,%edx
f010faee:	89 d0                	mov    %edx,%eax
f010faf0:	c1 f8 02             	sar    $0x2,%eax
f010faf3:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010faf6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010faf9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010fafc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010faff:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010fb02:	eb 15                	jmp    f010fb19 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010fb04:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb07:	8b 55 08             	mov    0x8(%ebp),%edx
f010fb0a:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010fb0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fb10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010fb13:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb16:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010fb19:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb1c:	8b 40 08             	mov    0x8(%eax),%eax
f010fb1f:	83 ec 08             	sub    $0x8,%esp
f010fb22:	6a 3a                	push   $0x3a
f010fb24:	50                   	push   %eax
f010fb25:	e8 d3 25 01 00       	call   f01220fd <strfind>
f010fb2a:	83 c4 10             	add    $0x10,%esp
f010fb2d:	89 c2                	mov    %eax,%edx
f010fb2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb32:	8b 40 08             	mov    0x8(%eax),%eax
f010fb35:	29 c2                	sub    %eax,%edx
f010fb37:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb3a:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010fb3d:	eb 03                	jmp    f010fb42 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010fb3f:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010fb42:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fb45:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010fb48:	7c 4e                	jl     f010fb98 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010fb4a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010fb4d:	89 d0                	mov    %edx,%eax
f010fb4f:	01 c0                	add    %eax,%eax
f010fb51:	01 d0                	add    %edx,%eax
f010fb53:	c1 e0 02             	shl    $0x2,%eax
f010fb56:	89 c2                	mov    %eax,%edx
f010fb58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fb5b:	01 d0                	add    %edx,%eax
f010fb5d:	8a 40 04             	mov    0x4(%eax),%al
f010fb60:	3c 84                	cmp    $0x84,%al
f010fb62:	74 34                	je     f010fb98 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010fb64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010fb67:	89 d0                	mov    %edx,%eax
f010fb69:	01 c0                	add    %eax,%eax
f010fb6b:	01 d0                	add    %edx,%eax
f010fb6d:	c1 e0 02             	shl    $0x2,%eax
f010fb70:	89 c2                	mov    %eax,%edx
f010fb72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fb75:	01 d0                	add    %edx,%eax
f010fb77:	8a 40 04             	mov    0x4(%eax),%al
f010fb7a:	3c 64                	cmp    $0x64,%al
f010fb7c:	75 c1                	jne    f010fb3f <debuginfo_eip+0x207>
f010fb7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010fb81:	89 d0                	mov    %edx,%eax
f010fb83:	01 c0                	add    %eax,%eax
f010fb85:	01 d0                	add    %edx,%eax
f010fb87:	c1 e0 02             	shl    $0x2,%eax
f010fb8a:	89 c2                	mov    %eax,%edx
f010fb8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fb8f:	01 d0                	add    %edx,%eax
f010fb91:	8b 40 08             	mov    0x8(%eax),%eax
f010fb94:	85 c0                	test   %eax,%eax
f010fb96:	74 a7                	je     f010fb3f <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010fb98:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010fb9b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010fb9e:	7c 42                	jl     f010fbe2 <debuginfo_eip+0x2aa>
f010fba0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010fba3:	89 d0                	mov    %edx,%eax
f010fba5:	01 c0                	add    %eax,%eax
f010fba7:	01 d0                	add    %edx,%eax
f010fba9:	c1 e0 02             	shl    $0x2,%eax
f010fbac:	89 c2                	mov    %eax,%edx
f010fbae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fbb1:	01 d0                	add    %edx,%eax
f010fbb3:	8b 00                	mov    (%eax),%eax
f010fbb5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010fbb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fbbb:	29 d1                	sub    %edx,%ecx
f010fbbd:	89 ca                	mov    %ecx,%edx
f010fbbf:	39 d0                	cmp    %edx,%eax
f010fbc1:	73 1f                	jae    f010fbe2 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010fbc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010fbc6:	89 d0                	mov    %edx,%eax
f010fbc8:	01 c0                	add    %eax,%eax
f010fbca:	01 d0                	add    %edx,%eax
f010fbcc:	c1 e0 02             	shl    $0x2,%eax
f010fbcf:	89 c2                	mov    %eax,%edx
f010fbd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fbd4:	01 d0                	add    %edx,%eax
f010fbd6:	8b 10                	mov    (%eax),%edx
f010fbd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fbdb:	01 c2                	add    %eax,%edx
f010fbdd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fbe0:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010fbe2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fbe7:	c9                   	leave  
f010fbe8:	c3                   	ret    

f010fbe9 <setPageReplacmentAlgorithmLRU>:

//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE) {
f010fbe9:	55                   	push   %ebp
f010fbea:	89 e5                	mov    %esp,%ebp
f010fbec:	83 ec 08             	sub    $0x8,%esp
	assert(
f010fbef:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010fbf3:	74 1c                	je     f010fc11 <setPageReplacmentAlgorithmLRU+0x28>
f010fbf5:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010fbf9:	74 16                	je     f010fc11 <setPageReplacmentAlgorithmLRU+0x28>
f010fbfb:	68 64 9a 12 f0       	push   $0xf0129a64
f010fc00:	68 ae 9a 12 f0       	push   $0xf0129aae
f010fc05:	6a 19                	push   $0x19
f010fc07:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010fc0c:	e8 28 07 ff ff       	call   f0100339 <_panic>
			LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
	_PageRepAlgoType = LRU_TYPE;
f010fc11:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc14:	a3 48 5f 74 f0       	mov    %eax,0xf0745f48
}
f010fc19:	90                   	nop
f010fc1a:	c9                   	leave  
f010fc1b:	c3                   	ret    

f010fc1c <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK() {
f010fc1c:	55                   	push   %ebp
f010fc1d:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_CLOCK;
f010fc1f:	c7 05 48 5f 74 f0 03 	movl   $0x3,0xf0745f48
f010fc26:	00 00 00 
}
f010fc29:	90                   	nop
f010fc2a:	5d                   	pop    %ebp
f010fc2b:	c3                   	ret    

f010fc2c <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO() {
f010fc2c:	55                   	push   %ebp
f010fc2d:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_FIFO;
f010fc2f:	c7 05 48 5f 74 f0 04 	movl   $0x4,0xf0745f48
f010fc36:	00 00 00 
}
f010fc39:	90                   	nop
f010fc3a:	5d                   	pop    %ebp
f010fc3b:	c3                   	ret    

f010fc3c <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK() {
f010fc3c:	55                   	push   %ebp
f010fc3d:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;
f010fc3f:	c7 05 48 5f 74 f0 05 	movl   $0x5,0xf0745f48
f010fc46:	00 00 00 
}
f010fc49:	90                   	nop
f010fc4a:	5d                   	pop    %ebp
f010fc4b:	c3                   	ret    

f010fc4c <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/void setPageReplacmentAlgorithmDynamicLocal() {
f010fc4c:	55                   	push   %ebp
f010fc4d:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;
f010fc4f:	c7 05 48 5f 74 f0 07 	movl   $0x7,0xf0745f48
f010fc56:	00 00 00 
}
f010fc59:	90                   	nop
f010fc5a:	5d                   	pop    %ebp
f010fc5b:	c3                   	ret    

f010fc5c <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps) {
f010fc5c:	55                   	push   %ebp
f010fc5d:	89 e5                	mov    %esp,%ebp
	_PageRepAlgoType = PG_REP_NchanceCLOCK;
f010fc5f:	c7 05 48 5f 74 f0 06 	movl   $0x6,0xf0745f48
f010fc66:	00 00 00 
	page_WS_max_sweeps = PageWSMaxSweeps;
f010fc69:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc6c:	a3 94 58 74 f0       	mov    %eax,0xf0745894
}
f010fc71:	90                   	nop
f010fc72:	5d                   	pop    %ebp
f010fc73:	c3                   	ret    

f010fc74 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE) {
f010fc74:	55                   	push   %ebp
f010fc75:	89 e5                	mov    %esp,%ebp
	return _PageRepAlgoType == LRU_TYPE ? 1 : 0;
f010fc77:	8b 15 48 5f 74 f0    	mov    0xf0745f48,%edx
f010fc7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc80:	39 c2                	cmp    %eax,%edx
f010fc82:	0f 94 c0             	sete   %al
f010fc85:	0f b6 c0             	movzbl %al,%eax
}
f010fc88:	5d                   	pop    %ebp
f010fc89:	c3                   	ret    

f010fc8a <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK() {
f010fc8a:	55                   	push   %ebp
f010fc8b:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_CLOCK)
f010fc8d:	a1 48 5f 74 f0       	mov    0xf0745f48,%eax
f010fc92:	83 f8 03             	cmp    $0x3,%eax
f010fc95:	75 07                	jne    f010fc9e <isPageReplacmentAlgorithmCLOCK+0x14>
		return 1;
f010fc97:	b8 01 00 00 00       	mov    $0x1,%eax
f010fc9c:	eb 05                	jmp    f010fca3 <isPageReplacmentAlgorithmCLOCK+0x19>
	return 0;
f010fc9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fca3:	5d                   	pop    %ebp
f010fca4:	c3                   	ret    

f010fca5 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO() {
f010fca5:	55                   	push   %ebp
f010fca6:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_FIFO)
f010fca8:	a1 48 5f 74 f0       	mov    0xf0745f48,%eax
f010fcad:	83 f8 04             	cmp    $0x4,%eax
f010fcb0:	75 07                	jne    f010fcb9 <isPageReplacmentAlgorithmFIFO+0x14>
		return 1;
f010fcb2:	b8 01 00 00 00       	mov    $0x1,%eax
f010fcb7:	eb 05                	jmp    f010fcbe <isPageReplacmentAlgorithmFIFO+0x19>
	return 0;
f010fcb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fcbe:	5d                   	pop    %ebp
f010fcbf:	c3                   	ret    

f010fcc0 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK() {
f010fcc0:	55                   	push   %ebp
f010fcc1:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_MODIFIEDCLOCK)
f010fcc3:	a1 48 5f 74 f0       	mov    0xf0745f48,%eax
f010fcc8:	83 f8 05             	cmp    $0x5,%eax
f010fccb:	75 07                	jne    f010fcd4 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
		return 1;
f010fccd:	b8 01 00 00 00       	mov    $0x1,%eax
f010fcd2:	eb 05                	jmp    f010fcd9 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
	return 0;
f010fcd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fcd9:	5d                   	pop    %ebp
f010fcda:	c3                   	ret    

f010fcdb <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/uint32 isPageReplacmentAlgorithmDynamicLocal() {
f010fcdb:	55                   	push   %ebp
f010fcdc:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL)
f010fcde:	a1 48 5f 74 f0       	mov    0xf0745f48,%eax
f010fce3:	83 f8 07             	cmp    $0x7,%eax
f010fce6:	75 07                	jne    f010fcef <isPageReplacmentAlgorithmDynamicLocal+0x14>
		return 1;
f010fce8:	b8 01 00 00 00       	mov    $0x1,%eax
f010fced:	eb 05                	jmp    f010fcf4 <isPageReplacmentAlgorithmDynamicLocal+0x19>
	return 0;
f010fcef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fcf4:	5d                   	pop    %ebp
f010fcf5:	c3                   	ret    

f010fcf6 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/uint32 isPageReplacmentAlgorithmNchanceCLOCK() {
f010fcf6:	55                   	push   %ebp
f010fcf7:	89 e5                	mov    %esp,%ebp
	if (_PageRepAlgoType == PG_REP_NchanceCLOCK)
f010fcf9:	a1 48 5f 74 f0       	mov    0xf0745f48,%eax
f010fcfe:	83 f8 06             	cmp    $0x6,%eax
f010fd01:	75 07                	jne    f010fd0a <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
		return 1;
f010fd03:	b8 01 00 00 00       	mov    $0x1,%eax
f010fd08:	eb 05                	jmp    f010fd0f <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
	return 0;
f010fd0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fd0f:	5d                   	pop    %ebp
f010fd10:	c3                   	ret    

f010fd11 <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt) {
f010fd11:	55                   	push   %ebp
f010fd12:	89 e5                	mov    %esp,%ebp
	_EnableModifiedBuffer = enableIt;
f010fd14:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd17:	a3 f8 5c 74 f0       	mov    %eax,0xf0745cf8
}
f010fd1c:	90                   	nop
f010fd1d:	5d                   	pop    %ebp
f010fd1e:	c3                   	ret    

f010fd1f <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled() {
f010fd1f:	55                   	push   %ebp
f010fd20:	89 e5                	mov    %esp,%ebp
	return _EnableModifiedBuffer;
f010fd22:	a1 f8 5c 74 f0       	mov    0xf0745cf8,%eax
}
f010fd27:	5d                   	pop    %ebp
f010fd28:	c3                   	ret    

f010fd29 <enableBuffering>:

void enableBuffering(uint32 enableIt) {
f010fd29:	55                   	push   %ebp
f010fd2a:	89 e5                	mov    %esp,%ebp
	_EnableBuffering = enableIt;
f010fd2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd2f:	a3 b4 5f 74 f0       	mov    %eax,0xf0745fb4
}
f010fd34:	90                   	nop
f010fd35:	5d                   	pop    %ebp
f010fd36:	c3                   	ret    

f010fd37 <isBufferingEnabled>:
uint8 isBufferingEnabled() {
f010fd37:	55                   	push   %ebp
f010fd38:	89 e5                	mov    %esp,%ebp
	return _EnableBuffering;
f010fd3a:	a1 b4 5f 74 f0       	mov    0xf0745fb4,%eax
}
f010fd3f:	5d                   	pop    %ebp
f010fd40:	c3                   	ret    

f010fd41 <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) {
f010fd41:	55                   	push   %ebp
f010fd42:	89 e5                	mov    %esp,%ebp
	_ModifiedBufferLength = length;
f010fd44:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd47:	a3 50 60 74 f0       	mov    %eax,0xf0746050
}
f010fd4c:	90                   	nop
f010fd4d:	5d                   	pop    %ebp
f010fd4e:	c3                   	ret    

f010fd4f <getModifiedBufferLength>:
uint32 getModifiedBufferLength() {
f010fd4f:	55                   	push   %ebp
f010fd50:	89 e5                	mov    %esp,%ebp
	return _ModifiedBufferLength;
f010fd52:	a1 50 60 74 f0       	mov    0xf0746050,%eax
}
f010fd57:	5d                   	pop    %ebp
f010fd58:	c3                   	ret    

f010fd59 <fault_handler>:
uint32 last_fault_va = 0;
uint32 before_last_fault_va = 0;
int8 num_repeated_fault = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf) {
f010fd59:	55                   	push   %ebp
f010fd5a:	89 e5                	mov    %esp,%ebp
f010fd5c:	83 ec 38             	sub    $0x38,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010fd5f:	0f 20 d0             	mov    %cr2,%eax
f010fd62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	return val;
f010fd65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010fd68:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010fd6b:	e8 d4 c1 ff ff       	call   f010bf44 <get_cpu_proc>
f010fd70:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env) {
f010fd73:	a1 8c d5 71 f0       	mov    0xf071d58c,%eax
f010fd78:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fd7b:	75 53                	jne    f010fdd0 <fault_handler+0x77>
f010fd7d:	a1 98 d5 71 f0       	mov    0xf071d598,%eax
f010fd82:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fd85:	75 49                	jne    f010fdd0 <fault_handler+0x77>
		num_repeated_fault++;
f010fd87:	a0 94 d5 71 f0       	mov    0xf071d594,%al
f010fd8c:	40                   	inc    %eax
f010fd8d:	a2 94 d5 71 f0       	mov    %al,0xf071d594
		if (num_repeated_fault == 3) {
f010fd92:	a0 94 d5 71 f0       	mov    0xf071d594,%al
f010fd97:	3c 03                	cmp    $0x3,%al
f010fd99:	75 50                	jne    f010fdeb <fault_handler+0x92>
			print_trapframe(tf);
f010fd9b:	83 ec 0c             	sub    $0xc,%esp
f010fd9e:	ff 75 08             	pushl  0x8(%ebp)
f010fda1:	e8 1d e8 ff ff       	call   f010e5c3 <print_trapframe>
f010fda6:	83 c4 10             	add    $0x10,%esp
			panic(
f010fda9:	8b 15 88 d5 71 f0    	mov    0xf071d588,%edx
f010fdaf:	a1 90 d5 71 f0       	mov    0xf071d590,%eax
f010fdb4:	83 ec 08             	sub    $0x8,%esp
f010fdb7:	ff 75 ec             	pushl  -0x14(%ebp)
f010fdba:	52                   	push   %edx
f010fdbb:	50                   	push   %eax
f010fdbc:	68 e0 9a 12 f0       	push   $0xf0129ae0
f010fdc1:	68 83 00 00 00       	push   $0x83
f010fdc6:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010fdcb:	e8 69 05 ff ff       	call   f0100339 <_panic>
					"Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n",
					before_last_fault_va, before_last_eip, fault_va);
		}
	} else {
		before_last_fault_va = last_fault_va;
f010fdd0:	a1 8c d5 71 f0       	mov    0xf071d58c,%eax
f010fdd5:	a3 90 d5 71 f0       	mov    %eax,0xf071d590
		before_last_eip = last_eip;
f010fdda:	a1 84 d5 71 f0       	mov    0xf071d584,%eax
f010fddf:	a3 88 d5 71 f0       	mov    %eax,0xf071d588
		num_repeated_fault = 0;
f010fde4:	c6 05 94 d5 71 f0 00 	movb   $0x0,0xf071d594
	}
	last_eip = (uint32) tf->tf_eip;
f010fdeb:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdee:	8b 40 30             	mov    0x30(%eax),%eax
f010fdf1:	a3 84 d5 71 f0       	mov    %eax,0xf071d584
	last_fault_va = fault_va;
f010fdf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010fdf9:	a3 8c d5 71 f0       	mov    %eax,0xf071d58c
	last_faulted_env = cur_env;
f010fdfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe01:	a3 98 d5 71 f0       	mov    %eax,0xf071d598
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010fe06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fe0d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe10:	8b 40 34             	mov    0x34(%eax),%eax
f010fe13:	0f b7 c0             	movzwl %ax,%eax
f010fe16:	83 e0 03             	and    $0x3,%eax
f010fe19:	83 f8 03             	cmp    $0x3,%eax
f010fe1c:	75 07                	jne    f010fe25 <fault_handler+0xcc>
		userTrap = 1;
f010fe1e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap) {
f010fe25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fe29:	0f 85 cb 00 00 00    	jne    f010fefa <fault_handler+0x1a1>
		struct cpu* c = mycpu();
f010fe2f:	e8 b3 79 ff ff       	call   f01077e7 <mycpu>
f010fe34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env
f010fe37:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fe3b:	74 32                	je     f010fe6f <fault_handler+0x116>
				&& fault_va
						>= (uint32) cur_env->kstack&& fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fe3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe40:	8b 40 70             	mov    0x70(%eax),%eax
	}
	if (!userTrap) {
		struct cpu* c = mycpu();
		//cprintf("trap from KERNEL\n");
		if (cur_env
				&& fault_va
f010fe43:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fe46:	77 27                	ja     f010fe6f <fault_handler+0x116>
						>= (uint32) cur_env->kstack&& fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fe48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fe4b:	8b 40 70             	mov    0x70(%eax),%eax
f010fe4e:	05 00 10 00 00       	add    $0x1000,%eax
f010fe53:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fe56:	76 17                	jbe    f010fe6f <fault_handler+0x116>
			panic("User Kernel Stack: overflow exception!");
f010fe58:	83 ec 04             	sub    $0x4,%esp
f010fe5b:	68 50 9b 12 f0       	push   $0xf0129b50
f010fe60:	68 99 00 00 00       	push   $0x99
f010fe65:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010fe6a:	e8 ca 04 ff ff       	call   f0100339 <_panic>
		else if (fault_va
				>= (uint32) c->stack&& fault_va < (uint32)c->stack + PAGE_SIZE)
f010fe6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe72:	8b 40 08             	mov    0x8(%eax),%eax
		//cprintf("trap from KERNEL\n");
		if (cur_env
				&& fault_va
						>= (uint32) cur_env->kstack&& fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
			panic("User Kernel Stack: overflow exception!");
		else if (fault_va
f010fe75:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fe78:	77 60                	ja     f010feda <fault_handler+0x181>
				>= (uint32) c->stack&& fault_va < (uint32)c->stack + PAGE_SIZE)
f010fe7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe7d:	8b 40 08             	mov    0x8(%eax),%eax
f010fe80:	05 00 10 00 00       	add    $0x1000,%eax
f010fe85:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fe88:	76 50                	jbe    f010feda <fault_handler+0x181>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!",
f010fe8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fe8d:	ba e0 59 74 f0       	mov    $0xf07459e0,%edx
f010fe92:	29 d0                	sub    %edx,%eax
f010fe94:	c1 f8 03             	sar    $0x3,%eax
f010fe97:	89 c2                	mov    %eax,%edx
f010fe99:	89 d0                	mov    %edx,%eax
f010fe9b:	c1 e0 02             	shl    $0x2,%eax
f010fe9e:	01 d0                	add    %edx,%eax
f010fea0:	01 c0                	add    %eax,%eax
f010fea2:	01 d0                	add    %edx,%eax
f010fea4:	c1 e0 03             	shl    $0x3,%eax
f010fea7:	01 d0                	add    %edx,%eax
f010fea9:	89 c1                	mov    %eax,%ecx
f010feab:	c1 e1 0b             	shl    $0xb,%ecx
f010feae:	01 c8                	add    %ecx,%eax
f010feb0:	c1 e0 05             	shl    $0x5,%eax
f010feb3:	01 d0                	add    %edx,%eax
f010feb5:	c1 e0 02             	shl    $0x2,%eax
f010feb8:	01 d0                	add    %edx,%eax
f010feba:	01 c0                	add    %eax,%eax
f010febc:	01 d0                	add    %edx,%eax
f010febe:	c1 e0 03             	shl    $0x3,%eax
f010fec1:	01 d0                	add    %edx,%eax
f010fec3:	f7 d8                	neg    %eax
f010fec5:	50                   	push   %eax
f010fec6:	68 78 9b 12 f0       	push   $0xf0129b78
f010fecb:	68 9d 00 00 00       	push   $0x9d
f010fed0:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010fed5:	e8 5f 04 ff ff       	call   f0100339 <_panic>
					c - CPUS);
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010feda:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fee1:	76 40                	jbe    f010ff23 <fault_handler+0x1ca>
			panic("Kernel: heap overflow exception!");
f010fee3:	83 ec 04             	sub    $0x4,%esp
f010fee6:	68 ac 9b 12 f0       	push   $0xf0129bac
f010feeb:	68 a0 00 00 00       	push   $0xa0
f010fef0:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010fef5:	e8 3f 04 ff ff       	call   f0100339 <_panic>
#endif
	}
	//2017: Check stack underflow for User
	else {
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010fefa:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010ff01:	76 20                	jbe    f010ff23 <fault_handler+0x1ca>
f010ff03:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010ff0a:	77 17                	ja     f010ff23 <fault_handler+0x1ca>
			panic("User: stack underflow exception!");
f010ff0c:	83 ec 04             	sub    $0x4,%esp
f010ff0f:	68 d0 9b 12 f0       	push   $0xf0129bd0
f010ff14:	68 a7 00 00 00       	push   $0xa7
f010ff19:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010ff1e:	e8 16 04 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010ff23:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ff26:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL) {
f010ff29:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ff2d:	75 25                	jne    f010ff54 <fault_handler+0x1fb>
		print_trapframe(tf);
f010ff2f:	83 ec 0c             	sub    $0xc,%esp
f010ff32:	ff 75 08             	pushl  0x8(%ebp)
f010ff35:	e8 89 e6 ff ff       	call   f010e5c3 <print_trapframe>
f010ff3a:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010ff3d:	83 ec 04             	sub    $0x4,%esp
f010ff40:	68 f1 9b 12 f0       	push   $0xf0129bf1
f010ff45:	68 af 00 00 00       	push   $0xaf
f010ff4a:	68 c3 9a 12 f0       	push   $0xf0129ac3
f010ff4f:	e8 e5 03 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ((faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT)
f010ff54:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ff57:	8b 40 64             	mov    0x64(%eax),%eax
f010ff5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ff5d:	c1 ea 16             	shr    $0x16,%edx
f010ff60:	c1 e2 02             	shl    $0x2,%edx
f010ff63:	01 d0                	add    %edx,%eax
f010ff65:	8b 00                	mov    (%eax),%eax
f010ff67:	83 e0 01             	and    $0x1,%eax
f010ff6a:	85 c0                	test   %eax,%eax
f010ff6c:	75 2b                	jne    f010ff99 <fault_handler+0x240>
			!= PERM_PRESENT) {
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter++;
f010ff6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ff71:	8b 80 9c 05 00 00    	mov    0x59c(%eax),%eax
f010ff77:	8d 50 01             	lea    0x1(%eax),%edx
f010ff7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ff7d:	89 90 9c 05 00 00    	mov    %edx,0x59c(%eax)

		table_fault_handler(faulted_env, fault_va);
f010ff83:	83 ec 08             	sub    $0x8,%esp
f010ff86:	ff 75 ec             	pushl  -0x14(%ebp)
f010ff89:	ff 75 e0             	pushl  -0x20(%ebp)
f010ff8c:	e8 02 01 00 00       	call   f0110093 <table_fault_handler>
f010ff91:	83 c4 10             	add    $0x10,%esp
f010ff94:	e9 eb 00 00 00       	jmp    f0110084 <fault_handler+0x32b>
	} else {
		if (userTrap) {
f010ff99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ff9d:	74 6a                	je     f0110009 <fault_handler+0x2b0>
			//============================================================================================/
			//TODO: [PROJECT'24.MS2 - #08] [2] FAULT HANDLER I - Check for invalid pointers
			//(e.g. pointing to unmarked user heap page, kernel or wrong access rights),
			//your code is here
			int perms = pt_get_page_permissions(faulted_env->env_page_directory,
f010ff9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ffa2:	8b 40 64             	mov    0x64(%eax),%eax
f010ffa5:	83 ec 08             	sub    $0x8,%esp
f010ffa8:	ff 75 ec             	pushl  -0x14(%ebp)
f010ffab:	50                   	push   %eax
f010ffac:	e8 45 a2 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f010ffb1:	83 c4 10             	add    $0x10,%esp
f010ffb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
					fault_va);
			if (!(perms & PERM_WRITEABLE) && (perms & PERM_PRESENT)) {
f010ffb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffba:	83 e0 02             	and    $0x2,%eax
f010ffbd:	85 c0                	test   %eax,%eax
f010ffbf:	75 0f                	jne    f010ffd0 <fault_handler+0x277>
f010ffc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffc4:	83 e0 01             	and    $0x1,%eax
f010ffc7:	85 c0                	test   %eax,%eax
f010ffc9:	74 05                	je     f010ffd0 <fault_handler+0x277>
				env_exit();
f010ffcb:	e8 32 bf ff ff       	call   f010bf02 <env_exit>
			}

			if (fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX) {
f010ffd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ffd3:	85 c0                	test   %eax,%eax
f010ffd5:	79 24                	jns    f010fffb <fault_handler+0x2a2>
f010ffd7:	81 7d ec ff ff ff 9f 	cmpl   $0x9fffffff,-0x14(%ebp)
f010ffde:	77 1b                	ja     f010fffb <fault_handler+0x2a2>
				if (!(perms & PERM_AVAILABLE) && (!(perms & PERM_PRESENT)))
f010ffe0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffe3:	25 00 0e 00 00       	and    $0xe00,%eax
f010ffe8:	85 c0                	test   %eax,%eax
f010ffea:	75 0f                	jne    f010fffb <fault_handler+0x2a2>
f010ffec:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffef:	83 e0 01             	and    $0x1,%eax
f010fff2:	85 c0                	test   %eax,%eax
f010fff4:	75 05                	jne    f010fffb <fault_handler+0x2a2>

				{
					env_exit();
f010fff6:	e8 07 bf ff ff       	call   f010bf02 <env_exit>
				}
			}
			if (fault_va >= USER_LIMIT) {
f010fffb:	81 7d ec ff ff 7f ef 	cmpl   $0xef7fffff,-0x14(%ebp)
f0110002:	76 05                	jbe    f0110009 <fault_handler+0x2b0>
				env_exit();
f0110004:	e8 f9 be ff ff       	call   f010bf02 <env_exit>
			}
		}
		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory,
f0110009:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011000c:	8b 40 64             	mov    0x64(%eax),%eax
f011000f:	83 ec 08             	sub    $0x8,%esp
f0110012:	ff 75 ec             	pushl  -0x14(%ebp)
f0110015:	50                   	push   %eax
f0110016:	e8 db a1 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f011001b:	83 c4 10             	add    $0x10,%esp
f011001e:	89 45 d8             	mov    %eax,-0x28(%ebp)
				fault_va);
		if (perms & PERM_PRESENT)
f0110021:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110024:	83 e0 01             	and    $0x1,%eax
f0110027:	85 c0                	test   %eax,%eax
f0110029:	74 17                	je     f0110042 <fault_handler+0x2e9>
			panic(
f011002b:	ff 75 ec             	pushl  -0x14(%ebp)
f011002e:	68 08 9c 12 f0       	push   $0xf0129c08
f0110033:	68 d9 00 00 00       	push   $0xd9
f0110038:	68 c3 9a 12 f0       	push   $0xf0129ac3
f011003d:	e8 f7 02 ff ff       	call   f0100339 <_panic>
					"Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n",
					fault_va);
		/*============================================================================================*/

		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter++;
f0110042:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110045:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f011004b:	8d 50 01             	lea    0x1(%eax),%edx
f011004e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110051:	89 90 98 05 00 00    	mov    %edx,0x598(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if (isBufferingEnabled()) {
f0110057:	e8 db fc ff ff       	call   f010fd37 <isBufferingEnabled>
f011005c:	84 c0                	test   %al,%al
f011005e:	74 13                	je     f0110073 <fault_handler+0x31a>
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f0110060:	83 ec 08             	sub    $0x8,%esp
f0110063:	ff 75 ec             	pushl  -0x14(%ebp)
f0110066:	ff 75 e0             	pushl  -0x20(%ebp)
f0110069:	e8 2e 07 00 00       	call   f011079c <__page_fault_handler_with_buffering>
f011006e:	83 c4 10             	add    $0x10,%esp
f0110071:	eb 11                	jmp    f0110084 <fault_handler+0x32b>
		} else {
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f0110073:	83 ec 08             	sub    $0x8,%esp
f0110076:	ff 75 ec             	pushl  -0x14(%ebp)
f0110079:	ff 75 e0             	pushl  -0x20(%ebp)
f011007c:	e8 33 00 00 00       	call   f01100b4 <page_fault_handler>
f0110081:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0110084:	0f 20 d8             	mov    %cr3,%eax
f0110087:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f011008a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011008d:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f0110090:	90                   	nop
f0110091:	c9                   	leave  
f0110092:	c3                   	ret    

f0110093 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va) {
f0110093:	55                   	push   %ebp
f0110094:	89 e5                	mov    %esp,%ebp
f0110096:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory,
f0110099:	8b 45 08             	mov    0x8(%ebp),%eax
f011009c:	8b 40 64             	mov    0x64(%eax),%eax
f011009f:	83 ec 08             	sub    $0x8,%esp
f01100a2:	ff 75 0c             	pushl  0xc(%ebp)
f01100a5:	50                   	push   %eax
f01100a6:	e8 8b 8b ff ff       	call   f0108c36 <create_page_table>
f01100ab:	83 c4 10             	add    $0x10,%esp
f01100ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f01100b1:	90                   	nop
f01100b2:	c9                   	leave  
f01100b3:	c3                   	ret    

f01100b4 <page_fault_handler>:
//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va) {
f01100b4:	55                   	push   %ebp
f01100b5:	89 e5                	mov    %esp,%ebp
f01100b7:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	struct WorkingSetElement *victimWSElement = NULL;
f01100ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f01100c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01100c4:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f01100ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#else
	int iWS =faulted_env->page_last_WS_index;
	uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif
	if (isPageReplacmentAlgorithmNchanceCLOCK()) {
f01100cd:	e8 24 fc ff ff       	call   f010fcf6 <isPageReplacmentAlgorithmNchanceCLOCK>
f01100d2:	85 c0                	test   %eax,%eax
f01100d4:	0f 84 bf 06 00 00    	je     f0110799 <page_fault_handler+0x6e5>
		if (wsSize < (faulted_env->page_WS_max_size)) {
f01100da:	8b 45 08             	mov    0x8(%ebp),%eax
f01100dd:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01100e3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01100e6:	0f 86 9d 01 00 00    	jbe    f0110289 <page_fault_handler+0x1d5>
			//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
			//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
			// Write your code here, remove the panic and write your code
			//panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
			struct FrameInfo *frame_info = NULL;
f01100ec:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
			int result = allocate_frame(&frame_info);
f01100f3:	83 ec 0c             	sub    $0xc,%esp
f01100f6:	8d 45 a4             	lea    -0x5c(%ebp),%eax
f01100f9:	50                   	push   %eax
f01100fa:	e8 a4 87 ff ff       	call   f01088a3 <allocate_frame>
f01100ff:	83 c4 10             	add    $0x10,%esp
f0110102:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (result != 0) {
f0110105:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110109:	74 17                	je     f0110122 <page_fault_handler+0x6e>
				panic("Failed to allocate frame!");
f011010b:	83 ec 04             	sub    $0x4,%esp
f011010e:	68 4c 9c 12 f0       	push   $0xf0129c4c
f0110113:	68 1a 01 00 00       	push   $0x11a
f0110118:	68 c3 9a 12 f0       	push   $0xf0129ac3
f011011d:	e8 17 02 ff ff       	call   f0100339 <_panic>
			}
			map_frame(faulted_env->env_page_directory, frame_info, fault_va,
f0110122:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0110125:	8b 45 08             	mov    0x8(%ebp),%eax
f0110128:	8b 40 64             	mov    0x64(%eax),%eax
f011012b:	6a 07                	push   $0x7
f011012d:	ff 75 0c             	pushl  0xc(%ebp)
f0110130:	52                   	push   %edx
f0110131:	50                   	push   %eax
f0110132:	e8 39 8c ff ff       	call   f0108d70 <map_frame>
f0110137:	83 c4 10             	add    $0x10,%esp
			PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
			int page_status = pf_read_env_page(faulted_env, (void *) fault_va);
f011013a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011013d:	83 ec 08             	sub    $0x8,%esp
f0110140:	50                   	push   %eax
f0110141:	ff 75 08             	pushl  0x8(%ebp)
f0110144:	e8 ab 45 ff ff       	call   f01046f4 <pf_read_env_page>
f0110149:	83 c4 10             	add    $0x10,%esp
f011014c:	89 45 dc             	mov    %eax,-0x24(%ebp)
			if (page_status == E_PAGE_NOT_EXIST_IN_PF) {
f011014f:	83 7d dc f7          	cmpl   $0xfffffff7,-0x24(%ebp)
f0110153:	75 45                	jne    f011019a <page_fault_handler+0xe6>
				if ((fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)
f0110155:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110158:	85 c0                	test   %eax,%eax
f011015a:	79 09                	jns    f0110165 <page_fault_handler+0xb1>
f011015c:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0110163:	76 35                	jbe    f011019a <page_fault_handler+0xe6>
						|| (fault_va >= USTACKBOTTOM && fault_va < USTACKTOP)) {
f0110165:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011016c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011016f:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0110174:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110177:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011017a:	ba 00 00 00 00       	mov    $0x0,%edx
f011017f:	f7 75 d8             	divl   -0x28(%ebp)
f0110182:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110185:	29 d0                	sub    %edx,%eax
f0110187:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011018a:	77 09                	ja     f0110195 <page_fault_handler+0xe1>
f011018c:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f0110193:	76 05                	jbe    f011019a <page_fault_handler+0xe6>
				} else {
					env_exit();
f0110195:	e8 68 bd ff ff       	call   f010bf02 <env_exit>
				}
			}
			struct WorkingSetElement *newElement =
f011019a:	83 ec 08             	sub    $0x8,%esp
f011019d:	ff 75 0c             	pushl  0xc(%ebp)
f01101a0:	ff 75 08             	pushl  0x8(%ebp)
f01101a3:	e8 c0 a1 ff ff       	call   f010a368 <env_page_ws_list_create_element>
f01101a8:	83 c4 10             	add    $0x10,%esp
f01101ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
					env_page_ws_list_create_element(faulted_env, fault_va);
			LIST_INSERT_TAIL(&(faulted_env->page_WS_list), newElement);
f01101ae:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01101b2:	75 17                	jne    f01101cb <page_fault_handler+0x117>
f01101b4:	83 ec 04             	sub    $0x4,%esp
f01101b7:	68 68 9c 12 f0       	push   $0xf0129c68
f01101bc:	68 28 01 00 00       	push   $0x128
f01101c1:	68 c3 9a 12 f0       	push   $0xf0129ac3
f01101c6:	e8 6e 01 ff ff       	call   f0100339 <_panic>
f01101cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01101ce:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f01101d4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101d7:	89 50 14             	mov    %edx,0x14(%eax)
f01101da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101dd:	8b 40 14             	mov    0x14(%eax),%eax
f01101e0:	85 c0                	test   %eax,%eax
f01101e2:	74 11                	je     f01101f5 <page_fault_handler+0x141>
f01101e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01101e7:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01101ed:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01101f0:	89 50 10             	mov    %edx,0x10(%eax)
f01101f3:	eb 0c                	jmp    f0110201 <page_fault_handler+0x14d>
f01101f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01101f8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01101fb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0110201:	8b 45 08             	mov    0x8(%ebp),%eax
f0110204:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110207:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f011020d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110210:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0110217:	8b 45 08             	mov    0x8(%ebp),%eax
f011021a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0110220:	8d 50 01             	lea    0x1(%eax),%edx
f0110223:	8b 45 08             	mov    0x8(%ebp),%eax
f0110226:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
			if (LIST_SIZE(&(faulted_env->page_WS_list))
f011022c:	8b 45 08             	mov    0x8(%ebp),%eax
f011022f:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
					== faulted_env->page_WS_max_size
f0110235:	8b 45 08             	mov    0x8(%ebp),%eax
f0110238:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
				}
			}
			struct WorkingSetElement *newElement =
					env_page_ws_list_create_element(faulted_env, fault_va);
			LIST_INSERT_TAIL(&(faulted_env->page_WS_list), newElement);
			if (LIST_SIZE(&(faulted_env->page_WS_list))
f011023e:	39 c2                	cmp    %eax,%edx
f0110240:	75 24                	jne    f0110266 <page_fault_handler+0x1b2>
					== faulted_env->page_WS_max_size
					&& faulted_env->isFirstTimeToBeMax == 0) {
f0110242:	8b 45 08             	mov    0x8(%ebp),%eax
f0110245:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f011024b:	85 c0                	test   %eax,%eax
f011024d:	75 17                	jne    f0110266 <page_fault_handler+0x1b2>
				faulted_env->page_last_WS_element = LIST_FIRST(
f011024f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110252:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0110258:	8b 45 08             	mov    0x8(%ebp),%eax
f011025b:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
f0110261:	e9 33 05 00 00       	jmp    f0110799 <page_fault_handler+0x6e5>
						&(faulted_env->page_WS_list));
			} else if (faulted_env->isFirstTimeToBeMax == 0) {
f0110266:	8b 45 08             	mov    0x8(%ebp),%eax
f0110269:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f011026f:	85 c0                	test   %eax,%eax
f0110271:	0f 85 22 05 00 00    	jne    f0110799 <page_fault_handler+0x6e5>
				faulted_env->page_last_WS_element = NULL;
f0110277:	8b 45 08             	mov    0x8(%ebp),%eax
f011027a:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
f0110281:	00 00 00 
					current = current->prev_next_info.le_next;
			}
		}
	}

}
f0110284:	e9 10 05 00 00       	jmp    f0110799 <page_fault_handler+0x6e5>
			//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
			//refer to the project presentation and documentation for details
			//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
			// Write your code here, remove the panic and write your code
			//panic("page_fault_handler() Replacement is not implemented yet...!!");
			fault_va=ROUNDDOWN(fault_va,PAGE_SIZE);
f0110289:	8b 45 0c             	mov    0xc(%ebp),%eax
f011028c:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011028f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110292:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110297:	89 45 0c             	mov    %eax,0xc(%ebp)
			uint32 *ptrpage = NULL;
f011029a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			struct WorkingSetElement *current =
f01102a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01102a4:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01102aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
					faulted_env->page_last_WS_element;
			struct FrameInfo *frame_info = NULL;
f01102ad:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
			int result = allocate_frame(&frame_info);
f01102b4:	83 ec 0c             	sub    $0xc,%esp
f01102b7:	8d 45 a0             	lea    -0x60(%ebp),%eax
f01102ba:	50                   	push   %eax
f01102bb:	e8 e3 85 ff ff       	call   f01088a3 <allocate_frame>
f01102c0:	83 c4 10             	add    $0x10,%esp
f01102c3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			if (result != 0) {
f01102c6:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f01102ca:	74 17                	je     f01102e3 <page_fault_handler+0x22f>
				panic("Failed to allocate frame!");
f01102cc:	83 ec 04             	sub    $0x4,%esp
f01102cf:	68 4c 9c 12 f0       	push   $0xf0129c4c
f01102d4:	68 40 01 00 00       	push   $0x140
f01102d9:	68 c3 9a 12 f0       	push   $0xf0129ac3
f01102de:	e8 56 00 ff ff       	call   f0100339 <_panic>
			}
			map_frame(faulted_env->env_page_directory, frame_info, fault_va,
f01102e3:	8b 55 a0             	mov    -0x60(%ebp),%edx
f01102e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01102e9:	8b 40 64             	mov    0x64(%eax),%eax
f01102ec:	6a 07                	push   $0x7
f01102ee:	ff 75 0c             	pushl  0xc(%ebp)
f01102f1:	52                   	push   %edx
f01102f2:	50                   	push   %eax
f01102f3:	e8 78 8a ff ff       	call   f0108d70 <map_frame>
f01102f8:	83 c4 10             	add    $0x10,%esp
			PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
			int page_status = pf_read_env_page(faulted_env, (void *) fault_va);
f01102fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102fe:	83 ec 08             	sub    $0x8,%esp
f0110301:	50                   	push   %eax
f0110302:	ff 75 08             	pushl  0x8(%ebp)
f0110305:	e8 ea 43 ff ff       	call   f01046f4 <pf_read_env_page>
f011030a:	83 c4 10             	add    $0x10,%esp
f011030d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if (page_status == E_PAGE_NOT_EXIST_IN_PF) {
f0110310:	83 7d c0 f7          	cmpl   $0xfffffff7,-0x40(%ebp)
f0110314:	75 45                	jne    f011035b <page_fault_handler+0x2a7>
				if ((fault_va >= USER_HEAP_START && fault_va < USER_HEAP_MAX)
f0110316:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110319:	85 c0                	test   %eax,%eax
f011031b:	79 09                	jns    f0110326 <page_fault_handler+0x272>
f011031d:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f0110324:	76 35                	jbe    f011035b <page_fault_handler+0x2a7>
						|| (fault_va >= USTACKBOTTOM && fault_va < USTACKTOP)) {
f0110326:	c7 45 bc 00 10 00 00 	movl   $0x1000,-0x44(%ebp)
f011032d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110330:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0110335:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0110338:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011033b:	ba 00 00 00 00       	mov    $0x0,%edx
f0110340:	f7 75 bc             	divl   -0x44(%ebp)
f0110343:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0110346:	29 d0                	sub    %edx,%eax
f0110348:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011034b:	77 09                	ja     f0110356 <page_fault_handler+0x2a2>
f011034d:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f0110354:	76 05                	jbe    f011035b <page_fault_handler+0x2a7>
				} else {
					env_exit();
f0110356:	e8 a7 bb ff ff       	call   f010bf02 <env_exit>
				}
			}
			int maxSweeps;
			int modifiedAlgorithm = 0;
f011035b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			if (page_WS_max_sweeps < 0) {
f0110362:	a1 94 58 74 f0       	mov    0xf0745894,%eax
f0110367:	85 c0                	test   %eax,%eax
f0110369:	79 13                	jns    f011037e <page_fault_handler+0x2ca>
				maxSweeps = -1 * page_WS_max_sweeps;
f011036b:	a1 94 58 74 f0       	mov    0xf0745894,%eax
f0110370:	f7 d8                	neg    %eax
f0110372:	89 45 f0             	mov    %eax,-0x10(%ebp)
				modifiedAlgorithm = 1;
f0110375:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
f011037c:	eb 08                	jmp    f0110386 <page_fault_handler+0x2d2>
			} else
				maxSweeps = page_WS_max_sweeps;
f011037e:	a1 94 58 74 f0       	mov    0xf0745894,%eax
f0110383:	89 45 f0             	mov    %eax,-0x10(%ebp)

			while (1) {

				uint32 page_permissions = pt_get_page_permissions(
f0110386:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110389:	8b 10                	mov    (%eax),%edx
f011038b:	8b 45 08             	mov    0x8(%ebp),%eax
f011038e:	8b 40 64             	mov    0x64(%eax),%eax
f0110391:	83 ec 08             	sub    $0x8,%esp
f0110394:	52                   	push   %edx
f0110395:	50                   	push   %eax
f0110396:	e8 5b 9e ff ff       	call   f010a1f6 <pt_get_page_permissions>
f011039b:	83 c4 10             	add    $0x10,%esp
f011039e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
						faulted_env->env_page_directory,
						current->virtual_address);

				if (page_permissions & PERM_USED) {
f01103a1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01103a4:	83 e0 20             	and    $0x20,%eax
f01103a7:	85 c0                	test   %eax,%eax
f01103a9:	74 28                	je     f01103d3 <page_fault_handler+0x31f>
					pt_set_page_permissions(faulted_env->env_page_directory,
f01103ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01103ae:	8b 10                	mov    (%eax),%edx
f01103b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01103b3:	8b 40 64             	mov    0x64(%eax),%eax
f01103b6:	6a 20                	push   $0x20
f01103b8:	6a 00                	push   $0x0
f01103ba:	52                   	push   %edx
f01103bb:	50                   	push   %eax
f01103bc:	e8 71 9d ff ff       	call   f010a132 <pt_set_page_permissions>
f01103c1:	83 c4 10             	add    $0x10,%esp
							current->virtual_address, 0, PERM_USED);
					current->sweeps_counter = 0;
f01103c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01103c7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01103ce:	e9 99 03 00 00       	jmp    f011076c <page_fault_handler+0x6b8>
				} else {
					current->sweeps_counter++;
f01103d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01103d6:	8b 40 0c             	mov    0xc(%eax),%eax
f01103d9:	8d 50 01             	lea    0x1(%eax),%edx
f01103dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01103df:	89 50 0c             	mov    %edx,0xc(%eax)
					if ((modifiedAlgorithm && (page_permissions & PERM_MODIFIED)
f01103e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01103e6:	74 18                	je     f0110400 <page_fault_handler+0x34c>
f01103e8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01103eb:	83 e0 40             	and    $0x40,%eax
f01103ee:	85 c0                	test   %eax,%eax
f01103f0:	74 0e                	je     f0110400 <page_fault_handler+0x34c>
							&& current->sweeps_counter >= (maxSweeps + 1))
f01103f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01103f5:	8b 40 0c             	mov    0xc(%eax),%eax
f01103f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01103fb:	42                   	inc    %edx
f01103fc:	39 d0                	cmp    %edx,%eax
f01103fe:	73 38                	jae    f0110438 <page_fault_handler+0x384>
							|| (modifiedAlgorithm
f0110400:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110404:	74 17                	je     f011041d <page_fault_handler+0x369>
									&& !(page_permissions & PERM_MODIFIED)
f0110406:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110409:	83 e0 40             	and    $0x40,%eax
f011040c:	85 c0                	test   %eax,%eax
f011040e:	75 0d                	jne    f011041d <page_fault_handler+0x369>
									&& current->sweeps_counter >= maxSweeps)
f0110410:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110413:	8b 50 0c             	mov    0xc(%eax),%edx
f0110416:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110419:	39 c2                	cmp    %eax,%edx
f011041b:	73 1b                	jae    f0110438 <page_fault_handler+0x384>
							|| ((!modifiedAlgorithm)
f011041d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110421:	0f 85 45 03 00 00    	jne    f011076c <page_fault_handler+0x6b8>
									&& current->sweeps_counter >= maxSweeps)) {
f0110427:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011042a:	8b 50 0c             	mov    0xc(%eax),%edx
f011042d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110430:	39 c2                	cmp    %eax,%edx
f0110432:	0f 82 34 03 00 00    	jb     f011076c <page_fault_handler+0x6b8>
						faulted_env->isFirstTimeToBeMax = 1;
f0110438:	8b 45 08             	mov    0x8(%ebp),%eax
f011043b:	c7 80 a8 00 00 00 01 	movl   $0x1,0xa8(%eax)
f0110442:	00 00 00 
						uint32 *ptr_table = NULL;
f0110445:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
						struct FrameInfo *victimFrame = get_frame_info(
f011044c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011044f:	8b 10                	mov    (%eax),%edx
f0110451:	8b 45 08             	mov    0x8(%ebp),%eax
f0110454:	8b 40 64             	mov    0x64(%eax),%eax
f0110457:	83 ec 04             	sub    $0x4,%esp
f011045a:	8d 4d 9c             	lea    -0x64(%ebp),%ecx
f011045d:	51                   	push   %ecx
f011045e:	52                   	push   %edx
f011045f:	50                   	push   %eax
f0110460:	e8 fe 89 ff ff       	call   f0108e63 <get_frame_info>
f0110465:	83 c4 10             	add    $0x10,%esp
f0110468:	89 45 b0             	mov    %eax,-0x50(%ebp)
								faulted_env->env_page_directory,
								current->virtual_address, &ptr_table);

						if (page_permissions & PERM_MODIFIED) {
f011046b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011046e:	83 e0 40             	and    $0x40,%eax
f0110471:	85 c0                	test   %eax,%eax
f0110473:	74 17                	je     f011048c <page_fault_handler+0x3d8>
							pf_update_env_page(faulted_env,
f0110475:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110478:	8b 00                	mov    (%eax),%eax
f011047a:	83 ec 04             	sub    $0x4,%esp
f011047d:	ff 75 b0             	pushl  -0x50(%ebp)
f0110480:	50                   	push   %eax
f0110481:	ff 75 08             	pushl  0x8(%ebp)
f0110484:	e8 87 40 ff ff       	call   f0104510 <pf_update_env_page>
f0110489:	83 c4 10             	add    $0x10,%esp
									current->virtual_address, victimFrame);
						}
						if (current->prev_next_info.le_next == NULL) {
f011048c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011048f:	8b 40 10             	mov    0x10(%eax),%eax
f0110492:	85 c0                	test   %eax,%eax
f0110494:	0f 85 5b 01 00 00    	jne    f01105f5 <page_fault_handler+0x541>
							faulted_env->page_last_WS_element = LIST_FIRST(
f011049a:	8b 45 08             	mov    0x8(%ebp),%eax
f011049d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f01104a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01104a6:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
									&(faulted_env->page_WS_list));
							unmap_frame(faulted_env->env_page_directory,
f01104ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104af:	8b 10                	mov    (%eax),%edx
f01104b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01104b4:	8b 40 64             	mov    0x64(%eax),%eax
f01104b7:	83 ec 08             	sub    $0x8,%esp
f01104ba:	52                   	push   %edx
f01104bb:	50                   	push   %eax
f01104bc:	e8 18 8a ff ff       	call   f0108ed9 <unmap_frame>
f01104c1:	83 c4 10             	add    $0x10,%esp
									current->virtual_address);

							LIST_REMOVE(&(faulted_env->page_WS_list), current);
f01104c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01104c8:	75 17                	jne    f01104e1 <page_fault_handler+0x42d>
f01104ca:	83 ec 04             	sub    $0x4,%esp
f01104cd:	68 8b 9c 12 f0       	push   $0xf0129c8b
f01104d2:	68 77 01 00 00       	push   $0x177
f01104d7:	68 c3 9a 12 f0       	push   $0xf0129ac3
f01104dc:	e8 58 fe fe ff       	call   f0100339 <_panic>
f01104e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104e4:	8b 40 10             	mov    0x10(%eax),%eax
f01104e7:	85 c0                	test   %eax,%eax
f01104e9:	74 11                	je     f01104fc <page_fault_handler+0x448>
f01104eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104ee:	8b 40 10             	mov    0x10(%eax),%eax
f01104f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01104f4:	8b 52 14             	mov    0x14(%edx),%edx
f01104f7:	89 50 14             	mov    %edx,0x14(%eax)
f01104fa:	eb 0f                	jmp    f011050b <page_fault_handler+0x457>
f01104fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104ff:	8b 50 14             	mov    0x14(%eax),%edx
f0110502:	8b 45 08             	mov    0x8(%ebp),%eax
f0110505:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f011050b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011050e:	8b 40 14             	mov    0x14(%eax),%eax
f0110511:	85 c0                	test   %eax,%eax
f0110513:	74 11                	je     f0110526 <page_fault_handler+0x472>
f0110515:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110518:	8b 40 14             	mov    0x14(%eax),%eax
f011051b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011051e:	8b 52 10             	mov    0x10(%edx),%edx
f0110521:	89 50 10             	mov    %edx,0x10(%eax)
f0110524:	eb 0f                	jmp    f0110535 <page_fault_handler+0x481>
f0110526:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110529:	8b 50 10             	mov    0x10(%eax),%edx
f011052c:	8b 45 08             	mov    0x8(%ebp),%eax
f011052f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0110535:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110538:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f011053f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110542:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0110549:	8b 45 08             	mov    0x8(%ebp),%eax
f011054c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0110552:	8d 50 ff             	lea    -0x1(%eax),%edx
f0110555:	8b 45 08             	mov    0x8(%ebp),%eax
f0110558:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
							struct WorkingSetElement *newElement =
f011055e:	83 ec 08             	sub    $0x8,%esp
f0110561:	ff 75 0c             	pushl  0xc(%ebp)
f0110564:	ff 75 08             	pushl  0x8(%ebp)
f0110567:	e8 fc 9d ff ff       	call   f010a368 <env_page_ws_list_create_element>
f011056c:	83 c4 10             	add    $0x10,%esp
f011056f:	89 45 ac             	mov    %eax,-0x54(%ebp)
									env_page_ws_list_create_element(faulted_env,
											fault_va);

							LIST_INSERT_TAIL(&(faulted_env->page_WS_list),
f0110572:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f0110576:	75 17                	jne    f011058f <page_fault_handler+0x4db>
f0110578:	83 ec 04             	sub    $0x4,%esp
f011057b:	68 68 9c 12 f0       	push   $0xf0129c68
f0110580:	68 7d 01 00 00       	push   $0x17d
f0110585:	68 c3 9a 12 f0       	push   $0xf0129ac3
f011058a:	e8 aa fd fe ff       	call   f0100339 <_panic>
f011058f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110592:	8b 90 98 00 00 00    	mov    0x98(%eax),%edx
f0110598:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011059b:	89 50 14             	mov    %edx,0x14(%eax)
f011059e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01105a1:	8b 40 14             	mov    0x14(%eax),%eax
f01105a4:	85 c0                	test   %eax,%eax
f01105a6:	74 11                	je     f01105b9 <page_fault_handler+0x505>
f01105a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01105ab:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01105b1:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01105b4:	89 50 10             	mov    %edx,0x10(%eax)
f01105b7:	eb 0c                	jmp    f01105c5 <page_fault_handler+0x511>
f01105b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01105bc:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01105bf:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f01105c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01105c8:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01105cb:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f01105d1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01105d4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01105db:	8b 45 08             	mov    0x8(%ebp),%eax
f01105de:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f01105e4:	8d 50 01             	lea    0x1(%eax),%edx
f01105e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01105ea:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
							LIST_INSERT_BEFORE(&(faulted_env->page_WS_list),
									faulted_env->page_last_WS_element,
									newElement);
						}

						break;
f01105f0:	e9 a4 01 00 00       	jmp    f0110799 <page_fault_handler+0x6e5>
							LIST_INSERT_TAIL(&(faulted_env->page_WS_list),
									newElement);

						} else {
							faulted_env->page_last_WS_element =
									current->prev_next_info.le_next;
f01105f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105f8:	8b 50 10             	mov    0x10(%eax),%edx

							LIST_INSERT_TAIL(&(faulted_env->page_WS_list),
									newElement);

						} else {
							faulted_env->page_last_WS_element =
f01105fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01105fe:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
									current->prev_next_info.le_next;
							unmap_frame(faulted_env->env_page_directory,
f0110604:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110607:	8b 10                	mov    (%eax),%edx
f0110609:	8b 45 08             	mov    0x8(%ebp),%eax
f011060c:	8b 40 64             	mov    0x64(%eax),%eax
f011060f:	83 ec 08             	sub    $0x8,%esp
f0110612:	52                   	push   %edx
f0110613:	50                   	push   %eax
f0110614:	e8 c0 88 ff ff       	call   f0108ed9 <unmap_frame>
f0110619:	83 c4 10             	add    $0x10,%esp
									current->virtual_address);

							LIST_REMOVE(&(faulted_env->page_WS_list), current);
f011061c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110620:	75 17                	jne    f0110639 <page_fault_handler+0x585>
f0110622:	83 ec 04             	sub    $0x4,%esp
f0110625:	68 8b 9c 12 f0       	push   $0xf0129c8b
f011062a:	68 85 01 00 00       	push   $0x185
f011062f:	68 c3 9a 12 f0       	push   $0xf0129ac3
f0110634:	e8 00 fd fe ff       	call   f0100339 <_panic>
f0110639:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011063c:	8b 40 10             	mov    0x10(%eax),%eax
f011063f:	85 c0                	test   %eax,%eax
f0110641:	74 11                	je     f0110654 <page_fault_handler+0x5a0>
f0110643:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110646:	8b 40 10             	mov    0x10(%eax),%eax
f0110649:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011064c:	8b 52 14             	mov    0x14(%edx),%edx
f011064f:	89 50 14             	mov    %edx,0x14(%eax)
f0110652:	eb 0f                	jmp    f0110663 <page_fault_handler+0x5af>
f0110654:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110657:	8b 50 14             	mov    0x14(%eax),%edx
f011065a:	8b 45 08             	mov    0x8(%ebp),%eax
f011065d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f0110663:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110666:	8b 40 14             	mov    0x14(%eax),%eax
f0110669:	85 c0                	test   %eax,%eax
f011066b:	74 11                	je     f011067e <page_fault_handler+0x5ca>
f011066d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110670:	8b 40 14             	mov    0x14(%eax),%eax
f0110673:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110676:	8b 52 10             	mov    0x10(%edx),%edx
f0110679:	89 50 10             	mov    %edx,0x10(%eax)
f011067c:	eb 0f                	jmp    f011068d <page_fault_handler+0x5d9>
f011067e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110681:	8b 50 10             	mov    0x10(%eax),%edx
f0110684:	8b 45 08             	mov    0x8(%ebp),%eax
f0110687:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f011068d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110690:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0110697:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011069a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01106a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01106a4:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f01106aa:	8d 50 ff             	lea    -0x1(%eax),%edx
f01106ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01106b0:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
							struct WorkingSetElement *newElement =
f01106b6:	83 ec 08             	sub    $0x8,%esp
f01106b9:	ff 75 0c             	pushl  0xc(%ebp)
f01106bc:	ff 75 08             	pushl  0x8(%ebp)
f01106bf:	e8 a4 9c ff ff       	call   f010a368 <env_page_ws_list_create_element>
f01106c4:	83 c4 10             	add    $0x10,%esp
f01106c7:	89 45 a8             	mov    %eax,-0x58(%ebp)
									env_page_ws_list_create_element(faulted_env,
											fault_va);

							LIST_INSERT_BEFORE(&(faulted_env->page_WS_list),
f01106ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01106cd:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01106d3:	85 c0                	test   %eax,%eax
f01106d5:	74 06                	je     f01106dd <page_fault_handler+0x629>
f01106d7:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01106db:	75 17                	jne    f01106f4 <page_fault_handler+0x640>
f01106dd:	83 ec 04             	sub    $0x4,%esp
f01106e0:	68 ac 9c 12 f0       	push   $0xf0129cac
f01106e5:	68 8c 01 00 00       	push   $0x18c
f01106ea:	68 c3 9a 12 f0       	push   $0xf0129ac3
f01106ef:	e8 45 fc fe ff       	call   f0100339 <_panic>
f01106f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01106f7:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f01106fd:	8b 50 14             	mov    0x14(%eax),%edx
f0110700:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110703:	89 50 14             	mov    %edx,0x14(%eax)
f0110706:	8b 45 08             	mov    0x8(%ebp),%eax
f0110709:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
f011070f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110712:	89 50 10             	mov    %edx,0x10(%eax)
f0110715:	8b 45 08             	mov    0x8(%ebp),%eax
f0110718:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011071e:	8b 40 14             	mov    0x14(%eax),%eax
f0110721:	85 c0                	test   %eax,%eax
f0110723:	74 14                	je     f0110739 <page_fault_handler+0x685>
f0110725:	8b 45 08             	mov    0x8(%ebp),%eax
f0110728:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011072e:	8b 40 14             	mov    0x14(%eax),%eax
f0110731:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0110734:	89 50 10             	mov    %edx,0x10(%eax)
f0110737:	eb 0c                	jmp    f0110745 <page_fault_handler+0x691>
f0110739:	8b 45 08             	mov    0x8(%ebp),%eax
f011073c:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011073f:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
f0110745:	8b 45 08             	mov    0x8(%ebp),%eax
f0110748:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f011074e:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0110751:	89 50 14             	mov    %edx,0x14(%eax)
f0110754:	8b 45 08             	mov    0x8(%ebp),%eax
f0110757:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011075d:	8d 50 01             	lea    0x1(%eax),%edx
f0110760:	8b 45 08             	mov    0x8(%ebp),%eax
f0110763:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
									faulted_env->page_last_WS_element,
									newElement);
						}

						break;
f0110769:	90                   	nop
f011076a:	eb 2d                	jmp    f0110799 <page_fault_handler+0x6e5>
					}

				}
				if (current == LIST_LAST(&(faulted_env->page_WS_list)))
f011076c:	8b 45 08             	mov    0x8(%ebp),%eax
f011076f:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0110775:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110778:	75 11                	jne    f011078b <page_fault_handler+0x6d7>
					current = LIST_FIRST(&(faulted_env->page_WS_list));
f011077a:	8b 45 08             	mov    0x8(%ebp),%eax
f011077d:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0110783:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110786:	e9 fb fb ff ff       	jmp    f0110386 <page_fault_handler+0x2d2>
				else
					current = current->prev_next_info.le_next;
f011078b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011078e:	8b 40 10             	mov    0x10(%eax),%eax
f0110791:	89 45 f4             	mov    %eax,-0xc(%ebp)
			}
f0110794:	e9 ed fb ff ff       	jmp    f0110386 <page_fault_handler+0x2d2>
		}
	}

}
f0110799:	90                   	nop
f011079a:	c9                   	leave  
f011079b:	c3                   	ret    

f011079c <__page_fault_handler_with_buffering>:
void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va) {
f011079c:	55                   	push   %ebp
f011079d:	89 e5                	mov    %esp,%ebp
f011079f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f01107a2:	83 ec 04             	sub    $0x4,%esp
f01107a5:	68 e4 9c 12 f0       	push   $0xf0129ce4
f01107aa:	68 9f 01 00 00       	push   $0x19f
f01107af:	68 c3 9a 12 f0       	push   $0xf0129ac3
f01107b4:	e8 80 fb fe ff       	call   f0100339 <_panic>

f01107b9 <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f01107b9:	55                   	push   %ebp
f01107ba:	89 e5                	mov    %esp,%ebp
f01107bc:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f01107bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01107c2:	83 c0 04             	add    $0x4,%eax
f01107c5:	83 ec 08             	sub    $0x8,%esp
f01107c8:	ff 75 0c             	pushl  0xc(%ebp)
f01107cb:	50                   	push   %eax
f01107cc:	e8 b9 17 01 00       	call   f0121f8a <strcpy>
f01107d1:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f01107d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01107d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f01107dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01107e0:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f01107e7:	90                   	nop
f01107e8:	c9                   	leave  
f01107e9:	c3                   	ret    

f01107ea <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f01107ea:	55                   	push   %ebp
f01107eb:	89 e5                	mov    %esp,%ebp
f01107ed:	53                   	push   %ebx
f01107ee:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f01107f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01107f4:	83 ec 0c             	sub    $0xc,%esp
f01107f7:	50                   	push   %eax
f01107f8:	e8 06 02 00 00       	call   f0110a03 <holding_spinlock>
f01107fd:	83 c4 10             	add    $0x10,%esp
f0110800:	85 c0                	test   %eax,%eax
f0110802:	74 18                	je     f011081c <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f0110804:	8b 45 08             	mov    0x8(%ebp),%eax
f0110807:	83 c0 04             	add    $0x4,%eax
f011080a:	50                   	push   %eax
f011080b:	68 28 9d 12 f0       	push   $0xf0129d28
f0110810:	6a 1f                	push   $0x1f
f0110812:	68 65 9d 12 f0       	push   $0xf0129d65
f0110817:	e8 1d fb fe ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f011081c:	e8 89 70 ff ff       	call   f01078aa <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f0110821:	90                   	nop
f0110822:	8b 45 08             	mov    0x8(%ebp),%eax
f0110825:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110828:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f011082f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0110832:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110835:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0110838:	f0 87 02             	lock xchg %eax,(%edx)
f011083b:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f011083e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110841:	85 c0                	test   %eax,%eax
f0110843:	75 dd                	jne    f0110822 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f0110845:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f011084a:	8b 5d 08             	mov    0x8(%ebp),%ebx
f011084d:	e8 95 6f ff ff       	call   f01077e7 <mycpu>
f0110852:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f0110855:	8b 45 08             	mov    0x8(%ebp),%eax
f0110858:	83 c0 48             	add    $0x48,%eax
f011085b:	83 ec 08             	sub    $0x8,%esp
f011085e:	50                   	push   %eax
f011085f:	8d 45 08             	lea    0x8(%ebp),%eax
f0110862:	50                   	push   %eax
f0110863:	e8 74 00 00 00       	call   f01108dc <getcallerpcs>
f0110868:	83 c4 10             	add    $0x10,%esp

}
f011086b:	90                   	nop
f011086c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011086f:	c9                   	leave  
f0110870:	c3                   	ret    

f0110871 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f0110871:	55                   	push   %ebp
f0110872:	89 e5                	mov    %esp,%ebp
f0110874:	83 ec 08             	sub    $0x8,%esp
	if(!holding_spinlock(lk))
f0110877:	83 ec 0c             	sub    $0xc,%esp
f011087a:	ff 75 08             	pushl  0x8(%ebp)
f011087d:	e8 81 01 00 00       	call   f0110a03 <holding_spinlock>
f0110882:	83 c4 10             	add    $0x10,%esp
f0110885:	85 c0                	test   %eax,%eax
f0110887:	75 26                	jne    f01108af <release_spinlock+0x3e>
	{
		printcallstack(lk);
f0110889:	83 ec 0c             	sub    $0xc,%esp
f011088c:	ff 75 08             	pushl  0x8(%ebp)
f011088f:	e8 08 01 00 00       	call   f011099c <printcallstack>
f0110894:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f0110897:	8b 45 08             	mov    0x8(%ebp),%eax
f011089a:	83 c0 04             	add    $0x4,%eax
f011089d:	50                   	push   %eax
f011089e:	68 7c 9d 12 f0       	push   $0xf0129d7c
f01108a3:	6a 3b                	push   $0x3b
f01108a5:	68 65 9d 12 f0       	push   $0xf0129d65
f01108aa:	e8 8a fa fe ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f01108af:	8b 45 08             	mov    0x8(%ebp),%eax
f01108b2:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f01108b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01108bc:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f01108c3:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f01108c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01108cb:	8b 55 08             	mov    0x8(%ebp),%edx
f01108ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f01108d4:	e8 23 70 ff ff       	call   f01078fc <popcli>
}
f01108d9:	90                   	nop
f01108da:	c9                   	leave  
f01108db:	c3                   	ret    

f01108dc <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f01108dc:	55                   	push   %ebp
f01108dd:	89 e5                	mov    %esp,%ebp
f01108df:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f01108e2:	e8 5d b6 ff ff       	call   f010bf44 <get_cpu_proc>
f01108e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f01108ea:	e8 f8 6e ff ff       	call   f01077e7 <mycpu>
f01108ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f01108f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01108f5:	83 e8 08             	sub    $0x8,%eax
f01108f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f01108fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0110902:	eb 67                	jmp    f011096b <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f0110904:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110908:	74 67                	je     f0110971 <getcallerpcs+0x95>
f011090a:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f0110911:	76 5e                	jbe    f0110971 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f0110913:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110916:	8b 40 08             	mov    0x8(%eax),%eax
f0110919:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f011091e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110921:	77 10                	ja     f0110933 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f0110923:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110926:	8b 40 08             	mov    0x8(%eax),%eax
f0110929:	05 00 90 00 00       	add    $0x9000,%eax
f011092e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110931:	77 3e                	ja     f0110971 <getcallerpcs+0x95>
f0110933:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110937:	74 10                	je     f0110949 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f0110939:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011093c:	8b 40 70             	mov    0x70(%eax),%eax
f011093f:	05 00 80 00 00       	add    $0x8000,%eax
f0110944:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110947:	76 28                	jbe    f0110971 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f0110949:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011094c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110953:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110956:	01 c2                	add    %eax,%edx
f0110958:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011095b:	8b 40 04             	mov    0x4(%eax),%eax
f011095e:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f0110960:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110963:	8b 00                	mov    (%eax),%eax
f0110965:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f0110968:	ff 45 f0             	incl   -0x10(%ebp)
f011096b:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011096f:	7e 93                	jle    f0110904 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f0110971:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110974:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f0110977:	eb 18                	jmp    f0110991 <getcallerpcs+0xb5>
		pcs[i] = 0;
f0110979:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011097c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110983:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110986:	01 d0                	add    %edx,%eax
f0110988:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f011098e:	ff 45 f0             	incl   -0x10(%ebp)
f0110991:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0110995:	7e e2                	jle    f0110979 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f0110997:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f011099a:	c9                   	leave  
f011099b:	c3                   	ret    

f011099c <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f011099c:	55                   	push   %ebp
f011099d:	89 e5                	mov    %esp,%ebp
f011099f:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f01109a2:	83 ec 0c             	sub    $0xc,%esp
f01109a5:	68 ba 9d 12 f0       	push   $0xf0129dba
f01109aa:	e8 dc 05 ff ff       	call   f0100f8b <cprintf>
f01109af:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f01109b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01109b5:	83 c0 48             	add    $0x48,%eax
f01109b8:	83 ec 08             	sub    $0x8,%esp
f01109bb:	50                   	push   %eax
f01109bc:	8d 45 08             	lea    0x8(%ebp),%eax
f01109bf:	50                   	push   %eax
f01109c0:	e8 17 ff ff ff       	call   f01108dc <getcallerpcs>
f01109c5:	83 c4 10             	add    $0x10,%esp
f01109c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f01109cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01109d2:	eb 24                	jmp    f01109f8 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f01109d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01109d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01109da:	83 c2 10             	add    $0x10,%edx
f01109dd:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f01109e1:	83 ec 04             	sub    $0x4,%esp
f01109e4:	50                   	push   %eax
f01109e5:	ff 75 f4             	pushl  -0xc(%ebp)
f01109e8:	68 ca 9d 12 f0       	push   $0xf0129dca
f01109ed:	e8 99 05 ff ff       	call   f0100f8b <cprintf>
f01109f2:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f01109f5:	ff 45 f4             	incl   -0xc(%ebp)
f01109f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01109fb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01109fe:	7c d4                	jl     f01109d4 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f0110a00:	90                   	nop
f0110a01:	c9                   	leave  
f0110a02:	c3                   	ret    

f0110a03 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f0110a03:	55                   	push   %ebp
f0110a04:	89 e5                	mov    %esp,%ebp
f0110a06:	53                   	push   %ebx
f0110a07:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f0110a0a:	e8 9b 6e ff ff       	call   f01078aa <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f0110a0f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a12:	8b 00                	mov    (%eax),%eax
f0110a14:	85 c0                	test   %eax,%eax
f0110a16:	74 16                	je     f0110a2e <holding_spinlock+0x2b>
f0110a18:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a1b:	8b 58 44             	mov    0x44(%eax),%ebx
f0110a1e:	e8 c4 6d ff ff       	call   f01077e7 <mycpu>
f0110a23:	39 c3                	cmp    %eax,%ebx
f0110a25:	75 07                	jne    f0110a2e <holding_spinlock+0x2b>
f0110a27:	b8 01 00 00 00       	mov    $0x1,%eax
f0110a2c:	eb 05                	jmp    f0110a33 <holding_spinlock+0x30>
f0110a2e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a33:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f0110a36:	e8 c1 6e ff ff       	call   f01078fc <popcli>
	return r;
f0110a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110a3e:	83 c4 14             	add    $0x14,%esp
f0110a41:	5b                   	pop    %ebx
f0110a42:	5d                   	pop    %ebp
f0110a43:	c3                   	ret    

f0110a44 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f0110a44:	55                   	push   %ebp
f0110a45:	89 e5                	mov    %esp,%ebp
f0110a47:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f0110a4a:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a4d:	83 c0 74             	add    $0x74,%eax
f0110a50:	83 ec 08             	sub    $0x8,%esp
f0110a53:	68 d9 9d 12 f0       	push   $0xf0129dd9
f0110a58:	50                   	push   %eax
f0110a59:	e8 4d 01 00 00       	call   f0110bab <init_channel>
f0110a5e:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f0110a61:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a64:	83 c0 04             	add    $0x4,%eax
f0110a67:	83 ec 08             	sub    $0x8,%esp
f0110a6a:	68 ec 9d 12 f0       	push   $0xf0129dec
f0110a6f:	50                   	push   %eax
f0110a70:	e8 44 fd ff ff       	call   f01107b9 <init_spinlock>
f0110a75:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f0110a78:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a7b:	05 c4 00 00 00       	add    $0xc4,%eax
f0110a80:	83 ec 08             	sub    $0x8,%esp
f0110a83:	ff 75 0c             	pushl  0xc(%ebp)
f0110a86:	50                   	push   %eax
f0110a87:	e8 fe 14 01 00       	call   f0121f8a <strcpy>
f0110a8c:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f0110a8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a92:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f0110a98:	8b 45 08             	mov    0x8(%ebp),%eax
f0110a9b:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f0110aa2:	00 00 00 
}
f0110aa5:	90                   	nop
f0110aa6:	c9                   	leave  
f0110aa7:	c3                   	ret    

f0110aa8 <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk)
{
f0110aa8:	55                   	push   %ebp
f0110aa9:	89 e5                	mov    %esp,%ebp
f0110aab:	53                   	push   %ebx
f0110aac:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f0110aaf:	8b 45 08             	mov    0x8(%ebp),%eax
f0110ab2:	83 c0 04             	add    $0x4,%eax
f0110ab5:	83 ec 0c             	sub    $0xc,%esp
f0110ab8:	50                   	push   %eax
f0110ab9:	e8 2c fd ff ff       	call   f01107ea <acquire_spinlock>
f0110abe:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f0110ac1:	8b 45 08             	mov    0x8(%ebp),%eax
f0110ac4:	8b 00                	mov    (%eax),%eax
f0110ac6:	85 c0                	test   %eax,%eax
f0110ac8:	74 1c                	je     f0110ae6 <holding_sleeplock+0x3e>
f0110aca:	8b 45 08             	mov    0x8(%ebp),%eax
f0110acd:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f0110ad3:	e8 6c b4 ff ff       	call   f010bf44 <get_cpu_proc>
f0110ad8:	8b 40 10             	mov    0x10(%eax),%eax
f0110adb:	39 c3                	cmp    %eax,%ebx
f0110add:	75 07                	jne    f0110ae6 <holding_sleeplock+0x3e>
f0110adf:	b8 01 00 00 00       	mov    $0x1,%eax
f0110ae4:	eb 05                	jmp    f0110aeb <holding_sleeplock+0x43>
f0110ae6:	b8 00 00 00 00       	mov    $0x0,%eax
f0110aeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f0110aee:	8b 45 08             	mov    0x8(%ebp),%eax
f0110af1:	83 c0 04             	add    $0x4,%eax
f0110af4:	83 ec 0c             	sub    $0xc,%esp
f0110af7:	50                   	push   %eax
f0110af8:	e8 74 fd ff ff       	call   f0110871 <release_spinlock>
f0110afd:	83 c4 10             	add    $0x10,%esp
	return r;
f0110b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0110b03:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110b06:	c9                   	leave  
f0110b07:	c3                   	ret    

f0110b08 <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f0110b08:	55                   	push   %ebp
f0110b09:	89 e5                	mov    %esp,%ebp
f0110b0b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
		//COMMENT THE FOLLOWING LINE BEFORE START CODING
		//panic("acquire_sleeplock is not implemented yet");
		//Your Code is Here...
	acquire_spinlock(&(lk->lk));
f0110b0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b11:	83 c0 04             	add    $0x4,%eax
f0110b14:	83 ec 0c             	sub    $0xc,%esp
f0110b17:	50                   	push   %eax
f0110b18:	e8 cd fc ff ff       	call   f01107ea <acquire_spinlock>
f0110b1d:	83 c4 10             	add    $0x10,%esp
	while(lk->locked == 1)// If the sleep lock is busy then block the running process
f0110b20:	eb 19                	jmp    f0110b3b <acquire_sleeplock+0x33>
	{
		sleep(&(lk->chan), &(lk->lk));// Takes a reference to the sleep lock of the current channel
f0110b22:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b25:	8d 50 04             	lea    0x4(%eax),%edx
f0110b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b2b:	83 c0 74             	add    $0x74,%eax
f0110b2e:	83 ec 08             	sub    $0x8,%esp
f0110b31:	52                   	push   %edx
f0110b32:	50                   	push   %eax
f0110b33:	e8 a0 00 00 00       	call   f0110bd8 <sleep>
f0110b38:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
		//COMMENT THE FOLLOWING LINE BEFORE START CODING
		//panic("acquire_sleeplock is not implemented yet");
		//Your Code is Here...
	acquire_spinlock(&(lk->lk));
	while(lk->locked == 1)// If the sleep lock is busy then block the running process
f0110b3b:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b3e:	8b 00                	mov    (%eax),%eax
f0110b40:	83 f8 01             	cmp    $0x1,%eax
f0110b43:	74 dd                	je     f0110b22 <acquire_sleeplock+0x1a>
	{
		sleep(&(lk->chan), &(lk->lk));// Takes a reference to the sleep lock of the current channel
									  // and a reference to the spin lock (guard) of the sleep lock
	}

	lk->locked = 1; // If the sleep lock is free then one process will make it busy (=1)
f0110b45:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b48:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	release_spinlock(&(lk->lk));
f0110b4e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b51:	83 c0 04             	add    $0x4,%eax
f0110b54:	83 ec 0c             	sub    $0xc,%esp
f0110b57:	50                   	push   %eax
f0110b58:	e8 14 fd ff ff       	call   f0110871 <release_spinlock>
f0110b5d:	83 c4 10             	add    $0x10,%esp

}
f0110b60:	90                   	nop
f0110b61:	c9                   	leave  
f0110b62:	c3                   	ret    

f0110b63 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f0110b63:	55                   	push   %ebp
f0110b64:	89 e5                	mov    %esp,%ebp
f0110b66:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&(lk->lk));
f0110b69:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b6c:	83 c0 04             	add    $0x4,%eax
f0110b6f:	83 ec 0c             	sub    $0xc,%esp
f0110b72:	50                   	push   %eax
f0110b73:	e8 72 fc ff ff       	call   f01107ea <acquire_spinlock>
f0110b78:	83 c4 10             	add    $0x10,%esp
	wakeup_all(&(lk->chan)); // Change the status of all processes to be ready
f0110b7b:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b7e:	83 c0 74             	add    $0x74,%eax
f0110b81:	83 ec 0c             	sub    $0xc,%esp
f0110b84:	50                   	push   %eax
f0110b85:	e8 31 01 00 00       	call   f0110cbb <wakeup_all>
f0110b8a:	83 c4 10             	add    $0x10,%esp
	lk->locked=0; // Free the sleep lock
f0110b8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b90:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	release_spinlock(&(lk->lk));
f0110b96:	8b 45 08             	mov    0x8(%ebp),%eax
f0110b99:	83 c0 04             	add    $0x4,%eax
f0110b9c:	83 ec 0c             	sub    $0xc,%esp
f0110b9f:	50                   	push   %eax
f0110ba0:	e8 cc fc ff ff       	call   f0110871 <release_spinlock>
f0110ba5:	83 c4 10             	add    $0x10,%esp
}
f0110ba8:	90                   	nop
f0110ba9:	c9                   	leave  
f0110baa:	c3                   	ret    

f0110bab <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110bab:	55                   	push   %ebp
f0110bac:	89 e5                	mov    %esp,%ebp
f0110bae:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f0110bb1:	8b 45 08             	mov    0x8(%ebp),%eax
f0110bb4:	83 c0 10             	add    $0x10,%eax
f0110bb7:	83 ec 08             	sub    $0x8,%esp
f0110bba:	ff 75 0c             	pushl  0xc(%ebp)
f0110bbd:	50                   	push   %eax
f0110bbe:	e8 c7 13 01 00       	call   f0121f8a <strcpy>
f0110bc3:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f0110bc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0110bc9:	83 ec 0c             	sub    $0xc,%esp
f0110bcc:	50                   	push   %eax
f0110bcd:	e8 aa 45 ff ff       	call   f010517c <init_queue>
f0110bd2:	83 c4 10             	add    $0x10,%esp
}
f0110bd5:	90                   	nop
f0110bd6:	c9                   	leave  
f0110bd7:	c3                   	ret    

f0110bd8 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f0110bd8:	55                   	push   %ebp
f0110bd9:	89 e5                	mov    %esp,%ebp
f0110bdb:	83 ec 18             	sub    $0x18,%esp

	struct Env *sara = get_cpu_proc(); //Get the current running process as
f0110bde:	e8 61 b3 ff ff       	call   f010bf44 <get_cpu_proc>
f0110be3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//it's the one that needs to be blocked not the head of the ready queue and saving it in the sara pointer

	acquire_spinlock(&ProcessQueues.qlock);//Acquire the spin lock to protect the process queues
f0110be6:	83 ec 0c             	sub    $0xc,%esp
f0110be9:	68 00 58 74 f0       	push   $0xf0745800
f0110bee:	e8 f7 fb ff ff       	call   f01107ea <acquire_spinlock>
f0110bf3:	83 c4 10             	add    $0x10,%esp
	release_spinlock(lk);// Release the spin lock of the current running process
f0110bf6:	83 ec 0c             	sub    $0xc,%esp
f0110bf9:	ff 75 0c             	pushl  0xc(%ebp)
f0110bfc:	e8 70 fc ff ff       	call   f0110871 <release_spinlock>
f0110c01:	83 c4 10             	add    $0x10,%esp
						 // That was passed to the sleep function before blocking this process

	sara->env_status = ENV_BLOCKED;// Blocking the running process
f0110c04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c07:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
	enqueue(&chan->queue, sara);// Enqueue the blocked process in the chan->queue
f0110c0e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110c11:	83 ec 08             	sub    $0x8,%esp
f0110c14:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c17:	50                   	push   %eax
f0110c18:	e8 a0 45 ff ff       	call   f01051bd <enqueue>
f0110c1d:	83 c4 10             	add    $0x10,%esp

	sched(); // Schedule another ready process to be running and context switch from the previous running one
f0110c20:	e8 99 b4 ff ff       	call   f010c0be <sched>
	acquire_spinlock(lk);// As I scheduled a new to process to be running then I need to reacquire the guard
f0110c25:	83 ec 0c             	sub    $0xc,%esp
f0110c28:	ff 75 0c             	pushl  0xc(%ebp)
f0110c2b:	e8 ba fb ff ff       	call   f01107ea <acquire_spinlock>
f0110c30:	83 c4 10             	add    $0x10,%esp

	release_spinlock(&ProcessQueues.qlock);// Release the spin lock of that was protecting the process queues
f0110c33:	83 ec 0c             	sub    $0xc,%esp
f0110c36:	68 00 58 74 f0       	push   $0xf0745800
f0110c3b:	e8 31 fc ff ff       	call   f0110871 <release_spinlock>
f0110c40:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...
}
f0110c43:	90                   	nop
f0110c44:	c9                   	leave  
f0110c45:	c3                   	ret    

f0110c46 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f0110c46:	55                   	push   %ebp
f0110c47:	89 e5                	mov    %esp,%ebp
f0110c49:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&ProcessQueues.qlock);
f0110c4c:	83 ec 0c             	sub    $0xc,%esp
f0110c4f:	68 00 58 74 f0       	push   $0xf0745800
f0110c54:	e8 91 fb ff ff       	call   f01107ea <acquire_spinlock>
f0110c59:	83 c4 10             	add    $0x10,%esp

	if (chan->queue.size != 0 ) // Make sure that the queue is not empty to wake up one blocked process
f0110c5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0110c5f:	8b 40 0c             	mov    0xc(%eax),%eax
f0110c62:	85 c0                	test   %eax,%eax
f0110c64:	74 32                	je     f0110c98 <wakeup_one+0x52>
	{

		struct Env *sara= dequeue(&chan->queue); // Taking the front process in the queue to be awaken
f0110c66:	8b 45 08             	mov    0x8(%ebp),%eax
f0110c69:	83 ec 0c             	sub    $0xc,%esp
f0110c6c:	50                   	push   %eax
f0110c6d:	e8 dc 45 ff ff       	call   f010524e <dequeue>
f0110c72:	83 c4 10             	add    $0x10,%esp
f0110c75:	89 45 f4             	mov    %eax,-0xc(%ebp)
		sara->env_status = ENV_READY;
f0110c78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110c7b:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
	    enqueue(&ProcessQueues.env_ready_queues[0], sara); // Enqueue the awaken (ready) process to the ready queue in the highest priority index [0]
f0110c82:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0110c87:	83 ec 08             	sub    $0x8,%esp
f0110c8a:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c8d:	50                   	push   %eax
f0110c8e:	e8 2a 45 ff ff       	call   f01051bd <enqueue>
f0110c93:	83 c4 10             	add    $0x10,%esp
f0110c96:	eb 10                	jmp    f0110ca8 <wakeup_one+0x62>
		//sched_insert_ready(sara);
	}
	else
		cprintf("There is nothing to be awaken\n"); // This message will be printed if the chan->queue is empty
f0110c98:	83 ec 0c             	sub    $0xc,%esp
f0110c9b:	68 00 9e 12 f0       	push   $0xf0129e00
f0110ca0:	e8 e6 02 ff ff       	call   f0100f8b <cprintf>
f0110ca5:	83 c4 10             	add    $0x10,%esp
	release_spinlock(&ProcessQueues.qlock);
f0110ca8:	83 ec 0c             	sub    $0xc,%esp
f0110cab:	68 00 58 74 f0       	push   $0xf0745800
f0110cb0:	e8 bc fb ff ff       	call   f0110871 <release_spinlock>
f0110cb5:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("wakeup_one is not implemented yet");
	//Your Code is Here...
}
f0110cb8:	90                   	nop
f0110cb9:	c9                   	leave  
f0110cba:	c3                   	ret    

f0110cbb <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f0110cbb:	55                   	push   %ebp
f0110cbc:	89 e5                	mov    %esp,%ebp
f0110cbe:	83 ec 18             	sub    $0x18,%esp
	//panic("wakeup_all is not implemented yet");
	//Your Code is Here...

	// Same logic of the wakeup_one
	// The only difference is that in the wakeup_all we use a loop instead of an if condition
	acquire_spinlock(&ProcessQueues.qlock);
f0110cc1:	83 ec 0c             	sub    $0xc,%esp
f0110cc4:	68 00 58 74 f0       	push   $0xf0745800
f0110cc9:	e8 1c fb ff ff       	call   f01107ea <acquire_spinlock>
f0110cce:	83 c4 10             	add    $0x10,%esp
	while (chan->queue.size != 0 )
f0110cd1:	eb 30                	jmp    f0110d03 <wakeup_all+0x48>
	{

		struct Env *sara= dequeue(&chan->queue);
f0110cd3:	8b 45 08             	mov    0x8(%ebp),%eax
f0110cd6:	83 ec 0c             	sub    $0xc,%esp
f0110cd9:	50                   	push   %eax
f0110cda:	e8 6f 45 ff ff       	call   f010524e <dequeue>
f0110cdf:	83 c4 10             	add    $0x10,%esp
f0110ce2:	89 45 f4             	mov    %eax,-0xc(%ebp)

           sara->env_status = ENV_READY;
f0110ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ce8:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		   enqueue(&ProcessQueues.env_ready_queues[0], sara);
f0110cef:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0110cf4:	83 ec 08             	sub    $0x8,%esp
f0110cf7:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cfa:	50                   	push   %eax
f0110cfb:	e8 bd 44 ff ff       	call   f01051bd <enqueue>
f0110d00:	83 c4 10             	add    $0x10,%esp
	//Your Code is Here...

	// Same logic of the wakeup_one
	// The only difference is that in the wakeup_all we use a loop instead of an if condition
	acquire_spinlock(&ProcessQueues.qlock);
	while (chan->queue.size != 0 )
f0110d03:	8b 45 08             	mov    0x8(%ebp),%eax
f0110d06:	8b 40 0c             	mov    0xc(%eax),%eax
f0110d09:	85 c0                	test   %eax,%eax
f0110d0b:	75 c6                	jne    f0110cd3 <wakeup_all+0x18>
           sara->env_status = ENV_READY;
		   enqueue(&ProcessQueues.env_ready_queues[0], sara);
   		//sched_insert_ready(sara);

	}
	release_spinlock(&ProcessQueues.qlock);
f0110d0d:	83 ec 0c             	sub    $0xc,%esp
f0110d10:	68 00 58 74 f0       	push   $0xf0745800
f0110d15:	e8 57 fb ff ff       	call   f0110871 <release_spinlock>
f0110d1a:	83 c4 10             	add    $0x10,%esp


}
f0110d1d:	90                   	nop
f0110d1e:	c9                   	leave  
f0110d1f:	c3                   	ret    

f0110d20 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f0110d20:	55                   	push   %ebp
f0110d21:	89 e5                	mov    %esp,%ebp
f0110d23:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f0110d26:	83 ec 04             	sub    $0x4,%esp
f0110d29:	68 20 9e 12 f0       	push   $0xf0129e20
f0110d2e:	6a 13                	push   $0x13
f0110d30:	68 47 9e 12 f0       	push   $0xf0129e47
f0110d35:	e8 ff f5 fe ff       	call   f0100339 <_panic>

f0110d3a <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110d3a:	55                   	push   %ebp
f0110d3b:	89 e5                	mov    %esp,%ebp
f0110d3d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f0110d40:	83 ec 04             	sub    $0x4,%esp
f0110d43:	68 60 9e 12 f0       	push   $0xf0129e60
f0110d48:	6a 1b                	push   $0x1b
f0110d4a:	68 47 9e 12 f0       	push   $0xf0129e47
f0110d4f:	e8 e5 f5 fe ff       	call   f0100339 <_panic>

f0110d54 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f0110d54:	55                   	push   %ebp
f0110d55:	89 e5                	mov    %esp,%ebp
f0110d57:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f0110d5a:	83 ec 04             	sub    $0x4,%esp
f0110d5d:	68 88 9e 12 f0       	push   $0xf0129e88
f0110d62:	6a 24                	push   $0x24
f0110d64:	68 47 9e 12 f0       	push   $0xf0129e47
f0110d69:	e8 cb f5 fe ff       	call   f0100339 <_panic>

f0110d6e <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0110d6e:	55                   	push   %ebp
f0110d6f:	89 e5                	mov    %esp,%ebp
f0110d71:	c7 05 90 5d 74 f0 01 	movl   $0x1,0xf0745d90
f0110d78:	00 00 00 
f0110d7b:	90                   	nop
f0110d7c:	5d                   	pop    %ebp
f0110d7d:	c3                   	ret    

f0110d7e <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0110d7e:	55                   	push   %ebp
f0110d7f:	89 e5                	mov    %esp,%ebp
f0110d81:	c7 05 90 5d 74 f0 02 	movl   $0x2,0xf0745d90
f0110d88:	00 00 00 
f0110d8b:	90                   	nop
f0110d8c:	5d                   	pop    %ebp
f0110d8d:	c3                   	ret    

f0110d8e <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0110d8e:	55                   	push   %ebp
f0110d8f:	89 e5                	mov    %esp,%ebp
f0110d91:	c7 05 90 5d 74 f0 03 	movl   $0x3,0xf0745d90
f0110d98:	00 00 00 
f0110d9b:	90                   	nop
f0110d9c:	5d                   	pop    %ebp
f0110d9d:	c3                   	ret    

f0110d9e <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0110d9e:	55                   	push   %ebp
f0110d9f:	89 e5                	mov    %esp,%ebp
f0110da1:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f0110da6:	83 f8 01             	cmp    $0x1,%eax
f0110da9:	75 04                	jne    f0110daf <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0110dab:	b0 01                	mov    $0x1,%al
f0110dad:	eb 02                	jmp    f0110db1 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0110daf:	b0 00                	mov    $0x0,%al
f0110db1:	5d                   	pop    %ebp
f0110db2:	c3                   	ret    

f0110db3 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f0110db3:	55                   	push   %ebp
f0110db4:	89 e5                	mov    %esp,%ebp
f0110db6:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f0110dbb:	83 f8 02             	cmp    $0x2,%eax
f0110dbe:	75 04                	jne    f0110dc4 <isKHeapPlacementStrategyBESTFIT+0x11>
f0110dc0:	b0 01                	mov    $0x1,%al
f0110dc2:	eb 02                	jmp    f0110dc6 <isKHeapPlacementStrategyBESTFIT+0x13>
f0110dc4:	b0 00                	mov    $0x0,%al
f0110dc6:	5d                   	pop    %ebp
f0110dc7:	c3                   	ret    

f0110dc8 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0110dc8:	55                   	push   %ebp
f0110dc9:	89 e5                	mov    %esp,%ebp
f0110dcb:	a1 90 5d 74 f0       	mov    0xf0745d90,%eax
f0110dd0:	83 f8 03             	cmp    $0x3,%eax
f0110dd3:	75 04                	jne    f0110dd9 <isKHeapPlacementStrategyNEXTFIT+0x11>
f0110dd5:	b0 01                	mov    $0x1,%al
f0110dd7:	eb 02                	jmp    f0110ddb <isKHeapPlacementStrategyNEXTFIT+0x13>
f0110dd9:	b0 00                	mov    $0x0,%al
f0110ddb:	5d                   	pop    %ebp
f0110ddc:	c3                   	ret    

f0110ddd <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110ddd:	55                   	push   %ebp
f0110dde:	89 e5                	mov    %esp,%ebp
f0110de0:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110de3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110dea:	eb 26                	jmp    f0110e12 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110dec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110def:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110df6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110df9:	01 c2                	add    %eax,%edx
f0110dfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110dfe:	40                   	inc    %eax
f0110dff:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110e06:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e09:	01 c8                	add    %ecx,%eax
f0110e0b:	8b 00                	mov    (%eax),%eax
f0110e0d:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110e0f:	ff 45 f4             	incl   -0xc(%ebp)
f0110e12:	8b 45 08             	mov    0x8(%ebp),%eax
f0110e15:	48                   	dec    %eax
f0110e16:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110e19:	7f d1                	jg     f0110dec <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f0110e1b:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f0110e1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110e25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0110e2c:	eb 35                	jmp    f0110e63 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f0110e2e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110e31:	89 d0                	mov    %edx,%eax
f0110e33:	01 c0                	add    %eax,%eax
f0110e35:	01 d0                	add    %edx,%eax
f0110e37:	c1 e0 02             	shl    $0x2,%eax
f0110e3a:	05 80 3d 18 f0       	add    $0xf0183d80,%eax
f0110e3f:	8b 10                	mov    (%eax),%edx
f0110e41:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e44:	8b 00                	mov    (%eax),%eax
f0110e46:	83 ec 08             	sub    $0x8,%esp
f0110e49:	52                   	push   %edx
f0110e4a:	50                   	push   %eax
f0110e4b:	e8 f7 11 01 00       	call   f0122047 <strcmp>
f0110e50:	83 c4 10             	add    $0x10,%esp
f0110e53:	85 c0                	test   %eax,%eax
f0110e55:	75 09                	jne    f0110e60 <tst_handler+0x83>
		{
			test_found = 1;
f0110e57:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f0110e5e:	eb 0f                	jmp    f0110e6f <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f0110e60:	ff 45 ec             	incl   -0x14(%ebp)
f0110e63:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110e66:	a1 34 3e 18 f0       	mov    0xf0183e34,%eax
f0110e6b:	39 c2                	cmp    %eax,%edx
f0110e6d:	72 bf                	jb     f0110e2e <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f0110e6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e73:	74 29                	je     f0110e9e <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f0110e75:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110e78:	89 d0                	mov    %edx,%eax
f0110e7a:	01 c0                	add    %eax,%eax
f0110e7c:	01 d0                	add    %edx,%eax
f0110e7e:	c1 e0 02             	shl    $0x2,%eax
f0110e81:	05 88 3d 18 f0       	add    $0xf0183d88,%eax
f0110e86:	8b 00                	mov    (%eax),%eax
f0110e88:	83 ec 08             	sub    $0x8,%esp
f0110e8b:	ff 75 0c             	pushl  0xc(%ebp)
f0110e8e:	ff 75 08             	pushl  0x8(%ebp)
f0110e91:	ff d0                	call   *%eax
f0110e93:	83 c4 10             	add    $0x10,%esp
f0110e96:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110e99:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110e9c:	eb 1b                	jmp    f0110eb9 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ea1:	8b 00                	mov    (%eax),%eax
f0110ea3:	83 ec 08             	sub    $0x8,%esp
f0110ea6:	50                   	push   %eax
f0110ea7:	68 c8 a1 12 f0       	push   $0xf012a1c8
f0110eac:	e8 da 00 ff ff       	call   f0100f8b <cprintf>
f0110eb1:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110eb4:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110eb9:	c9                   	leave  
f0110eba:	c3                   	ret    

f0110ebb <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110ebb:	55                   	push   %ebp
f0110ebc:	89 e5                	mov    %esp,%ebp
f0110ebe:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f0110ec1:	e8 48 d0 00 00       	call   f011df0e <test_three_creation_functions>
	return 0;
f0110ec6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110ecb:	c9                   	leave  
f0110ecc:	c3                   	ret    

f0110ecd <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110ecd:	55                   	push   %ebp
f0110ece:	89 e5                	mov    %esp,%ebp
f0110ed0:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f0110ed3:	e8 03 69 00 00       	call   f01177db <test_priority_normal_and_higher>
	return 0;
f0110ed8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110edd:	c9                   	leave  
f0110ede:	c3                   	ret    

f0110edf <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110edf:	55                   	push   %ebp
f0110ee0:	89 e5                	mov    %esp,%ebp
f0110ee2:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f0110ee5:	e8 0b 69 00 00       	call   f01177f5 <test_priority_normal_and_lower>
	return 0;
f0110eea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110eef:	c9                   	leave  
f0110ef0:	c3                   	ret    

f0110ef1 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f0110ef1:	55                   	push   %ebp
f0110ef2:	89 e5                	mov    %esp,%ebp
f0110ef4:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0110ef7:	e8 c5 d1 00 00       	call   f011e0c1 <test_kfreeall>
	return 0;
f0110efc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f01:	c9                   	leave  
f0110f02:	c3                   	ret    

f0110f03 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f0110f03:	55                   	push   %ebp
f0110f04:	89 e5                	mov    %esp,%ebp
f0110f06:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110f09:	e8 d0 d1 00 00       	call   f011e0de <test_kexpand>
	return 0;
f0110f0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f13:	c9                   	leave  
f0110f14:	c3                   	ret    

f0110f15 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f0110f15:	55                   	push   %ebp
f0110f16:	89 e5                	mov    %esp,%ebp
f0110f18:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f0110f1b:	e8 db d1 00 00       	call   f011e0fb <test_kshrink>
	return 0;
f0110f20:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f25:	c9                   	leave  
f0110f26:	c3                   	ret    

f0110f27 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f0110f27:	55                   	push   %ebp
f0110f28:	89 e5                	mov    %esp,%ebp
f0110f2a:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f0110f2d:	e8 e6 d1 00 00       	call   f011e118 <test_kfreelast>
	return 0;
f0110f32:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110f37:	c9                   	leave  
f0110f38:	c3                   	ret    

f0110f39 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f0110f39:	55                   	push   %ebp
f0110f3a:	89 e5                	mov    %esp,%ebp
f0110f3c:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f0110f3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f42:	83 c0 04             	add    $0x4,%eax
f0110f45:	8b 00                	mov    (%eax),%eax
f0110f47:	83 ec 04             	sub    $0x4,%esp
f0110f4a:	6a 0a                	push   $0xa
f0110f4c:	6a 00                	push   $0x0
f0110f4e:	50                   	push   %eax
f0110f4f:	e8 47 13 01 00       	call   f012229b <strtol>
f0110f54:	83 c4 10             	add    $0x10,%esp
f0110f57:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f0110f5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f0110f61:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f0110f68:	83 ec 0c             	sub    $0xc,%esp
f0110f6b:	68 00 58 74 f0       	push   $0xf0745800
f0110f70:	e8 75 f8 ff ff       	call   f01107ea <acquire_spinlock>
f0110f75:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110f78:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f0110f7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110f80:	eb 3b                	jmp    f0110fbd <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f0110f82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110f85:	83 c0 20             	add    $0x20,%eax
f0110f88:	83 ec 08             	sub    $0x8,%esp
f0110f8b:	68 db a1 12 f0       	push   $0xf012a1db
f0110f90:	50                   	push   %eax
f0110f91:	e8 b1 10 01 00       	call   f0122047 <strcmp>
f0110f96:	83 c4 10             	add    $0x10,%esp
f0110f99:	85 c0                	test   %eax,%eax
f0110f9b:	75 12                	jne    f0110faf <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110f9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110fa1:	74 07                	je     f0110faa <tst_sc_MLFQ+0x71>
					firstTime = 0;
f0110fa3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110faa:	ff 45 f4             	incl   -0xc(%ebp)
f0110fad:	eb 06                	jmp    f0110fb5 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0110faf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110fb3:	74 31                	je     f0110fe6 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110fb5:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0110fba:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110fbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110fc1:	74 08                	je     f0110fcb <tst_sc_MLFQ+0x92>
f0110fc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110fc6:	8b 40 08             	mov    0x8(%eax),%eax
f0110fc9:	eb 05                	jmp    f0110fd0 <tst_sc_MLFQ+0x97>
f0110fcb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fd0:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f0110fd5:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0110fda:	85 c0                	test   %eax,%eax
f0110fdc:	75 a4                	jne    f0110f82 <tst_sc_MLFQ+0x49>
f0110fde:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110fe2:	75 9e                	jne    f0110f82 <tst_sc_MLFQ+0x49>
f0110fe4:	eb 01                	jmp    f0110fe7 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f0110fe6:	90                   	nop
			}
		if(cnt == numOfSlave2)
f0110fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110fed:	75 12                	jne    f0111001 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110fef:	83 ec 0c             	sub    $0xc,%esp
f0110ff2:	68 e4 a1 12 f0       	push   $0xf012a1e4
f0110ff7:	e8 8f ff fe ff       	call   f0100f8b <cprintf>
f0110ffc:	83 c4 10             	add    $0x10,%esp
f0110fff:	eb 17                	jmp    f0111018 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f0111001:	83 ec 04             	sub    $0x4,%esp
f0111004:	68 1d a2 12 f0       	push   $0xf012a21d
f0111009:	68 9b 00 00 00       	push   $0x9b
f011100e:	68 33 a2 12 f0       	push   $0xf012a233
f0111013:	e8 21 f3 fe ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0111018:	83 ec 0c             	sub    $0xc,%esp
f011101b:	68 00 58 74 f0       	push   $0xf0745800
f0111020:	e8 4c f8 ff ff       	call   f0110871 <release_spinlock>
f0111025:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111028:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011102d:	c9                   	leave  
f011102e:	c3                   	ret    

f011102f <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f011102f:	55                   	push   %ebp
f0111030:	89 e5                	mov    %esp,%ebp
f0111032:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0111035:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0111039:	74 17                	je     f0111052 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f011103b:	83 ec 0c             	sub    $0xc,%esp
f011103e:	68 4c a2 12 f0       	push   $0xf012a24c
f0111043:	e8 43 ff fe ff       	call   f0100f8b <cprintf>
f0111048:	83 c4 10             	add    $0x10,%esp
		return 0;
f011104b:	b8 00 00 00 00       	mov    $0x0,%eax
f0111050:	eb 45                	jmp    f0111097 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0111052:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111055:	83 c0 04             	add    $0x4,%eax
f0111058:	8b 00                	mov    (%eax),%eax
f011105a:	83 ec 04             	sub    $0x4,%esp
f011105d:	6a 0a                	push   $0xa
f011105f:	6a 00                	push   $0x0
f0111061:	50                   	push   %eax
f0111062:	e8 34 12 01 00       	call   f012229b <strtol>
f0111067:	83 c4 10             	add    $0x10,%esp
f011106a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f011106d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111070:	83 f8 01             	cmp    $0x1,%eax
f0111073:	74 10                	je     f0111085 <tst_bsd_nice+0x56>
f0111075:	83 f8 02             	cmp    $0x2,%eax
f0111078:	74 12                	je     f011108c <tst_bsd_nice+0x5d>
f011107a:	85 c0                	test   %eax,%eax
f011107c:	75 14                	jne    f0111092 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f011107e:	e8 50 ea 00 00       	call   f011fad3 <test_bsd_nice_0>
		break;
f0111083:	eb 0d                	jmp    f0111092 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f0111085:	e8 d3 ec 00 00       	call   f011fd5d <test_bsd_nice_1>
		break;
f011108a:	eb 06                	jmp    f0111092 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f011108c:	e8 e0 ee 00 00       	call   f011ff71 <test_bsd_nice_2>
		break;
f0111091:	90                   	nop
	}
	return 0;
f0111092:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111097:	c9                   	leave  
f0111098:	c3                   	ret    

f0111099 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f0111099:	55                   	push   %ebp
f011109a:	89 e5                	mov    %esp,%ebp
f011109c:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f011109f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01110a3:	74 17                	je     f01110bc <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f01110a5:	83 ec 0c             	sub    $0xc,%esp
f01110a8:	68 8c a2 12 f0       	push   $0xf012a28c
f01110ad:	e8 d9 fe fe ff       	call   f0100f8b <cprintf>
f01110b2:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110b5:	b8 00 00 00 00       	mov    $0x0,%eax
f01110ba:	eb 0a                	jmp    f01110c6 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01110bc:	e8 3f 15 00 00       	call   f0112600 <test_str2lower_function>
	return 0;
f01110c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01110c6:	c9                   	leave  
f01110c7:	c3                   	ret    

f01110c8 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01110c8:	55                   	push   %ebp
f01110c9:	89 e5                	mov    %esp,%ebp
f01110cb:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01110ce:	e8 63 11 00 00       	call   f0112236 <TestAutoCompleteCommand>
f01110d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01110d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01110db:	c9                   	leave  
f01110dc:	c3                   	ret    

f01110dd <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01110dd:	55                   	push   %ebp
f01110de:	89 e5                	mov    %esp,%ebp
f01110e0:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01110e3:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01110e7:	74 1a                	je     f0111103 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01110e9:	83 ec 0c             	sub    $0xc,%esp
f01110ec:	68 c0 a2 12 f0       	push   $0xf012a2c0
f01110f1:	e8 95 fe fe ff       	call   f0100f8b <cprintf>
f01110f6:	83 c4 10             	add    $0x10,%esp
		return 0;
f01110f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01110fe:	e9 2f 01 00 00       	jmp    f0111232 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f0111103:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111106:	83 c0 04             	add    $0x4,%eax
f0111109:	8b 00                	mov    (%eax),%eax
f011110b:	83 ec 08             	sub    $0x8,%esp
f011110e:	68 fd a2 12 f0       	push   $0xf012a2fd
f0111113:	50                   	push   %eax
f0111114:	e8 2e 0f 01 00       	call   f0122047 <strcmp>
f0111119:	83 c4 10             	add    $0x10,%esp
f011111c:	85 c0                	test   %eax,%eax
f011111e:	75 0a                	jne    f011112a <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f0111120:	e8 40 08 00 00       	call   f0111965 <test_initialize_dynamic_allocator>
f0111125:	e9 03 01 00 00       	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f011112a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011112d:	83 c0 04             	add    $0x4,%eax
f0111130:	8b 00                	mov    (%eax),%eax
f0111132:	83 ec 08             	sub    $0x8,%esp
f0111135:	68 02 a3 12 f0       	push   $0xf012a302
f011113a:	50                   	push   %eax
f011113b:	e8 07 0f 01 00       	call   f0122047 <strcmp>
f0111140:	83 c4 10             	add    $0x10,%esp
f0111143:	85 c0                	test   %eax,%eax
f0111145:	75 0a                	jne    f0111151 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f0111147:	e8 4d 08 00 00       	call   f0111999 <test_alloc_block_FF>
f011114c:	e9 dc 00 00 00       	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f0111151:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111154:	83 c0 04             	add    $0x4,%eax
f0111157:	8b 00                	mov    (%eax),%eax
f0111159:	83 ec 08             	sub    $0x8,%esp
f011115c:	68 0a a3 12 f0       	push   $0xf012a30a
f0111161:	50                   	push   %eax
f0111162:	e8 e0 0e 01 00       	call   f0122047 <strcmp>
f0111167:	83 c4 10             	add    $0x10,%esp
f011116a:	85 c0                	test   %eax,%eax
f011116c:	75 0a                	jne    f0111178 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f011116e:	e8 43 08 00 00       	call   f01119b6 <test_alloc_block_BF>
f0111173:	e9 b5 00 00 00       	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f0111178:	8b 45 0c             	mov    0xc(%ebp),%eax
f011117b:	83 c0 04             	add    $0x4,%eax
f011117e:	8b 00                	mov    (%eax),%eax
f0111180:	83 ec 08             	sub    $0x8,%esp
f0111183:	68 12 a3 12 f0       	push   $0xf012a312
f0111188:	50                   	push   %eax
f0111189:	e8 b9 0e 01 00       	call   f0122047 <strcmp>
f011118e:	83 c4 10             	add    $0x10,%esp
f0111191:	85 c0                	test   %eax,%eax
f0111193:	75 0a                	jne    f011119f <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f0111195:	e8 3c 08 00 00       	call   f01119d6 <test_alloc_block_NF>
f011119a:	e9 8e 00 00 00       	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f011119f:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111a2:	83 c0 04             	add    $0x4,%eax
f01111a5:	8b 00                	mov    (%eax),%eax
f01111a7:	83 ec 08             	sub    $0x8,%esp
f01111aa:	68 1a a3 12 f0       	push   $0xf012a31a
f01111af:	50                   	push   %eax
f01111b0:	e8 92 0e 01 00       	call   f0122047 <strcmp>
f01111b5:	83 c4 10             	add    $0x10,%esp
f01111b8:	85 c0                	test   %eax,%eax
f01111ba:	75 07                	jne    f01111c3 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f01111bc:	e8 1b 08 00 00       	call   f01119dc <test_free_block_FF>
f01111c1:	eb 6a                	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f01111c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111c6:	83 c0 04             	add    $0x4,%eax
f01111c9:	8b 00                	mov    (%eax),%eax
f01111cb:	83 ec 08             	sub    $0x8,%esp
f01111ce:	68 21 a3 12 f0       	push   $0xf012a321
f01111d3:	50                   	push   %eax
f01111d4:	e8 6e 0e 01 00       	call   f0122047 <strcmp>
f01111d9:	83 c4 10             	add    $0x10,%esp
f01111dc:	85 c0                	test   %eax,%eax
f01111de:	75 07                	jne    f01111e7 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f01111e0:	e8 14 08 00 00       	call   f01119f9 <test_free_block_BF>
f01111e5:	eb 46                	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f01111e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111ea:	83 c0 04             	add    $0x4,%eax
f01111ed:	8b 00                	mov    (%eax),%eax
f01111ef:	83 ec 08             	sub    $0x8,%esp
f01111f2:	68 28 a3 12 f0       	push   $0xf012a328
f01111f7:	50                   	push   %eax
f01111f8:	e8 4a 0e 01 00       	call   f0122047 <strcmp>
f01111fd:	83 c4 10             	add    $0x10,%esp
f0111200:	85 c0                	test   %eax,%eax
f0111202:	75 07                	jne    f011120b <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f0111204:	e8 0d 08 00 00       	call   f0111a16 <test_free_block_NF>
f0111209:	eb 22                	jmp    f011122d <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f011120b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011120e:	83 c0 04             	add    $0x4,%eax
f0111211:	8b 00                	mov    (%eax),%eax
f0111213:	83 ec 08             	sub    $0x8,%esp
f0111216:	68 2f a3 12 f0       	push   $0xf012a32f
f011121b:	50                   	push   %eax
f011121c:	e8 26 0e 01 00       	call   f0122047 <strcmp>
f0111221:	83 c4 10             	add    $0x10,%esp
f0111224:	85 c0                	test   %eax,%eax
f0111226:	75 05                	jne    f011122d <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f0111228:	e8 06 08 00 00       	call   f0111a33 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f011122d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111232:	c9                   	leave  
f0111233:	c3                   	ret    

f0111234 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f0111234:	55                   	push   %ebp
f0111235:	89 e5                	mov    %esp,%ebp
f0111237:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011123a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011123e:	74 1a                	je     f011125a <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f0111240:	83 ec 0c             	sub    $0xc,%esp
f0111243:	68 3c a3 12 f0       	push   $0xf012a33c
f0111248:	e8 3e fd fe ff       	call   f0100f8b <cprintf>
f011124d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111250:	b8 00 00 00 00       	mov    $0x0,%eax
f0111255:	e9 e1 00 00 00       	jmp    f011133b <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f011125a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011125d:	83 c0 04             	add    $0x4,%eax
f0111260:	8b 00                	mov    (%eax),%eax
f0111262:	83 ec 08             	sub    $0x8,%esp
f0111265:	68 75 a3 12 f0       	push   $0xf012a375
f011126a:	50                   	push   %eax
f011126b:	e8 d7 0d 01 00       	call   f0122047 <strcmp>
f0111270:	83 c4 10             	add    $0x10,%esp
f0111273:	85 c0                	test   %eax,%eax
f0111275:	75 0a                	jne    f0111281 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f0111277:	e8 97 1c 00 00       	call   f0112f13 <test_cut_paste_pages>
f011127c:	e9 b5 00 00 00       	jmp    f0111336 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f0111281:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111284:	83 c0 04             	add    $0x4,%eax
f0111287:	8b 00                	mov    (%eax),%eax
f0111289:	83 ec 08             	sub    $0x8,%esp
f011128c:	68 7e a3 12 f0       	push   $0xf012a37e
f0111291:	50                   	push   %eax
f0111292:	e8 b0 0d 01 00       	call   f0122047 <strcmp>
f0111297:	83 c4 10             	add    $0x10,%esp
f011129a:	85 c0                	test   %eax,%eax
f011129c:	75 0a                	jne    f01112a8 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f011129e:	e8 bb 26 00 00       	call   f011395e <test_copy_paste_chunk>
f01112a3:	e9 8e 00 00 00       	jmp    f0111336 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01112a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112ab:	83 c0 04             	add    $0x4,%eax
f01112ae:	8b 00                	mov    (%eax),%eax
f01112b0:	83 ec 08             	sub    $0x8,%esp
f01112b3:	68 88 a3 12 f0       	push   $0xf012a388
f01112b8:	50                   	push   %eax
f01112b9:	e8 89 0d 01 00       	call   f0122047 <strcmp>
f01112be:	83 c4 10             	add    $0x10,%esp
f01112c1:	85 c0                	test   %eax,%eax
f01112c3:	75 07                	jne    f01112cc <tst_chunks+0x98>
	{
		test_share_chunk();
f01112c5:	e8 92 37 00 00       	call   f0114a5c <test_share_chunk>
f01112ca:	eb 6a                	jmp    f0111336 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f01112cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112cf:	83 c0 04             	add    $0x4,%eax
f01112d2:	8b 00                	mov    (%eax),%eax
f01112d4:	83 ec 08             	sub    $0x8,%esp
f01112d7:	68 8e a3 12 f0       	push   $0xf012a38e
f01112dc:	50                   	push   %eax
f01112dd:	e8 65 0d 01 00       	call   f0122047 <strcmp>
f01112e2:	83 c4 10             	add    $0x10,%esp
f01112e5:	85 c0                	test   %eax,%eax
f01112e7:	75 07                	jne    f01112f0 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f01112e9:	e8 96 41 00 00       	call   f0115484 <test_allocate_chunk>
f01112ee:	eb 46                	jmp    f0111336 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f01112f0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112f3:	83 c0 04             	add    $0x4,%eax
f01112f6:	8b 00                	mov    (%eax),%eax
f01112f8:	83 ec 08             	sub    $0x8,%esp
f01112fb:	68 97 a3 12 f0       	push   $0xf012a397
f0111300:	50                   	push   %eax
f0111301:	e8 41 0d 01 00       	call   f0122047 <strcmp>
f0111306:	83 c4 10             	add    $0x10,%esp
f0111309:	85 c0                	test   %eax,%eax
f011130b:	75 07                	jne    f0111314 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f011130d:	e8 79 4a 00 00       	call   f0115d8b <test_calculate_required_frames>
f0111312:	eb 22                	jmp    f0111336 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f0111314:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111317:	83 c0 04             	add    $0x4,%eax
f011131a:	8b 00                	mov    (%eax),%eax
f011131c:	83 ec 08             	sub    $0x8,%esp
f011131f:	68 a6 a3 12 f0       	push   $0xf012a3a6
f0111324:	50                   	push   %eax
f0111325:	e8 1d 0d 01 00       	call   f0122047 <strcmp>
f011132a:	83 c4 10             	add    $0x10,%esp
f011132d:	85 c0                	test   %eax,%eax
f011132f:	75 05                	jne    f0111336 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0111331:	e8 c9 52 00 00       	call   f01165ff <test_calculate_allocated_space>
	}
	return 0;
f0111336:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011133b:	c9                   	leave  
f011133c:	c3                   	ret    

f011133d <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f011133d:	55                   	push   %ebp
f011133e:	89 e5                	mov    %esp,%ebp
f0111340:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0111343:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0111347:	74 1a                	je     f0111363 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f0111349:	83 ec 0c             	sub    $0xc,%esp
f011134c:	68 b8 a3 12 f0       	push   $0xf012a3b8
f0111351:	e8 35 fc fe ff       	call   f0100f8b <cprintf>
f0111356:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111359:	b8 00 00 00 00       	mov    $0x0,%eax
f011135e:	e9 ba 00 00 00       	jmp    f011141d <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f0111363:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111366:	83 c0 04             	add    $0x4,%eax
f0111369:	8b 00                	mov    (%eax),%eax
f011136b:	83 ec 08             	sub    $0x8,%esp
f011136e:	68 ee a3 12 f0       	push   $0xf012a3ee
f0111373:	50                   	push   %eax
f0111374:	e8 ce 0c 01 00       	call   f0122047 <strcmp>
f0111379:	83 c4 10             	add    $0x10,%esp
f011137c:	85 c0                	test   %eax,%eax
f011137e:	75 0a                	jne    f011138a <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f0111380:	e8 01 16 00 00       	call   f0112986 <test_pt_set_page_permissions>
f0111385:	e9 8e 00 00 00       	jmp    f0111418 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f011138a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011138d:	83 c0 04             	add    $0x4,%eax
f0111390:	8b 00                	mov    (%eax),%eax
f0111392:	83 ec 08             	sub    $0x8,%esp
f0111395:	68 f6 a3 12 f0       	push   $0xf012a3f6
f011139a:	50                   	push   %eax
f011139b:	e8 a7 0c 01 00       	call   f0122047 <strcmp>
f01113a0:	83 c4 10             	add    $0x10,%esp
f01113a3:	85 c0                	test   %eax,%eax
f01113a5:	75 07                	jne    f01113ae <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f01113a7:	e8 49 18 00 00       	call   f0112bf5 <test_pt_set_page_permissions_invalid_va>
f01113ac:	eb 6a                	jmp    f0111418 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f01113ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01113b1:	83 c0 04             	add    $0x4,%eax
f01113b4:	8b 00                	mov    (%eax),%eax
f01113b6:	83 ec 08             	sub    $0x8,%esp
f01113b9:	68 fe a3 12 f0       	push   $0xf012a3fe
f01113be:	50                   	push   %eax
f01113bf:	e8 83 0c 01 00       	call   f0122047 <strcmp>
f01113c4:	83 c4 10             	add    $0x10,%esp
f01113c7:	85 c0                	test   %eax,%eax
f01113c9:	75 07                	jne    f01113d2 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f01113cb:	e8 6e 18 00 00       	call   f0112c3e <test_pt_get_page_permissions>
f01113d0:	eb 46                	jmp    f0111418 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f01113d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01113d5:	83 c0 04             	add    $0x4,%eax
f01113d8:	8b 00                	mov    (%eax),%eax
f01113da:	83 ec 08             	sub    $0x8,%esp
f01113dd:	68 06 a4 12 f0       	push   $0xf012a406
f01113e2:	50                   	push   %eax
f01113e3:	e8 5f 0c 01 00       	call   f0122047 <strcmp>
f01113e8:	83 c4 10             	add    $0x10,%esp
f01113eb:	85 c0                	test   %eax,%eax
f01113ed:	75 07                	jne    f01113f6 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f01113ef:	e8 8e 19 00 00       	call   f0112d82 <test_pt_clear_page_table_entry>
f01113f4:	eb 22                	jmp    f0111418 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f01113f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01113f9:	83 c0 04             	add    $0x4,%eax
f01113fc:	8b 00                	mov    (%eax),%eax
f01113fe:	83 ec 08             	sub    $0x8,%esp
f0111401:	68 0d a4 12 f0       	push   $0xf012a40d
f0111406:	50                   	push   %eax
f0111407:	e8 3b 0c 01 00       	call   f0122047 <strcmp>
f011140c:	83 c4 10             	add    $0x10,%esp
f011140f:	85 c0                	test   %eax,%eax
f0111411:	75 05                	jne    f0111418 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f0111413:	e8 c3 1a 00 00       	call   f0112edb <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f0111418:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011141d:	c9                   	leave  
f011141e:	c3                   	ret    

f011141f <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011141f:	55                   	push   %ebp
f0111420:	89 e5                	mov    %esp,%ebp
f0111422:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f0111425:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111428:	83 c0 08             	add    $0x8,%eax
f011142b:	8b 00                	mov    (%eax),%eax
f011142d:	83 ec 08             	sub    $0x8,%esp
f0111430:	68 14 a4 12 f0       	push   $0xf012a414
f0111435:	50                   	push   %eax
f0111436:	e8 0c 0c 01 00       	call   f0122047 <strcmp>
f011143b:	83 c4 10             	add    $0x10,%esp
f011143e:	85 c0                	test   %eax,%eax
f0111440:	75 20                	jne    f0111462 <tst_kheap+0x43>
f0111442:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0111446:	74 1a                	je     f0111462 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f0111448:	83 ec 0c             	sub    $0xc,%esp
f011144b:	68 1c a4 12 f0       	push   $0xf012a41c
f0111450:	e8 36 fb fe ff       	call   f0100f8b <cprintf>
f0111455:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111458:	b8 00 00 00 00       	mov    $0x0,%eax
f011145d:	e9 42 04 00 00       	jmp    f01118a4 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f0111462:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111465:	83 c0 08             	add    $0x8,%eax
f0111468:	8b 00                	mov    (%eax),%eax
f011146a:	83 ec 08             	sub    $0x8,%esp
f011146d:	68 14 a4 12 f0       	push   $0xf012a414
f0111472:	50                   	push   %eax
f0111473:	e8 cf 0b 01 00       	call   f0122047 <strcmp>
f0111478:	83 c4 10             	add    $0x10,%esp
f011147b:	85 c0                	test   %eax,%eax
f011147d:	74 43                	je     f01114c2 <tst_kheap+0xa3>
f011147f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0111483:	74 3d                	je     f01114c2 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f0111485:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111488:	83 c0 08             	add    $0x8,%eax
f011148b:	8b 00                	mov    (%eax),%eax
f011148d:	83 ec 08             	sub    $0x8,%esp
f0111490:	68 6c a4 12 f0       	push   $0xf012a46c
f0111495:	50                   	push   %eax
f0111496:	e8 ac 0b 01 00       	call   f0122047 <strcmp>
f011149b:	83 c4 10             	add    $0x10,%esp
f011149e:	85 c0                	test   %eax,%eax
f01114a0:	74 20                	je     f01114c2 <tst_kheap+0xa3>
f01114a2:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f01114a6:	74 1a                	je     f01114c2 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f01114a8:	83 ec 0c             	sub    $0xc,%esp
f01114ab:	68 78 a4 12 f0       	push   $0xf012a478
f01114b0:	e8 d6 fa fe ff       	call   f0100f8b <cprintf>
f01114b5:	83 c4 10             	add    $0x10,%esp
			return 0;
f01114b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01114bd:	e9 e2 03 00 00       	jmp    f01118a4 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f01114c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114c5:	83 c0 04             	add    $0x4,%eax
f01114c8:	8b 00                	mov    (%eax),%eax
f01114ca:	83 ec 08             	sub    $0x8,%esp
f01114cd:	68 bd a4 12 f0       	push   $0xf012a4bd
f01114d2:	50                   	push   %eax
f01114d3:	e8 6f 0b 01 00       	call   f0122047 <strcmp>
f01114d8:	83 c4 10             	add    $0x10,%esp
f01114db:	85 c0                	test   %eax,%eax
f01114dd:	74 1d                	je     f01114fc <tst_kheap+0xdd>
f01114df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01114e2:	83 c0 04             	add    $0x4,%eax
f01114e5:	8b 00                	mov    (%eax),%eax
f01114e7:	83 ec 08             	sub    $0x8,%esp
f01114ea:	68 c0 a4 12 f0       	push   $0xf012a4c0
f01114ef:	50                   	push   %eax
f01114f0:	e8 52 0b 01 00       	call   f0122047 <strcmp>
f01114f5:	83 c4 10             	add    $0x10,%esp
f01114f8:	85 c0                	test   %eax,%eax
f01114fa:	75 1a                	jne    f0111516 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f01114fc:	e8 6d f8 ff ff       	call   f0110d6e <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0111501:	83 ec 0c             	sub    $0xc,%esp
f0111504:	68 c4 a4 12 f0       	push   $0xf012a4c4
f0111509:	e8 7d fa fe ff       	call   f0100f8b <cprintf>
f011150e:	83 c4 10             	add    $0x10,%esp
f0111511:	e9 a0 00 00 00       	jmp    f01115b6 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0111516:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111519:	83 c0 04             	add    $0x4,%eax
f011151c:	8b 00                	mov    (%eax),%eax
f011151e:	83 ec 08             	sub    $0x8,%esp
f0111521:	68 f1 a4 12 f0       	push   $0xf012a4f1
f0111526:	50                   	push   %eax
f0111527:	e8 1b 0b 01 00       	call   f0122047 <strcmp>
f011152c:	83 c4 10             	add    $0x10,%esp
f011152f:	85 c0                	test   %eax,%eax
f0111531:	74 1d                	je     f0111550 <tst_kheap+0x131>
f0111533:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111536:	83 c0 04             	add    $0x4,%eax
f0111539:	8b 00                	mov    (%eax),%eax
f011153b:	83 ec 08             	sub    $0x8,%esp
f011153e:	68 f4 a4 12 f0       	push   $0xf012a4f4
f0111543:	50                   	push   %eax
f0111544:	e8 fe 0a 01 00       	call   f0122047 <strcmp>
f0111549:	83 c4 10             	add    $0x10,%esp
f011154c:	85 c0                	test   %eax,%eax
f011154e:	75 17                	jne    f0111567 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f0111550:	e8 29 f8 ff ff       	call   f0110d7e <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0111555:	83 ec 0c             	sub    $0xc,%esp
f0111558:	68 f8 a4 12 f0       	push   $0xf012a4f8
f011155d:	e8 29 fa fe ff       	call   f0100f8b <cprintf>
f0111562:	83 c4 10             	add    $0x10,%esp
f0111565:	eb 4f                	jmp    f01115b6 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0111567:	8b 45 0c             	mov    0xc(%ebp),%eax
f011156a:	83 c0 04             	add    $0x4,%eax
f011156d:	8b 00                	mov    (%eax),%eax
f011156f:	83 ec 08             	sub    $0x8,%esp
f0111572:	68 24 a5 12 f0       	push   $0xf012a524
f0111577:	50                   	push   %eax
f0111578:	e8 ca 0a 01 00       	call   f0122047 <strcmp>
f011157d:	83 c4 10             	add    $0x10,%esp
f0111580:	85 c0                	test   %eax,%eax
f0111582:	74 1d                	je     f01115a1 <tst_kheap+0x182>
f0111584:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111587:	83 c0 04             	add    $0x4,%eax
f011158a:	8b 00                	mov    (%eax),%eax
f011158c:	83 ec 08             	sub    $0x8,%esp
f011158f:	68 27 a5 12 f0       	push   $0xf012a527
f0111594:	50                   	push   %eax
f0111595:	e8 ad 0a 01 00       	call   f0122047 <strcmp>
f011159a:	83 c4 10             	add    $0x10,%esp
f011159d:	85 c0                	test   %eax,%eax
f011159f:	75 15                	jne    f01115b6 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f01115a1:	e8 e8 f7 ff ff       	call   f0110d8e <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01115a6:	83 ec 0c             	sub    $0xc,%esp
f01115a9:	68 2c a5 12 f0       	push   $0xf012a52c
f01115ae:	e8 d8 f9 fe ff       	call   f0100f8b <cprintf>
f01115b3:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f01115b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01115b9:	83 c0 08             	add    $0x8,%eax
f01115bc:	8b 00                	mov    (%eax),%eax
f01115be:	83 ec 08             	sub    $0x8,%esp
f01115c1:	68 14 a4 12 f0       	push   $0xf012a414
f01115c6:	50                   	push   %eax
f01115c7:	e8 7b 0a 01 00       	call   f0122047 <strcmp>
f01115cc:	83 c4 10             	add    $0x10,%esp
f01115cf:	85 c0                	test   %eax,%eax
f01115d1:	0f 85 13 01 00 00    	jne    f01116ea <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f01115d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01115da:	83 c0 0c             	add    $0xc,%eax
f01115dd:	8b 00                	mov    (%eax),%eax
f01115df:	83 ec 04             	sub    $0x4,%esp
f01115e2:	6a 0a                	push   $0xa
f01115e4:	6a 00                	push   $0x0
f01115e6:	50                   	push   %eax
f01115e7:	e8 af 0c 01 00       	call   f012229b <strtol>
f01115ec:	83 c4 10             	add    $0x10,%esp
f01115ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f01115f2:	e8 a7 f7 ff ff       	call   f0110d9e <isKHeapPlacementStrategyFIRSTFIT>
f01115f7:	84 c0                	test   %al,%al
f01115f9:	74 54                	je     f011164f <tst_kheap+0x230>
		{
			if (testNum == 0)
f01115fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01115ff:	75 1a                	jne    f011161b <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f0111601:	83 ec 0c             	sub    $0xc,%esp
f0111604:	68 58 a5 12 f0       	push   $0xf012a558
f0111609:	e8 7d f9 fe ff       	call   f0100f8b <cprintf>
f011160e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0111611:	b8 00 00 00 00       	mov    $0x0,%eax
f0111616:	e9 89 02 00 00       	jmp    f01118a4 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f011161b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011161f:	75 0a                	jne    f011162b <tst_kheap+0x20c>
				test_kmalloc();
f0111621:	e8 ec 61 00 00       	call   f0117812 <test_kmalloc>
f0111626:	e9 b5 00 00 00       	jmp    f01116e0 <tst_kheap+0x2c1>
			else if (testNum == 2)
f011162b:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011162f:	75 0a                	jne    f011163b <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f0111631:	e8 68 6d 00 00       	call   f011839e <test_kmalloc_firstfit1>
f0111636:	e9 a5 00 00 00       	jmp    f01116e0 <tst_kheap+0x2c1>
			else if (testNum == 3)
f011163b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011163f:	0f 85 9b 00 00 00    	jne    f01116e0 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f0111645:	e8 38 78 00 00       	call   f0118e82 <test_kmalloc_firstfit2>
f011164a:	e9 91 00 00 00       	jmp    f01116e0 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f011164f:	e8 5f f7 ff ff       	call   f0110db3 <isKHeapPlacementStrategyBESTFIT>
f0111654:	84 c0                	test   %al,%al
f0111656:	74 47                	je     f011169f <tst_kheap+0x280>
		{
			if (testNum == 0)
f0111658:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011165c:	75 1a                	jne    f0111678 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f011165e:	83 ec 0c             	sub    $0xc,%esp
f0111661:	68 a8 a5 12 f0       	push   $0xf012a5a8
f0111666:	e8 20 f9 fe ff       	call   f0100f8b <cprintf>
f011166b:	83 c4 10             	add    $0x10,%esp
				return 0;
f011166e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111673:	e9 2c 02 00 00       	jmp    f01118a4 <tst_kheap+0x485>
			}
			if (testNum == 1)
f0111678:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f011167c:	75 07                	jne    f0111685 <tst_kheap+0x266>
				test_kmalloc();
f011167e:	e8 8f 61 00 00       	call   f0117812 <test_kmalloc>
f0111683:	eb 5b                	jmp    f01116e0 <tst_kheap+0x2c1>
			else if (testNum == 2)
f0111685:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0111689:	75 07                	jne    f0111692 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f011168b:	e8 0a c8 00 00       	call   f011de9a <test_kmalloc_bestfit1>
f0111690:	eb 4e                	jmp    f01116e0 <tst_kheap+0x2c1>
			else if (testNum == 3)
f0111692:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0111696:	75 48                	jne    f01116e0 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f0111698:	e8 1a c8 00 00       	call   f011deb7 <test_kmalloc_bestfit2>
f011169d:	eb 41                	jmp    f01116e0 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f011169f:	e8 24 f7 ff ff       	call   f0110dc8 <isKHeapPlacementStrategyNEXTFIT>
f01116a4:	84 c0                	test   %al,%al
f01116a6:	74 38                	je     f01116e0 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f01116a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01116ac:	75 1a                	jne    f01116c8 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f01116ae:	83 ec 0c             	sub    $0xc,%esp
f01116b1:	68 f8 a5 12 f0       	push   $0xf012a5f8
f01116b6:	e8 d0 f8 fe ff       	call   f0100f8b <cprintf>
f01116bb:	83 c4 10             	add    $0x10,%esp
				return 0;
f01116be:	b8 00 00 00 00       	mov    $0x0,%eax
f01116c3:	e9 dc 01 00 00       	jmp    f01118a4 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f01116c8:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01116cc:	75 07                	jne    f01116d5 <tst_kheap+0x2b6>
				test_kmalloc();
f01116ce:	e8 3f 61 00 00       	call   f0117812 <test_kmalloc>
f01116d3:	eb 0b                	jmp    f01116e0 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f01116d5:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f01116d9:	75 05                	jne    f01116e0 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f01116db:	e8 9d c7 00 00       	call   f011de7d <test_kmalloc_nextfit>
		}
		return 0;
f01116e0:	b8 00 00 00 00       	mov    $0x0,%eax
f01116e5:	e9 ba 01 00 00       	jmp    f01118a4 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f01116ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01116ed:	83 c0 08             	add    $0x8,%eax
f01116f0:	8b 00                	mov    (%eax),%eax
f01116f2:	83 ec 08             	sub    $0x8,%esp
f01116f5:	68 46 a6 12 f0       	push   $0xf012a646
f01116fa:	50                   	push   %eax
f01116fb:	e8 47 09 01 00       	call   f0122047 <strcmp>
f0111700:	83 c4 10             	add    $0x10,%esp
f0111703:	85 c0                	test   %eax,%eax
f0111705:	75 2f                	jne    f0111736 <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f0111707:	e8 92 f6 ff ff       	call   f0110d9e <isKHeapPlacementStrategyFIRSTFIT>
f011170c:	84 c0                	test   %al,%al
f011170e:	74 0f                	je     f011171f <tst_kheap+0x300>
		{
			test_fastfirstfit();
f0111710:	e8 74 82 00 00       	call   f0119989 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f0111715:	b8 00 00 00 00       	mov    $0x0,%eax
f011171a:	e9 85 01 00 00       	jmp    f01118a4 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f011171f:	83 ec 04             	sub    $0x4,%esp
f0111722:	68 4c a6 12 f0       	push   $0xf012a64c
f0111727:	68 ac 01 00 00       	push   $0x1ac
f011172c:	68 33 a2 12 f0       	push   $0xf012a233
f0111731:	e8 03 ec fe ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f0111736:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111739:	83 c0 08             	add    $0x8,%eax
f011173c:	8b 00                	mov    (%eax),%eax
f011173e:	83 ec 08             	sub    $0x8,%esp
f0111741:	68 8d a6 12 f0       	push   $0xf012a68d
f0111746:	50                   	push   %eax
f0111747:	e8 fb 08 01 00       	call   f0122047 <strcmp>
f011174c:	83 c4 10             	add    $0x10,%esp
f011174f:	85 c0                	test   %eax,%eax
f0111751:	75 28                	jne    f011177b <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f0111753:	e8 5b f6 ff ff       	call   f0110db3 <isKHeapPlacementStrategyBESTFIT>
f0111758:	84 c0                	test   %al,%al
f011175a:	75 09                	jne    f0111765 <tst_kheap+0x346>
f011175c:	e8 3d f6 ff ff       	call   f0110d9e <isKHeapPlacementStrategyFIRSTFIT>
f0111761:	84 c0                	test   %al,%al
f0111763:	74 07                	je     f011176c <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f0111765:	e8 ee 8a 00 00       	call   f011a258 <test_kfree_bestfirstfit>
f011176a:	eb 05                	jmp    f0111771 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f011176c:	e8 80 c7 00 00       	call   f011def1 <test_kfree>
		}
		return 0;
f0111771:	b8 00 00 00 00       	mov    $0x0,%eax
f0111776:	e9 29 01 00 00       	jmp    f01118a4 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f011177b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011177e:	83 c0 08             	add    $0x8,%eax
f0111781:	8b 00                	mov    (%eax),%eax
f0111783:	83 ec 08             	sub    $0x8,%esp
f0111786:	68 93 a6 12 f0       	push   $0xf012a693
f011178b:	50                   	push   %eax
f011178c:	e8 b6 08 01 00       	call   f0122047 <strcmp>
f0111791:	83 c4 10             	add    $0x10,%esp
f0111794:	85 c0                	test   %eax,%eax
f0111796:	75 0f                	jne    f01117a7 <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f0111798:	e8 17 a1 00 00       	call   f011b8b4 <test_kheap_phys_addr>
		return 0;
f011179d:	b8 00 00 00 00       	mov    $0x0,%eax
f01117a2:	e9 fd 00 00 00       	jmp    f01118a4 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f01117a7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01117aa:	83 c0 08             	add    $0x8,%eax
f01117ad:	8b 00                	mov    (%eax),%eax
f01117af:	83 ec 08             	sub    $0x8,%esp
f01117b2:	68 9d a6 12 f0       	push   $0xf012a69d
f01117b7:	50                   	push   %eax
f01117b8:	e8 8a 08 01 00       	call   f0122047 <strcmp>
f01117bd:	83 c4 10             	add    $0x10,%esp
f01117c0:	85 c0                	test   %eax,%eax
f01117c2:	75 0f                	jne    f01117d3 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f01117c4:	e8 ce ae 00 00       	call   f011c697 <test_kheap_virt_addr>
		return 0;
f01117c9:	b8 00 00 00 00       	mov    $0x0,%eax
f01117ce:	e9 d1 00 00 00       	jmp    f01118a4 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f01117d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01117d6:	83 c0 08             	add    $0x8,%eax
f01117d9:	8b 00                	mov    (%eax),%eax
f01117db:	83 ec 08             	sub    $0x8,%esp
f01117de:	68 6c a4 12 f0       	push   $0xf012a46c
f01117e3:	50                   	push   %eax
f01117e4:	e8 5e 08 01 00       	call   f0122047 <strcmp>
f01117e9:	83 c4 10             	add    $0x10,%esp
f01117ec:	85 c0                	test   %eax,%eax
f01117ee:	0f 85 89 00 00 00    	jne    f011187d <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f01117f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01117f7:	83 c0 0c             	add    $0xc,%eax
f01117fa:	8b 00                	mov    (%eax),%eax
f01117fc:	83 ec 04             	sub    $0x4,%esp
f01117ff:	6a 0a                	push   $0xa
f0111801:	6a 00                	push   $0x0
f0111803:	50                   	push   %eax
f0111804:	e8 92 0a 01 00       	call   f012229b <strtol>
f0111809:	83 c4 10             	add    $0x10,%esp
f011180c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f011180f:	e8 8a f5 ff ff       	call   f0110d9e <isKHeapPlacementStrategyFIRSTFIT>
f0111814:	84 c0                	test   %al,%al
f0111816:	74 42                	je     f011185a <tst_kheap+0x43b>
		{
			if (testNum == 0)
f0111818:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011181c:	75 17                	jne    f0111835 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f011181e:	83 ec 0c             	sub    $0xc,%esp
f0111821:	68 58 a5 12 f0       	push   $0xf012a558
f0111826:	e8 60 f7 fe ff       	call   f0100f8b <cprintf>
f011182b:	83 c4 10             	add    $0x10,%esp
				return 0;
f011182e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111833:	eb 6f                	jmp    f01118a4 <tst_kheap+0x485>
			}
			if (testNum==1)
f0111835:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111839:	75 07                	jne    f0111842 <tst_kheap+0x423>
				test_krealloc_FF1();
f011183b:	e8 2f c9 00 00       	call   f011e16f <test_krealloc_FF1>
f0111840:	eb 18                	jmp    f011185a <tst_kheap+0x43b>
			else if (testNum==2)
f0111842:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f0111846:	75 07                	jne    f011184f <tst_kheap+0x430>
				test_krealloc_FF2();
f0111848:	e8 f7 e0 00 00       	call   f011f944 <test_krealloc_FF2>
f011184d:	eb 0b                	jmp    f011185a <tst_kheap+0x43b>
			else if (testNum==3)
f011184f:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111853:	75 05                	jne    f011185a <tst_kheap+0x43b>
				test_krealloc_FF3();
f0111855:	e8 07 e1 00 00       	call   f011f961 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f011185a:	e8 69 f5 ff ff       	call   f0110dc8 <isKHeapPlacementStrategyNEXTFIT>
f011185f:	84 c0                	test   %al,%al
f0111861:	74 05                	je     f0111868 <tst_kheap+0x449>
		{
			test_krealloc();
f0111863:	e8 cd c8 00 00       	call   f011e135 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f0111868:	e8 46 f5 ff ff       	call   f0110db3 <isKHeapPlacementStrategyBESTFIT>
f011186d:	84 c0                	test   %al,%al
f011186f:	74 05                	je     f0111876 <tst_kheap+0x457>
		{
			test_krealloc_BF();
f0111871:	e8 dc c8 00 00       	call   f011e152 <test_krealloc_BF>
		}
		return 0;
f0111876:	b8 00 00 00 00       	mov    $0x0,%eax
f011187b:	eb 27                	jmp    f01118a4 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f011187d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111880:	83 c0 08             	add    $0x8,%eax
f0111883:	8b 00                	mov    (%eax),%eax
f0111885:	83 ec 08             	sub    $0x8,%esp
f0111888:	68 a7 a6 12 f0       	push   $0xf012a6a7
f011188d:	50                   	push   %eax
f011188e:	e8 b4 07 01 00       	call   f0122047 <strcmp>
f0111893:	83 c4 10             	add    $0x10,%esp
f0111896:	85 c0                	test   %eax,%eax
f0111898:	75 05                	jne    f011189f <tst_kheap+0x480>
	{
		test_ksbrk();
f011189a:	e8 1d bb 00 00       	call   f011d3bc <test_ksbrk>
	}
	return 0;
f011189f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01118a4:	c9                   	leave  
f01118a5:	c3                   	ret    

f01118a6 <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f01118a6:	55                   	push   %ebp
f01118a7:	89 e5                	mov    %esp,%ebp
f01118a9:	83 ec 28             	sub    $0x28,%esp
f01118ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01118af:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//Check returned va
	if(va != expectedVA)
f01118b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01118b5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01118b8:	74 1d                	je     f01118d7 <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f01118ba:	83 ec 04             	sub    $0x4,%esp
f01118bd:	ff 75 08             	pushl  0x8(%ebp)
f01118c0:	ff 75 0c             	pushl  0xc(%ebp)
f01118c3:	68 ac a6 12 f0       	push   $0xf012a6ac
f01118c8:	e8 be f6 fe ff       	call   f0100f8b <cprintf>
f01118cd:	83 c4 10             	add    $0x10,%esp
		return 0;
f01118d0:	b8 00 00 00 00       	mov    $0x0,%eax
f01118d5:	eb 55                	jmp    f011192c <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f01118d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01118da:	8b 40 fc             	mov    -0x4(%eax),%eax
f01118dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f01118e0:	8b 45 10             	mov    0x10(%ebp),%eax
f01118e3:	8d 50 f8             	lea    -0x8(%eax),%edx
f01118e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01118e9:	01 d0                	add    %edx,%eax
f01118eb:	8b 00                	mov    (%eax),%eax
f01118ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f01118f0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f01118f4:	0b 45 10             	or     0x10(%ebp),%eax
f01118f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f01118fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01118fd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111900:	75 08                	jne    f011190a <check_block+0x64>
f0111902:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111905:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0111908:	74 1d                	je     f0111927 <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f011190a:	ff 75 f0             	pushl  -0x10(%ebp)
f011190d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111910:	ff 75 ec             	pushl  -0x14(%ebp)
f0111913:	68 dc a6 12 f0       	push   $0xf012a6dc
f0111918:	e8 6e f6 fe ff       	call   f0100f8b <cprintf>
f011191d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111920:	b8 00 00 00 00       	mov    $0x0,%eax
f0111925:	eb 05                	jmp    f011192c <check_block+0x86>
	}
	return 1;
f0111927:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011192c:	c9                   	leave  
f011192d:	c3                   	ret    

f011192e <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f011192e:	55                   	push   %ebp
f011192f:	89 e5                	mov    %esp,%ebp
f0111931:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f0111934:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0111939:	3b 45 08             	cmp    0x8(%ebp),%eax
f011193c:	74 20                	je     f011195e <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f011193e:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0111943:	83 ec 04             	sub    $0x4,%esp
f0111946:	50                   	push   %eax
f0111947:	ff 75 08             	pushl  0x8(%ebp)
f011194a:	68 18 a7 12 f0       	push   $0xf012a718
f011194f:	e8 37 f6 fe ff       	call   f0100f8b <cprintf>
f0111954:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111957:	b8 00 00 00 00       	mov    $0x0,%eax
f011195c:	eb 05                	jmp    f0111963 <check_list_size+0x35>
	}
	return 1;
f011195e:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111963:	c9                   	leave  
f0111964:	c3                   	ret    

f0111965 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0111965:	55                   	push   %ebp
f0111966:	89 e5                	mov    %esp,%ebp
f0111968:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f011196b:	83 ec 04             	sub    $0x4,%esp
f011196e:	68 4c a7 12 f0       	push   $0xf012a74c
f0111973:	6a 3f                	push   $0x3f
f0111975:	68 ac a7 12 f0       	push   $0xf012a7ac
f011197a:	e8 ba e9 fe ff       	call   f0100339 <_panic>

f011197f <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f011197f:	55                   	push   %ebp
f0111980:	89 e5                	mov    %esp,%ebp
f0111982:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111985:	83 ec 04             	sub    $0x4,%esp
f0111988:	68 d0 a7 12 f0       	push   $0xf012a7d0
f011198d:	6a 61                	push   $0x61
f011198f:	68 ac a7 12 f0       	push   $0xf012a7ac
f0111994:	e8 a0 e9 fe ff       	call   f0100339 <_panic>

f0111999 <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f0111999:	55                   	push   %ebp
f011199a:	89 e5                	mov    %esp,%ebp
f011199c:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f011199f:	83 ec 04             	sub    $0x4,%esp
f01119a2:	68 20 a8 12 f0       	push   $0xf012a820
f01119a7:	68 e7 00 00 00       	push   $0xe7
f01119ac:	68 ac a7 12 f0       	push   $0xf012a7ac
f01119b1:	e8 83 e9 fe ff       	call   f0100339 <_panic>

f01119b6 <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f01119b6:	55                   	push   %ebp
f01119b7:	89 e5                	mov    %esp,%ebp
f01119b9:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01119bf:	83 ec 04             	sub    $0x4,%esp
f01119c2:	68 74 a8 12 f0       	push   $0xf012a874
f01119c7:	68 88 01 00 00       	push   $0x188
f01119cc:	68 ac a7 12 f0       	push   $0xf012a7ac
f01119d1:	e8 63 e9 fe ff       	call   f0100339 <_panic>

f01119d6 <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f01119d6:	55                   	push   %ebp
f01119d7:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f01119d9:	90                   	nop
f01119da:	5d                   	pop    %ebp
f01119db:	c3                   	ret    

f01119dc <test_free_block_FF>:

void test_free_block_FF()
{
f01119dc:	55                   	push   %ebp
f01119dd:	89 e5                	mov    %esp,%ebp
f01119df:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01119e2:	83 ec 04             	sub    $0x4,%esp
f01119e5:	68 c8 a8 12 f0       	push   $0xf012a8c8
f01119ea:	68 4e 02 00 00       	push   $0x24e
f01119ef:	68 ac a7 12 f0       	push   $0xf012a7ac
f01119f4:	e8 40 e9 fe ff       	call   f0100339 <_panic>

f01119f9 <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f01119f9:	55                   	push   %ebp
f01119fa:	89 e5                	mov    %esp,%ebp
f01119fc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01119ff:	83 ec 04             	sub    $0x4,%esp
f0111a02:	68 c8 a8 12 f0       	push   $0xf012a8c8
f0111a07:	68 a1 03 00 00       	push   $0x3a1
f0111a0c:	68 ac a7 12 f0       	push   $0xf012a7ac
f0111a11:	e8 23 e9 fe ff       	call   f0100339 <_panic>

f0111a16 <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f0111a16:	55                   	push   %ebp
f0111a17:	89 e5                	mov    %esp,%ebp
f0111a19:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0111a1c:	83 ec 04             	sub    $0x4,%esp
f0111a1f:	68 15 a9 12 f0       	push   $0xf012a915
f0111a24:	68 c1 04 00 00       	push   $0x4c1
f0111a29:	68 ac a7 12 f0       	push   $0xf012a7ac
f0111a2e:	e8 06 e9 fe ff       	call   f0100339 <_panic>

f0111a33 <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0111a33:	55                   	push   %ebp
f0111a34:	89 e5                	mov    %esp,%ebp
f0111a36:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111a39:	83 ec 04             	sub    $0x4,%esp
f0111a3c:	68 c8 a8 12 f0       	push   $0xf012a8c8
f0111a41:	68 c7 04 00 00       	push   $0x4c7
f0111a46:	68 ac a7 12 f0       	push   $0xf012a7ac
f0111a4b:	e8 e9 e8 fe ff       	call   f0100339 <_panic>

f0111a50 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0111a50:	55                   	push   %ebp
f0111a51:	89 e5                	mov    %esp,%ebp
f0111a53:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111a56:	83 ec 04             	sub    $0x4,%esp
f0111a59:	68 c8 a8 12 f0       	push   $0xf012a8c8
f0111a5e:	68 f3 05 00 00       	push   $0x5f3
f0111a63:	68 ac a7 12 f0       	push   $0xf012a7ac
f0111a68:	e8 cc e8 fe ff       	call   f0100339 <_panic>

f0111a6d <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111a6d:	55                   	push   %ebp
f0111a6e:	89 e5                	mov    %esp,%ebp
f0111a70:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111a73:	e8 cc a4 ff ff       	call   f010bf44 <get_cpu_proc>
f0111a78:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111a7b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111a7f:	75 16                	jne    f0111a97 <sys_check_LRU_lists+0x2a>
f0111a81:	68 28 a9 12 f0       	push   $0xf012a928
f0111a86:	68 38 a9 12 f0       	push   $0xf012a938
f0111a8b:	6a 10                	push   $0x10
f0111a8d:	68 4d a9 12 f0       	push   $0xf012a94d
f0111a92:	e8 a2 e8 fe ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0111a97:	83 ec 0c             	sub    $0xc,%esp
f0111a9a:	68 6c a9 12 f0       	push   $0xf012a96c
f0111a9f:	e8 e7 f4 fe ff       	call   f0100f8b <cprintf>
f0111aa4:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0111aa7:	83 ec 0c             	sub    $0xc,%esp
f0111aaa:	ff 75 e0             	pushl  -0x20(%ebp)
f0111aad:	e8 50 8e ff ff       	call   f010a902 <env_page_ws_print>
f0111ab2:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0111ab5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111ab8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0111abb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f0111ac2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0111ac9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0111acd:	0f 84 a5 00 00 00    	je     f0111b78 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f0111ad3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111ada:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111add:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0111ae3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111ae6:	eb 4a                	jmp    f0111b32 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0111ae8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111aeb:	8b 00                	mov    (%eax),%eax
f0111aed:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111af0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111af3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111af8:	89 c2                	mov    %eax,%edx
f0111afa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111afd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111b04:	8b 45 08             	mov    0x8(%ebp),%eax
f0111b07:	01 c8                	add    %ecx,%eax
f0111b09:	8b 00                	mov    (%eax),%eax
f0111b0b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111b0e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111b11:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111b16:	39 c2                	cmp    %eax,%edx
f0111b18:	74 09                	je     f0111b23 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111b1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111b21:	eb 3e                	jmp    f0111b61 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f0111b23:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111b26:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b29:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0111b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111b32:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111b36:	74 08                	je     f0111b40 <sys_check_LRU_lists+0xd3>
f0111b38:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111b3b:	8b 40 10             	mov    0x10(%eax),%eax
f0111b3e:	eb 05                	jmp    f0111b45 <sys_check_LRU_lists+0xd8>
f0111b40:	b8 00 00 00 00       	mov    $0x0,%eax
f0111b45:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111b48:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f0111b4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b51:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0111b57:	85 c0                	test   %eax,%eax
f0111b59:	75 8d                	jne    f0111ae8 <sys_check_LRU_lists+0x7b>
f0111b5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111b5f:	75 87                	jne    f0111ae8 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f0111b61:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b64:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f0111b6a:	8b 45 10             	mov    0x10(%ebp),%eax
f0111b6d:	39 c2                	cmp    %eax,%edx
f0111b6f:	74 07                	je     f0111b78 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f0111b71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111b78:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111b7c:	0f 84 a5 00 00 00    	je     f0111c27 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f0111b82:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111b89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111b8c:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f0111b92:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111b95:	eb 4a                	jmp    f0111be1 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0111b97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111b9a:	8b 00                	mov    (%eax),%eax
f0111b9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111b9f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111ba2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111ba7:	89 c2                	mov    %eax,%edx
f0111ba9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111bac:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111bb3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111bb6:	01 c8                	add    %ecx,%eax
f0111bb8:	8b 00                	mov    (%eax),%eax
f0111bba:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0111bbd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111bc0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111bc5:	39 c2                	cmp    %eax,%edx
f0111bc7:	74 09                	je     f0111bd2 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111bc9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f0111bd0:	eb 3e                	jmp    f0111c10 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f0111bd2:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111bd5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111bd8:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0111bde:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111be1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111be5:	74 08                	je     f0111bef <sys_check_LRU_lists+0x182>
f0111be7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111bea:	8b 40 10             	mov    0x10(%eax),%eax
f0111bed:	eb 05                	jmp    f0111bf4 <sys_check_LRU_lists+0x187>
f0111bef:	b8 00 00 00 00       	mov    $0x0,%eax
f0111bf4:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111bf7:	89 82 7c 05 00 00    	mov    %eax,0x57c(%edx)
f0111bfd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111c00:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0111c06:	85 c0                	test   %eax,%eax
f0111c08:	75 8d                	jne    f0111b97 <sys_check_LRU_lists+0x12a>
f0111c0a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111c0e:	75 87                	jne    f0111b97 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f0111c10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111c13:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f0111c19:	8b 45 14             	mov    0x14(%ebp),%eax
f0111c1c:	39 c2                	cmp    %eax,%edx
f0111c1e:	74 07                	je     f0111c27 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f0111c20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111c2a:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111c2d:	c9                   	leave  
f0111c2e:	c3                   	ret    

f0111c2f <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111c2f:	55                   	push   %ebp
f0111c30:	89 e5                	mov    %esp,%ebp
f0111c32:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0111c35:	e8 0a a3 ff ff       	call   f010bf44 <get_cpu_proc>
f0111c3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111c3d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0111c41:	75 16                	jne    f0111c59 <sys_check_LRU_lists_free+0x2a>
f0111c43:	68 28 a9 12 f0       	push   $0xf012a928
f0111c48:	68 38 a9 12 f0       	push   $0xf012a938
f0111c4d:	6a 45                	push   $0x45
f0111c4f:	68 4d a9 12 f0       	push   $0xf012a94d
f0111c54:	e8 e0 e6 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111c59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111c5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111c5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111c66:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111c69:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0111c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111c72:	eb 65                	jmp    f0111cd9 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111c74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111c7b:	eb 3a                	jmp    f0111cb7 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111c7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111c80:	8b 00                	mov    (%eax),%eax
f0111c82:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111c85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111c88:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111c8d:	89 c2                	mov    %eax,%edx
f0111c8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111c92:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111c99:	8b 45 08             	mov    0x8(%ebp),%eax
f0111c9c:	01 c8                	add    %ecx,%eax
f0111c9e:	8b 00                	mov    (%eax),%eax
f0111ca0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111ca3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111ca6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111cab:	39 c2                	cmp    %eax,%edx
f0111cad:	75 05                	jne    f0111cb4 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0111caf:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111cb2:	eb 0b                	jmp    f0111cbf <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0111cb4:	ff 45 ec             	incl   -0x14(%ebp)
f0111cb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111cba:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111cbd:	7c be                	jl     f0111c7d <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111cbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111cc3:	7e 08                	jle    f0111ccd <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0111cc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111cc8:	e9 ed 00 00 00       	jmp    f0111dba <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111ccd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111cd0:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0111cd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111cd9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111cdd:	74 08                	je     f0111ce7 <sys_check_LRU_lists_free+0xb8>
f0111cdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111ce2:	8b 40 10             	mov    0x10(%eax),%eax
f0111ce5:	eb 05                	jmp    f0111cec <sys_check_LRU_lists_free+0xbd>
f0111ce7:	b8 00 00 00 00       	mov    $0x0,%eax
f0111cec:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111cef:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f0111cf5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111cf8:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0111cfe:	85 c0                	test   %eax,%eax
f0111d00:	0f 85 6e ff ff ff    	jne    f0111c74 <sys_check_LRU_lists_free+0x45>
f0111d06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111d0a:	0f 85 64 ff ff ff    	jne    f0111c74 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111d10:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111d13:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f0111d19:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111d1c:	eb 62                	jmp    f0111d80 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111d1e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111d25:	eb 3a                	jmp    f0111d61 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111d27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111d2a:	8b 00                	mov    (%eax),%eax
f0111d2c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111d2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111d32:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111d37:	89 c2                	mov    %eax,%edx
f0111d39:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111d3c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111d43:	8b 45 08             	mov    0x8(%ebp),%eax
f0111d46:	01 c8                	add    %ecx,%eax
f0111d48:	8b 00                	mov    (%eax),%eax
f0111d4a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111d4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111d55:	39 c2                	cmp    %eax,%edx
f0111d57:	75 05                	jne    f0111d5e <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111d59:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111d5c:	eb 0b                	jmp    f0111d69 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111d5e:	ff 45 e8             	incl   -0x18(%ebp)
f0111d61:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111d64:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111d67:	7c be                	jl     f0111d27 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111d69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111d6d:	7e 05                	jle    f0111d74 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111d6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111d72:	eb 46                	jmp    f0111dba <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111d74:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111d77:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0111d7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111d80:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111d84:	74 08                	je     f0111d8e <sys_check_LRU_lists_free+0x15f>
f0111d86:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111d89:	8b 40 10             	mov    0x10(%eax),%eax
f0111d8c:	eb 05                	jmp    f0111d93 <sys_check_LRU_lists_free+0x164>
f0111d8e:	b8 00 00 00 00       	mov    $0x0,%eax
f0111d93:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111d96:	89 82 7c 05 00 00    	mov    %eax,0x57c(%edx)
f0111d9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111d9f:	8b 80 7c 05 00 00    	mov    0x57c(%eax),%eax
f0111da5:	85 c0                	test   %eax,%eax
f0111da7:	0f 85 71 ff ff ff    	jne    f0111d1e <sys_check_LRU_lists_free+0xef>
f0111dad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111db1:	0f 85 67 ff ff ff    	jne    f0111d1e <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0111db7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111dba:	c9                   	leave  
f0111dbb:	c3                   	ret    

f0111dbc <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0111dbc:	55                   	push   %ebp
f0111dbd:	89 e5                	mov    %esp,%ebp
f0111dbf:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0111dc2:	e8 7d a1 ff ff       	call   f010bf44 <get_cpu_proc>
f0111dc7:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0111dca:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0111dce:	75 16                	jne    f0111de6 <sys_check_WS_list+0x2a>
f0111dd0:	68 28 a9 12 f0       	push   $0xf012a928
f0111dd5:	68 38 a9 12 f0       	push   $0xf012a938
f0111dda:	6a 79                	push   $0x79
f0111ddc:	68 4d a9 12 f0       	push   $0xf012a94d
f0111de1:	e8 53 e5 fe ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f0111de6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111de9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f0111dec:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f0111df3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111df7:	74 06                	je     f0111dff <sys_check_WS_list+0x43>
f0111df9:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111dfd:	75 1f                	jne    f0111e1e <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111dff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111e02:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
f0111e08:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111e0b:	39 c2                	cmp    %eax,%edx
f0111e0d:	74 0f                	je     f0111e1e <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111e0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111e16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111e19:	e9 15 03 00 00       	jmp    f0112133 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111e1e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111e22:	74 39                	je     f0111e5d <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111e24:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111e27:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111e2d:	8b 00                	mov    (%eax),%eax
f0111e2f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0111e32:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0111e35:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111e3a:	89 c2                	mov    %eax,%edx
f0111e3c:	8b 45 10             	mov    0x10(%ebp),%eax
f0111e3f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0111e42:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0111e45:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111e4a:	39 c2                	cmp    %eax,%edx
f0111e4c:	74 0f                	je     f0111e5d <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111e4e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111e58:	e9 d6 02 00 00       	jmp    f0112133 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111e5d:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111e61:	0f 85 3c 01 00 00    	jne    f0111fa3 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111e67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0111e6e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0111e72:	74 4c                	je     f0111ec0 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111e74:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111e7b:	eb 3b                	jmp    f0111eb8 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111e7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111e80:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111e87:	8b 45 08             	mov    0x8(%ebp),%eax
f0111e8a:	01 d0                	add    %edx,%eax
f0111e8c:	8b 00                	mov    (%eax),%eax
f0111e8e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0111e91:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111e94:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111e99:	89 c2                	mov    %eax,%edx
f0111e9b:	8b 45 10             	mov    0x10(%ebp),%eax
f0111e9e:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0111ea1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0111ea4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111ea9:	39 c2                	cmp    %eax,%edx
f0111eab:	75 08                	jne    f0111eb5 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0111ead:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111eb0:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0111eb3:	eb 0b                	jmp    f0111ec0 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0111eb5:	ff 45 e8             	incl   -0x18(%ebp)
f0111eb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111ebb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111ebe:	7c bd                	jl     f0111e7d <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0111ec0:	83 ec 08             	sub    $0x8,%esp
f0111ec3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ec6:	68 94 a9 12 f0       	push   $0xf012a994
f0111ecb:	e8 bb f0 fe ff       	call   f0100f8b <cprintf>
f0111ed0:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0111ed3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111ed6:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111edc:	85 c0                	test   %eax,%eax
f0111ede:	74 0e                	je     f0111eee <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f0111ee0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111ee3:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
f0111ee9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111eec:	eb 0c                	jmp    f0111efa <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111eee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111ef1:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111ef7:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f0111efa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111efd:	8b 00                	mov    (%eax),%eax
f0111eff:	83 ec 08             	sub    $0x8,%esp
f0111f02:	50                   	push   %eax
f0111f03:	68 b3 a9 12 f0       	push   $0xf012a9b3
f0111f08:	e8 7e f0 fe ff       	call   f0100f8b <cprintf>
f0111f0d:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111f10:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111f17:	eb 79                	jmp    f0111f92 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f0111f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111f1c:	8b 00                	mov    (%eax),%eax
f0111f1e:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111f21:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111f24:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111f29:	89 c2                	mov    %eax,%edx
f0111f2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111f2e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111f35:	8b 45 08             	mov    0x8(%ebp),%eax
f0111f38:	01 c8                	add    %ecx,%eax
f0111f3a:	8b 00                	mov    (%eax),%eax
f0111f3c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111f3f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111f42:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111f47:	39 c2                	cmp    %eax,%edx
f0111f49:	74 0c                	je     f0111f57 <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f0111f4b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111f52:	e9 d9 01 00 00       	jmp    f0112130 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111f57:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111f5a:	40                   	inc    %eax
f0111f5b:	89 c2                	mov    %eax,%edx
f0111f5d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111f60:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f0111f66:	89 d0                	mov    %edx,%eax
f0111f68:	ba 00 00 00 00       	mov    $0x0,%edx
f0111f6d:	f7 f1                	div    %ecx
f0111f6f:	89 d0                	mov    %edx,%eax
f0111f71:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111f74:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111f77:	8b 40 10             	mov    0x10(%eax),%eax
f0111f7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0111f7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111f81:	75 0c                	jne    f0111f8f <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111f83:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111f86:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111f8f:	ff 45 e4             	incl   -0x1c(%ebp)
f0111f92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111f95:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111f98:	0f 8c 7b ff ff ff    	jl     f0111f19 <sys_check_WS_list+0x15d>
f0111f9e:	e9 8d 01 00 00       	jmp    f0112130 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111fa3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111fa7:	74 0a                	je     f0111fb3 <sys_check_WS_list+0x1f7>
f0111fa9:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0111fad:	0f 85 be 00 00 00    	jne    f0112071 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111fb3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0111fba:	e9 a1 00 00 00       	jmp    f0112060 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0111fbf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0111fc6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111fc9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0111fcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111fd2:	eb 47                	jmp    f011201b <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0111fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111fd7:	8b 00                	mov    (%eax),%eax
f0111fd9:	89 45 a8             	mov    %eax,-0x58(%ebp)
f0111fdc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111fdf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111fe4:	89 c2                	mov    %eax,%edx
f0111fe6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111fe9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111ff0:	8b 45 08             	mov    0x8(%ebp),%eax
f0111ff3:	01 c8                	add    %ecx,%eax
f0111ff5:	8b 00                	mov    (%eax),%eax
f0111ff7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0111ffa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0111ffd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0112002:	39 c2                	cmp    %eax,%edx
f0112004:	75 09                	jne    f011200f <sys_check_WS_list+0x253>
				{
					found = 1;
f0112006:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f011200d:	eb 3b                	jmp    f011204a <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011200f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112012:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0112018:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011201b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011201f:	74 08                	je     f0112029 <sys_check_WS_list+0x26d>
f0112021:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112024:	8b 40 10             	mov    0x10(%eax),%eax
f0112027:	eb 05                	jmp    f011202e <sys_check_WS_list+0x272>
f0112029:	b8 00 00 00 00       	mov    $0x0,%eax
f011202e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0112031:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f0112037:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011203a:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0112040:	85 c0                	test   %eax,%eax
f0112042:	75 90                	jne    f0111fd4 <sys_check_WS_list+0x218>
f0112044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112048:	75 8a                	jne    f0111fd4 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011204a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011204e:	75 0d                	jne    f011205d <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0112050:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0112057:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0112058:	e9 d3 00 00 00       	jmp    f0112130 <sys_check_WS_list+0x374>
f011205d:	ff 45 e0             	incl   -0x20(%ebp)
f0112060:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0112063:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0112066:	0f 8c 53 ff ff ff    	jl     f0111fbf <sys_check_WS_list+0x203>
f011206c:	e9 bf 00 00 00       	jmp    f0112130 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0112071:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0112075:	0f 85 b5 00 00 00    	jne    f0112130 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011207b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0112082:	e9 9d 00 00 00       	jmp    f0112124 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f0112087:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011208e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112091:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0112097:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011209a:	eb 47                	jmp    f01120e3 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011209c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011209f:	8b 00                	mov    (%eax),%eax
f01120a1:	89 45 b0             	mov    %eax,-0x50(%ebp)
f01120a4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01120a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01120ac:	89 c2                	mov    %eax,%edx
f01120ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01120b1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01120b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01120bb:	01 c8                	add    %ecx,%eax
f01120bd:	8b 00                	mov    (%eax),%eax
f01120bf:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01120c2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01120c5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01120ca:	39 c2                	cmp    %eax,%edx
f01120cc:	75 09                	jne    f01120d7 <sys_check_WS_list+0x31b>
				{
					found = 1;
f01120ce:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01120d5:	eb 3b                	jmp    f0112112 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01120d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01120da:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f01120e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01120e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01120e7:	74 08                	je     f01120f1 <sys_check_WS_list+0x335>
f01120e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01120ec:	8b 40 10             	mov    0x10(%eax),%eax
f01120ef:	eb 05                	jmp    f01120f6 <sys_check_WS_list+0x33a>
f01120f1:	b8 00 00 00 00       	mov    $0x0,%eax
f01120f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01120f9:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
f01120ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0112102:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
f0112108:	85 c0                	test   %eax,%eax
f011210a:	75 90                	jne    f011209c <sys_check_WS_list+0x2e0>
f011210c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112110:	75 8a                	jne    f011209c <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f0112112:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0112116:	74 09                	je     f0112121 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f0112118:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011211f:	eb 0f                	jmp    f0112130 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0112121:	ff 45 d8             	incl   -0x28(%ebp)
f0112124:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112127:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011212a:	0f 8c 57 ff ff ff    	jl     f0112087 <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f0112130:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0112133:	c9                   	leave  
f0112134:	c3                   	ret    

f0112135 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0112135:	55                   	push   %ebp
f0112136:	89 e5                	mov    %esp,%ebp
f0112138:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011213b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0112142:	8b 15 58 5f 74 f0    	mov    0xf0745f58,%edx
f0112148:	8b 45 0c             	mov    0xc(%ebp),%eax
f011214b:	39 c2                	cmp    %eax,%edx
f011214d:	74 0a                	je     f0112159 <hasExpectedCommands+0x24>
		return 0;
f011214f:	b8 00 00 00 00       	mov    $0x0,%eax
f0112154:	e9 8b 00 00 00       	jmp    f01121e4 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0112159:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f011215e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0112161:	eb 55                	jmp    f01121b8 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0112163:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011216a:	eb 2a                	jmp    f0112196 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011216c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011216f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0112176:	8b 45 08             	mov    0x8(%ebp),%eax
f0112179:	01 d0                	add    %edx,%eax
f011217b:	8b 10                	mov    (%eax),%edx
f011217d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0112180:	8b 00                	mov    (%eax),%eax
f0112182:	83 ec 08             	sub    $0x8,%esp
f0112185:	52                   	push   %edx
f0112186:	50                   	push   %eax
f0112187:	e8 bb fe 00 00       	call   f0122047 <strcmp>
f011218c:	83 c4 10             	add    $0x10,%esp
f011218f:	85 c0                	test   %eax,%eax
f0112191:	74 0d                	je     f01121a0 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0112193:	ff 45 f0             	incl   -0x10(%ebp)
f0112196:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0112199:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011219c:	7c ce                	jl     f011216c <hasExpectedCommands+0x37>
f011219e:	eb 01                	jmp    f01121a1 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01121a0:	90                   	nop
		if (i == commandsCount)
f01121a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01121a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01121a7:	75 07                	jne    f01121b0 <hasExpectedCommands+0x7b>
			return 0;
f01121a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01121ae:	eb 34                	jmp    f01121e4 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01121b0:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f01121b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01121b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01121bc:	74 08                	je     f01121c6 <hasExpectedCommands+0x91>
f01121be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01121c1:	8b 40 10             	mov    0x10(%eax),%eax
f01121c4:	eb 05                	jmp    f01121cb <hasExpectedCommands+0x96>
f01121c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01121cb:	a3 54 5f 74 f0       	mov    %eax,0xf0745f54
f01121d0:	a1 54 5f 74 f0       	mov    0xf0745f54,%eax
f01121d5:	85 c0                	test   %eax,%eax
f01121d7:	75 8a                	jne    f0112163 <hasExpectedCommands+0x2e>
f01121d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01121dd:	75 84                	jne    f0112163 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01121df:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01121e4:	c9                   	leave  
f01121e5:	c3                   	ret    

f01121e6 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01121e6:	55                   	push   %ebp
f01121e7:	89 e5                	mov    %esp,%ebp
f01121e9:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01121ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01121f3:	eb 2e                	jmp    f0112223 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01121f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01121f8:	89 d0                	mov    %edx,%eax
f01121fa:	01 c0                	add    %eax,%eax
f01121fc:	01 d0                	add    %edx,%eax
f01121fe:	c1 e0 03             	shl    $0x3,%eax
f0112201:	05 40 35 18 f0       	add    $0xf0183540,%eax
f0112206:	8b 00                	mov    (%eax),%eax
f0112208:	83 ec 08             	sub    $0x8,%esp
f011220b:	ff 75 08             	pushl  0x8(%ebp)
f011220e:	50                   	push   %eax
f011220f:	e8 33 fe 00 00       	call   f0122047 <strcmp>
f0112214:	83 c4 10             	add    $0x10,%esp
f0112217:	85 c0                	test   %eax,%eax
f0112219:	75 05                	jne    f0112220 <getIndexOfCommand+0x3a>
			return i;
f011221b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011221e:	eb 14                	jmp    f0112234 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0112220:	ff 45 f4             	incl   -0xc(%ebp)
f0112223:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0112226:	a1 90 39 18 f0       	mov    0xf0183990,%eax
f011222b:	39 c2                	cmp    %eax,%edx
f011222d:	72 c6                	jb     f01121f5 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011222f:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0112234:	c9                   	leave  
f0112235:	c3                   	ret    

f0112236 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0112236:	55                   	push   %ebp
f0112237:	89 e5                	mov    %esp,%ebp
f0112239:	57                   	push   %edi
f011223a:	56                   	push   %esi
f011223b:	53                   	push   %ebx
f011223c:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0112242:	83 ec 0c             	sub    $0xc,%esp
f0112245:	68 e0 a9 12 f0       	push   $0xf012a9e0
f011224a:	e8 3c ed fe ff       	call   f0100f8b <cprintf>
f011224f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0112252:	83 ec 0c             	sub    $0xc,%esp
f0112255:	68 04 aa 12 f0       	push   $0xf012aa04
f011225a:	e8 2c ed fe ff       	call   f0100f8b <cprintf>
f011225f:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0112262:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0112269:	c7 45 8c 1f aa 12 f0 	movl   $0xf012aa1f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0112270:	83 ec 08             	sub    $0x8,%esp
f0112273:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0112276:	50                   	push   %eax
f0112277:	6a 01                	push   $0x1
f0112279:	e8 52 ff fe ff       	call   f01021d0 <process_command>
f011227e:	83 c4 10             	add    $0x10,%esp
f0112281:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0112284:	83 ec 0c             	sub    $0xc,%esp
f0112287:	68 2c aa 12 f0       	push   $0xf012aa2c
f011228c:	e8 fa ec fe ff       	call   f0100f8b <cprintf>
f0112291:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0112294:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112297:	83 ec 0c             	sub    $0xc,%esp
f011229a:	50                   	push   %eax
f011229b:	e8 46 ff ff ff       	call   f01121e6 <getIndexOfCommand>
f01122a0:	83 c4 10             	add    $0x10,%esp
f01122a3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01122a6:	75 0f                	jne    f01122b7 <TestAutoCompleteCommand+0x81>
f01122a8:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f01122ad:	85 c0                	test   %eax,%eax
f01122af:	75 06                	jne    f01122b7 <TestAutoCompleteCommand+0x81>
		eval += 15;
f01122b1:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01122b5:	eb 10                	jmp    f01122c7 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01122b7:	83 ec 0c             	sub    $0xc,%esp
f01122ba:	68 5c aa 12 f0       	push   $0xf012aa5c
f01122bf:	e8 c7 ec fe ff       	call   f0100f8b <cprintf>
f01122c4:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01122c7:	83 ec 0c             	sub    $0xc,%esp
f01122ca:	68 ac aa 12 f0       	push   $0xf012aaac
f01122cf:	e8 b7 ec fe ff       	call   f0100f8b <cprintf>
f01122d4:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01122d7:	c7 45 88 d2 aa 12 f0 	movl   $0xf012aad2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01122de:	83 ec 08             	sub    $0x8,%esp
f01122e1:	8d 45 88             	lea    -0x78(%ebp),%eax
f01122e4:	50                   	push   %eax
f01122e5:	6a 01                	push   $0x1
f01122e7:	e8 e4 fe fe ff       	call   f01021d0 <process_command>
f01122ec:	83 c4 10             	add    $0x10,%esp
f01122ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01122f2:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01122f6:	75 30                	jne    f0112328 <TestAutoCompleteCommand+0xf2>
f01122f8:	8d 45 90             	lea    -0x70(%ebp),%eax
f01122fb:	bb b0 ae 12 f0       	mov    $0xf012aeb0,%ebx
f0112300:	ba 03 00 00 00       	mov    $0x3,%edx
f0112305:	89 c7                	mov    %eax,%edi
f0112307:	89 de                	mov    %ebx,%esi
f0112309:	89 d1                	mov    %edx,%ecx
f011230b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011230d:	83 ec 08             	sub    $0x8,%esp
f0112310:	6a 03                	push   $0x3
f0112312:	8d 45 90             	lea    -0x70(%ebp),%eax
f0112315:	50                   	push   %eax
f0112316:	e8 1a fe ff ff       	call   f0112135 <hasExpectedCommands>
f011231b:	83 c4 10             	add    $0x10,%esp
f011231e:	85 c0                	test   %eax,%eax
f0112320:	74 06                	je     f0112328 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0112322:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0112326:	eb 10                	jmp    f0112338 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0112328:	83 ec 0c             	sub    $0xc,%esp
f011232b:	68 d8 aa 12 f0       	push   $0xf012aad8
f0112330:	e8 56 ec fe ff       	call   f0100f8b <cprintf>
f0112335:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0112338:	83 ec 0c             	sub    $0xc,%esp
f011233b:	68 28 ab 12 f0       	push   $0xf012ab28
f0112340:	e8 46 ec fe ff       	call   f0100f8b <cprintf>
f0112345:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0112348:	c7 45 84 4d ab 12 f0 	movl   $0xf012ab4d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011234f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0112352:	83 ec 04             	sub    $0x4,%esp
f0112355:	50                   	push   %eax
f0112356:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0112359:	50                   	push   %eax
f011235a:	68 50 ab 12 f0       	push   $0xf012ab50
f011235f:	e8 27 ec fe ff       	call   f0100f8b <cprintf>
f0112364:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0112367:	83 ec 08             	sub    $0x8,%esp
f011236a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011236d:	50                   	push   %eax
f011236e:	6a 01                	push   $0x1
f0112370:	e8 5b fe fe ff       	call   f01021d0 <process_command>
f0112375:	83 c4 10             	add    $0x10,%esp
f0112378:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011237b:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f011237f:	75 1b                	jne    f011239c <TestAutoCompleteCommand+0x166>
f0112381:	83 ec 08             	sub    $0x8,%esp
f0112384:	6a 01                	push   $0x1
f0112386:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0112389:	50                   	push   %eax
f011238a:	e8 a6 fd ff ff       	call   f0112135 <hasExpectedCommands>
f011238f:	83 c4 10             	add    $0x10,%esp
f0112392:	85 c0                	test   %eax,%eax
f0112394:	74 06                	je     f011239c <TestAutoCompleteCommand+0x166>
		eval += 15;
f0112396:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011239a:	eb 10                	jmp    f01123ac <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f011239c:	83 ec 0c             	sub    $0xc,%esp
f011239f:	68 70 ab 12 f0       	push   $0xf012ab70
f01123a4:	e8 e2 eb fe ff       	call   f0100f8b <cprintf>
f01123a9:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01123ac:	83 ec 0c             	sub    $0xc,%esp
f01123af:	68 c8 ab 12 f0       	push   $0xf012abc8
f01123b4:	e8 d2 eb fe ff       	call   f0100f8b <cprintf>
f01123b9:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01123bc:	c7 45 80 ee ab 12 f0 	movl   $0xf012abee,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01123c3:	83 ec 08             	sub    $0x8,%esp
f01123c6:	8d 45 80             	lea    -0x80(%ebp),%eax
f01123c9:	50                   	push   %eax
f01123ca:	6a 01                	push   $0x1
f01123cc:	e8 ff fd fe ff       	call   f01021d0 <process_command>
f01123d1:	83 c4 10             	add    $0x10,%esp
f01123d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f01123d7:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f01123db:	75 0f                	jne    f01123ec <TestAutoCompleteCommand+0x1b6>
f01123dd:	a1 58 5f 74 f0       	mov    0xf0745f58,%eax
f01123e2:	85 c0                	test   %eax,%eax
f01123e4:	75 06                	jne    f01123ec <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f01123e6:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01123ea:	eb 10                	jmp    f01123fc <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01123ec:	83 ec 0c             	sub    $0xc,%esp
f01123ef:	68 f4 ab 12 f0       	push   $0xf012abf4
f01123f4:	e8 92 eb fe ff       	call   f0100f8b <cprintf>
f01123f9:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f01123fc:	83 ec 0c             	sub    $0xc,%esp
f01123ff:	68 44 ac 12 f0       	push   $0xf012ac44
f0112404:	e8 82 eb fe ff       	call   f0100f8b <cprintf>
f0112409:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011240c:	c7 85 7c ff ff ff 69 	movl   $0xf012ac69,-0x84(%ebp)
f0112413:	ac 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0112416:	83 ec 08             	sub    $0x8,%esp
f0112419:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011241f:	50                   	push   %eax
f0112420:	6a 01                	push   $0x1
f0112422:	e8 a9 fd fe ff       	call   f01021d0 <process_command>
f0112427:	83 c4 10             	add    $0x10,%esp
f011242a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011242d:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0112431:	75 30                	jne    f0112463 <TestAutoCompleteCommand+0x22d>
f0112433:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0112436:	bb 40 af 12 f0       	mov    $0xf012af40,%ebx
f011243b:	ba 0c 00 00 00       	mov    $0xc,%edx
f0112440:	89 c7                	mov    %eax,%edi
f0112442:	89 de                	mov    %ebx,%esi
f0112444:	89 d1                	mov    %edx,%ecx
f0112446:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0112448:	83 ec 08             	sub    $0x8,%esp
f011244b:	6a 0c                	push   $0xc
f011244d:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0112450:	50                   	push   %eax
f0112451:	e8 df fc ff ff       	call   f0112135 <hasExpectedCommands>
f0112456:	83 c4 10             	add    $0x10,%esp
f0112459:	85 c0                	test   %eax,%eax
f011245b:	74 06                	je     f0112463 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011245d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0112461:	eb 10                	jmp    f0112473 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0112463:	83 ec 0c             	sub    $0xc,%esp
f0112466:	68 6c ac 12 f0       	push   $0xf012ac6c
f011246b:	e8 1b eb fe ff       	call   f0100f8b <cprintf>
f0112470:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0112473:	83 ec 0c             	sub    $0xc,%esp
f0112476:	68 c4 ac 12 f0       	push   $0xf012acc4
f011247b:	e8 0b eb fe ff       	call   f0100f8b <cprintf>
f0112480:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0112483:	c7 85 78 ff ff ff e9 	movl   $0xf012ace9,-0x88(%ebp)
f011248a:	ac 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f011248d:	83 ec 08             	sub    $0x8,%esp
f0112490:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0112496:	50                   	push   %eax
f0112497:	6a 01                	push   $0x1
f0112499:	e8 32 fd fe ff       	call   f01021d0 <process_command>
f011249e:	83 c4 10             	add    $0x10,%esp
f01124a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01124a4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01124a8:	75 30                	jne    f01124da <TestAutoCompleteCommand+0x2a4>
f01124aa:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01124ad:	bb 88 af 12 f0       	mov    $0xf012af88,%ebx
f01124b2:	ba 05 00 00 00       	mov    $0x5,%edx
f01124b7:	89 c7                	mov    %eax,%edi
f01124b9:	89 de                	mov    %ebx,%esi
f01124bb:	89 d1                	mov    %edx,%ecx
f01124bd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01124bf:	83 ec 08             	sub    $0x8,%esp
f01124c2:	6a 05                	push   $0x5
f01124c4:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01124c7:	50                   	push   %eax
f01124c8:	e8 68 fc ff ff       	call   f0112135 <hasExpectedCommands>
f01124cd:	83 c4 10             	add    $0x10,%esp
f01124d0:	85 c0                	test   %eax,%eax
f01124d2:	74 06                	je     f01124da <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f01124d4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01124d8:	eb 10                	jmp    f01124ea <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f01124da:	83 ec 0c             	sub    $0xc,%esp
f01124dd:	68 ec ac 12 f0       	push   $0xf012acec
f01124e2:	e8 a4 ea fe ff       	call   f0100f8b <cprintf>
f01124e7:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f01124ea:	83 ec 0c             	sub    $0xc,%esp
f01124ed:	68 44 ad 12 f0       	push   $0xf012ad44
f01124f2:	e8 94 ea fe ff       	call   f0100f8b <cprintf>
f01124f7:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f01124fa:	c7 85 70 ff ff ff 70 	movl   $0xf012ad70,-0x90(%ebp)
f0112501:	ad 12 f0 
f0112504:	c7 85 74 ff ff ff 75 	movl   $0xf012ad75,-0x8c(%ebp)
f011250b:	ad 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011250e:	83 ec 08             	sub    $0x8,%esp
f0112511:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0112517:	50                   	push   %eax
f0112518:	6a 02                	push   $0x2
f011251a:	e8 b1 fc fe ff       	call   f01021d0 <process_command>
f011251f:	83 c4 10             	add    $0x10,%esp
f0112522:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0112525:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011252b:	83 ec 0c             	sub    $0xc,%esp
f011252e:	50                   	push   %eax
f011252f:	e8 b2 fc ff ff       	call   f01121e6 <getIndexOfCommand>
f0112534:	83 c4 10             	add    $0x10,%esp
f0112537:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011253a:	75 0f                	jne    f011254b <TestAutoCompleteCommand+0x315>
f011253c:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f0112541:	85 c0                	test   %eax,%eax
f0112543:	75 06                	jne    f011254b <TestAutoCompleteCommand+0x315>
		eval += 10;
f0112545:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0112549:	eb 10                	jmp    f011255b <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011254b:	83 ec 0c             	sub    $0xc,%esp
f011254e:	68 7c ad 12 f0       	push   $0xf012ad7c
f0112553:	e8 33 ea fe ff       	call   f0100f8b <cprintf>
f0112558:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011255b:	83 ec 0c             	sub    $0xc,%esp
f011255e:	68 cc ad 12 f0       	push   $0xf012adcc
f0112563:	e8 23 ea fe ff       	call   f0100f8b <cprintf>
f0112568:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011256b:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0112571:	bb b0 af 12 f0       	mov    $0xf012afb0,%ebx
f0112576:	ba 03 00 00 00       	mov    $0x3,%edx
f011257b:	89 c7                	mov    %eax,%edi
f011257d:	89 de                	mov    %ebx,%esi
f011257f:	89 d1                	mov    %edx,%ecx
f0112581:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0112583:	83 ec 08             	sub    $0x8,%esp
f0112586:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f011258c:	50                   	push   %eax
f011258d:	6a 03                	push   $0x3
f011258f:	e8 3c fc fe ff       	call   f01021d0 <process_command>
f0112594:	83 c4 10             	add    $0x10,%esp
f0112597:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f011259a:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01125a0:	83 ec 0c             	sub    $0xc,%esp
f01125a3:	50                   	push   %eax
f01125a4:	e8 3d fc ff ff       	call   f01121e6 <getIndexOfCommand>
f01125a9:	83 c4 10             	add    $0x10,%esp
f01125ac:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01125af:	75 0f                	jne    f01125c0 <TestAutoCompleteCommand+0x38a>
f01125b1:	a1 4c 5f 74 f0       	mov    0xf0745f4c,%eax
f01125b6:	85 c0                	test   %eax,%eax
f01125b8:	75 06                	jne    f01125c0 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f01125ba:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01125be:	eb 10                	jmp    f01125d0 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01125c0:	83 ec 0c             	sub    $0xc,%esp
f01125c3:	68 00 ae 12 f0       	push   $0xf012ae00
f01125c8:	e8 be e9 fe ff       	call   f0100f8b <cprintf>
f01125cd:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f01125d0:	83 ec 08             	sub    $0x8,%esp
f01125d3:	ff 75 e4             	pushl  -0x1c(%ebp)
f01125d6:	68 50 ae 12 f0       	push   $0xf012ae50
f01125db:	e8 ab e9 fe ff       	call   f0100f8b <cprintf>
f01125e0:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01125e3:	83 ec 0c             	sub    $0xc,%esp
f01125e6:	68 80 ae 12 f0       	push   $0xf012ae80
f01125eb:	e8 9b e9 fe ff       	call   f0100f8b <cprintf>
f01125f0:	83 c4 10             	add    $0x10,%esp

	return 0;
f01125f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01125f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01125fb:	5b                   	pop    %ebx
f01125fc:	5e                   	pop    %esi
f01125fd:	5f                   	pop    %edi
f01125fe:	5d                   	pop    %ebp
f01125ff:	c3                   	ret    

f0112600 <test_str2lower_function>:

int test_str2lower_function()
{
f0112600:	55                   	push   %ebp
f0112601:	89 e5                	mov    %esp,%ebp
f0112603:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0112609:	83 ec 0c             	sub    $0xc,%esp
f011260c:	68 bc af 12 f0       	push   $0xf012afbc
f0112611:	e8 75 e9 fe ff       	call   f0100f8b <cprintf>
f0112616:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0112619:	83 ec 0c             	sub    $0xc,%esp
f011261c:	68 dd af 12 f0       	push   $0xf012afdd
f0112621:	e8 65 e9 fe ff       	call   f0100f8b <cprintf>
f0112626:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0112629:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0112630:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0112637:	c7 45 ec f7 af 12 f0 	movl   $0xf012aff7,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011263e:	83 ec 08             	sub    $0x8,%esp
f0112641:	ff 75 ec             	pushl  -0x14(%ebp)
f0112644:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f011264a:	50                   	push   %eax
f011264b:	e8 d4 ff 00 00       	call   f0122624 <str2lower>
f0112650:	83 c4 10             	add    $0x10,%esp
f0112653:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0112656:	83 ec 0c             	sub    $0xc,%esp
f0112659:	ff 75 e8             	pushl  -0x18(%ebp)
f011265c:	e8 da f8 00 00       	call   f0121f3b <strlen>
f0112661:	83 c4 10             	add    $0x10,%esp
f0112664:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0112667:	83 ec 08             	sub    $0x8,%esp
f011266a:	68 02 b0 12 f0       	push   $0xf012b002
f011266f:	ff 75 e8             	pushl  -0x18(%ebp)
f0112672:	e8 d0 f9 00 00       	call   f0122047 <strcmp>
f0112677:	83 c4 10             	add    $0x10,%esp
f011267a:	85 c0                	test   %eax,%eax
f011267c:	75 13                	jne    f0112691 <test_str2lower_function+0x91>
f011267e:	83 ec 0c             	sub    $0xc,%esp
f0112681:	ff 75 ec             	pushl  -0x14(%ebp)
f0112684:	e8 b2 f8 00 00       	call   f0121f3b <strlen>
f0112689:	83 c4 10             	add    $0x10,%esp
f011268c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011268f:	74 15                	je     f01126a6 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0112691:	83 ec 08             	sub    $0x8,%esp
f0112694:	ff 75 e8             	pushl  -0x18(%ebp)
f0112697:	68 10 b0 12 f0       	push   $0xf012b010
f011269c:	e8 ea e8 fe ff       	call   f0100f8b <cprintf>
f01126a1:	83 c4 10             	add    $0x10,%esp
f01126a4:	eb 04                	jmp    f01126aa <test_str2lower_function+0xaa>
	else
		eval += 10;
f01126a6:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01126aa:	c7 45 e0 72 b0 12 f0 	movl   $0xf012b072,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01126b1:	83 ec 08             	sub    $0x8,%esp
f01126b4:	ff 75 e0             	pushl  -0x20(%ebp)
f01126b7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126bd:	50                   	push   %eax
f01126be:	e8 61 ff 00 00       	call   f0122624 <str2lower>
f01126c3:	83 c4 10             	add    $0x10,%esp
f01126c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01126c9:	83 ec 0c             	sub    $0xc,%esp
f01126cc:	ff 75 e8             	pushl  -0x18(%ebp)
f01126cf:	e8 67 f8 00 00       	call   f0121f3b <strlen>
f01126d4:	83 c4 10             	add    $0x10,%esp
f01126d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f01126da:	83 ec 08             	sub    $0x8,%esp
f01126dd:	68 72 b0 12 f0       	push   $0xf012b072
f01126e2:	ff 75 e8             	pushl  -0x18(%ebp)
f01126e5:	e8 5d f9 00 00       	call   f0122047 <strcmp>
f01126ea:	83 c4 10             	add    $0x10,%esp
f01126ed:	85 c0                	test   %eax,%eax
f01126ef:	75 13                	jne    f0112704 <test_str2lower_function+0x104>
f01126f1:	83 ec 0c             	sub    $0xc,%esp
f01126f4:	ff 75 e0             	pushl  -0x20(%ebp)
f01126f7:	e8 3f f8 00 00       	call   f0121f3b <strlen>
f01126fc:	83 c4 10             	add    $0x10,%esp
f01126ff:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112702:	74 15                	je     f0112719 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0112704:	83 ec 08             	sub    $0x8,%esp
f0112707:	ff 75 e8             	pushl  -0x18(%ebp)
f011270a:	68 74 b0 12 f0       	push   $0xf012b074
f011270f:	e8 77 e8 fe ff       	call   f0100f8b <cprintf>
f0112714:	83 c4 10             	add    $0x10,%esp
f0112717:	eb 04                	jmp    f011271d <test_str2lower_function+0x11d>
	else
		eval += 10;
f0112719:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011271d:	c7 45 dc cc b0 12 f0 	movl   $0xf012b0cc,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0112724:	83 ec 08             	sub    $0x8,%esp
f0112727:	ff 75 dc             	pushl  -0x24(%ebp)
f011272a:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0112730:	50                   	push   %eax
f0112731:	e8 ee fe 00 00       	call   f0122624 <str2lower>
f0112736:	83 c4 10             	add    $0x10,%esp
f0112739:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011273c:	83 ec 0c             	sub    $0xc,%esp
f011273f:	ff 75 e8             	pushl  -0x18(%ebp)
f0112742:	e8 f4 f7 00 00       	call   f0121f3b <strlen>
f0112747:	83 c4 10             	add    $0x10,%esp
f011274a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011274d:	83 ec 08             	sub    $0x8,%esp
f0112750:	68 cc b0 12 f0       	push   $0xf012b0cc
f0112755:	ff 75 e8             	pushl  -0x18(%ebp)
f0112758:	e8 ea f8 00 00       	call   f0122047 <strcmp>
f011275d:	83 c4 10             	add    $0x10,%esp
f0112760:	85 c0                	test   %eax,%eax
f0112762:	75 13                	jne    f0112777 <test_str2lower_function+0x177>
f0112764:	83 ec 0c             	sub    $0xc,%esp
f0112767:	ff 75 dc             	pushl  -0x24(%ebp)
f011276a:	e8 cc f7 00 00       	call   f0121f3b <strlen>
f011276f:	83 c4 10             	add    $0x10,%esp
f0112772:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112775:	74 15                	je     f011278c <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0112777:	83 ec 08             	sub    $0x8,%esp
f011277a:	ff 75 e8             	pushl  -0x18(%ebp)
f011277d:	68 d8 b0 12 f0       	push   $0xf012b0d8
f0112782:	e8 04 e8 fe ff       	call   f0100f8b <cprintf>
f0112787:	83 c4 10             	add    $0x10,%esp
f011278a:	eb 04                	jmp    f0112790 <test_str2lower_function+0x190>
	else
		eval += 15;
f011278c:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0112790:	c7 45 d8 3b b1 12 f0 	movl   $0xf012b13b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0112797:	83 ec 08             	sub    $0x8,%esp
f011279a:	ff 75 d8             	pushl  -0x28(%ebp)
f011279d:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01127a3:	50                   	push   %eax
f01127a4:	e8 7b fe 00 00       	call   f0122624 <str2lower>
f01127a9:	83 c4 10             	add    $0x10,%esp
f01127ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01127af:	83 ec 0c             	sub    $0xc,%esp
f01127b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01127b5:	e8 81 f7 00 00       	call   f0121f3b <strlen>
f01127ba:	83 c4 10             	add    $0x10,%esp
f01127bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f01127c0:	83 ec 08             	sub    $0x8,%esp
f01127c3:	68 3b b1 12 f0       	push   $0xf012b13b
f01127c8:	ff 75 e8             	pushl  -0x18(%ebp)
f01127cb:	e8 77 f8 00 00       	call   f0122047 <strcmp>
f01127d0:	83 c4 10             	add    $0x10,%esp
f01127d3:	85 c0                	test   %eax,%eax
f01127d5:	75 13                	jne    f01127ea <test_str2lower_function+0x1ea>
f01127d7:	83 ec 0c             	sub    $0xc,%esp
f01127da:	ff 75 d8             	pushl  -0x28(%ebp)
f01127dd:	e8 59 f7 00 00       	call   f0121f3b <strlen>
f01127e2:	83 c4 10             	add    $0x10,%esp
f01127e5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01127e8:	74 15                	je     f01127ff <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f01127ea:	83 ec 08             	sub    $0x8,%esp
f01127ed:	ff 75 e8             	pushl  -0x18(%ebp)
f01127f0:	68 48 b1 12 f0       	push   $0xf012b148
f01127f5:	e8 91 e7 fe ff       	call   f0100f8b <cprintf>
f01127fa:	83 c4 10             	add    $0x10,%esp
f01127fd:	eb 04                	jmp    f0112803 <test_str2lower_function+0x203>
	else
		eval += 15;
f01127ff:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0112803:	c7 45 d4 aa b1 12 f0 	movl   $0xf012b1aa,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f011280a:	83 ec 08             	sub    $0x8,%esp
f011280d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112810:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0112816:	50                   	push   %eax
f0112817:	e8 08 fe 00 00       	call   f0122624 <str2lower>
f011281c:	83 c4 10             	add    $0x10,%esp
f011281f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112822:	83 ec 0c             	sub    $0xc,%esp
f0112825:	ff 75 e8             	pushl  -0x18(%ebp)
f0112828:	e8 0e f7 00 00       	call   f0121f3b <strlen>
f011282d:	83 c4 10             	add    $0x10,%esp
f0112830:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0112833:	83 ec 08             	sub    $0x8,%esp
f0112836:	68 c0 b1 12 f0       	push   $0xf012b1c0
f011283b:	ff 75 e8             	pushl  -0x18(%ebp)
f011283e:	e8 04 f8 00 00       	call   f0122047 <strcmp>
f0112843:	83 c4 10             	add    $0x10,%esp
f0112846:	85 c0                	test   %eax,%eax
f0112848:	75 13                	jne    f011285d <test_str2lower_function+0x25d>
f011284a:	83 ec 0c             	sub    $0xc,%esp
f011284d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112850:	e8 e6 f6 00 00       	call   f0121f3b <strlen>
f0112855:	83 c4 10             	add    $0x10,%esp
f0112858:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011285b:	74 15                	je     f0112872 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f011285d:	83 ec 08             	sub    $0x8,%esp
f0112860:	ff 75 e8             	pushl  -0x18(%ebp)
f0112863:	68 d8 b1 12 f0       	push   $0xf012b1d8
f0112868:	e8 1e e7 fe ff       	call   f0100f8b <cprintf>
f011286d:	83 c4 10             	add    $0x10,%esp
f0112870:	eb 04                	jmp    f0112876 <test_str2lower_function+0x276>
	else
		eval += 15;
f0112872:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0112876:	c7 45 d0 45 b2 12 f0 	movl   $0xf012b245,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f011287d:	83 ec 08             	sub    $0x8,%esp
f0112880:	ff 75 d0             	pushl  -0x30(%ebp)
f0112883:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0112889:	50                   	push   %eax
f011288a:	e8 95 fd 00 00       	call   f0122624 <str2lower>
f011288f:	83 c4 10             	add    $0x10,%esp
f0112892:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112895:	83 ec 0c             	sub    $0xc,%esp
f0112898:	ff 75 e8             	pushl  -0x18(%ebp)
f011289b:	e8 9b f6 00 00       	call   f0121f3b <strlen>
f01128a0:	83 c4 10             	add    $0x10,%esp
f01128a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f01128a6:	83 ec 08             	sub    $0x8,%esp
f01128a9:	68 51 b2 12 f0       	push   $0xf012b251
f01128ae:	ff 75 e8             	pushl  -0x18(%ebp)
f01128b1:	e8 91 f7 00 00       	call   f0122047 <strcmp>
f01128b6:	83 c4 10             	add    $0x10,%esp
f01128b9:	85 c0                	test   %eax,%eax
f01128bb:	75 13                	jne    f01128d0 <test_str2lower_function+0x2d0>
f01128bd:	83 ec 0c             	sub    $0xc,%esp
f01128c0:	ff 75 d0             	pushl  -0x30(%ebp)
f01128c3:	e8 73 f6 00 00       	call   f0121f3b <strlen>
f01128c8:	83 c4 10             	add    $0x10,%esp
f01128cb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01128ce:	74 15                	je     f01128e5 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f01128d0:	83 ec 08             	sub    $0x8,%esp
f01128d3:	ff 75 e8             	pushl  -0x18(%ebp)
f01128d6:	68 60 b2 12 f0       	push   $0xf012b260
f01128db:	e8 ab e6 fe ff       	call   f0100f8b <cprintf>
f01128e0:	83 c4 10             	add    $0x10,%esp
f01128e3:	eb 04                	jmp    f01128e9 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f01128e5:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f01128e9:	c7 45 cc c3 b2 12 f0 	movl   $0xf012b2c3,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f01128f0:	83 ec 08             	sub    $0x8,%esp
f01128f3:	ff 75 cc             	pushl  -0x34(%ebp)
f01128f6:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f01128fc:	50                   	push   %eax
f01128fd:	e8 22 fd 00 00       	call   f0122624 <str2lower>
f0112902:	83 c4 10             	add    $0x10,%esp
f0112905:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0112908:	83 ec 0c             	sub    $0xc,%esp
f011290b:	ff 75 e8             	pushl  -0x18(%ebp)
f011290e:	e8 28 f6 00 00       	call   f0121f3b <strlen>
f0112913:	83 c4 10             	add    $0x10,%esp
f0112916:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0112919:	83 ec 08             	sub    $0x8,%esp
f011291c:	68 de b2 12 f0       	push   $0xf012b2de
f0112921:	ff 75 e8             	pushl  -0x18(%ebp)
f0112924:	e8 1e f7 00 00       	call   f0122047 <strcmp>
f0112929:	83 c4 10             	add    $0x10,%esp
f011292c:	85 c0                	test   %eax,%eax
f011292e:	75 13                	jne    f0112943 <test_str2lower_function+0x343>
f0112930:	83 ec 0c             	sub    $0xc,%esp
f0112933:	ff 75 cc             	pushl  -0x34(%ebp)
f0112936:	e8 00 f6 00 00       	call   f0121f3b <strlen>
f011293b:	83 c4 10             	add    $0x10,%esp
f011293e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112941:	74 15                	je     f0112958 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0112943:	83 ec 08             	sub    $0x8,%esp
f0112946:	ff 75 e8             	pushl  -0x18(%ebp)
f0112949:	68 fc b2 12 f0       	push   $0xf012b2fc
f011294e:	e8 38 e6 fe ff       	call   f0100f8b <cprintf>
f0112953:	83 c4 10             	add    $0x10,%esp
f0112956:	eb 04                	jmp    f011295c <test_str2lower_function+0x35c>
	else
		eval += 20;
f0112958:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f011295c:	83 ec 08             	sub    $0x8,%esp
f011295f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112962:	68 70 b3 12 f0       	push   $0xf012b370
f0112967:	e8 1f e6 fe ff       	call   f0100f8b <cprintf>
f011296c:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f011296f:	83 ec 0c             	sub    $0xc,%esp
f0112972:	68 80 ae 12 f0       	push   $0xf012ae80
f0112977:	e8 0f e6 fe ff       	call   f0100f8b <cprintf>
f011297c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011297f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112984:	c9                   	leave  
f0112985:	c3                   	ret    

f0112986 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0112986:	55                   	push   %ebp
f0112987:	89 e5                	mov    %esp,%ebp
f0112989:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f011298c:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112993:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011299a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01129a1:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01129a6:	ff 75 ec             	pushl  -0x14(%ebp)
f01129a9:	ff 75 f0             	pushl  -0x10(%ebp)
f01129ac:	ff 75 f4             	pushl  -0xc(%ebp)
f01129af:	50                   	push   %eax
f01129b0:	e8 7d 77 ff ff       	call   f010a132 <pt_set_page_permissions>
f01129b5:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01129b8:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01129bd:	ff 75 ec             	pushl  -0x14(%ebp)
f01129c0:	ff 75 f0             	pushl  -0x10(%ebp)
f01129c3:	ff 75 f4             	pushl  -0xc(%ebp)
f01129c6:	50                   	push   %eax
f01129c7:	e8 74 4b 00 00       	call   f0117540 <CP>
f01129cc:	83 c4 10             	add    $0x10,%esp
f01129cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01129d2:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01129d6:	74 17                	je     f01129ef <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f01129d8:	83 ec 04             	sub    $0x4,%esp
f01129db:	68 a0 b3 12 f0       	push   $0xf012b3a0
f01129e0:	68 23 01 00 00       	push   $0x123
f01129e5:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01129ea:	e8 4a d9 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f01129ef:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f01129f6:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f01129fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112a04:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112a09:	ff 75 ec             	pushl  -0x14(%ebp)
f0112a0c:	ff 75 f0             	pushl  -0x10(%ebp)
f0112a0f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112a12:	50                   	push   %eax
f0112a13:	e8 1a 77 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112a18:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112a1b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112a20:	ff 75 ec             	pushl  -0x14(%ebp)
f0112a23:	ff 75 f0             	pushl  -0x10(%ebp)
f0112a26:	ff 75 f4             	pushl  -0xc(%ebp)
f0112a29:	50                   	push   %eax
f0112a2a:	e8 11 4b 00 00       	call   f0117540 <CP>
f0112a2f:	83 c4 10             	add    $0x10,%esp
f0112a32:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112a35:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112a39:	74 17                	je     f0112a52 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0112a3b:	83 ec 04             	sub    $0x4,%esp
f0112a3e:	68 e0 b3 12 f0       	push   $0xf012b3e0
f0112a43:	68 2f 01 00 00       	push   $0x12f
f0112a48:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112a4d:	e8 e7 d8 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0112a52:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0112a59:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0112a60:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112a67:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112a6c:	ff 75 ec             	pushl  -0x14(%ebp)
f0112a6f:	ff 75 f0             	pushl  -0x10(%ebp)
f0112a72:	ff 75 f4             	pushl  -0xc(%ebp)
f0112a75:	50                   	push   %eax
f0112a76:	e8 b7 76 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112a7b:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112a7e:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112a83:	ff 75 ec             	pushl  -0x14(%ebp)
f0112a86:	ff 75 f0             	pushl  -0x10(%ebp)
f0112a89:	ff 75 f4             	pushl  -0xc(%ebp)
f0112a8c:	50                   	push   %eax
f0112a8d:	e8 ae 4a 00 00       	call   f0117540 <CP>
f0112a92:	83 c4 10             	add    $0x10,%esp
f0112a95:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112a98:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112a9c:	74 17                	je     f0112ab5 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0112a9e:	83 ec 04             	sub    $0x4,%esp
f0112aa1:	68 04 b4 12 f0       	push   $0xf012b404
f0112aa6:	68 3a 01 00 00       	push   $0x13a
f0112aab:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112ab0:	e8 84 d8 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0112ab5:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0112abc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0112ac3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112aca:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112acf:	ff 75 ec             	pushl  -0x14(%ebp)
f0112ad2:	ff 75 f0             	pushl  -0x10(%ebp)
f0112ad5:	ff 75 f4             	pushl  -0xc(%ebp)
f0112ad8:	50                   	push   %eax
f0112ad9:	e8 54 76 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112ade:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112ae1:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112ae6:	ff 75 ec             	pushl  -0x14(%ebp)
f0112ae9:	ff 75 f0             	pushl  -0x10(%ebp)
f0112aec:	ff 75 f4             	pushl  -0xc(%ebp)
f0112aef:	50                   	push   %eax
f0112af0:	e8 4b 4a 00 00       	call   f0117540 <CP>
f0112af5:	83 c4 10             	add    $0x10,%esp
f0112af8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112afb:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112aff:	74 17                	je     f0112b18 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112b01:	83 ec 04             	sub    $0x4,%esp
f0112b04:	68 28 b4 12 f0       	push   $0xf012b428
f0112b09:	68 46 01 00 00       	push   $0x146
f0112b0e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112b13:	e8 21 d8 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0112b18:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112b1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0112b26:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112b2d:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112b32:	ff 75 ec             	pushl  -0x14(%ebp)
f0112b35:	ff 75 f0             	pushl  -0x10(%ebp)
f0112b38:	ff 75 f4             	pushl  -0xc(%ebp)
f0112b3b:	50                   	push   %eax
f0112b3c:	e8 f1 75 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112b41:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112b44:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112b49:	ff 75 ec             	pushl  -0x14(%ebp)
f0112b4c:	ff 75 f0             	pushl  -0x10(%ebp)
f0112b4f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112b52:	50                   	push   %eax
f0112b53:	e8 e8 49 00 00       	call   f0117540 <CP>
f0112b58:	83 c4 10             	add    $0x10,%esp
f0112b5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112b5e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112b62:	74 17                	je     f0112b7b <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112b64:	83 ec 04             	sub    $0x4,%esp
f0112b67:	68 4c b4 12 f0       	push   $0xf012b44c
f0112b6c:	68 52 01 00 00       	push   $0x152
f0112b71:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112b76:	e8 be d7 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0112b7b:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0112b82:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0112b89:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112b90:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112b95:	ff 75 ec             	pushl  -0x14(%ebp)
f0112b98:	ff 75 f0             	pushl  -0x10(%ebp)
f0112b9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0112b9e:	50                   	push   %eax
f0112b9f:	e8 8e 75 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112ba4:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112ba7:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112bac:	ff 75 ec             	pushl  -0x14(%ebp)
f0112baf:	ff 75 f0             	pushl  -0x10(%ebp)
f0112bb2:	ff 75 f4             	pushl  -0xc(%ebp)
f0112bb5:	50                   	push   %eax
f0112bb6:	e8 85 49 00 00       	call   f0117540 <CP>
f0112bbb:	83 c4 10             	add    $0x10,%esp
f0112bbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112bc1:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112bc5:	74 17                	je     f0112bde <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0112bc7:	83 ec 04             	sub    $0x4,%esp
f0112bca:	68 70 b4 12 f0       	push   $0xf012b470
f0112bcf:	68 5e 01 00 00       	push   $0x15e
f0112bd4:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112bd9:	e8 5b d7 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112bde:	83 ec 0c             	sub    $0xc,%esp
f0112be1:	68 9c b4 12 f0       	push   $0xf012b49c
f0112be6:	e8 a0 e3 fe ff       	call   f0100f8b <cprintf>
f0112beb:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112bee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112bf3:	c9                   	leave  
f0112bf4:	c3                   	ret    

f0112bf5 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112bf5:	55                   	push   %ebp
f0112bf6:	89 e5                	mov    %esp,%ebp
f0112bf8:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0112bfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112c02:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0112c09:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112c10:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112c15:	ff 75 ec             	pushl  -0x14(%ebp)
f0112c18:	ff 75 f0             	pushl  -0x10(%ebp)
f0112c1b:	ff 75 f4             	pushl  -0xc(%ebp)
f0112c1e:	50                   	push   %eax
f0112c1f:	e8 0e 75 ff ff       	call   f010a132 <pt_set_page_permissions>
f0112c24:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0112c27:	83 ec 04             	sub    $0x4,%esp
f0112c2a:	68 ec b4 12 f0       	push   $0xf012b4ec
f0112c2f:	68 6b 01 00 00       	push   $0x16b
f0112c34:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112c39:	e8 fb d6 fe ff       	call   f0100339 <_panic>

f0112c3e <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112c3e:	55                   	push   %ebp
f0112c3f:	89 e5                	mov    %esp,%ebp
f0112c41:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112c44:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0112c4b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112c50:	83 ec 08             	sub    $0x8,%esp
f0112c53:	ff 75 f4             	pushl  -0xc(%ebp)
f0112c56:	50                   	push   %eax
f0112c57:	e8 9a 75 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f0112c5c:	83 c4 10             	add    $0x10,%esp
f0112c5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112c62:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112c66:	74 17                	je     f0112c7f <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0112c68:	83 ec 04             	sub    $0x4,%esp
f0112c6b:	68 88 b5 12 f0       	push   $0xf012b588
f0112c70:	68 79 01 00 00       	push   $0x179
f0112c75:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112c7a:	e8 ba d6 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0112c7f:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112c86:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112c8b:	83 ec 08             	sub    $0x8,%esp
f0112c8e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112c91:	50                   	push   %eax
f0112c92:	e8 5f 75 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f0112c97:	83 c4 10             	add    $0x10,%esp
f0112c9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0112c9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0112ca1:	74 17                	je     f0112cba <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0112ca3:	83 ec 04             	sub    $0x4,%esp
f0112ca6:	68 ac b5 12 f0       	push   $0xf012b5ac
f0112cab:	68 81 01 00 00       	push   $0x181
f0112cb0:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112cb5:	e8 7f d6 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0112cba:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112cc1:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112cc6:	83 ec 08             	sub    $0x8,%esp
f0112cc9:	ff 75 f4             	pushl  -0xc(%ebp)
f0112ccc:	50                   	push   %eax
f0112ccd:	e8 24 75 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f0112cd2:	83 c4 10             	add    $0x10,%esp
f0112cd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112cd8:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112cdc:	74 17                	je     f0112cf5 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112cde:	83 ec 04             	sub    $0x4,%esp
f0112ce1:	68 d0 b5 12 f0       	push   $0xf012b5d0
f0112ce6:	68 89 01 00 00       	push   $0x189
f0112ceb:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112cf0:	e8 44 d6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f0112cf5:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112cfc:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112d01:	83 ec 08             	sub    $0x8,%esp
f0112d04:	ff 75 f4             	pushl  -0xc(%ebp)
f0112d07:	50                   	push   %eax
f0112d08:	e8 e9 74 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f0112d0d:	83 c4 10             	add    $0x10,%esp
f0112d10:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112d13:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112d17:	74 17                	je     f0112d30 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0112d19:	83 ec 04             	sub    $0x4,%esp
f0112d1c:	68 f4 b5 12 f0       	push   $0xf012b5f4
f0112d21:	68 90 01 00 00       	push   $0x190
f0112d26:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112d2b:	e8 09 d6 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112d30:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112d37:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112d3c:	83 ec 08             	sub    $0x8,%esp
f0112d3f:	ff 75 f4             	pushl  -0xc(%ebp)
f0112d42:	50                   	push   %eax
f0112d43:	e8 ae 74 ff ff       	call   f010a1f6 <pt_get_page_permissions>
f0112d48:	83 c4 10             	add    $0x10,%esp
f0112d4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112d4e:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112d52:	74 17                	je     f0112d6b <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112d54:	83 ec 04             	sub    $0x4,%esp
f0112d57:	68 18 b6 12 f0       	push   $0xf012b618
f0112d5c:	68 97 01 00 00       	push   $0x197
f0112d61:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112d66:	e8 ce d5 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0112d6b:	83 ec 0c             	sub    $0xc,%esp
f0112d6e:	68 3c b6 12 f0       	push   $0xf012b63c
f0112d73:	e8 13 e2 fe ff       	call   f0100f8b <cprintf>
f0112d78:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112d7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112d80:	c9                   	leave  
f0112d81:	c3                   	ret    

f0112d82 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0112d82:	55                   	push   %ebp
f0112d83:	89 e5                	mov    %esp,%ebp
f0112d85:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0112d88:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112d8f:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112d94:	83 ec 08             	sub    $0x8,%esp
f0112d97:	ff 75 f4             	pushl  -0xc(%ebp)
f0112d9a:	50                   	push   %eax
f0112d9b:	e8 9f 74 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f0112da0:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0112da3:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112da8:	83 ec 08             	sub    $0x8,%esp
f0112dab:	ff 75 f4             	pushl  -0xc(%ebp)
f0112dae:	50                   	push   %eax
f0112daf:	e8 e8 46 00 00       	call   f011749c <CE>
f0112db4:	83 c4 10             	add    $0x10,%esp
f0112db7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112dba:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112dbe:	74 17                	je     f0112dd7 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0112dc0:	83 ec 04             	sub    $0x4,%esp
f0112dc3:	68 84 b6 12 f0       	push   $0xf012b684
f0112dc8:	68 a7 01 00 00       	push   $0x1a7
f0112dcd:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112dd2:	e8 62 d5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f0112dd7:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112dde:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112de3:	83 ec 08             	sub    $0x8,%esp
f0112de6:	ff 75 f4             	pushl  -0xc(%ebp)
f0112de9:	50                   	push   %eax
f0112dea:	e8 50 74 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f0112def:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112df2:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112df7:	83 ec 08             	sub    $0x8,%esp
f0112dfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0112dfd:	50                   	push   %eax
f0112dfe:	e8 99 46 00 00       	call   f011749c <CE>
f0112e03:	83 c4 10             	add    $0x10,%esp
f0112e06:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112e09:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112e0d:	74 17                	je     f0112e26 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112e0f:	83 ec 04             	sub    $0x4,%esp
f0112e12:	68 b0 b6 12 f0       	push   $0xf012b6b0
f0112e17:	68 af 01 00 00       	push   $0x1af
f0112e1c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112e21:	e8 13 d5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0112e26:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112e2d:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112e32:	83 ec 08             	sub    $0x8,%esp
f0112e35:	ff 75 f4             	pushl  -0xc(%ebp)
f0112e38:	50                   	push   %eax
f0112e39:	e8 01 74 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f0112e3e:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112e41:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112e46:	83 ec 08             	sub    $0x8,%esp
f0112e49:	ff 75 f4             	pushl  -0xc(%ebp)
f0112e4c:	50                   	push   %eax
f0112e4d:	e8 4a 46 00 00       	call   f011749c <CE>
f0112e52:	83 c4 10             	add    $0x10,%esp
f0112e55:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112e58:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112e5c:	74 17                	je     f0112e75 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112e5e:	83 ec 04             	sub    $0x4,%esp
f0112e61:	68 dc b6 12 f0       	push   $0xf012b6dc
f0112e66:	68 b7 01 00 00       	push   $0x1b7
f0112e6b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112e70:	e8 c4 d4 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0112e75:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112e7c:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112e81:	83 ec 08             	sub    $0x8,%esp
f0112e84:	ff 75 f4             	pushl  -0xc(%ebp)
f0112e87:	50                   	push   %eax
f0112e88:	e8 b2 73 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f0112e8d:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112e90:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112e95:	83 ec 08             	sub    $0x8,%esp
f0112e98:	ff 75 f4             	pushl  -0xc(%ebp)
f0112e9b:	50                   	push   %eax
f0112e9c:	e8 fb 45 00 00       	call   f011749c <CE>
f0112ea1:	83 c4 10             	add    $0x10,%esp
f0112ea4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112ea7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0112eab:	74 17                	je     f0112ec4 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0112ead:	83 ec 04             	sub    $0x4,%esp
f0112eb0:	68 08 b7 12 f0       	push   $0xf012b708
f0112eb5:	68 bf 01 00 00       	push   $0x1bf
f0112eba:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112ebf:	e8 75 d4 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0112ec4:	83 ec 0c             	sub    $0xc,%esp
f0112ec7:	68 34 b7 12 f0       	push   $0xf012b734
f0112ecc:	e8 ba e0 fe ff       	call   f0100f8b <cprintf>
f0112ed1:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112ed4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112ed9:	c9                   	leave  
f0112eda:	c3                   	ret    

f0112edb <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0112edb:	55                   	push   %ebp
f0112edc:	89 e5                	mov    %esp,%ebp
f0112ede:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112ee1:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112ee8:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0112eed:	83 ec 08             	sub    $0x8,%esp
f0112ef0:	ff 75 f4             	pushl  -0xc(%ebp)
f0112ef3:	50                   	push   %eax
f0112ef4:	e8 46 73 ff ff       	call   f010a23f <pt_clear_page_table_entry>
f0112ef9:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f0112efc:	83 ec 04             	sub    $0x4,%esp
f0112eff:	68 80 b7 12 f0       	push   $0xf012b780
f0112f04:	68 ca 01 00 00       	push   $0x1ca
f0112f09:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0112f0e:	e8 26 d4 fe ff       	call   f0100339 <_panic>

f0112f13 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0112f13:	55                   	push   %ebp
f0112f14:	89 e5                	mov    %esp,%ebp
f0112f16:	57                   	push   %edi
f0112f17:	56                   	push   %esi
f0112f18:	53                   	push   %ebx
f0112f19:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112f1f:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112f25:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f0112f2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f2f:	89 c7                	mov    %eax,%edi
f0112f31:	89 de                	mov    %ebx,%esi
f0112f33:	89 d1                	mov    %edx,%ecx
f0112f35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f37:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0112f3d:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112f42:	b0 00                	mov    $0x0,%al
f0112f44:	89 d7                	mov    %edx,%edi
f0112f46:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112f48:	6a 00                	push   $0x0
f0112f4a:	6a 0a                	push   $0xa
f0112f4c:	6a 14                	push   $0x14
f0112f4e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112f54:	50                   	push   %eax
f0112f55:	e8 6c 85 ff ff       	call   f010b4c6 <env_create>
f0112f5a:	83 c4 10             	add    $0x10,%esp
f0112f5d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112f60:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112f63:	8b 40 64             	mov    0x64(%eax),%eax
f0112f66:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112f69:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112f6c:	8b 40 68             	mov    0x68(%eax),%eax
f0112f6f:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112f72:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112f75:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112f78:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0112f7f:	75 70 20 
f0112f82:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112f89:	00 00 00 
f0112f8c:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112f92:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112f97:	b8 00 00 00 00       	mov    $0x0,%eax
f0112f9c:	89 d7                	mov    %edx,%edi
f0112f9e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112fa0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112fa3:	8b 40 10             	mov    0x10(%eax),%eax
f0112fa6:	83 ec 08             	sub    $0x8,%esp
f0112fa9:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112faf:	52                   	push   %edx
f0112fb0:	50                   	push   %eax
f0112fb1:	e8 2b f4 00 00       	call   f01223e1 <ltostr>
f0112fb6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112fb9:	83 ec 04             	sub    $0x4,%esp
f0112fbc:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112fc2:	50                   	push   %eax
f0112fc3:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112fc9:	50                   	push   %eax
f0112fca:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112fd0:	50                   	push   %eax
f0112fd1:	e8 e4 f4 00 00       	call   f01224ba <strcconcat>
f0112fd6:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112fd9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112fe0:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0112fe7:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112fee:	83 ec 0c             	sub    $0xc,%esp
f0112ff1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ff4:	e8 85 45 00 00       	call   f011757e <ClearUserSpace>
f0112ff9:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112ffc:	83 ec 04             	sub    $0x4,%esp
f0112fff:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0113005:	50                   	push   %eax
f0113006:	68 16 b8 12 f0       	push   $0xf012b816
f011300b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113011:	50                   	push   %eax
f0113012:	e8 a3 f4 00 00       	call   f01224ba <strcconcat>
f0113017:	83 c4 10             	add    $0x10,%esp
f011301a:	83 ec 0c             	sub    $0xc,%esp
f011301d:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0113023:	50                   	push   %eax
f0113024:	e8 d2 ee fe ff       	call   f0101efb <execute_command>
f0113029:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f011302c:	83 ec 04             	sub    $0x4,%esp
f011302f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0113035:	50                   	push   %eax
f0113036:	68 21 b8 12 f0       	push   $0xf012b821
f011303b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113041:	50                   	push   %eax
f0113042:	e8 73 f4 00 00       	call   f01224ba <strcconcat>
f0113047:	83 c4 10             	add    $0x10,%esp
f011304a:	83 ec 0c             	sub    $0xc,%esp
f011304d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0113053:	50                   	push   %eax
f0113054:	e8 a2 ee fe ff       	call   f0101efb <execute_command>
f0113059:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f011305c:	83 ec 04             	sub    $0x4,%esp
f011305f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0113065:	50                   	push   %eax
f0113066:	68 2c b8 12 f0       	push   $0xf012b82c
f011306b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0113071:	50                   	push   %eax
f0113072:	e8 43 f4 00 00       	call   f01224ba <strcconcat>
f0113077:	83 c4 10             	add    $0x10,%esp
f011307a:	83 ec 0c             	sub    $0xc,%esp
f011307d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0113083:	50                   	push   %eax
f0113084:	e8 72 ee fe ff       	call   f0101efb <execute_command>
f0113089:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f011308c:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0113093:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113096:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0113099:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01130a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01130a3:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01130a6:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01130ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01130b0:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f01130b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01130b6:	83 ec 08             	sub    $0x8,%esp
f01130b9:	50                   	push   %eax
f01130ba:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130bd:	e8 9d 44 00 00       	call   f011755f <GP>
f01130c2:	83 c4 10             	add    $0x10,%esp
f01130c5:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01130c8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f01130cf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f01130d6:	e8 59 bd ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01130db:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f01130de:	83 ec 0c             	sub    $0xc,%esp
f01130e1:	68 38 b8 12 f0       	push   $0xf012b838
f01130e6:	e8 a0 de fe ff       	call   f0100f8b <cprintf>
f01130eb:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01130ee:	6a 03                	push   $0x3
f01130f0:	68 00 00 90 02       	push   $0x2900000
f01130f5:	68 00 00 80 02       	push   $0x2800000
f01130fa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130fd:	e8 83 7e ff ff       	call   f010af85 <cut_paste_pages>
f0113102:	83 c4 10             	add    $0x10,%esp
f0113105:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0113108:	e8 27 bd ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011310d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0113110:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0113117:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011311b:	75 08                	jne    f0113125 <test_cut_paste_pages+0x212>
f011311d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113120:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0113123:	74 2b                	je     f0113150 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0113125:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113128:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011312b:	83 ec 0c             	sub    $0xc,%esp
f011312e:	50                   	push   %eax
f011312f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0113132:	68 68 b8 12 f0       	push   $0xf012b868
f0113137:	68 04 02 00 00       	push   $0x204
f011313c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113141:	e8 90 d3 fe ff       	call   f01004d6 <_warn>
f0113146:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113149:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0113150:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113154:	74 04                	je     f011315a <test_cut_paste_pages+0x247>
f0113156:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011315a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0113161:	83 ec 08             	sub    $0x8,%esp
f0113164:	6a 00                	push   $0x0
f0113166:	6a 01                	push   $0x1
f0113168:	6a 00                	push   $0x0
f011316a:	68 ff 0f 00 00       	push   $0xfff
f011316f:	ff 75 bc             	pushl  -0x44(%ebp)
f0113172:	6a 01                	push   $0x1
f0113174:	68 00 30 00 00       	push   $0x3000
f0113179:	68 00 00 90 02       	push   $0x2900000
f011317e:	68 00 00 80 02       	push   $0x2800000
f0113183:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113186:	e8 27 44 00 00       	call   f01175b2 <CCP>
f011318b:	83 c4 30             	add    $0x30,%esp
f011318e:	83 f8 01             	cmp    $0x1,%eax
f0113191:	74 21                	je     f01131b4 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0113193:	83 ec 04             	sub    $0x4,%esp
f0113196:	68 bc b8 12 f0       	push   $0xf012b8bc
f011319b:	68 0c 02 00 00       	push   $0x20c
f01131a0:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01131a5:	e8 2c d3 fe ff       	call   f01004d6 <_warn>
f01131aa:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01131ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f01131b4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01131b8:	74 04                	je     f01131be <test_cut_paste_pages+0x2ab>
f01131ba:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f01131be:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01131c5:	83 ec 04             	sub    $0x4,%esp
f01131c8:	6a 00                	push   $0x0
f01131ca:	68 00 00 90 02       	push   $0x2900000
f01131cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131d2:	e8 b7 41 00 00       	call   f011738e <CB>
f01131d7:	83 c4 10             	add    $0x10,%esp
f01131da:	85 c0                	test   %eax,%eax
f01131dc:	0f 84 f6 00 00 00    	je     f01132d8 <test_cut_paste_pages+0x3c5>
f01131e2:	83 ec 04             	sub    $0x4,%esp
f01131e5:	6a 00                	push   $0x0
f01131e7:	68 00 10 90 02       	push   $0x2901000
f01131ec:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131ef:	e8 9a 41 00 00       	call   f011738e <CB>
f01131f4:	83 c4 10             	add    $0x10,%esp
f01131f7:	85 c0                	test   %eax,%eax
f01131f9:	0f 84 d9 00 00 00    	je     f01132d8 <test_cut_paste_pages+0x3c5>
f01131ff:	83 ec 04             	sub    $0x4,%esp
f0113202:	6a 00                	push   $0x0
f0113204:	68 00 20 90 02       	push   $0x2902000
f0113209:	ff 75 d4             	pushl  -0x2c(%ebp)
f011320c:	e8 7d 41 00 00       	call   f011738e <CB>
f0113211:	83 c4 10             	add    $0x10,%esp
f0113214:	85 c0                	test   %eax,%eax
f0113216:	0f 84 bc 00 00 00    	je     f01132d8 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011321c:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0113223:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f011322a:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0113231:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113234:	8a 00                	mov    (%eax),%al
f0113236:	3c 61                	cmp    $0x61,%al
f0113238:	75 12                	jne    f011324c <test_cut_paste_pages+0x339>
f011323a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011323d:	8a 00                	mov    (%eax),%al
f011323f:	3c 62                	cmp    $0x62,%al
f0113241:	75 09                	jne    f011324c <test_cut_paste_pages+0x339>
f0113243:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113246:	8a 00                	mov    (%eax),%al
f0113248:	3c 63                	cmp    $0x63,%al
f011324a:	74 21                	je     f011326d <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011324c:	83 ec 04             	sub    $0x4,%esp
f011324f:	68 08 b9 12 f0       	push   $0xf012b908
f0113254:	68 19 02 00 00       	push   $0x219
f0113259:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011325e:	e8 73 d2 fe ff       	call   f01004d6 <_warn>
f0113263:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113266:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011326d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113271:	74 04                	je     f0113277 <test_cut_paste_pages+0x364>
f0113273:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113277:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f011327e:	83 ec 04             	sub    $0x4,%esp
f0113281:	6a 01                	push   $0x1
f0113283:	68 00 10 90 02       	push   $0x2901000
f0113288:	ff 75 d4             	pushl  -0x2c(%ebp)
f011328b:	e8 fe 40 00 00       	call   f011738e <CB>
f0113290:	83 c4 10             	add    $0x10,%esp
f0113293:	85 c0                	test   %eax,%eax
f0113295:	74 41                	je     f01132d8 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0113297:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011329a:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f011329d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01132a0:	8a 00                	mov    (%eax),%al
f01132a2:	3c 79                	cmp    $0x79,%al
f01132a4:	74 21                	je     f01132c7 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01132a6:	83 ec 04             	sub    $0x4,%esp
f01132a9:	68 08 b9 12 f0       	push   $0xf012b908
f01132ae:	68 24 02 00 00       	push   $0x224
f01132b3:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01132b8:	e8 19 d2 fe ff       	call   f01004d6 <_warn>
f01132bd:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01132c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01132c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132cb:	74 04                	je     f01132d1 <test_cut_paste_pages+0x3be>
f01132cd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01132d1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f01132d8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01132db:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01132de:	6a 02                	push   $0x2
f01132e0:	68 00 f0 bf 02       	push   $0x2bff000
f01132e5:	68 00 10 90 02       	push   $0x2901000
f01132ea:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132ed:	e8 93 7c ff ff       	call   f010af85 <cut_paste_pages>
f01132f2:	83 c4 10             	add    $0x10,%esp
f01132f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01132f8:	e8 37 bb ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01132fd:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0113300:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0113304:	75 0b                	jne    f0113311 <test_cut_paste_pages+0x3fe>
f0113306:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113309:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011330c:	83 f8 01             	cmp    $0x1,%eax
f011330f:	74 2b                	je     f011333c <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0113311:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113314:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0113317:	83 ec 0c             	sub    $0xc,%esp
f011331a:	50                   	push   %eax
f011331b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011331e:	68 68 b8 12 f0       	push   $0xf012b868
f0113323:	68 35 02 00 00       	push   $0x235
f0113328:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011332d:	e8 a4 d1 fe ff       	call   f01004d6 <_warn>
f0113332:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113335:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011333c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113340:	74 04                	je     f0113346 <test_cut_paste_pages+0x433>
f0113342:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0113346:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011334d:	83 ec 08             	sub    $0x8,%esp
f0113350:	6a 00                	push   $0x0
f0113352:	6a 01                	push   $0x1
f0113354:	6a 00                	push   $0x0
f0113356:	68 ff 0f 00 00       	push   $0xfff
f011335b:	ff 75 bc             	pushl  -0x44(%ebp)
f011335e:	6a 01                	push   $0x1
f0113360:	68 00 20 00 00       	push   $0x2000
f0113365:	68 00 f0 bf 02       	push   $0x2bff000
f011336a:	68 00 10 90 02       	push   $0x2901000
f011336f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113372:	e8 3b 42 00 00       	call   f01175b2 <CCP>
f0113377:	83 c4 30             	add    $0x30,%esp
f011337a:	83 f8 01             	cmp    $0x1,%eax
f011337d:	74 21                	je     f01133a0 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011337f:	83 ec 04             	sub    $0x4,%esp
f0113382:	68 bc b8 12 f0       	push   $0xf012b8bc
f0113387:	68 3d 02 00 00       	push   $0x23d
f011338c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113391:	e8 40 d1 fe ff       	call   f01004d6 <_warn>
f0113396:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0113399:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01133a0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01133a4:	74 04                	je     f01133aa <test_cut_paste_pages+0x497>
f01133a6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01133aa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01133b1:	83 ec 04             	sub    $0x4,%esp
f01133b4:	6a 00                	push   $0x0
f01133b6:	68 ff f7 bf 02       	push   $0x2bff7ff
f01133bb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01133be:	e8 cb 3f 00 00       	call   f011738e <CB>
f01133c3:	83 c4 10             	add    $0x10,%esp
f01133c6:	85 c0                	test   %eax,%eax
f01133c8:	74 6b                	je     f0113435 <test_cut_paste_pages+0x522>
f01133ca:	83 ec 04             	sub    $0x4,%esp
f01133cd:	6a 00                	push   $0x0
f01133cf:	68 ff 0f c0 02       	push   $0x2c00fff
f01133d4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01133d7:	e8 b2 3f 00 00       	call   f011738e <CB>
f01133dc:	83 c4 10             	add    $0x10,%esp
f01133df:	85 c0                	test   %eax,%eax
f01133e1:	74 52                	je     f0113435 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f01133e3:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f01133ea:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f01133f1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01133f4:	8a 00                	mov    (%eax),%al
f01133f6:	3c 79                	cmp    $0x79,%al
f01133f8:	75 09                	jne    f0113403 <test_cut_paste_pages+0x4f0>
f01133fa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01133fd:	8a 00                	mov    (%eax),%al
f01133ff:	3c 63                	cmp    $0x63,%al
f0113401:	74 21                	je     f0113424 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0113403:	83 ec 04             	sub    $0x4,%esp
f0113406:	68 08 b9 12 f0       	push   $0xf012b908
f011340b:	68 49 02 00 00       	push   $0x249
f0113410:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113415:	e8 bc d0 fe ff       	call   f01004d6 <_warn>
f011341a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011341d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113424:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113428:	74 04                	je     f011342e <test_cut_paste_pages+0x51b>
f011342a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011342e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0113435:	83 ec 0c             	sub    $0xc,%esp
f0113438:	68 41 b9 12 f0       	push   $0xf012b941
f011343d:	e8 49 db fe ff       	call   f0100f8b <cprintf>
f0113442:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0113445:	83 ec 0c             	sub    $0xc,%esp
f0113448:	68 50 b9 12 f0       	push   $0xf012b950
f011344d:	e8 39 db fe ff       	call   f0100f8b <cprintf>
f0113452:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0113455:	83 ec 04             	sub    $0x4,%esp
f0113458:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011345e:	50                   	push   %eax
f011345f:	68 79 b9 12 f0       	push   $0xf012b979
f0113464:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011346a:	50                   	push   %eax
f011346b:	e8 4a f0 00 00       	call   f01224ba <strcconcat>
f0113470:	83 c4 10             	add    $0x10,%esp
f0113473:	83 ec 0c             	sub    $0xc,%esp
f0113476:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011347c:	50                   	push   %eax
f011347d:	e8 79 ea fe ff       	call   f0101efb <execute_command>
f0113482:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0113485:	83 ec 04             	sub    $0x4,%esp
f0113488:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f011348e:	50                   	push   %eax
f011348f:	68 84 b9 12 f0       	push   $0xf012b984
f0113494:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011349a:	50                   	push   %eax
f011349b:	e8 1a f0 00 00       	call   f01224ba <strcconcat>
f01134a0:	83 c4 10             	add    $0x10,%esp
f01134a3:	83 ec 0c             	sub    $0xc,%esp
f01134a6:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01134ac:	50                   	push   %eax
f01134ad:	e8 49 ea fe ff       	call   f0101efb <execute_command>
f01134b2:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01134b5:	83 ec 04             	sub    $0x4,%esp
f01134b8:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01134be:	50                   	push   %eax
f01134bf:	68 8f b9 12 f0       	push   $0xf012b98f
f01134c4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01134ca:	50                   	push   %eax
f01134cb:	e8 ea ef 00 00       	call   f01224ba <strcconcat>
f01134d0:	83 c4 10             	add    $0x10,%esp
f01134d3:	83 ec 0c             	sub    $0xc,%esp
f01134d6:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01134dc:	50                   	push   %eax
f01134dd:	e8 19 ea fe ff       	call   f0101efb <execute_command>
f01134e2:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f01134e5:	83 ec 04             	sub    $0x4,%esp
f01134e8:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01134ee:	50                   	push   %eax
f01134ef:	68 9a b9 12 f0       	push   $0xf012b99a
f01134f4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01134fa:	50                   	push   %eax
f01134fb:	e8 ba ef 00 00       	call   f01224ba <strcconcat>
f0113500:	83 c4 10             	add    $0x10,%esp
f0113503:	83 ec 0c             	sub    $0xc,%esp
f0113506:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011350c:	50                   	push   %eax
f011350d:	e8 e9 e9 fe ff       	call   f0101efb <execute_command>
f0113512:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0113515:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011351c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011351f:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0113522:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0113529:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011352c:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011352f:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0113536:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113539:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011353c:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0113543:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113546:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0113549:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0113550:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113553:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0113556:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f011355d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113560:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0113563:	83 ec 08             	sub    $0x8,%esp
f0113566:	68 00 00 c0 01       	push   $0x1c00000
f011356b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011356e:	e8 ec 3f 00 00       	call   f011755f <GP>
f0113573:	83 c4 10             	add    $0x10,%esp
f0113576:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0113579:	83 ec 08             	sub    $0x8,%esp
f011357c:	68 00 00 40 01       	push   $0x1400000
f0113581:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113584:	e8 d6 3f 00 00       	call   f011755f <GP>
f0113589:	83 c4 10             	add    $0x10,%esp
f011358c:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f011358f:	e8 a0 b8 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0113594:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0113597:	6a 01                	push   $0x1
f0113599:	68 00 00 40 01       	push   $0x1400000
f011359e:	68 00 00 c0 01       	push   $0x1c00000
f01135a3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01135a6:	e8 da 79 ff ff       	call   f010af85 <cut_paste_pages>
f01135ab:	83 c4 10             	add    $0x10,%esp
f01135ae:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01135b1:	e8 7e b8 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01135b6:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01135b9:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01135bd:	75 08                	jne    f01135c7 <test_cut_paste_pages+0x6b4>
f01135bf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01135c2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01135c5:	74 2b                	je     f01135f2 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01135c7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01135ca:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01135cd:	83 ec 0c             	sub    $0xc,%esp
f01135d0:	50                   	push   %eax
f01135d1:	ff 75 b4             	pushl  -0x4c(%ebp)
f01135d4:	68 a8 b9 12 f0       	push   $0xf012b9a8
f01135d9:	68 6c 02 00 00       	push   $0x26c
f01135de:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01135e3:	e8 ee ce fe ff       	call   f01004d6 <_warn>
f01135e8:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01135eb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01135f2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01135f6:	74 04                	je     f01135fc <test_cut_paste_pages+0x6e9>
f01135f8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01135fc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0113603:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f011360a:	83 ec 08             	sub    $0x8,%esp
f011360d:	6a 00                	push   $0x0
f011360f:	68 ff 0f 00 00       	push   $0xfff
f0113614:	ff 75 a4             	pushl  -0x5c(%ebp)
f0113617:	68 ff 0f 00 00       	push   $0xfff
f011361c:	ff 75 a0             	pushl  -0x60(%ebp)
f011361f:	6a 01                	push   $0x1
f0113621:	68 00 10 00 00       	push   $0x1000
f0113626:	68 00 00 40 01       	push   $0x1400000
f011362b:	68 00 00 c0 01       	push   $0x1c00000
f0113630:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113633:	e8 7a 3f 00 00       	call   f01175b2 <CCP>
f0113638:	83 c4 30             	add    $0x30,%esp
f011363b:	83 f8 01             	cmp    $0x1,%eax
f011363e:	74 28                	je     f0113668 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0113640:	83 ec 04             	sub    $0x4,%esp
f0113643:	68 bc b8 12 f0       	push   $0xf012b8bc
f0113648:	68 75 02 00 00       	push   $0x275
f011364d:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113652:	e8 7f ce fe ff       	call   f01004d6 <_warn>
f0113657:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011365a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0113661:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113668:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011366c:	74 04                	je     f0113672 <test_cut_paste_pages+0x75f>
f011366e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113672:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113679:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011367d:	0f 84 92 00 00 00    	je     f0113715 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0113683:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011368a:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0113691:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113698:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011369f:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01136a6:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01136ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01136b0:	8a 00                	mov    (%eax),%al
f01136b2:	3c 61                	cmp    $0x61,%al
f01136b4:	75 2d                	jne    f01136e3 <test_cut_paste_pages+0x7d0>
f01136b6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01136b9:	8a 00                	mov    (%eax),%al
f01136bb:	3c 78                	cmp    $0x78,%al
f01136bd:	75 24                	jne    f01136e3 <test_cut_paste_pages+0x7d0>
f01136bf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01136c2:	8a 00                	mov    (%eax),%al
f01136c4:	3c 62                	cmp    $0x62,%al
f01136c6:	75 1b                	jne    f01136e3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01136c8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01136cb:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01136cd:	3c 79                	cmp    $0x79,%al
f01136cf:	75 12                	jne    f01136e3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01136d1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01136d4:	8a 00                	mov    (%eax),%al
f01136d6:	3c 63                	cmp    $0x63,%al
f01136d8:	75 09                	jne    f01136e3 <test_cut_paste_pages+0x7d0>
f01136da:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01136dd:	8a 00                	mov    (%eax),%al
f01136df:	3c 7a                	cmp    $0x7a,%al
f01136e1:	74 21                	je     f0113704 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01136e3:	83 ec 04             	sub    $0x4,%esp
f01136e6:	68 08 b9 12 f0       	push   $0xf012b908
f01136eb:	68 87 02 00 00       	push   $0x287
f01136f0:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01136f5:	e8 dc cd fe ff       	call   f01004d6 <_warn>
f01136fa:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01136fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113704:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113708:	74 04                	je     f011370e <test_cut_paste_pages+0x7fb>
f011370a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011370e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0113715:	e8 1a b7 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011371a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011371d:	6a 03                	push   $0x3
f011371f:	68 00 f0 bf 01       	push   $0x1bff000
f0113724:	68 00 00 40 01       	push   $0x1400000
f0113729:	ff 75 d4             	pushl  -0x2c(%ebp)
f011372c:	e8 54 78 ff ff       	call   f010af85 <cut_paste_pages>
f0113731:	83 c4 10             	add    $0x10,%esp
f0113734:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0113737:	e8 f8 b6 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011373c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011373f:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0113743:	75 08                	jne    f011374d <test_cut_paste_pages+0x83a>
f0113745:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113748:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011374b:	74 2b                	je     f0113778 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011374d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113750:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0113753:	83 ec 0c             	sub    $0xc,%esp
f0113756:	50                   	push   %eax
f0113757:	ff 75 b4             	pushl  -0x4c(%ebp)
f011375a:	68 a8 b9 12 f0       	push   $0xf012b9a8
f011375f:	68 96 02 00 00       	push   $0x296
f0113764:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113769:	e8 68 cd fe ff       	call   f01004d6 <_warn>
f011376e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113771:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0113778:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011377c:	74 04                	je     f0113782 <test_cut_paste_pages+0x86f>
f011377e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0113782:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0113789:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0113790:	83 ec 04             	sub    $0x4,%esp
f0113793:	6a 00                	push   $0x0
f0113795:	68 00 00 40 01       	push   $0x1400000
f011379a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011379d:	e8 ec 3b 00 00       	call   f011738e <CB>
f01137a2:	83 c4 10             	add    $0x10,%esp
f01137a5:	83 f8 01             	cmp    $0x1,%eax
f01137a8:	0f 85 80 00 00 00    	jne    f011382e <test_cut_paste_pages+0x91b>
f01137ae:	83 ec 04             	sub    $0x4,%esp
f01137b1:	6a 00                	push   $0x0
f01137b3:	68 00 10 40 01       	push   $0x1401000
f01137b8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01137bb:	e8 ce 3b 00 00       	call   f011738e <CB>
f01137c0:	83 c4 10             	add    $0x10,%esp
f01137c3:	83 f8 01             	cmp    $0x1,%eax
f01137c6:	75 66                	jne    f011382e <test_cut_paste_pages+0x91b>
f01137c8:	83 ec 04             	sub    $0x4,%esp
f01137cb:	6a 00                	push   $0x0
f01137cd:	68 00 20 40 01       	push   $0x1402000
f01137d2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01137d5:	e8 b4 3b 00 00       	call   f011738e <CB>
f01137da:	83 c4 10             	add    $0x10,%esp
f01137dd:	83 f8 01             	cmp    $0x1,%eax
f01137e0:	75 4c                	jne    f011382e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01137e2:	83 ec 04             	sub    $0x4,%esp
f01137e5:	6a 00                	push   $0x0
f01137e7:	68 00 f0 bf 01       	push   $0x1bff000
f01137ec:	ff 75 d4             	pushl  -0x2c(%ebp)
f01137ef:	e8 9a 3b 00 00       	call   f011738e <CB>
f01137f4:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01137f7:	85 c0                	test   %eax,%eax
f01137f9:	75 33                	jne    f011382e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01137fb:	83 ec 04             	sub    $0x4,%esp
f01137fe:	6a 00                	push   $0x0
f0113800:	68 00 00 c0 01       	push   $0x1c00000
f0113805:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113808:	e8 81 3b 00 00       	call   f011738e <CB>
f011380d:	83 c4 10             	add    $0x10,%esp
f0113810:	83 f8 01             	cmp    $0x1,%eax
f0113813:	75 19                	jne    f011382e <test_cut_paste_pages+0x91b>
f0113815:	83 ec 04             	sub    $0x4,%esp
f0113818:	6a 00                	push   $0x0
f011381a:	68 00 10 c0 01       	push   $0x1c01000
f011381f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113822:	e8 67 3b 00 00       	call   f011738e <CB>
f0113827:	83 c4 10             	add    $0x10,%esp
f011382a:	85 c0                	test   %eax,%eax
f011382c:	74 28                	je     f0113856 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f011382e:	83 ec 04             	sub    $0x4,%esp
f0113831:	68 08 ba 12 f0       	push   $0xf012ba08
f0113836:	68 9f 02 00 00       	push   $0x29f
f011383b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113840:	e8 91 cc fe ff       	call   f01004d6 <_warn>
f0113845:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0113848:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011384f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113856:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011385a:	74 04                	je     f0113860 <test_cut_paste_pages+0x94d>
f011385c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113860:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113867:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011386b:	0f 84 99 00 00 00    	je     f011390a <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0113871:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0113878:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011387f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113886:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011388d:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113894:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011389b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011389e:	8a 00                	mov    (%eax),%al
f01138a0:	3c 61                	cmp    $0x61,%al
f01138a2:	75 2d                	jne    f01138d1 <test_cut_paste_pages+0x9be>
f01138a4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01138a7:	8a 00                	mov    (%eax),%al
f01138a9:	3c 78                	cmp    $0x78,%al
f01138ab:	75 24                	jne    f01138d1 <test_cut_paste_pages+0x9be>
f01138ad:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01138b0:	8a 00                	mov    (%eax),%al
f01138b2:	3c 62                	cmp    $0x62,%al
f01138b4:	75 1b                	jne    f01138d1 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01138b6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01138b9:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01138bb:	3c 79                	cmp    $0x79,%al
f01138bd:	75 12                	jne    f01138d1 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01138bf:	8b 45 98             	mov    -0x68(%ebp),%eax
f01138c2:	8a 00                	mov    (%eax),%al
f01138c4:	3c 63                	cmp    $0x63,%al
f01138c6:	75 09                	jne    f01138d1 <test_cut_paste_pages+0x9be>
f01138c8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01138cb:	8a 00                	mov    (%eax),%al
f01138cd:	3c 7a                	cmp    $0x7a,%al
f01138cf:	74 28                	je     f01138f9 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f01138d1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f01138d8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01138df:	83 ec 04             	sub    $0x4,%esp
f01138e2:	68 08 b9 12 f0       	push   $0xf012b908
f01138e7:	68 b3 02 00 00       	push   $0x2b3
f01138ec:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01138f1:	e8 e0 cb fe ff       	call   f01004d6 <_warn>
f01138f6:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01138f9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138fd:	74 04                	je     f0113903 <test_cut_paste_pages+0x9f0>
f01138ff:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113903:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f011390a:	83 ec 0c             	sub    $0xc,%esp
f011390d:	68 41 ba 12 f0       	push   $0xf012ba41
f0113912:	e8 74 d6 fe ff       	call   f0100f8b <cprintf>
f0113917:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f011391a:	83 ec 08             	sub    $0x8,%esp
f011391d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113920:	68 50 ba 12 f0       	push   $0xf012ba50
f0113925:	e8 61 d6 fe ff       	call   f0100f8b <cprintf>
f011392a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011392d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113931:	75 10                	jne    f0113943 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0113933:	83 ec 0c             	sub    $0xc,%esp
f0113936:	68 84 ba 12 f0       	push   $0xf012ba84
f011393b:	e8 4b d6 fe ff       	call   f0100f8b <cprintf>
f0113940:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113943:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f0113948:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011394b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011394e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113951:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113956:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113959:	5b                   	pop    %ebx
f011395a:	5e                   	pop    %esi
f011395b:	5f                   	pop    %edi
f011395c:	5d                   	pop    %ebp
f011395d:	c3                   	ret    

f011395e <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f011395e:	55                   	push   %ebp
f011395f:	89 e5                	mov    %esp,%ebp
f0113961:	57                   	push   %edi
f0113962:	56                   	push   %esi
f0113963:	53                   	push   %ebx
f0113964:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011396a:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113970:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f0113975:	ba 0f 00 00 00       	mov    $0xf,%edx
f011397a:	89 c7                	mov    %eax,%edi
f011397c:	89 de                	mov    %ebx,%esi
f011397e:	89 d1                	mov    %edx,%ecx
f0113980:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113982:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113988:	b9 23 00 00 00       	mov    $0x23,%ecx
f011398d:	b0 00                	mov    $0x0,%al
f011398f:	89 d7                	mov    %edx,%edi
f0113991:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113993:	6a 00                	push   $0x0
f0113995:	6a 0a                	push   $0xa
f0113997:	6a 14                	push   $0x14
f0113999:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011399f:	50                   	push   %eax
f01139a0:	e8 21 7b ff ff       	call   f010b4c6 <env_create>
f01139a5:	83 c4 10             	add    $0x10,%esp
f01139a8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01139ab:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01139ae:	8b 40 64             	mov    0x64(%eax),%eax
f01139b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01139b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01139b7:	8b 40 68             	mov    0x68(%eax),%eax
f01139ba:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01139c0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01139c6:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01139c9:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f01139d0:	75 70 20 
f01139d3:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f01139da:	00 00 00 
f01139dd:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01139e3:	b9 03 00 00 00       	mov    $0x3,%ecx
f01139e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01139ed:	89 d7                	mov    %edx,%edi
f01139ef:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01139f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01139f4:	8b 40 10             	mov    0x10(%eax),%eax
f01139f7:	83 ec 08             	sub    $0x8,%esp
f01139fa:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0113a00:	52                   	push   %edx
f0113a01:	50                   	push   %eax
f0113a02:	e8 da e9 00 00       	call   f01223e1 <ltostr>
f0113a07:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0113a0a:	83 ec 04             	sub    $0x4,%esp
f0113a0d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a13:	50                   	push   %eax
f0113a14:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0113a1a:	50                   	push   %eax
f0113a1b:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0113a21:	50                   	push   %eax
f0113a22:	e8 93 ea 00 00       	call   f01224ba <strcconcat>
f0113a27:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0113a2a:	83 ec 0c             	sub    $0xc,%esp
f0113a2d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113a30:	e8 49 3b 00 00       	call   f011757e <ClearUserSpace>
f0113a35:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0113a38:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0113a3f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0113a46:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0113a4d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0113a54:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113a5b:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0113a62:	83 ec 0c             	sub    $0xc,%esp
f0113a65:	68 f8 ba 12 f0       	push   $0xf012baf8
f0113a6a:	e8 1c d5 fe ff       	call   f0100f8b <cprintf>
f0113a6f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0113a72:	83 ec 04             	sub    $0x4,%esp
f0113a75:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113a7b:	50                   	push   %eax
f0113a7c:	68 2e bb 12 f0       	push   $0xf012bb2e
f0113a81:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a87:	50                   	push   %eax
f0113a88:	e8 2d ea 00 00       	call   f01224ba <strcconcat>
f0113a8d:	83 c4 10             	add    $0x10,%esp
f0113a90:	83 ec 0c             	sub    $0xc,%esp
f0113a93:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113a99:	50                   	push   %eax
f0113a9a:	e8 5c e4 fe ff       	call   f0101efb <execute_command>
f0113a9f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0113aa2:	83 ec 04             	sub    $0x4,%esp
f0113aa5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113aab:	50                   	push   %eax
f0113aac:	68 33 bb 12 f0       	push   $0xf012bb33
f0113ab1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ab7:	50                   	push   %eax
f0113ab8:	e8 fd e9 00 00       	call   f01224ba <strcconcat>
f0113abd:	83 c4 10             	add    $0x10,%esp
f0113ac0:	83 ec 0c             	sub    $0xc,%esp
f0113ac3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113ac9:	50                   	push   %eax
f0113aca:	e8 2c e4 fe ff       	call   f0101efb <execute_command>
f0113acf:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113ad2:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113ad8:	bb 39 be 12 f0       	mov    $0xf012be39,%ebx
f0113add:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ae2:	89 c7                	mov    %eax,%edi
f0113ae4:	89 de                	mov    %ebx,%esi
f0113ae6:	89 d1                	mov    %edx,%ecx
f0113ae8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113aea:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113af0:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113af5:	b0 00                	mov    $0x0,%al
f0113af7:	89 d7                	mov    %edx,%edi
f0113af9:	f3 aa                	rep stos %al,%es:(%edi)
f0113afb:	83 ec 0c             	sub    $0xc,%esp
f0113afe:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113b04:	50                   	push   %eax
f0113b05:	e8 f1 e3 fe ff       	call   f0101efb <execute_command>
f0113b0a:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0113b0d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113b13:	bb 9d be 12 f0       	mov    $0xf012be9d,%ebx
f0113b18:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b1d:	89 c7                	mov    %eax,%edi
f0113b1f:	89 de                	mov    %ebx,%esi
f0113b21:	89 d1                	mov    %edx,%ecx
f0113b23:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b25:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113b2b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b30:	b0 00                	mov    $0x0,%al
f0113b32:	89 d7                	mov    %edx,%edi
f0113b34:	f3 aa                	rep stos %al,%es:(%edi)
f0113b36:	83 ec 0c             	sub    $0xc,%esp
f0113b39:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113b3f:	50                   	push   %eax
f0113b40:	e8 b6 e3 fe ff       	call   f0101efb <execute_command>
f0113b45:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113b48:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113b4e:	bb 01 bf 12 f0       	mov    $0xf012bf01,%ebx
f0113b53:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b58:	89 c7                	mov    %eax,%edi
f0113b5a:	89 de                	mov    %ebx,%esi
f0113b5c:	89 d1                	mov    %edx,%ecx
f0113b5e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b60:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113b66:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b6b:	b0 00                	mov    $0x0,%al
f0113b6d:	89 d7                	mov    %edx,%edi
f0113b6f:	f3 aa                	rep stos %al,%es:(%edi)
f0113b71:	83 ec 0c             	sub    $0xc,%esp
f0113b74:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113b7a:	50                   	push   %eax
f0113b7b:	e8 7b e3 fe ff       	call   f0101efb <execute_command>
f0113b80:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113b83:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113b89:	bb 65 bf 12 f0       	mov    $0xf012bf65,%ebx
f0113b8e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b93:	89 c7                	mov    %eax,%edi
f0113b95:	89 de                	mov    %ebx,%esi
f0113b97:	89 d1                	mov    %edx,%ecx
f0113b99:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b9b:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113ba1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113ba6:	b0 00                	mov    $0x0,%al
f0113ba8:	89 d7                	mov    %edx,%edi
f0113baa:	f3 aa                	rep stos %al,%es:(%edi)
f0113bac:	83 ec 0c             	sub    $0xc,%esp
f0113baf:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113bb5:	50                   	push   %eax
f0113bb6:	e8 40 e3 fe ff       	call   f0101efb <execute_command>
f0113bbb:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0113bbe:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113bc4:	bb c9 bf 12 f0       	mov    $0xf012bfc9,%ebx
f0113bc9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113bce:	89 c7                	mov    %eax,%edi
f0113bd0:	89 de                	mov    %ebx,%esi
f0113bd2:	89 d1                	mov    %edx,%ecx
f0113bd4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113bd6:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113bdc:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113be1:	b0 00                	mov    $0x0,%al
f0113be3:	89 d7                	mov    %edx,%edi
f0113be5:	f3 aa                	rep stos %al,%es:(%edi)
f0113be7:	83 ec 0c             	sub    $0xc,%esp
f0113bea:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113bf0:	50                   	push   %eax
f0113bf1:	e8 05 e3 fe ff       	call   f0101efb <execute_command>
f0113bf6:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0113bf9:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113bff:	bb 2d c0 12 f0       	mov    $0xf012c02d,%ebx
f0113c04:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113c09:	89 c7                	mov    %eax,%edi
f0113c0b:	89 de                	mov    %ebx,%esi
f0113c0d:	89 d1                	mov    %edx,%ecx
f0113c0f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113c11:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113c17:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113c1c:	b0 00                	mov    $0x0,%al
f0113c1e:	89 d7                	mov    %edx,%edi
f0113c20:	f3 aa                	rep stos %al,%es:(%edi)
f0113c22:	83 ec 0c             	sub    $0xc,%esp
f0113c25:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113c2b:	50                   	push   %eax
f0113c2c:	e8 ca e2 fe ff       	call   f0101efb <execute_command>
f0113c31:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0113c34:	83 ec 04             	sub    $0x4,%esp
f0113c37:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113c3d:	50                   	push   %eax
f0113c3e:	68 3b bb 12 f0       	push   $0xf012bb3b
f0113c43:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113c49:	50                   	push   %eax
f0113c4a:	e8 6b e8 00 00       	call   f01224ba <strcconcat>
f0113c4f:	83 c4 10             	add    $0x10,%esp
f0113c52:	83 ec 0c             	sub    $0xc,%esp
f0113c55:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113c5b:	50                   	push   %eax
f0113c5c:	e8 9a e2 fe ff       	call   f0101efb <execute_command>
f0113c61:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113c64:	83 ec 04             	sub    $0x4,%esp
f0113c67:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113c6d:	50                   	push   %eax
f0113c6e:	68 45 bb 12 f0       	push   $0xf012bb45
f0113c73:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113c79:	50                   	push   %eax
f0113c7a:	e8 3b e8 00 00       	call   f01224ba <strcconcat>
f0113c7f:	83 c4 10             	add    $0x10,%esp
f0113c82:	83 ec 0c             	sub    $0xc,%esp
f0113c85:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113c8b:	50                   	push   %eax
f0113c8c:	e8 6a e2 fe ff       	call   f0101efb <execute_command>
f0113c91:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113c94:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113c9a:	bb 91 c0 12 f0       	mov    $0xf012c091,%ebx
f0113c9f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ca4:	89 c7                	mov    %eax,%edi
f0113ca6:	89 de                	mov    %ebx,%esi
f0113ca8:	89 d1                	mov    %edx,%ecx
f0113caa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113cac:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113cb2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113cb7:	b0 00                	mov    $0x0,%al
f0113cb9:	89 d7                	mov    %edx,%edi
f0113cbb:	f3 aa                	rep stos %al,%es:(%edi)
f0113cbd:	83 ec 0c             	sub    $0xc,%esp
f0113cc0:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113cc6:	50                   	push   %eax
f0113cc7:	e8 2f e2 fe ff       	call   f0101efb <execute_command>
f0113ccc:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0113ccf:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113cd5:	bb f5 c0 12 f0       	mov    $0xf012c0f5,%ebx
f0113cda:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113cdf:	89 c7                	mov    %eax,%edi
f0113ce1:	89 de                	mov    %ebx,%esi
f0113ce3:	89 d1                	mov    %edx,%ecx
f0113ce5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ce7:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113ced:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113cf2:	b0 00                	mov    $0x0,%al
f0113cf4:	89 d7                	mov    %edx,%edi
f0113cf6:	f3 aa                	rep stos %al,%es:(%edi)
f0113cf8:	83 ec 0c             	sub    $0xc,%esp
f0113cfb:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113d01:	50                   	push   %eax
f0113d02:	e8 f4 e1 fe ff       	call   f0101efb <execute_command>
f0113d07:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0113d0a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113d10:	bb 59 c1 12 f0       	mov    $0xf012c159,%ebx
f0113d15:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113d1a:	89 c7                	mov    %eax,%edi
f0113d1c:	89 de                	mov    %ebx,%esi
f0113d1e:	89 d1                	mov    %edx,%ecx
f0113d20:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113d22:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113d28:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113d2d:	b0 00                	mov    $0x0,%al
f0113d2f:	89 d7                	mov    %edx,%edi
f0113d31:	f3 aa                	rep stos %al,%es:(%edi)
f0113d33:	83 ec 0c             	sub    $0xc,%esp
f0113d36:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113d3c:	50                   	push   %eax
f0113d3d:	e8 b9 e1 fe ff       	call   f0101efb <execute_command>
f0113d42:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113d45:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0113d4c:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113d53:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0113d5a:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113d61:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113d68:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0113d6f:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113d76:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0113d7d:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113d84:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0113d8b:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113d92:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113d99:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113d9c:	8a 00                	mov    (%eax),%al
f0113d9e:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113da4:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113da7:	8a 00                	mov    (%eax),%al
f0113da9:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0113daf:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113db2:	8a 00                	mov    (%eax),%al
f0113db4:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113dba:	e8 75 b0 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0113dbf:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113dc2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113dc5:	89 d0                	mov    %edx,%eax
f0113dc7:	01 c0                	add    %eax,%eax
f0113dc9:	01 d0                	add    %edx,%eax
f0113dcb:	01 c0                	add    %eax,%eax
f0113dcd:	50                   	push   %eax
f0113dce:	68 00 00 10 00       	push   $0x100000
f0113dd3:	6a 00                	push   $0x0
f0113dd5:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dd8:	e8 c2 71 ff ff       	call   f010af9f <copy_paste_chunk>
f0113ddd:	83 c4 10             	add    $0x10,%esp
f0113de0:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113de3:	e8 4c b0 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0113de8:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113deb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113df2:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0113df6:	75 08                	jne    f0113e00 <test_copy_paste_chunk+0x4a2>
f0113df8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113dfb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113dfe:	74 2b                	je     f0113e2b <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113e00:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113e03:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113e06:	83 ec 0c             	sub    $0xc,%esp
f0113e09:	50                   	push   %eax
f0113e0a:	ff 75 88             	pushl  -0x78(%ebp)
f0113e0d:	68 54 bb 12 f0       	push   $0xf012bb54
f0113e12:	68 06 03 00 00       	push   $0x306
f0113e17:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113e1c:	e8 b5 c6 fe ff       	call   f01004d6 <_warn>
f0113e21:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113e24:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113e2b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e2f:	74 04                	je     f0113e35 <test_copy_paste_chunk+0x4d7>
f0113e31:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113e35:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0113e3c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e3f:	8a 00                	mov    (%eax),%al
f0113e41:	3c 61                	cmp    $0x61,%al
f0113e43:	75 75                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e45:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e48:	8a 00                	mov    (%eax),%al
f0113e4a:	3c 78                	cmp    $0x78,%al
f0113e4c:	75 6c                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e4e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113e51:	8a 00                	mov    (%eax),%al
f0113e53:	3c 62                	cmp    $0x62,%al
f0113e55:	75 63                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e57:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113e5a:	8a 00                	mov    (%eax),%al
f0113e5c:	3c 79                	cmp    $0x79,%al
f0113e5e:	75 5a                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e60:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113e63:	8a 00                	mov    (%eax),%al
f0113e65:	3c 63                	cmp    $0x63,%al
f0113e67:	75 51                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e69:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113e6c:	8a 00                	mov    (%eax),%al
f0113e6e:	3c 7a                	cmp    $0x7a,%al
f0113e70:	75 48                	jne    f0113eba <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113e72:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113e75:	8a 00                	mov    (%eax),%al
f0113e77:	3c 64                	cmp    $0x64,%al
f0113e79:	75 3f                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e7b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113e7e:	8a 10                	mov    (%eax),%dl
f0113e80:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113e86:	38 c2                	cmp    %al,%dl
f0113e88:	75 30                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e8a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113e8d:	8a 00                	mov    (%eax),%al
f0113e8f:	3c 65                	cmp    $0x65,%al
f0113e91:	75 27                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113e93:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113e96:	8a 10                	mov    (%eax),%dl
f0113e98:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0113e9e:	38 c2                	cmp    %al,%dl
f0113ea0:	75 18                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113ea2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113ea5:	8a 00                	mov    (%eax),%al
f0113ea7:	3c 66                	cmp    $0x66,%al
f0113ea9:	75 0f                	jne    f0113eba <test_copy_paste_chunk+0x55c>
f0113eab:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113eae:	8a 10                	mov    (%eax),%dl
f0113eb0:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113eb6:	38 c2                	cmp    %al,%dl
f0113eb8:	74 21                	je     f0113edb <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113eba:	83 ec 04             	sub    $0x4,%esp
f0113ebd:	68 b8 bb 12 f0       	push   $0xf012bbb8
f0113ec2:	68 0f 03 00 00       	push   $0x30f
f0113ec7:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0113ecc:	e8 05 c6 fe ff       	call   f01004d6 <_warn>
f0113ed1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ed4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113edb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113edf:	74 04                	je     f0113ee5 <test_copy_paste_chunk+0x587>
f0113ee1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113ee5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f0113eec:	83 ec 0c             	sub    $0xc,%esp
f0113eef:	68 f2 bb 12 f0       	push   $0xf012bbf2
f0113ef4:	e8 92 d0 fe ff       	call   f0100f8b <cprintf>
f0113ef9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f0113efc:	83 ec 0c             	sub    $0xc,%esp
f0113eff:	68 04 bc 12 f0       	push   $0xf012bc04
f0113f04:	e8 82 d0 fe ff       	call   f0100f8b <cprintf>
f0113f09:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f0113f0c:	83 ec 04             	sub    $0x4,%esp
f0113f0f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113f15:	50                   	push   %eax
f0113f16:	68 3a bc 12 f0       	push   $0xf012bc3a
f0113f1b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f21:	50                   	push   %eax
f0113f22:	e8 93 e5 00 00       	call   f01224ba <strcconcat>
f0113f27:	83 c4 10             	add    $0x10,%esp
f0113f2a:	83 ec 0c             	sub    $0xc,%esp
f0113f2d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113f33:	50                   	push   %eax
f0113f34:	e8 c2 df fe ff       	call   f0101efb <execute_command>
f0113f39:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0113f3c:	83 ec 04             	sub    $0x4,%esp
f0113f3f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113f45:	50                   	push   %eax
f0113f46:	68 44 bc 12 f0       	push   $0xf012bc44
f0113f4b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f51:	50                   	push   %eax
f0113f52:	e8 63 e5 00 00       	call   f01224ba <strcconcat>
f0113f57:	83 c4 10             	add    $0x10,%esp
f0113f5a:	83 ec 0c             	sub    $0xc,%esp
f0113f5d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113f63:	50                   	push   %eax
f0113f64:	e8 92 df fe ff       	call   f0101efb <execute_command>
f0113f69:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0113f6c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113f72:	bb bd c1 12 f0       	mov    $0xf012c1bd,%ebx
f0113f77:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113f7c:	89 c7                	mov    %eax,%edi
f0113f7e:	89 de                	mov    %ebx,%esi
f0113f80:	89 d1                	mov    %edx,%ecx
f0113f82:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113f84:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113f8a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113f8f:	b0 00                	mov    $0x0,%al
f0113f91:	89 d7                	mov    %edx,%edi
f0113f93:	f3 aa                	rep stos %al,%es:(%edi)
f0113f95:	83 ec 0c             	sub    $0xc,%esp
f0113f98:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113f9e:	50                   	push   %eax
f0113f9f:	e8 57 df fe ff       	call   f0101efb <execute_command>
f0113fa4:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113fa7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113fad:	bb 21 c2 12 f0       	mov    $0xf012c221,%ebx
f0113fb2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113fb7:	89 c7                	mov    %eax,%edi
f0113fb9:	89 de                	mov    %ebx,%esi
f0113fbb:	89 d1                	mov    %edx,%ecx
f0113fbd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113fbf:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113fc5:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113fca:	b0 00                	mov    $0x0,%al
f0113fcc:	89 d7                	mov    %edx,%edi
f0113fce:	f3 aa                	rep stos %al,%es:(%edi)
f0113fd0:	83 ec 0c             	sub    $0xc,%esp
f0113fd3:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113fd9:	50                   	push   %eax
f0113fda:	e8 1c df fe ff       	call   f0101efb <execute_command>
f0113fdf:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113fe2:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113fe8:	bb 85 c2 12 f0       	mov    $0xf012c285,%ebx
f0113fed:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ff2:	89 c7                	mov    %eax,%edi
f0113ff4:	89 de                	mov    %ebx,%esi
f0113ff6:	89 d1                	mov    %edx,%ecx
f0113ff8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ffa:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0114000:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114005:	b0 00                	mov    $0x0,%al
f0114007:	89 d7                	mov    %edx,%edi
f0114009:	f3 aa                	rep stos %al,%es:(%edi)
f011400b:	83 ec 0c             	sub    $0xc,%esp
f011400e:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0114014:	50                   	push   %eax
f0114015:	e8 e1 de fe ff       	call   f0101efb <execute_command>
f011401a:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f011401d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0114023:	bb e9 c2 12 f0       	mov    $0xf012c2e9,%ebx
f0114028:	ba 0f 00 00 00       	mov    $0xf,%edx
f011402d:	89 c7                	mov    %eax,%edi
f011402f:	89 de                	mov    %ebx,%esi
f0114031:	89 d1                	mov    %edx,%ecx
f0114033:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114035:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011403b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114040:	b0 00                	mov    $0x0,%al
f0114042:	89 d7                	mov    %edx,%edi
f0114044:	f3 aa                	rep stos %al,%es:(%edi)
f0114046:	83 ec 0c             	sub    $0xc,%esp
f0114049:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011404f:	50                   	push   %eax
f0114050:	e8 a6 de fe ff       	call   f0101efb <execute_command>
f0114055:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0114058:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011405e:	bb 4d c3 12 f0       	mov    $0xf012c34d,%ebx
f0114063:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114068:	89 c7                	mov    %eax,%edi
f011406a:	89 de                	mov    %ebx,%esi
f011406c:	89 d1                	mov    %edx,%ecx
f011406e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114070:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0114076:	b9 55 00 00 00       	mov    $0x55,%ecx
f011407b:	b0 00                	mov    $0x0,%al
f011407d:	89 d7                	mov    %edx,%edi
f011407f:	f3 aa                	rep stos %al,%es:(%edi)
f0114081:	83 ec 0c             	sub    $0xc,%esp
f0114084:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011408a:	50                   	push   %eax
f011408b:	e8 6b de fe ff       	call   f0101efb <execute_command>
f0114090:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0114093:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0114099:	bb b1 c3 12 f0       	mov    $0xf012c3b1,%ebx
f011409e:	ba 0f 00 00 00       	mov    $0xf,%edx
f01140a3:	89 c7                	mov    %eax,%edi
f01140a5:	89 de                	mov    %ebx,%esi
f01140a7:	89 d1                	mov    %edx,%ecx
f01140a9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01140ab:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01140b1:	b9 55 00 00 00       	mov    $0x55,%ecx
f01140b6:	b0 00                	mov    $0x0,%al
f01140b8:	89 d7                	mov    %edx,%edi
f01140ba:	f3 aa                	rep stos %al,%es:(%edi)
f01140bc:	83 ec 0c             	sub    $0xc,%esp
f01140bf:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01140c5:	50                   	push   %eax
f01140c6:	e8 30 de fe ff       	call   f0101efb <execute_command>
f01140cb:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f01140ce:	83 ec 04             	sub    $0x4,%esp
f01140d1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01140d7:	50                   	push   %eax
f01140d8:	68 4e bc 12 f0       	push   $0xf012bc4e
f01140dd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01140e3:	50                   	push   %eax
f01140e4:	e8 d1 e3 00 00       	call   f01224ba <strcconcat>
f01140e9:	83 c4 10             	add    $0x10,%esp
f01140ec:	83 ec 0c             	sub    $0xc,%esp
f01140ef:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01140f5:	50                   	push   %eax
f01140f6:	e8 00 de fe ff       	call   f0101efb <execute_command>
f01140fb:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f01140fe:	83 ec 04             	sub    $0x4,%esp
f0114101:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114107:	50                   	push   %eax
f0114108:	68 58 bc 12 f0       	push   $0xf012bc58
f011410d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114113:	50                   	push   %eax
f0114114:	e8 a1 e3 00 00       	call   f01224ba <strcconcat>
f0114119:	83 c4 10             	add    $0x10,%esp
f011411c:	83 ec 0c             	sub    $0xc,%esp
f011411f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0114125:	50                   	push   %eax
f0114126:	e8 d0 dd fe ff       	call   f0101efb <execute_command>
f011412b:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f011412e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114134:	bb 15 c4 12 f0       	mov    $0xf012c415,%ebx
f0114139:	ba 0f 00 00 00       	mov    $0xf,%edx
f011413e:	89 c7                	mov    %eax,%edi
f0114140:	89 de                	mov    %ebx,%esi
f0114142:	89 d1                	mov    %edx,%ecx
f0114144:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114146:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011414c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114151:	b0 00                	mov    $0x0,%al
f0114153:	89 d7                	mov    %edx,%edi
f0114155:	f3 aa                	rep stos %al,%es:(%edi)
f0114157:	83 ec 0c             	sub    $0xc,%esp
f011415a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114160:	50                   	push   %eax
f0114161:	e8 95 dd fe ff       	call   f0101efb <execute_command>
f0114166:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0114169:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011416f:	bb 79 c4 12 f0       	mov    $0xf012c479,%ebx
f0114174:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114179:	89 c7                	mov    %eax,%edi
f011417b:	89 de                	mov    %ebx,%esi
f011417d:	89 d1                	mov    %edx,%ecx
f011417f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114181:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0114187:	b9 55 00 00 00       	mov    $0x55,%ecx
f011418c:	b0 00                	mov    $0x0,%al
f011418e:	89 d7                	mov    %edx,%edi
f0114190:	f3 aa                	rep stos %al,%es:(%edi)
f0114192:	83 ec 0c             	sub    $0xc,%esp
f0114195:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011419b:	50                   	push   %eax
f011419c:	e8 5a dd fe ff       	call   f0101efb <execute_command>
f01141a1:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01141a4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01141aa:	bb dd c4 12 f0       	mov    $0xf012c4dd,%ebx
f01141af:	ba 0f 00 00 00       	mov    $0xf,%edx
f01141b4:	89 c7                	mov    %eax,%edi
f01141b6:	89 de                	mov    %ebx,%esi
f01141b8:	89 d1                	mov    %edx,%ecx
f01141ba:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01141bc:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01141c2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01141c7:	b0 00                	mov    $0x0,%al
f01141c9:	89 d7                	mov    %edx,%edi
f01141cb:	f3 aa                	rep stos %al,%es:(%edi)
f01141cd:	83 ec 0c             	sub    $0xc,%esp
f01141d0:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01141d6:	50                   	push   %eax
f01141d7:	e8 1f dd fe ff       	call   f0101efb <execute_command>
f01141dc:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f01141df:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01141e6:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01141ed:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01141f4:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f01141fb:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0114202:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0114209:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0114210:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0114217:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011421e:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0114225:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011422c:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0114233:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114236:	8a 00                	mov    (%eax),%al
f0114238:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011423e:	e8 f1 ab ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114243:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0114246:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114249:	89 d0                	mov    %edx,%eax
f011424b:	01 c0                	add    %eax,%eax
f011424d:	01 d0                	add    %edx,%eax
f011424f:	01 c0                	add    %eax,%eax
f0114251:	50                   	push   %eax
f0114252:	68 00 00 40 00       	push   $0x400000
f0114257:	68 00 00 20 00       	push   $0x200000
f011425c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011425f:	e8 3b 6d ff ff       	call   f010af9f <copy_paste_chunk>
f0114264:	83 c4 10             	add    $0x10,%esp
f0114267:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011426a:	e8 c5 ab ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011426f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0114272:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0114279:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f011427d:	75 08                	jne    f0114287 <test_copy_paste_chunk+0x929>
f011427f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114282:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0114285:	74 2b                	je     f01142b2 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114287:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011428a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011428d:	83 ec 0c             	sub    $0xc,%esp
f0114290:	50                   	push   %eax
f0114291:	ff 75 80             	pushl  -0x80(%ebp)
f0114294:	68 64 bc 12 f0       	push   $0xf012bc64
f0114299:	68 3f 03 00 00       	push   $0x33f
f011429e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01142a3:	e8 2e c2 fe ff       	call   f01004d6 <_warn>
f01142a8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01142ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01142b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01142b6:	74 04                	je     f01142bc <test_copy_paste_chunk+0x95e>
f01142b8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142bc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01142c3:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01142ca:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01142cd:	83 ec 08             	sub    $0x8,%esp
f01142d0:	6a 01                	push   $0x1
f01142d2:	6a 07                	push   $0x7
f01142d4:	6a 07                	push   $0x7
f01142d6:	6a 07                	push   $0x7
f01142d8:	6a 07                	push   $0x7
f01142da:	6a 01                	push   $0x1
f01142dc:	68 00 20 00 00       	push   $0x2000
f01142e1:	68 00 00 40 00       	push   $0x400000
f01142e6:	68 00 00 20 00       	push   $0x200000
f01142eb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01142ee:	e8 bf 32 00 00       	call   f01175b2 <CCP>
f01142f3:	83 c4 30             	add    $0x30,%esp
f01142f6:	83 f8 01             	cmp    $0x1,%eax
f01142f9:	74 2b                	je     f0114326 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f01142fb:	83 ec 04             	sub    $0x4,%esp
f01142fe:	68 b8 bc 12 f0       	push   $0xf012bcb8
f0114303:	68 48 03 00 00       	push   $0x348
f0114308:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011430d:	e8 c4 c1 fe ff       	call   f01004d6 <_warn>
f0114312:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114315:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011431c:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0114323:	00 00 00 
		}
		if (correct) eval += 5 ;
f0114326:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011432a:	74 04                	je     f0114330 <test_copy_paste_chunk+0x9d2>
f011432c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114330:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0114337:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011433a:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011433d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114340:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0114343:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114346:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0114349:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011434c:	8a 00                	mov    (%eax),%al
f011434e:	3c 61                	cmp    $0x61,%al
f0114350:	75 69                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f0114352:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114355:	8a 00                	mov    (%eax),%al
f0114357:	3c 61                	cmp    $0x61,%al
f0114359:	75 60                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f011435b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011435e:	8a 00                	mov    (%eax),%al
f0114360:	3c 79                	cmp    $0x79,%al
f0114362:	75 57                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f0114364:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114367:	8a 00                	mov    (%eax),%al
f0114369:	3c 62                	cmp    $0x62,%al
f011436b:	75 4e                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f011436d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114370:	8a 00                	mov    (%eax),%al
f0114372:	3c 63                	cmp    $0x63,%al
f0114374:	75 45                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f0114376:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0114379:	8a 00                	mov    (%eax),%al
f011437b:	3c 7a                	cmp    $0x7a,%al
f011437d:	75 3c                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f011437f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114382:	8a 00                	mov    (%eax),%al
f0114384:	3c 77                	cmp    $0x77,%al
f0114386:	75 33                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f0114388:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011438b:	8a 00                	mov    (%eax),%al
f011438d:	3c 64                	cmp    $0x64,%al
f011438f:	75 2a                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f0114391:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114394:	8a 00                	mov    (%eax),%al
f0114396:	3c 65                	cmp    $0x65,%al
f0114398:	75 21                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f011439a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011439d:	8a 00                	mov    (%eax),%al
f011439f:	3c 65                	cmp    $0x65,%al
f01143a1:	75 18                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f01143a3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01143a6:	8a 00                	mov    (%eax),%al
f01143a8:	3c 66                	cmp    $0x66,%al
f01143aa:	75 0f                	jne    f01143bb <test_copy_paste_chunk+0xa5d>
f01143ac:	8b 45 90             	mov    -0x70(%ebp),%eax
f01143af:	8a 10                	mov    (%eax),%dl
f01143b1:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01143b7:	38 c2                	cmp    %al,%dl
f01143b9:	74 21                	je     f01143dc <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01143bb:	83 ec 04             	sub    $0x4,%esp
f01143be:	68 b8 bb 12 f0       	push   $0xf012bbb8
f01143c3:	68 56 03 00 00       	push   $0x356
f01143c8:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01143cd:	e8 04 c1 fe ff       	call   f01004d6 <_warn>
f01143d2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01143d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01143dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01143e0:	74 04                	je     f01143e6 <test_copy_paste_chunk+0xa88>
f01143e2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01143e6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f01143ed:	8b 45 98             	mov    -0x68(%ebp),%eax
f01143f0:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01143f3:	e8 3c aa ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01143f8:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f01143fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01143fe:	89 c2                	mov    %eax,%edx
f0114400:	01 d2                	add    %edx,%edx
f0114402:	01 d0                	add    %edx,%eax
f0114404:	50                   	push   %eax
f0114405:	68 00 08 20 00       	push   $0x200800
f011440a:	68 00 08 40 00       	push   $0x400800
f011440f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114412:	e8 88 6b ff ff       	call   f010af9f <copy_paste_chunk>
f0114417:	83 c4 10             	add    $0x10,%esp
f011441a:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011441d:	e8 12 aa ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114422:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0114425:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0114429:	75 08                	jne    f0114433 <test_copy_paste_chunk+0xad5>
f011442b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011442e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0114431:	74 2b                	je     f011445e <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114433:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114436:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114439:	83 ec 0c             	sub    $0xc,%esp
f011443c:	50                   	push   %eax
f011443d:	ff 75 80             	pushl  -0x80(%ebp)
f0114440:	68 64 bc 12 f0       	push   $0xf012bc64
f0114445:	68 66 03 00 00       	push   $0x366
f011444a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011444f:	e8 82 c0 fe ff       	call   f01004d6 <_warn>
f0114454:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114457:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011445e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114462:	74 04                	je     f0114468 <test_copy_paste_chunk+0xb0a>
f0114464:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114468:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011446f:	83 ec 08             	sub    $0x8,%esp
f0114472:	6a 01                	push   $0x1
f0114474:	6a 07                	push   $0x7
f0114476:	6a 07                	push   $0x7
f0114478:	6a 07                	push   $0x7
f011447a:	6a 07                	push   $0x7
f011447c:	6a 01                	push   $0x1
f011447e:	68 00 20 00 00       	push   $0x2000
f0114483:	68 00 00 20 00       	push   $0x200000
f0114488:	68 00 00 40 00       	push   $0x400000
f011448d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114490:	e8 1d 31 00 00       	call   f01175b2 <CCP>
f0114495:	83 c4 30             	add    $0x30,%esp
f0114498:	83 f8 01             	cmp    $0x1,%eax
f011449b:	74 21                	je     f01144be <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f011449d:	83 ec 04             	sub    $0x4,%esp
f01144a0:	68 04 bd 12 f0       	push   $0xf012bd04
f01144a5:	68 6e 03 00 00       	push   $0x36e
f01144aa:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01144af:	e8 22 c0 fe ff       	call   f01004d6 <_warn>
f01144b4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01144be:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01144c2:	74 04                	je     f01144c8 <test_copy_paste_chunk+0xb6a>
f01144c4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144c8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01144cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01144d2:	8a 00                	mov    (%eax),%al
f01144d4:	3c 61                	cmp    $0x61,%al
f01144d6:	75 69                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f01144d8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01144db:	8a 00                	mov    (%eax),%al
f01144dd:	3c 61                	cmp    $0x61,%al
f01144df:	75 60                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f01144e1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01144e4:	8a 00                	mov    (%eax),%al
f01144e6:	3c 79                	cmp    $0x79,%al
f01144e8:	75 57                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f01144ea:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01144ed:	8a 00                	mov    (%eax),%al
f01144ef:	3c 62                	cmp    $0x62,%al
f01144f1:	75 4e                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f01144f3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01144f6:	8a 00                	mov    (%eax),%al
f01144f8:	3c 7a                	cmp    $0x7a,%al
f01144fa:	75 45                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f01144fc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01144ff:	8a 00                	mov    (%eax),%al
f0114501:	3c 7a                	cmp    $0x7a,%al
f0114503:	75 3c                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0114505:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114508:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011450a:	3c 64                	cmp    $0x64,%al
f011450c:	75 33                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011450e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0114511:	8a 00                	mov    (%eax),%al
f0114513:	3c 64                	cmp    $0x64,%al
f0114515:	75 2a                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f0114517:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011451a:	8a 00                	mov    (%eax),%al
f011451c:	3c 65                	cmp    $0x65,%al
f011451e:	75 21                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f0114520:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114523:	8a 00                	mov    (%eax),%al
f0114525:	3c 78                	cmp    $0x78,%al
f0114527:	75 18                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f0114529:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011452c:	8a 00                	mov    (%eax),%al
f011452e:	3c 66                	cmp    $0x66,%al
f0114530:	75 0f                	jne    f0114541 <test_copy_paste_chunk+0xbe3>
f0114532:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114535:	8a 10                	mov    (%eax),%dl
f0114537:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011453d:	38 c2                	cmp    %al,%dl
f011453f:	74 21                	je     f0114562 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114541:	83 ec 04             	sub    $0x4,%esp
f0114544:	68 b8 bb 12 f0       	push   $0xf012bbb8
f0114549:	68 77 03 00 00       	push   $0x377
f011454e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114553:	e8 7e bf fe ff       	call   f01004d6 <_warn>
f0114558:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011455b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0114562:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114566:	74 04                	je     f011456c <test_copy_paste_chunk+0xc0e>
f0114568:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011456c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0114573:	83 ec 0c             	sub    $0xc,%esp
f0114576:	68 4f bd 12 f0       	push   $0xf012bd4f
f011457b:	e8 0b ca fe ff       	call   f0100f8b <cprintf>
f0114580:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0114583:	83 ec 0c             	sub    $0xc,%esp
f0114586:	68 60 bd 12 f0       	push   $0xf012bd60
f011458b:	e8 fb c9 fe ff       	call   f0100f8b <cprintf>
f0114590:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0114593:	83 ec 04             	sub    $0x4,%esp
f0114596:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011459c:	50                   	push   %eax
f011459d:	68 94 bd 12 f0       	push   $0xf012bd94
f01145a2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01145a8:	50                   	push   %eax
f01145a9:	e8 0c df 00 00       	call   f01224ba <strcconcat>
f01145ae:	83 c4 10             	add    $0x10,%esp
f01145b1:	83 ec 0c             	sub    $0xc,%esp
f01145b4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01145ba:	50                   	push   %eax
f01145bb:	e8 3b d9 fe ff       	call   f0101efb <execute_command>
f01145c0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f01145c3:	83 ec 04             	sub    $0x4,%esp
f01145c6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01145cc:	50                   	push   %eax
f01145cd:	68 9e bd 12 f0       	push   $0xf012bd9e
f01145d2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01145d8:	50                   	push   %eax
f01145d9:	e8 dc de 00 00       	call   f01224ba <strcconcat>
f01145de:	83 c4 10             	add    $0x10,%esp
f01145e1:	83 ec 0c             	sub    $0xc,%esp
f01145e4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01145ea:	50                   	push   %eax
f01145eb:	e8 0b d9 fe ff       	call   f0101efb <execute_command>
f01145f0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f01145f3:	83 ec 04             	sub    $0x4,%esp
f01145f6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01145fc:	50                   	push   %eax
f01145fd:	68 a8 bd 12 f0       	push   $0xf012bda8
f0114602:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114608:	50                   	push   %eax
f0114609:	e8 ac de 00 00       	call   f01224ba <strcconcat>
f011460e:	83 c4 10             	add    $0x10,%esp
f0114611:	83 ec 0c             	sub    $0xc,%esp
f0114614:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011461a:	50                   	push   %eax
f011461b:	e8 db d8 fe ff       	call   f0101efb <execute_command>
f0114620:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0114623:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114629:	bb 41 c5 12 f0       	mov    $0xf012c541,%ebx
f011462e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114633:	89 c7                	mov    %eax,%edi
f0114635:	89 de                	mov    %ebx,%esi
f0114637:	89 d1                	mov    %edx,%ecx
f0114639:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011463b:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114641:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114646:	b0 00                	mov    $0x0,%al
f0114648:	89 d7                	mov    %edx,%edi
f011464a:	f3 aa                	rep stos %al,%es:(%edi)
f011464c:	83 ec 0c             	sub    $0xc,%esp
f011464f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114655:	50                   	push   %eax
f0114656:	e8 a0 d8 fe ff       	call   f0101efb <execute_command>
f011465b:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f011465e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114664:	bb a5 c5 12 f0       	mov    $0xf012c5a5,%ebx
f0114669:	ba 0f 00 00 00       	mov    $0xf,%edx
f011466e:	89 c7                	mov    %eax,%edi
f0114670:	89 de                	mov    %ebx,%esi
f0114672:	89 d1                	mov    %edx,%ecx
f0114674:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114676:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011467c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114681:	b0 00                	mov    $0x0,%al
f0114683:	89 d7                	mov    %edx,%edi
f0114685:	f3 aa                	rep stos %al,%es:(%edi)
f0114687:	83 ec 0c             	sub    $0xc,%esp
f011468a:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114690:	50                   	push   %eax
f0114691:	e8 65 d8 fe ff       	call   f0101efb <execute_command>
f0114696:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0114699:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011469f:	bb 09 c6 12 f0       	mov    $0xf012c609,%ebx
f01146a4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01146a9:	89 c7                	mov    %eax,%edi
f01146ab:	89 de                	mov    %ebx,%esi
f01146ad:	89 d1                	mov    %edx,%ecx
f01146af:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01146b1:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01146b7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01146bc:	b0 00                	mov    $0x0,%al
f01146be:	89 d7                	mov    %edx,%edi
f01146c0:	f3 aa                	rep stos %al,%es:(%edi)
f01146c2:	83 ec 0c             	sub    $0xc,%esp
f01146c5:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01146cb:	50                   	push   %eax
f01146cc:	e8 2a d8 fe ff       	call   f0101efb <execute_command>
f01146d1:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01146d4:	e8 5b a7 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01146d9:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f01146dc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01146df:	89 d0                	mov    %edx,%eax
f01146e1:	01 c0                	add    %eax,%eax
f01146e3:	01 d0                	add    %edx,%eax
f01146e5:	c1 e0 02             	shl    $0x2,%eax
f01146e8:	50                   	push   %eax
f01146e9:	68 00 00 90 00       	push   $0x900000
f01146ee:	68 00 00 80 00       	push   $0x800000
f01146f3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01146f6:	e8 a4 68 ff ff       	call   f010af9f <copy_paste_chunk>
f01146fb:	83 c4 10             	add    $0x10,%esp
f01146fe:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114704:	e8 2b a7 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114709:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011470c:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0114713:	75 0b                	jne    f0114720 <test_copy_paste_chunk+0xdc2>
f0114715:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114718:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011471b:	83 f8 03             	cmp    $0x3,%eax
f011471e:	74 2e                	je     f011474e <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114720:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0114723:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0114726:	83 ec 0c             	sub    $0xc,%esp
f0114729:	50                   	push   %eax
f011472a:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0114730:	68 64 bc 12 f0       	push   $0xf012bc64
f0114735:	68 95 03 00 00       	push   $0x395
f011473a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011473f:	e8 92 bd fe ff       	call   f01004d6 <_warn>
f0114744:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114747:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011474e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114752:	74 04                	je     f0114758 <test_copy_paste_chunk+0xdfa>
f0114754:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114758:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f011475f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0114766:	83 ec 08             	sub    $0x8,%esp
f0114769:	6a 01                	push   $0x1
f011476b:	6a 07                	push   $0x7
f011476d:	6a 07                	push   $0x7
f011476f:	6a 07                	push   $0x7
f0114771:	6a 07                	push   $0x7
f0114773:	6a 01                	push   $0x1
f0114775:	68 00 30 00 00       	push   $0x3000
f011477a:	68 00 00 90 00       	push   $0x900000
f011477f:	68 00 00 80 00       	push   $0x800000
f0114784:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114787:	e8 26 2e 00 00       	call   f01175b2 <CCP>
f011478c:	83 c4 30             	add    $0x30,%esp
f011478f:	83 f8 01             	cmp    $0x1,%eax
f0114792:	74 28                	je     f01147bc <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114794:	83 ec 04             	sub    $0x4,%esp
f0114797:	68 04 bd 12 f0       	push   $0xf012bd04
f011479c:	68 9e 03 00 00       	push   $0x39e
f01147a1:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01147a6:	e8 2b bd fe ff       	call   f01004d6 <_warn>
f01147ab:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01147b5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f01147bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01147c0:	74 04                	je     f01147c6 <test_copy_paste_chunk+0xe68>
f01147c2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147c6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01147cd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01147d1:	0f 84 9e 00 00 00    	je     f0114875 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f01147d7:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f01147de:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f01147e5:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f01147ec:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f01147f3:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f01147fa:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0114801:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114804:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0114807:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011480a:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f011480d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114810:	8a 00                	mov    (%eax),%al
f0114812:	3c 61                	cmp    $0x61,%al
f0114814:	75 2d                	jne    f0114843 <test_copy_paste_chunk+0xee5>
f0114816:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114819:	8a 00                	mov    (%eax),%al
f011481b:	3c 61                	cmp    $0x61,%al
f011481d:	75 24                	jne    f0114843 <test_copy_paste_chunk+0xee5>
f011481f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114822:	8a 00                	mov    (%eax),%al
f0114824:	3c 79                	cmp    $0x79,%al
f0114826:	75 1b                	jne    f0114843 <test_copy_paste_chunk+0xee5>
f0114828:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011482b:	8a 00                	mov    (%eax),%al
f011482d:	3c 62                	cmp    $0x62,%al
f011482f:	75 12                	jne    f0114843 <test_copy_paste_chunk+0xee5>
f0114831:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0114834:	8a 00                	mov    (%eax),%al
f0114836:	3c 63                	cmp    $0x63,%al
f0114838:	75 09                	jne    f0114843 <test_copy_paste_chunk+0xee5>
f011483a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011483d:	8a 00                	mov    (%eax),%al
f011483f:	3c 7a                	cmp    $0x7a,%al
f0114841:	74 21                	je     f0114864 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114843:	83 ec 04             	sub    $0x4,%esp
f0114846:	68 b8 bb 12 f0       	push   $0xf012bbb8
f011484b:	68 b0 03 00 00       	push   $0x3b0
f0114850:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114855:	e8 7c bc fe ff       	call   f01004d6 <_warn>
f011485a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011485d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0114864:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114868:	74 04                	je     f011486e <test_copy_paste_chunk+0xf10>
f011486a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f011486e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114875:	e8 ba a5 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011487a:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011487d:	6a 00                	push   $0x0
f011487f:	6a 02                	push   $0x2
f0114881:	68 00 10 90 00       	push   $0x901000
f0114886:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114889:	e8 b1 2b 00 00       	call   f011743f <SB>
f011488e:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0114891:	6a 00                	push   $0x0
f0114893:	6a 02                	push   $0x2
f0114895:	68 00 20 90 00       	push   $0x902000
f011489a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011489d:	e8 9d 2b 00 00       	call   f011743f <SB>
f01148a2:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f01148a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148a8:	c1 e0 03             	shl    $0x3,%eax
f01148ab:	50                   	push   %eax
f01148ac:	68 00 f0 bf 00       	push   $0xbff000
f01148b1:	68 00 10 90 00       	push   $0x901000
f01148b6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01148b9:	e8 e1 66 ff ff       	call   f010af9f <copy_paste_chunk>
f01148be:	83 c4 10             	add    $0x10,%esp
f01148c1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01148c7:	e8 68 a5 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01148cc:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01148cf:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01148d6:	75 0b                	jne    f01148e3 <test_copy_paste_chunk+0xf85>
f01148d8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01148db:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01148de:	83 f8 03             	cmp    $0x3,%eax
f01148e1:	74 2e                	je     f0114911 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01148e3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01148e6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01148e9:	83 ec 0c             	sub    $0xc,%esp
f01148ec:	50                   	push   %eax
f01148ed:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01148f3:	68 64 bc 12 f0       	push   $0xf012bc64
f01148f8:	68 c0 03 00 00       	push   $0x3c0
f01148fd:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114902:	e8 cf bb fe ff       	call   f01004d6 <_warn>
f0114907:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011490a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0114911:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114915:	74 04                	je     f011491b <test_copy_paste_chunk+0xfbd>
f0114917:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011491b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0114922:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0114929:	83 ec 08             	sub    $0x8,%esp
f011492c:	6a 01                	push   $0x1
f011492e:	6a 07                	push   $0x7
f0114930:	6a 03                	push   $0x3
f0114932:	6a 07                	push   $0x7
f0114934:	6a 03                	push   $0x3
f0114936:	6a 01                	push   $0x1
f0114938:	68 00 20 00 00       	push   $0x2000
f011493d:	68 00 f0 bf 00       	push   $0xbff000
f0114942:	68 00 10 90 00       	push   $0x901000
f0114947:	ff 75 d4             	pushl  -0x2c(%ebp)
f011494a:	e8 63 2c 00 00       	call   f01175b2 <CCP>
f011494f:	83 c4 30             	add    $0x30,%esp
f0114952:	83 f8 01             	cmp    $0x1,%eax
f0114955:	74 28                	je     f011497f <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114957:	83 ec 04             	sub    $0x4,%esp
f011495a:	68 04 bd 12 f0       	push   $0xf012bd04
f011495f:	68 c9 03 00 00       	push   $0x3c9
f0114964:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114969:	e8 68 bb fe ff       	call   f01004d6 <_warn>
f011496e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114971:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114978:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f011497f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114983:	74 04                	je     f0114989 <test_copy_paste_chunk+0x102b>
f0114985:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114989:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114990:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114994:	74 72                	je     f0114a08 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0114996:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f011499d:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f01149a4:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f01149ab:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f01149b2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01149b5:	8a 00                	mov    (%eax),%al
f01149b7:	3c 62                	cmp    $0x62,%al
f01149b9:	75 1b                	jne    f01149d6 <test_copy_paste_chunk+0x1078>
f01149bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01149be:	8a 00                	mov    (%eax),%al
f01149c0:	3c 62                	cmp    $0x62,%al
f01149c2:	75 12                	jne    f01149d6 <test_copy_paste_chunk+0x1078>
f01149c4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149c7:	8a 00                	mov    (%eax),%al
f01149c9:	3c 7a                	cmp    $0x7a,%al
f01149cb:	75 09                	jne    f01149d6 <test_copy_paste_chunk+0x1078>
f01149cd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01149d0:	8a 00                	mov    (%eax),%al
f01149d2:	3c 7a                	cmp    $0x7a,%al
f01149d4:	74 21                	je     f01149f7 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01149d6:	83 ec 04             	sub    $0x4,%esp
f01149d9:	68 b8 bb 12 f0       	push   $0xf012bbb8
f01149de:	68 d5 03 00 00       	push   $0x3d5
f01149e3:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01149e8:	e8 e9 ba fe ff       	call   f01004d6 <_warn>
f01149ed:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01149f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01149f7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01149fb:	74 04                	je     f0114a01 <test_copy_paste_chunk+0x10a3>
f01149fd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114a01:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114a08:	83 ec 0c             	sub    $0xc,%esp
f0114a0b:	68 b2 bd 12 f0       	push   $0xf012bdb2
f0114a10:	e8 76 c5 fe ff       	call   f0100f8b <cprintf>
f0114a15:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0114a18:	83 ec 08             	sub    $0x8,%esp
f0114a1b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114a1e:	68 c4 bd 12 f0       	push   $0xf012bdc4
f0114a23:	e8 63 c5 fe ff       	call   f0100f8b <cprintf>
f0114a28:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114a2b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114a2f:	75 10                	jne    f0114a41 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0114a31:	83 ec 0c             	sub    $0xc,%esp
f0114a34:	68 f8 bd 12 f0       	push   $0xf012bdf8
f0114a39:	e8 4d c5 fe ff       	call   f0100f8b <cprintf>
f0114a3e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114a41:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f0114a46:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114a49:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114a4c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114a4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114a54:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114a57:	5b                   	pop    %ebx
f0114a58:	5e                   	pop    %esi
f0114a59:	5f                   	pop    %edi
f0114a5a:	5d                   	pop    %ebp
f0114a5b:	c3                   	ret    

f0114a5c <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0114a5c:	55                   	push   %ebp
f0114a5d:	89 e5                	mov    %esp,%ebp
f0114a5f:	57                   	push   %edi
f0114a60:	56                   	push   %esi
f0114a61:	53                   	push   %ebx
f0114a62:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114a68:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0114a6e:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f0114a73:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114a78:	89 c7                	mov    %eax,%edi
f0114a7a:	89 de                	mov    %ebx,%esi
f0114a7c:	89 d1                	mov    %edx,%ecx
f0114a7e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114a80:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0114a86:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114a8b:	b0 00                	mov    $0x0,%al
f0114a8d:	89 d7                	mov    %edx,%edi
f0114a8f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114a91:	6a 00                	push   $0x0
f0114a93:	6a 0a                	push   $0xa
f0114a95:	6a 14                	push   $0x14
f0114a97:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0114a9d:	50                   	push   %eax
f0114a9e:	e8 23 6a ff ff       	call   f010b4c6 <env_create>
f0114aa3:	83 c4 10             	add    $0x10,%esp
f0114aa6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114aa9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114aac:	8b 40 64             	mov    0x64(%eax),%eax
f0114aaf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114ab2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114ab5:	8b 40 68             	mov    0x68(%eax),%eax
f0114ab8:	89 45 80             	mov    %eax,-0x80(%ebp)
f0114abb:	8b 45 80             	mov    -0x80(%ebp),%eax
f0114abe:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114ac1:	83 ec 0c             	sub    $0xc,%esp
f0114ac4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ac7:	e8 b2 2a 00 00       	call   f011757e <ClearUserSpace>
f0114acc:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114acf:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114ad6:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114add:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0114ae4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0114ae8:	83 ec 0c             	sub    $0xc,%esp
f0114aeb:	68 70 c6 12 f0       	push   $0xf012c670
f0114af0:	e8 96 c4 fe ff       	call   f0100f8b <cprintf>
f0114af5:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0114af8:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0114aff:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0114b06:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b09:	8a 00                	mov    (%eax),%al
f0114b0b:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0114b11:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114b14:	8a 00                	mov    (%eax),%al
f0114b16:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b1c:	e8 13 a3 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114b21:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0114b24:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b27:	89 d0                	mov    %edx,%eax
f0114b29:	01 c0                	add    %eax,%eax
f0114b2b:	01 d0                	add    %edx,%eax
f0114b2d:	01 c0                	add    %eax,%eax
f0114b2f:	83 ec 0c             	sub    $0xc,%esp
f0114b32:	6a 02                	push   $0x2
f0114b34:	50                   	push   %eax
f0114b35:	68 00 40 10 f0       	push   $0xf0104000
f0114b3a:	68 00 00 10 f0       	push   $0xf0100000
f0114b3f:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b42:	e8 72 64 ff ff       	call   f010afb9 <share_chunk>
f0114b47:	83 c4 20             	add    $0x20,%esp
f0114b4a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b4d:	e8 e2 a2 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114b52:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114b55:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114b59:	75 08                	jne    f0114b63 <test_share_chunk+0x107>
f0114b5b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b5e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114b61:	74 28                	je     f0114b8b <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114b63:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b66:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114b69:	83 ec 0c             	sub    $0xc,%esp
f0114b6c:	50                   	push   %eax
f0114b6d:	ff 75 b0             	pushl  -0x50(%ebp)
f0114b70:	68 9c c6 12 f0       	push   $0xf012c69c
f0114b75:	68 11 04 00 00       	push   $0x411
f0114b7a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114b7f:	e8 52 b9 fe ff       	call   f01004d6 <_warn>
f0114b84:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b87:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b8b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b8f:	74 04                	je     f0114b95 <test_share_chunk+0x139>
f0114b91:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b95:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114b99:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b9c:	c1 e0 03             	shl    $0x3,%eax
f0114b9f:	83 ec 08             	sub    $0x8,%esp
f0114ba2:	68 fd 00 00 00       	push   $0xfd
f0114ba7:	6a 07                	push   $0x7
f0114ba9:	6a 03                	push   $0x3
f0114bab:	6a 07                	push   $0x7
f0114bad:	6a 03                	push   $0x3
f0114baf:	6a 01                	push   $0x1
f0114bb1:	50                   	push   %eax
f0114bb2:	68 00 40 10 f0       	push   $0xf0104000
f0114bb7:	68 00 00 10 f0       	push   $0xf0100000
f0114bbc:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bbf:	e8 ee 29 00 00       	call   f01175b2 <CCP>
f0114bc4:	83 c4 30             	add    $0x30,%esp
f0114bc7:	85 c0                	test   %eax,%eax
f0114bc9:	75 1e                	jne    f0114be9 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114bcb:	83 ec 04             	sub    $0x4,%esp
f0114bce:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0114bd3:	68 19 04 00 00       	push   $0x419
f0114bd8:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114bdd:	e8 f4 b8 fe ff       	call   f01004d6 <_warn>
f0114be2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114be5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114be9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114bed:	74 04                	je     f0114bf3 <test_share_chunk+0x197>
f0114bef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0114bf3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114bf6:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0114bf9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114bfc:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0114bff:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c02:	8a 00                	mov    (%eax),%al
f0114c04:	3c 41                	cmp    $0x41,%al
f0114c06:	75 09                	jne    f0114c11 <test_share_chunk+0x1b5>
f0114c08:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114c0b:	8a 00                	mov    (%eax),%al
f0114c0d:	3c 42                	cmp    $0x42,%al
f0114c0f:	74 1e                	je     f0114c2f <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114c11:	83 ec 04             	sub    $0x4,%esp
f0114c14:	68 40 c7 12 f0       	push   $0xf012c740
f0114c19:	68 23 04 00 00       	push   $0x423
f0114c1e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114c23:	e8 ae b8 fe ff       	call   f01004d6 <_warn>
f0114c28:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c2b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114c2f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c33:	74 04                	je     f0114c39 <test_share_chunk+0x1dd>
f0114c35:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114c39:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0114c3d:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114c43:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c46:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114c48:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0114c4e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114c51:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114c53:	83 ec 0c             	sub    $0xc,%esp
f0114c56:	68 75 c7 12 f0       	push   $0xf012c775
f0114c5b:	e8 2b c3 fe ff       	call   f0100f8b <cprintf>
f0114c60:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114c63:	83 ec 0c             	sub    $0xc,%esp
f0114c66:	68 84 c7 12 f0       	push   $0xf012c784
f0114c6b:	e8 1b c3 fe ff       	call   f0100f8b <cprintf>
f0114c70:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114c73:	e8 bc a1 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114c78:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0114c7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c7e:	c1 e0 05             	shl    $0x5,%eax
f0114c81:	83 ec 0c             	sub    $0xc,%esp
f0114c84:	68 02 0e 00 00       	push   $0xe02
f0114c89:	50                   	push   %eax
f0114c8a:	68 00 00 00 40       	push   $0x40000000
f0114c8f:	68 00 00 00 f0       	push   $0xf0000000
f0114c94:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c97:	e8 1d 63 ff ff       	call   f010afb9 <share_chunk>
f0114c9c:	83 c4 20             	add    $0x20,%esp
f0114c9f:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ca2:	e8 8d a1 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114ca7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0114caa:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0114cae:	75 1f                	jne    f0114ccf <test_share_chunk+0x273>
f0114cb0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cb3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cb6:	89 c1                	mov    %eax,%ecx
f0114cb8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cbb:	c1 e0 05             	shl    $0x5,%eax
f0114cbe:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114cc1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114cc8:	99                   	cltd   
f0114cc9:	f7 fb                	idiv   %ebx
f0114ccb:	39 c1                	cmp    %eax,%ecx
f0114ccd:	74 28                	je     f0114cf7 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114ccf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cd2:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cd5:	83 ec 0c             	sub    $0xc,%esp
f0114cd8:	50                   	push   %eax
f0114cd9:	ff 75 a8             	pushl  -0x58(%ebp)
f0114cdc:	68 c0 c7 12 f0       	push   $0xf012c7c0
f0114ce1:	68 3b 04 00 00       	push   $0x43b
f0114ce6:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114ceb:	e8 e6 b7 fe ff       	call   f01004d6 <_warn>
f0114cf0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114cf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114cf7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114cfb:	74 04                	je     f0114d01 <test_share_chunk+0x2a5>
f0114cfd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d01:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114d05:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114d0c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d0f:	c1 e0 05             	shl    $0x5,%eax
f0114d12:	83 ec 08             	sub    $0x8,%esp
f0114d15:	6a 02                	push   $0x2
f0114d17:	6a 07                	push   $0x7
f0114d19:	6a 03                	push   $0x3
f0114d1b:	68 07 0e 00 00       	push   $0xe07
f0114d20:	68 03 0e 00 00       	push   $0xe03
f0114d25:	6a ff                	push   $0xffffffff
f0114d27:	50                   	push   %eax
f0114d28:	68 00 00 00 40       	push   $0x40000000
f0114d2d:	68 00 00 00 f0       	push   $0xf0000000
f0114d32:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d35:	e8 78 28 00 00       	call   f01175b2 <CCP>
f0114d3a:	83 c4 30             	add    $0x30,%esp
f0114d3d:	85 c0                	test   %eax,%eax
f0114d3f:	75 25                	jne    f0114d66 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114d41:	83 ec 04             	sub    $0x4,%esp
f0114d44:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0114d49:	68 44 04 00 00       	push   $0x444
f0114d4e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114d53:	e8 7e b7 fe ff       	call   f01004d6 <_warn>
f0114d58:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114d5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114d5f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114d66:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d69:	89 d0                	mov    %edx,%eax
f0114d6b:	01 c0                	add    %eax,%eax
f0114d6d:	01 d0                	add    %edx,%eax
f0114d6f:	c1 e0 02             	shl    $0x2,%eax
f0114d72:	83 ec 08             	sub    $0x8,%esp
f0114d75:	6a 02                	push   $0x2
f0114d77:	6a 07                	push   $0x7
f0114d79:	6a 03                	push   $0x3
f0114d7b:	68 07 0e 00 00       	push   $0xe07
f0114d80:	68 03 0e 00 00       	push   $0xe03
f0114d85:	6a 02                	push   $0x2
f0114d87:	50                   	push   %eax
f0114d88:	68 00 00 00 40       	push   $0x40000000
f0114d8d:	68 00 00 00 f0       	push   $0xf0000000
f0114d92:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d95:	e8 18 28 00 00       	call   f01175b2 <CCP>
f0114d9a:	83 c4 30             	add    $0x30,%esp
f0114d9d:	85 c0                	test   %eax,%eax
f0114d9f:	75 1e                	jne    f0114dbf <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114da1:	83 ec 04             	sub    $0x4,%esp
f0114da4:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0114da9:	68 4b 04 00 00       	push   $0x44b
f0114dae:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114db3:	e8 1e b7 fe ff       	call   f01004d6 <_warn>
f0114db8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114dbb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114dbf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114dc3:	74 04                	je     f0114dc9 <test_share_chunk+0x36d>
f0114dc5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114dc9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0114dcd:	b8 b0 8a 76 f0       	mov    $0xf0768ab0,%eax
f0114dd2:	05 00 00 00 10       	add    $0x10000000,%eax
f0114dd7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114dda:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0114ddd:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0114de2:	83 ec 08             	sub    $0x8,%esp
f0114de5:	6a 02                	push   $0x2
f0114de7:	6a 07                	push   $0x7
f0114de9:	6a 03                	push   $0x3
f0114deb:	68 07 0e 00 00       	push   $0xe07
f0114df0:	68 03 0e 00 00       	push   $0xe03
f0114df5:	6a 02                	push   $0x2
f0114df7:	50                   	push   %eax
f0114df8:	68 00 00 0a 40       	push   $0x400a0000
f0114dfd:	68 00 00 0a f0       	push   $0xf00a0000
f0114e02:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e05:	e8 a8 27 00 00       	call   f01175b2 <CCP>
f0114e0a:	83 c4 30             	add    $0x30,%esp
f0114e0d:	85 c0                	test   %eax,%eax
f0114e0f:	75 1e                	jne    f0114e2f <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114e11:	83 ec 04             	sub    $0x4,%esp
f0114e14:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0114e19:	68 55 04 00 00       	push   $0x455
f0114e1e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114e23:	e8 ae b6 fe ff       	call   f01004d6 <_warn>
f0114e28:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114e2b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e2f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e33:	74 04                	je     f0114e39 <test_share_chunk+0x3dd>
f0114e35:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e39:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114e3d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114e41:	0f 84 a4 00 00 00    	je     f0114eeb <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114e47:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0114e4e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e51:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114e54:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f0114e5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e5e:	8a 00                	mov    (%eax),%al
f0114e60:	3c 41                	cmp    $0x41,%al
f0114e62:	75 09                	jne    f0114e6d <test_share_chunk+0x411>
f0114e64:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114e67:	8a 00                	mov    (%eax),%al
f0114e69:	3c 41                	cmp    $0x41,%al
f0114e6b:	74 1e                	je     f0114e8b <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114e6d:	83 ec 04             	sub    $0x4,%esp
f0114e70:	68 40 c7 12 f0       	push   $0xf012c740
f0114e75:	68 62 04 00 00       	push   $0x462
f0114e7a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114e7f:	e8 52 b6 fe ff       	call   f01004d6 <_warn>
f0114e84:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114e87:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114e8b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e8f:	74 04                	je     f0114e95 <test_share_chunk+0x439>
f0114e91:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114e95:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114e99:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114ea0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114ea3:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114ea6:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0114ead:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114eb0:	8a 00                	mov    (%eax),%al
f0114eb2:	3c 43                	cmp    $0x43,%al
f0114eb4:	75 09                	jne    f0114ebf <test_share_chunk+0x463>
f0114eb6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114eb9:	8a 00                	mov    (%eax),%al
f0114ebb:	3c 43                	cmp    $0x43,%al
f0114ebd:	74 1e                	je     f0114edd <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114ebf:	83 ec 04             	sub    $0x4,%esp
f0114ec2:	68 40 c7 12 f0       	push   $0xf012c740
f0114ec7:	68 6d 04 00 00       	push   $0x46d
f0114ecc:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114ed1:	e8 00 b6 fe ff       	call   f01004d6 <_warn>
f0114ed6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114ed9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114edd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ee1:	74 04                	je     f0114ee7 <test_share_chunk+0x48b>
f0114ee3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114ee7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114eeb:	83 ec 0c             	sub    $0xc,%esp
f0114eee:	68 4f bd 12 f0       	push   $0xf012bd4f
f0114ef3:	e8 93 c0 fe ff       	call   f0100f8b <cprintf>
f0114ef8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0114efb:	83 ec 0c             	sub    $0xc,%esp
f0114efe:	68 10 c8 12 f0       	push   $0xf012c810
f0114f03:	e8 83 c0 fe ff       	call   f0100f8b <cprintf>
f0114f08:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f0b:	e8 24 9f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114f10:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0114f13:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f16:	89 d0                	mov    %edx,%eax
f0114f18:	c1 e0 03             	shl    $0x3,%eax
f0114f1b:	01 d0                	add    %edx,%eax
f0114f1d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114f24:	01 d0                	add    %edx,%eax
f0114f26:	c1 e0 03             	shl    $0x3,%eax
f0114f29:	83 ec 0c             	sub    $0xc,%esp
f0114f2c:	6a 06                	push   $0x6
f0114f2e:	50                   	push   %eax
f0114f2f:	6a 00                	push   $0x0
f0114f31:	68 00 00 00 40       	push   $0x40000000
f0114f36:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f39:	e8 7b 60 ff ff       	call   f010afb9 <share_chunk>
f0114f3e:	83 c4 20             	add    $0x20,%esp
f0114f41:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f44:	e8 eb 9e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0114f49:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114f4c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114f50:	75 0b                	jne    f0114f5d <test_share_chunk+0x501>
f0114f52:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f55:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f58:	83 f8 01             	cmp    $0x1,%eax
f0114f5b:	74 28                	je     f0114f85 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114f5d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114f60:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114f63:	83 ec 0c             	sub    $0xc,%esp
f0114f66:	50                   	push   %eax
f0114f67:	ff 75 a0             	pushl  -0x60(%ebp)
f0114f6a:	68 c0 c7 12 f0       	push   $0xf012c7c0
f0114f6f:	68 83 04 00 00       	push   $0x483
f0114f74:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114f79:	e8 58 b5 fe ff       	call   f01004d6 <_warn>
f0114f7e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f81:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114f85:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f89:	74 04                	je     f0114f8f <test_share_chunk+0x533>
f0114f8b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114f8f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114f93:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114f9a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114f9d:	05 00 80 02 00       	add    $0x28000,%eax
f0114fa2:	c1 e0 02             	shl    $0x2,%eax
f0114fa5:	83 ec 08             	sub    $0x8,%esp
f0114fa8:	6a 02                	push   $0x2
f0114faa:	6a 07                	push   $0x7
f0114fac:	6a 03                	push   $0x3
f0114fae:	6a 07                	push   $0x7
f0114fb0:	6a 07                	push   $0x7
f0114fb2:	6a ff                	push   $0xffffffff
f0114fb4:	50                   	push   %eax
f0114fb5:	6a 00                	push   $0x0
f0114fb7:	68 00 00 00 40       	push   $0x40000000
f0114fbc:	ff 75 cc             	pushl  -0x34(%ebp)
f0114fbf:	e8 ee 25 00 00       	call   f01175b2 <CCP>
f0114fc4:	83 c4 30             	add    $0x30,%esp
f0114fc7:	85 c0                	test   %eax,%eax
f0114fc9:	75 25                	jne    f0114ff0 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114fcb:	83 ec 04             	sub    $0x4,%esp
f0114fce:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0114fd3:	68 8c 04 00 00       	push   $0x48c
f0114fd8:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0114fdd:	e8 f4 b4 fe ff       	call   f01004d6 <_warn>
f0114fe2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114fe5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114fe9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114ff0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ff3:	89 d0                	mov    %edx,%eax
f0114ff5:	01 c0                	add    %eax,%eax
f0114ff7:	01 d0                	add    %edx,%eax
f0114ff9:	c1 e0 02             	shl    $0x2,%eax
f0114ffc:	83 ec 08             	sub    $0x8,%esp
f0114fff:	6a 02                	push   $0x2
f0115001:	6a 07                	push   $0x7
f0115003:	6a 03                	push   $0x3
f0115005:	6a 07                	push   $0x7
f0115007:	6a 07                	push   $0x7
f0115009:	6a 03                	push   $0x3
f011500b:	50                   	push   %eax
f011500c:	6a 00                	push   $0x0
f011500e:	68 00 00 00 40       	push   $0x40000000
f0115013:	ff 75 cc             	pushl  -0x34(%ebp)
f0115016:	e8 97 25 00 00       	call   f01175b2 <CCP>
f011501b:	83 c4 30             	add    $0x30,%esp
f011501e:	85 c0                	test   %eax,%eax
f0115020:	75 1e                	jne    f0115040 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115022:	83 ec 04             	sub    $0x4,%esp
f0115025:	68 f8 c6 12 f0       	push   $0xf012c6f8
f011502a:	68 93 04 00 00       	push   $0x493
f011502f:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115034:	e8 9d b4 fe ff       	call   f01004d6 <_warn>
f0115039:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011503c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115040:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115044:	74 04                	je     f011504a <test_share_chunk+0x5ee>
f0115046:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011504a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011504e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115051:	89 d0                	mov    %edx,%eax
f0115053:	01 c0                	add    %eax,%eax
f0115055:	01 d0                	add    %edx,%eax
f0115057:	c1 e0 02             	shl    $0x2,%eax
f011505a:	f7 d8                	neg    %eax
f011505c:	05 00 00 0a 00       	add    $0xa0000,%eax
f0115061:	83 ec 08             	sub    $0x8,%esp
f0115064:	6a 02                	push   $0x2
f0115066:	6a 07                	push   $0x7
f0115068:	6a 03                	push   $0x3
f011506a:	6a 07                	push   $0x7
f011506c:	6a 07                	push   $0x7
f011506e:	6a 02                	push   $0x2
f0115070:	50                   	push   %eax
f0115071:	68 00 30 00 00       	push   $0x3000
f0115076:	68 00 30 00 40       	push   $0x40003000
f011507b:	ff 75 cc             	pushl  -0x34(%ebp)
f011507e:	e8 2f 25 00 00       	call   f01175b2 <CCP>
f0115083:	83 c4 30             	add    $0x30,%esp
f0115086:	85 c0                	test   %eax,%eax
f0115088:	75 1e                	jne    f01150a8 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011508a:	83 ec 04             	sub    $0x4,%esp
f011508d:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0115092:	68 9b 04 00 00       	push   $0x49b
f0115097:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011509c:	e8 35 b4 fe ff       	call   f01004d6 <_warn>
f01150a1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150a4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01150a8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01150ac:	74 04                	je     f01150b2 <test_share_chunk+0x656>
f01150ae:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01150b2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01150b6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01150b9:	c1 e0 02             	shl    $0x2,%eax
f01150bc:	83 ec 08             	sub    $0x8,%esp
f01150bf:	6a 02                	push   $0x2
f01150c1:	6a 07                	push   $0x7
f01150c3:	6a 03                	push   $0x3
f01150c5:	6a 07                	push   $0x7
f01150c7:	6a 07                	push   $0x7
f01150c9:	6a 03                	push   $0x3
f01150cb:	50                   	push   %eax
f01150cc:	68 00 00 0a 00       	push   $0xa0000
f01150d1:	68 00 00 0a 40       	push   $0x400a0000
f01150d6:	ff 75 cc             	pushl  -0x34(%ebp)
f01150d9:	e8 d4 24 00 00       	call   f01175b2 <CCP>
f01150de:	83 c4 30             	add    $0x30,%esp
f01150e1:	85 c0                	test   %eax,%eax
f01150e3:	75 1e                	jne    f0115103 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01150e5:	83 ec 04             	sub    $0x4,%esp
f01150e8:	68 f8 c6 12 f0       	push   $0xf012c6f8
f01150ed:	68 a3 04 00 00       	push   $0x4a3
f01150f2:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01150f7:	e8 da b3 fe ff       	call   f01004d6 <_warn>
f01150fc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150ff:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115103:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115107:	74 04                	je     f011510d <test_share_chunk+0x6b1>
f0115109:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011510d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0115111:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0115115:	0f 84 92 00 00 00    	je     f01151ad <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f011511b:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0115122:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0115129:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0115130:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0115137:	8b 45 98             	mov    -0x68(%ebp),%eax
f011513a:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f011513d:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0115144:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011514b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011514e:	8a 00                	mov    (%eax),%al
f0115150:	3c 41                	cmp    $0x41,%al
f0115152:	75 2d                	jne    f0115181 <test_share_chunk+0x725>
f0115154:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0115157:	8a 00                	mov    (%eax),%al
f0115159:	3c 41                	cmp    $0x41,%al
f011515b:	75 24                	jne    f0115181 <test_share_chunk+0x725>
f011515d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0115160:	8a 00                	mov    (%eax),%al
f0115162:	3c 41                	cmp    $0x41,%al
f0115164:	75 1b                	jne    f0115181 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0115166:	8b 45 98             	mov    -0x68(%ebp),%eax
f0115169:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011516b:	3c 44                	cmp    $0x44,%al
f011516d:	75 12                	jne    f0115181 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011516f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0115172:	8a 00                	mov    (%eax),%al
f0115174:	3c 44                	cmp    $0x44,%al
f0115176:	75 09                	jne    f0115181 <test_share_chunk+0x725>
f0115178:	8b 45 90             	mov    -0x70(%ebp),%eax
f011517b:	8a 00                	mov    (%eax),%al
f011517d:	3c 44                	cmp    $0x44,%al
f011517f:	74 1e                	je     f011519f <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115181:	83 ec 04             	sub    $0x4,%esp
f0115184:	68 40 c7 12 f0       	push   $0xf012c740
f0115189:	68 b5 04 00 00       	push   $0x4b5
f011518e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115193:	e8 3e b3 fe ff       	call   f01004d6 <_warn>
f0115198:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011519b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011519f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01151a3:	74 04                	je     f01151a9 <test_share_chunk+0x74d>
f01151a5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01151a9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01151ad:	83 ec 0c             	sub    $0xc,%esp
f01151b0:	68 b2 bd 12 f0       	push   $0xf012bdb2
f01151b5:	e8 d1 bd fe ff       	call   f0100f8b <cprintf>
f01151ba:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f01151bd:	83 ec 0c             	sub    $0xc,%esp
f01151c0:	68 4c c8 12 f0       	push   $0xf012c84c
f01151c5:	e8 c1 bd fe ff       	call   f0100f8b <cprintf>
f01151ca:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01151cd:	e8 62 9c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01151d2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f01151d5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151d8:	89 d0                	mov    %edx,%eax
f01151da:	01 c0                	add    %eax,%eax
f01151dc:	01 d0                	add    %edx,%eax
f01151de:	01 c0                	add    %eax,%eax
f01151e0:	01 d0                	add    %edx,%eax
f01151e2:	83 ec 0c             	sub    $0xc,%esp
f01151e5:	6a 04                	push   $0x4
f01151e7:	50                   	push   %eax
f01151e8:	68 00 fc 3f 00       	push   $0x3ffc00
f01151ed:	68 00 fc 09 00       	push   $0x9fc00
f01151f2:	ff 75 cc             	pushl  -0x34(%ebp)
f01151f5:	e8 bf 5d ff ff       	call   f010afb9 <share_chunk>
f01151fa:	83 c4 20             	add    $0x20,%esp
f01151fd:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115200:	e8 2f 9c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115205:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0115208:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011520c:	75 0b                	jne    f0115219 <test_share_chunk+0x7bd>
f011520e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115211:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115214:	83 f8 01             	cmp    $0x1,%eax
f0115217:	74 28                	je     f0115241 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0115219:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011521c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011521f:	83 ec 0c             	sub    $0xc,%esp
f0115222:	50                   	push   %eax
f0115223:	ff 75 8c             	pushl  -0x74(%ebp)
f0115226:	68 c0 c7 12 f0       	push   $0xf012c7c0
f011522b:	68 cb 04 00 00       	push   $0x4cb
f0115230:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115235:	e8 9c b2 fe ff       	call   f01004d6 <_warn>
f011523a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011523d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115241:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115245:	74 04                	je     f011524b <test_share_chunk+0x7ef>
f0115247:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011524b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011524f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0115256:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115259:	89 d0                	mov    %edx,%eax
f011525b:	01 c0                	add    %eax,%eax
f011525d:	01 d0                	add    %edx,%eax
f011525f:	c1 e0 02             	shl    $0x2,%eax
f0115262:	83 ec 08             	sub    $0x8,%esp
f0115265:	6a 02                	push   $0x2
f0115267:	6a 07                	push   $0x7
f0115269:	6a 07                	push   $0x7
f011526b:	6a 07                	push   $0x7
f011526d:	6a 05                	push   $0x5
f011526f:	6a ff                	push   $0xffffffff
f0115271:	50                   	push   %eax
f0115272:	68 00 f0 3f 00       	push   $0x3ff000
f0115277:	68 00 f0 09 00       	push   $0x9f000
f011527c:	ff 75 cc             	pushl  -0x34(%ebp)
f011527f:	e8 2e 23 00 00       	call   f01175b2 <CCP>
f0115284:	83 c4 30             	add    $0x30,%esp
f0115287:	85 c0                	test   %eax,%eax
f0115289:	75 25                	jne    f01152b0 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011528b:	83 ec 04             	sub    $0x4,%esp
f011528e:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0115293:	68 d4 04 00 00       	push   $0x4d4
f0115298:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011529d:	e8 34 b2 fe ff       	call   f01004d6 <_warn>
f01152a2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01152a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01152a9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01152b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152b4:	74 04                	je     f01152ba <test_share_chunk+0x85e>
f01152b6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152ba:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01152be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01152c1:	c1 e0 02             	shl    $0x2,%eax
f01152c4:	83 ec 08             	sub    $0x8,%esp
f01152c7:	6a 02                	push   $0x2
f01152c9:	6a 07                	push   $0x7
f01152cb:	6a 07                	push   $0x7
f01152cd:	6a 07                	push   $0x7
f01152cf:	6a 05                	push   $0x5
f01152d1:	6a 03                	push   $0x3
f01152d3:	50                   	push   %eax
f01152d4:	68 00 f0 3f 00       	push   $0x3ff000
f01152d9:	68 00 f0 09 00       	push   $0x9f000
f01152de:	ff 75 cc             	pushl  -0x34(%ebp)
f01152e1:	e8 cc 22 00 00       	call   f01175b2 <CCP>
f01152e6:	83 c4 30             	add    $0x30,%esp
f01152e9:	85 c0                	test   %eax,%eax
f01152eb:	75 1e                	jne    f011530b <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01152ed:	83 ec 04             	sub    $0x4,%esp
f01152f0:	68 f8 c6 12 f0       	push   $0xf012c6f8
f01152f5:	68 dd 04 00 00       	push   $0x4dd
f01152fa:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01152ff:	e8 d2 b1 fe ff       	call   f01004d6 <_warn>
f0115304:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115307:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011530b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011530f:	74 04                	je     f0115315 <test_share_chunk+0x8b9>
f0115311:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115315:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0115319:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011531c:	c1 e0 03             	shl    $0x3,%eax
f011531f:	83 ec 08             	sub    $0x8,%esp
f0115322:	6a 02                	push   $0x2
f0115324:	6a 07                	push   $0x7
f0115326:	6a 07                	push   $0x7
f0115328:	6a 07                	push   $0x7
f011532a:	6a 05                	push   $0x5
f011532c:	6a 04                	push   $0x4
f011532e:	50                   	push   %eax
f011532f:	68 00 00 40 00       	push   $0x400000
f0115334:	68 00 00 0a 00       	push   $0xa0000
f0115339:	ff 75 cc             	pushl  -0x34(%ebp)
f011533c:	e8 71 22 00 00       	call   f01175b2 <CCP>
f0115341:	83 c4 30             	add    $0x30,%esp
f0115344:	85 c0                	test   %eax,%eax
f0115346:	75 1e                	jne    f0115366 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0115348:	83 ec 04             	sub    $0x4,%esp
f011534b:	68 f8 c6 12 f0       	push   $0xf012c6f8
f0115350:	68 e5 04 00 00       	push   $0x4e5
f0115355:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011535a:	e8 77 b1 fe ff       	call   f01004d6 <_warn>
f011535f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115362:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115366:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011536a:	74 04                	je     f0115370 <test_share_chunk+0x914>
f011536c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115370:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0115374:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115378:	0f 84 b2 00 00 00    	je     f0115430 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f011537e:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0115385:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f011538c:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0115393:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f011539a:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01153a1:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01153a8:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01153af:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01153b6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01153b9:	8a 00                	mov    (%eax),%al
f01153bb:	3c 44                	cmp    $0x44,%al
f01153bd:	75 45                	jne    f0115404 <test_share_chunk+0x9a8>
f01153bf:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01153c2:	8a 00                	mov    (%eax),%al
f01153c4:	3c 44                	cmp    $0x44,%al
f01153c6:	75 3c                	jne    f0115404 <test_share_chunk+0x9a8>
f01153c8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01153cb:	8a 00                	mov    (%eax),%al
f01153cd:	3c 44                	cmp    $0x44,%al
f01153cf:	75 33                	jne    f0115404 <test_share_chunk+0x9a8>
f01153d1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01153d4:	8a 00                	mov    (%eax),%al
f01153d6:	3c 44                	cmp    $0x44,%al
f01153d8:	75 2a                	jne    f0115404 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01153da:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01153dd:	8a 10                	mov    (%eax),%dl
f01153df:	8b 45 90             	mov    -0x70(%ebp),%eax
f01153e2:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01153e4:	38 c2                	cmp    %al,%dl
f01153e6:	75 1c                	jne    f0115404 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01153e8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01153eb:	8a 10                	mov    (%eax),%dl
f01153ed:	8b 45 88             	mov    -0x78(%ebp),%eax
f01153f0:	8a 00                	mov    (%eax),%al
f01153f2:	38 c2                	cmp    %al,%dl
f01153f4:	75 0e                	jne    f0115404 <test_share_chunk+0x9a8>
f01153f6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01153f9:	8a 10                	mov    (%eax),%dl
f01153fb:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01153fe:	8a 00                	mov    (%eax),%al
f0115400:	38 c2                	cmp    %al,%dl
f0115402:	74 1e                	je     f0115422 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0115404:	83 ec 04             	sub    $0x4,%esp
f0115407:	68 40 c7 12 f0       	push   $0xf012c740
f011540c:	68 fa 04 00 00       	push   $0x4fa
f0115411:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115416:	e8 bb b0 fe ff       	call   f01004d6 <_warn>
f011541b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011541e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0115422:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115426:	74 04                	je     f011542c <test_share_chunk+0x9d0>
f0115428:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011542c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0115430:	83 ec 0c             	sub    $0xc,%esp
f0115433:	68 84 c8 12 f0       	push   $0xf012c884
f0115438:	e8 4e bb fe ff       	call   f0100f8b <cprintf>
f011543d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0115440:	83 ec 08             	sub    $0x8,%esp
f0115443:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115446:	68 94 c8 12 f0       	push   $0xf012c894
f011544b:	e8 3b bb fe ff       	call   f0100f8b <cprintf>
f0115450:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115453:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115457:	75 10                	jne    f0115469 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0115459:	83 ec 0c             	sub    $0xc,%esp
f011545c:	68 c4 c8 12 f0       	push   $0xf012c8c4
f0115461:	e8 25 bb fe ff       	call   f0100f8b <cprintf>
f0115466:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115469:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f011546e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115471:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115474:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115477:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011547c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011547f:	5b                   	pop    %ebx
f0115480:	5e                   	pop    %esi
f0115481:	5f                   	pop    %edi
f0115482:	5d                   	pop    %ebp
f0115483:	c3                   	ret    

f0115484 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0115484:	55                   	push   %ebp
f0115485:	89 e5                	mov    %esp,%ebp
f0115487:	57                   	push   %edi
f0115488:	56                   	push   %esi
f0115489:	53                   	push   %ebx
f011548a:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115490:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0115496:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f011549b:	ba 0f 00 00 00       	mov    $0xf,%edx
f01154a0:	89 c7                	mov    %eax,%edi
f01154a2:	89 de                	mov    %ebx,%esi
f01154a4:	89 d1                	mov    %edx,%ecx
f01154a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01154a8:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01154ae:	b9 23 00 00 00       	mov    $0x23,%ecx
f01154b3:	b0 00                	mov    $0x0,%al
f01154b5:	89 d7                	mov    %edx,%edi
f01154b7:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01154b9:	6a 00                	push   $0x0
f01154bb:	6a 0a                	push   $0xa
f01154bd:	6a 14                	push   $0x14
f01154bf:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01154c5:	50                   	push   %eax
f01154c6:	e8 fb 5f ff ff       	call   f010b4c6 <env_create>
f01154cb:	83 c4 10             	add    $0x10,%esp
f01154ce:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01154d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01154d4:	8b 40 64             	mov    0x64(%eax),%eax
f01154d7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f01154da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01154dd:	8b 40 68             	mov    0x68(%eax),%eax
f01154e0:	89 45 90             	mov    %eax,-0x70(%ebp)
f01154e3:	8b 45 90             	mov    -0x70(%ebp),%eax
f01154e6:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01154e9:	83 ec 0c             	sub    $0xc,%esp
f01154ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01154ef:	e8 8a 20 00 00       	call   f011757e <ClearUserSpace>
f01154f4:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01154f7:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01154fe:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0115505:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011550c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0115510:	83 ec 0c             	sub    $0xc,%esp
f0115513:	68 00 c9 12 f0       	push   $0xf012c900
f0115518:	e8 6e ba fe ff       	call   f0100f8b <cprintf>
f011551d:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0115520:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0115527:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011552e:	eb 03                	jmp    f0115533 <test_allocate_chunk+0xaf>
f0115530:	ff 4d e4             	decl   -0x1c(%ebp)
f0115533:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011553a:	76 09                	jbe    f0115545 <test_allocate_chunk+0xc1>
f011553c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011553f:	8a 00                	mov    (%eax),%al
f0115541:	84 c0                	test   %al,%al
f0115543:	74 eb                	je     f0115530 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0115545:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011554c:	75 06                	jne    f0115554 <test_allocate_chunk+0xd0>
f011554e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115551:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0115554:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115557:	8a 00                	mov    (%eax),%al
f0115559:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f011555f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115562:	8a 00                	mov    (%eax),%al
f0115564:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011556a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011556d:	8a 00                	mov    (%eax),%al
f011556f:	0f be c0             	movsbl %al,%eax
f0115572:	83 ec 08             	sub    $0x8,%esp
f0115575:	50                   	push   %eax
f0115576:	68 2a c9 12 f0       	push   $0xf012c92a
f011557b:	e8 0b ba fe ff       	call   f0100f8b <cprintf>
f0115580:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0115583:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115586:	8a 00                	mov    (%eax),%al
f0115588:	0f be c0             	movsbl %al,%eax
f011558b:	83 ec 08             	sub    $0x8,%esp
f011558e:	50                   	push   %eax
f011558f:	68 36 c9 12 f0       	push   $0xf012c936
f0115594:	e8 f2 b9 fe ff       	call   f0100f8b <cprintf>
f0115599:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f011559c:	83 ec 08             	sub    $0x8,%esp
f011559f:	68 00 f0 bf ef       	push   $0xefbff000
f01155a4:	ff 75 cc             	pushl  -0x34(%ebp)
f01155a7:	e8 b3 1f 00 00       	call   f011755f <GP>
f01155ac:	83 c4 10             	add    $0x10,%esp
f01155af:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01155b2:	e8 7d 98 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01155b7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f01155ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01155bd:	c1 e0 02             	shl    $0x2,%eax
f01155c0:	6a 02                	push   $0x2
f01155c2:	50                   	push   %eax
f01155c3:	68 00 f0 bf ef       	push   $0xefbff000
f01155c8:	ff 75 cc             	pushl  -0x34(%ebp)
f01155cb:	e8 03 5a ff ff       	call   f010afd3 <allocate_chunk>
f01155d0:	83 c4 10             	add    $0x10,%esp
f01155d3:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01155d6:	e8 59 98 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01155db:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01155de:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01155e2:	75 08                	jne    f01155ec <test_allocate_chunk+0x168>
f01155e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01155e7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01155ea:	74 2a                	je     f0115616 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01155ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01155ef:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01155f2:	83 ec 08             	sub    $0x8,%esp
f01155f5:	6a 00                	push   $0x0
f01155f7:	50                   	push   %eax
f01155f8:	ff 75 b0             	pushl  -0x50(%ebp)
f01155fb:	68 44 c9 12 f0       	push   $0xf012c944
f0115600:	68 3a 05 00 00       	push   $0x53a
f0115605:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011560a:	e8 c7 ae fe ff       	call   f01004d6 <_warn>
f011560f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115612:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115616:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011561a:	74 04                	je     f0115620 <test_allocate_chunk+0x19c>
f011561c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115620:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115624:	e8 0b 98 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115629:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011562c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011562f:	01 c0                	add    %eax,%eax
f0115631:	89 c1                	mov    %eax,%ecx
f0115633:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115636:	89 d0                	mov    %edx,%eax
f0115638:	c1 e0 02             	shl    $0x2,%eax
f011563b:	01 d0                	add    %edx,%eax
f011563d:	f7 d8                	neg    %eax
f011563f:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0115644:	6a 02                	push   $0x2
f0115646:	51                   	push   %ecx
f0115647:	50                   	push   %eax
f0115648:	ff 75 cc             	pushl  -0x34(%ebp)
f011564b:	e8 83 59 ff ff       	call   f010afd3 <allocate_chunk>
f0115650:	83 c4 10             	add    $0x10,%esp
f0115653:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115656:	e8 d9 97 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011565b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011565e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115662:	75 08                	jne    f011566c <test_allocate_chunk+0x1e8>
f0115664:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115667:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011566a:	74 2a                	je     f0115696 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011566c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011566f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115672:	83 ec 08             	sub    $0x8,%esp
f0115675:	6a 00                	push   $0x0
f0115677:	50                   	push   %eax
f0115678:	ff 75 b0             	pushl  -0x50(%ebp)
f011567b:	68 44 c9 12 f0       	push   $0xf012c944
f0115680:	68 48 05 00 00       	push   $0x548
f0115685:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011568a:	e8 47 ae fe ff       	call   f01004d6 <_warn>
f011568f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115692:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115696:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011569a:	74 04                	je     f01156a0 <test_allocate_chunk+0x21c>
f011569c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01156a0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01156a4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01156a7:	c1 e0 02             	shl    $0x2,%eax
f01156aa:	83 ec 08             	sub    $0x8,%esp
f01156ad:	6a 03                	push   $0x3
f01156af:	6a 00                	push   $0x0
f01156b1:	6a 00                	push   $0x0
f01156b3:	68 ff 0f 00 00       	push   $0xfff
f01156b8:	ff 75 b8             	pushl  -0x48(%ebp)
f01156bb:	6a 01                	push   $0x1
f01156bd:	50                   	push   %eax
f01156be:	68 00 f0 bf ef       	push   $0xefbff000
f01156c3:	6a 00                	push   $0x0
f01156c5:	ff 75 cc             	pushl  -0x34(%ebp)
f01156c8:	e8 e5 1e 00 00       	call   f01175b2 <CCP>
f01156cd:	83 c4 30             	add    $0x30,%esp
f01156d0:	85 c0                	test   %eax,%eax
f01156d2:	75 1e                	jne    f01156f2 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01156d4:	83 ec 04             	sub    $0x4,%esp
f01156d7:	68 ac c9 12 f0       	push   $0xf012c9ac
f01156dc:	68 50 05 00 00       	push   $0x550
f01156e1:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01156e6:	e8 eb ad fe ff       	call   f01004d6 <_warn>
f01156eb:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01156ee:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01156f2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01156f6:	74 04                	je     f01156fc <test_allocate_chunk+0x278>
f01156f8:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01156fc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0115700:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115703:	8a 10                	mov    (%eax),%dl
f0115705:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011570b:	38 c2                	cmp    %al,%dl
f011570d:	75 0f                	jne    f011571e <test_allocate_chunk+0x29a>
f011570f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115712:	8a 10                	mov    (%eax),%dl
f0115714:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f011571a:	38 c2                	cmp    %al,%dl
f011571c:	74 1e                	je     f011573c <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011571e:	83 ec 04             	sub    $0x4,%esp
f0115721:	68 f8 c9 12 f0       	push   $0xf012c9f8
f0115726:	68 58 05 00 00       	push   $0x558
f011572b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115730:	e8 a1 ad fe ff       	call   f01004d6 <_warn>
f0115735:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115738:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011573c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115740:	74 04                	je     f0115746 <test_allocate_chunk+0x2c2>
f0115742:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115746:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011574a:	83 ec 0c             	sub    $0xc,%esp
f011574d:	68 75 c7 12 f0       	push   $0xf012c775
f0115752:	e8 34 b8 fe ff       	call   f0100f8b <cprintf>
f0115757:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011575a:	83 ec 0c             	sub    $0xc,%esp
f011575d:	68 30 ca 12 f0       	push   $0xf012ca30
f0115762:	e8 24 b8 fe ff       	call   f0100f8b <cprintf>
f0115767:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011576a:	e8 c5 96 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011576f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115772:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115775:	c1 e0 05             	shl    $0x5,%eax
f0115778:	68 02 0e 00 00       	push   $0xe02
f011577d:	50                   	push   %eax
f011577e:	6a 00                	push   $0x0
f0115780:	ff 75 cc             	pushl  -0x34(%ebp)
f0115783:	e8 4b 58 ff ff       	call   f010afd3 <allocate_chunk>
f0115788:	83 c4 10             	add    $0x10,%esp
f011578b:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011578e:	e8 a1 96 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115793:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0115796:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011579a:	75 36                	jne    f01157d2 <test_allocate_chunk+0x34e>
f011579c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011579f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01157a2:	89 c1                	mov    %eax,%ecx
f01157a4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157a7:	c1 e0 05             	shl    $0x5,%eax
f01157aa:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01157ad:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01157b4:	99                   	cltd   
f01157b5:	f7 fe                	idiv   %esi
f01157b7:	89 c3                	mov    %eax,%ebx
f01157b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157bc:	c1 e0 05             	shl    $0x5,%eax
f01157bf:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01157c2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01157c9:	99                   	cltd   
f01157ca:	f7 fe                	idiv   %esi
f01157cc:	01 d8                	add    %ebx,%eax
f01157ce:	39 c1                	cmp    %eax,%ecx
f01157d0:	74 54                	je     f0115826 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f01157d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157d5:	c1 e0 05             	shl    $0x5,%eax
f01157d8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01157db:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01157e2:	99                   	cltd   
f01157e3:	f7 ff                	idiv   %edi
f01157e5:	89 c1                	mov    %eax,%ecx
f01157e7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157ea:	c1 e0 05             	shl    $0x5,%eax
f01157ed:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01157f0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01157f7:	99                   	cltd   
f01157f8:	f7 fe                	idiv   %esi
f01157fa:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01157fd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115800:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115803:	83 ec 08             	sub    $0x8,%esp
f0115806:	52                   	push   %edx
f0115807:	50                   	push   %eax
f0115808:	ff 75 a8             	pushl  -0x58(%ebp)
f011580b:	68 70 ca 12 f0       	push   $0xf012ca70
f0115810:	68 6d 05 00 00       	push   $0x56d
f0115815:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011581a:	e8 b7 ac fe ff       	call   f01004d6 <_warn>
f011581f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115822:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115826:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011582a:	74 04                	je     f0115830 <test_allocate_chunk+0x3ac>
f011582c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115830:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115834:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011583b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011583e:	c1 e0 05             	shl    $0x5,%eax
f0115841:	83 ec 08             	sub    $0x8,%esp
f0115844:	6a 03                	push   $0x3
f0115846:	6a 00                	push   $0x0
f0115848:	6a 00                	push   $0x0
f011584a:	68 07 0e 00 00       	push   $0xe07
f011584f:	68 03 0e 00 00       	push   $0xe03
f0115854:	6a 01                	push   $0x1
f0115856:	50                   	push   %eax
f0115857:	6a 00                	push   $0x0
f0115859:	6a 00                	push   $0x0
f011585b:	ff 75 cc             	pushl  -0x34(%ebp)
f011585e:	e8 4f 1d 00 00       	call   f01175b2 <CCP>
f0115863:	83 c4 30             	add    $0x30,%esp
f0115866:	85 c0                	test   %eax,%eax
f0115868:	75 25                	jne    f011588f <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011586a:	83 ec 04             	sub    $0x4,%esp
f011586d:	68 ac c9 12 f0       	push   $0xf012c9ac
f0115872:	68 76 05 00 00       	push   $0x576
f0115877:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011587c:	e8 55 ac fe ff       	call   f01004d6 <_warn>
f0115881:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115884:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115888:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f011588f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115893:	74 04                	je     f0115899 <test_allocate_chunk+0x415>
f0115895:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115899:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011589d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01158a1:	74 5a                	je     f01158fd <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f01158a3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01158a6:	01 c0                	add    %eax,%eax
f01158a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01158ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01158ae:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f01158b1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01158b4:	01 c0                	add    %eax,%eax
f01158b6:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01158b9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01158bc:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01158bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01158c2:	8a 00                	mov    (%eax),%al
f01158c4:	3c 4b                	cmp    $0x4b,%al
f01158c6:	75 09                	jne    f01158d1 <test_allocate_chunk+0x44d>
f01158c8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01158cb:	8a 00                	mov    (%eax),%al
f01158cd:	3c 4d                	cmp    $0x4d,%al
f01158cf:	74 1e                	je     f01158ef <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01158d1:	83 ec 04             	sub    $0x4,%esp
f01158d4:	68 f8 c9 12 f0       	push   $0xf012c9f8
f01158d9:	68 84 05 00 00       	push   $0x584
f01158de:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01158e3:	e8 ee ab fe ff       	call   f01004d6 <_warn>
f01158e8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01158eb:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01158ef:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01158f3:	74 04                	je     f01158f9 <test_allocate_chunk+0x475>
f01158f5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01158f9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01158fd:	83 ec 0c             	sub    $0xc,%esp
f0115900:	68 4f bd 12 f0       	push   $0xf012bd4f
f0115905:	e8 81 b6 fe ff       	call   f0100f8b <cprintf>
f011590a:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f011590d:	83 ec 0c             	sub    $0xc,%esp
f0115910:	68 d0 ca 12 f0       	push   $0xf012cad0
f0115915:	e8 71 b6 fe ff       	call   f0100f8b <cprintf>
f011591a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011591d:	e8 12 95 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115922:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0115925:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115928:	c1 e0 06             	shl    $0x6,%eax
f011592b:	89 c2                	mov    %eax,%edx
f011592d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115930:	c1 e0 05             	shl    $0x5,%eax
f0115933:	6a 00                	push   $0x0
f0115935:	52                   	push   %edx
f0115936:	50                   	push   %eax
f0115937:	ff 75 cc             	pushl  -0x34(%ebp)
f011593a:	e8 94 56 ff ff       	call   f010afd3 <allocate_chunk>
f011593f:	83 c4 10             	add    $0x10,%esp
f0115942:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115945:	e8 ea 94 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011594a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011594d:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0115951:	75 36                	jne    f0115989 <test_allocate_chunk+0x505>
f0115953:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115956:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115959:	89 c1                	mov    %eax,%ecx
f011595b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011595e:	c1 e0 06             	shl    $0x6,%eax
f0115961:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115964:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011596b:	99                   	cltd   
f011596c:	f7 ff                	idiv   %edi
f011596e:	89 c3                	mov    %eax,%ebx
f0115970:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115973:	c1 e0 06             	shl    $0x6,%eax
f0115976:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115979:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115980:	99                   	cltd   
f0115981:	f7 fe                	idiv   %esi
f0115983:	01 d8                	add    %ebx,%eax
f0115985:	39 c1                	cmp    %eax,%ecx
f0115987:	74 54                	je     f01159dd <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115989:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011598c:	c1 e0 06             	shl    $0x6,%eax
f011598f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115992:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115999:	99                   	cltd   
f011599a:	f7 fb                	idiv   %ebx
f011599c:	89 c1                	mov    %eax,%ecx
f011599e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01159a1:	c1 e0 06             	shl    $0x6,%eax
f01159a4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01159a7:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01159ae:	99                   	cltd   
f01159af:	f7 ff                	idiv   %edi
f01159b1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01159b4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01159b7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01159ba:	83 ec 08             	sub    $0x8,%esp
f01159bd:	52                   	push   %edx
f01159be:	50                   	push   %eax
f01159bf:	ff 75 a4             	pushl  -0x5c(%ebp)
f01159c2:	68 70 ca 12 f0       	push   $0xf012ca70
f01159c7:	68 9a 05 00 00       	push   $0x59a
f01159cc:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01159d1:	e8 00 ab fe ff       	call   f01004d6 <_warn>
f01159d6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01159dd:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01159e1:	74 04                	je     f01159e7 <test_allocate_chunk+0x563>
f01159e3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01159e7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01159eb:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01159f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01159f5:	c1 e0 06             	shl    $0x6,%eax
f01159f8:	89 c2                	mov    %eax,%edx
f01159fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01159fd:	c1 e0 05             	shl    $0x5,%eax
f0115a00:	83 ec 08             	sub    $0x8,%esp
f0115a03:	6a 03                	push   $0x3
f0115a05:	6a 00                	push   $0x0
f0115a07:	6a 00                	push   $0x0
f0115a09:	68 07 0e 00 00       	push   $0xe07
f0115a0e:	6a 01                	push   $0x1
f0115a10:	6a 01                	push   $0x1
f0115a12:	52                   	push   %edx
f0115a13:	50                   	push   %eax
f0115a14:	6a 00                	push   $0x0
f0115a16:	ff 75 cc             	pushl  -0x34(%ebp)
f0115a19:	e8 94 1b 00 00       	call   f01175b2 <CCP>
f0115a1e:	83 c4 30             	add    $0x30,%esp
f0115a21:	85 c0                	test   %eax,%eax
f0115a23:	75 25                	jne    f0115a4a <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115a25:	83 ec 04             	sub    $0x4,%esp
f0115a28:	68 ac c9 12 f0       	push   $0xf012c9ac
f0115a2d:	68 a3 05 00 00       	push   $0x5a3
f0115a32:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115a37:	e8 9a aa fe ff       	call   f01004d6 <_warn>
f0115a3c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115a3f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115a43:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0115a4a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115a4e:	74 04                	je     f0115a54 <test_allocate_chunk+0x5d0>
f0115a50:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115a54:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0115a58:	83 ec 0c             	sub    $0xc,%esp
f0115a5b:	68 b2 bd 12 f0       	push   $0xf012bdb2
f0115a60:	e8 26 b5 fe ff       	call   f0100f8b <cprintf>
f0115a65:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0115a68:	83 ec 0c             	sub    $0xc,%esp
f0115a6b:	68 10 cb 12 f0       	push   $0xf012cb10
f0115a70:	e8 16 b5 fe ff       	call   f0100f8b <cprintf>
f0115a75:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115a78:	e8 b7 93 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115a7d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0115a80:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115a83:	c1 e0 06             	shl    $0x6,%eax
f0115a86:	68 06 0e 00 00       	push   $0xe06
f0115a8b:	50                   	push   %eax
f0115a8c:	68 00 00 00 80       	push   $0x80000000
f0115a91:	ff 75 cc             	pushl  -0x34(%ebp)
f0115a94:	e8 3a 55 ff ff       	call   f010afd3 <allocate_chunk>
f0115a99:	83 c4 10             	add    $0x10,%esp
f0115a9c:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115a9f:	e8 90 93 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115aa4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0115aa7:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0115aab:	75 36                	jne    f0115ae3 <test_allocate_chunk+0x65f>
f0115aad:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115ab0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115ab3:	89 c1                	mov    %eax,%ecx
f0115ab5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115ab8:	c1 e0 06             	shl    $0x6,%eax
f0115abb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115abe:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115ac5:	99                   	cltd   
f0115ac6:	f7 fb                	idiv   %ebx
f0115ac8:	89 c3                	mov    %eax,%ebx
f0115aca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115acd:	c1 e0 06             	shl    $0x6,%eax
f0115ad0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115ad3:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115ada:	99                   	cltd   
f0115adb:	f7 fe                	idiv   %esi
f0115add:	01 d8                	add    %ebx,%eax
f0115adf:	39 c1                	cmp    %eax,%ecx
f0115ae1:	74 54                	je     f0115b37 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0115ae3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115ae6:	c1 e0 06             	shl    $0x6,%eax
f0115ae9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115aec:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0115af3:	99                   	cltd   
f0115af4:	f7 ff                	idiv   %edi
f0115af6:	89 c1                	mov    %eax,%ecx
f0115af8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115afb:	c1 e0 06             	shl    $0x6,%eax
f0115afe:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115b01:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115b08:	99                   	cltd   
f0115b09:	f7 fb                	idiv   %ebx
f0115b0b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115b0e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115b11:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115b14:	83 ec 08             	sub    $0x8,%esp
f0115b17:	52                   	push   %edx
f0115b18:	50                   	push   %eax
f0115b19:	ff 75 9c             	pushl  -0x64(%ebp)
f0115b1c:	68 70 ca 12 f0       	push   $0xf012ca70
f0115b21:	68 b9 05 00 00       	push   $0x5b9
f0115b26:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115b2b:	e8 a6 a9 fe ff       	call   f01004d6 <_warn>
f0115b30:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b33:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0115b37:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115b3b:	74 04                	je     f0115b41 <test_allocate_chunk+0x6bd>
f0115b3d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115b41:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115b45:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0115b4c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115b4f:	c1 e0 06             	shl    $0x6,%eax
f0115b52:	83 ec 08             	sub    $0x8,%esp
f0115b55:	6a 03                	push   $0x3
f0115b57:	6a 00                	push   $0x0
f0115b59:	6a 00                	push   $0x0
f0115b5b:	68 07 0e 00 00       	push   $0xe07
f0115b60:	68 07 0e 00 00       	push   $0xe07
f0115b65:	6a 01                	push   $0x1
f0115b67:	50                   	push   %eax
f0115b68:	68 00 00 00 80       	push   $0x80000000
f0115b6d:	6a 00                	push   $0x0
f0115b6f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115b72:	e8 3b 1a 00 00       	call   f01175b2 <CCP>
f0115b77:	83 c4 30             	add    $0x30,%esp
f0115b7a:	85 c0                	test   %eax,%eax
f0115b7c:	75 25                	jne    f0115ba3 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115b7e:	83 ec 04             	sub    $0x4,%esp
f0115b81:	68 ac c9 12 f0       	push   $0xf012c9ac
f0115b86:	68 c2 05 00 00       	push   $0x5c2
f0115b8b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115b90:	e8 41 a9 fe ff       	call   f01004d6 <_warn>
f0115b95:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115b98:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115b9c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115ba3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115ba7:	74 04                	je     f0115bad <test_allocate_chunk+0x729>
f0115ba9:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115bad:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115bb1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115bb5:	74 6f                	je     f0115c26 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115bb7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115bba:	01 c0                	add    %eax,%eax
f0115bbc:	05 00 00 00 80       	add    $0x80000000,%eax
f0115bc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115bc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115bc7:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0115bca:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115bcd:	89 d0                	mov    %edx,%eax
f0115bcf:	c1 e0 02             	shl    $0x2,%eax
f0115bd2:	01 d0                	add    %edx,%eax
f0115bd4:	01 c0                	add    %eax,%eax
f0115bd6:	01 d0                	add    %edx,%eax
f0115bd8:	01 c0                	add    %eax,%eax
f0115bda:	05 00 00 00 80       	add    $0x80000000,%eax
f0115bdf:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115be2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115be5:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0115be8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115beb:	8a 00                	mov    (%eax),%al
f0115bed:	3c 4b                	cmp    $0x4b,%al
f0115bef:	75 09                	jne    f0115bfa <test_allocate_chunk+0x776>
f0115bf1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115bf4:	8a 00                	mov    (%eax),%al
f0115bf6:	3c 4d                	cmp    $0x4d,%al
f0115bf8:	74 1e                	je     f0115c18 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115bfa:	83 ec 04             	sub    $0x4,%esp
f0115bfd:	68 f8 c9 12 f0       	push   $0xf012c9f8
f0115c02:	68 d0 05 00 00       	push   $0x5d0
f0115c07:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115c0c:	e8 c5 a8 fe ff       	call   f01004d6 <_warn>
f0115c11:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0115c14:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0115c18:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115c1c:	74 04                	je     f0115c22 <test_allocate_chunk+0x79e>
f0115c1e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0115c22:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0115c26:	83 ec 0c             	sub    $0xc,%esp
f0115c29:	68 84 c8 12 f0       	push   $0xf012c884
f0115c2e:	e8 58 b3 fe ff       	call   f0100f8b <cprintf>
f0115c33:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0115c36:	83 ec 0c             	sub    $0xc,%esp
f0115c39:	68 4c cb 12 f0       	push   $0xf012cb4c
f0115c3e:	e8 48 b3 fe ff       	call   f0100f8b <cprintf>
f0115c43:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115c46:	e8 e9 91 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115c4b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0115c4e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115c51:	89 d0                	mov    %edx,%eax
f0115c53:	01 c0                	add    %eax,%eax
f0115c55:	01 d0                	add    %edx,%eax
f0115c57:	01 c0                	add    %eax,%eax
f0115c59:	01 d0                	add    %edx,%eax
f0115c5b:	68 04 0e 00 00       	push   $0xe04
f0115c60:	50                   	push   %eax
f0115c61:	68 00 fc 3f 40       	push   $0x403ffc00
f0115c66:	ff 75 cc             	pushl  -0x34(%ebp)
f0115c69:	e8 65 53 ff ff       	call   f010afd3 <allocate_chunk>
f0115c6e:	83 c4 10             	add    $0x10,%esp
f0115c71:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115c74:	e8 bb 91 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0115c79:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0115c7c:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0115c80:	75 0b                	jne    f0115c8d <test_allocate_chunk+0x809>
f0115c82:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115c85:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115c88:	83 f8 05             	cmp    $0x5,%eax
f0115c8b:	74 2a                	je     f0115cb7 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0115c8d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115c90:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115c93:	83 ec 08             	sub    $0x8,%esp
f0115c96:	6a 05                	push   $0x5
f0115c98:	50                   	push   %eax
f0115c99:	ff 75 98             	pushl  -0x68(%ebp)
f0115c9c:	68 70 ca 12 f0       	push   $0xf012ca70
f0115ca1:	68 e7 05 00 00       	push   $0x5e7
f0115ca6:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115cab:	e8 26 a8 fe ff       	call   f01004d6 <_warn>
f0115cb0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115cb3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115cb7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115cbb:	74 04                	je     f0115cc1 <test_allocate_chunk+0x83d>
f0115cbd:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115cc1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115cc5:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0115ccc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115ccf:	89 d0                	mov    %edx,%eax
f0115cd1:	01 c0                	add    %eax,%eax
f0115cd3:	01 d0                	add    %edx,%eax
f0115cd5:	c1 e0 02             	shl    $0x2,%eax
f0115cd8:	83 ec 08             	sub    $0x8,%esp
f0115cdb:	6a 03                	push   $0x3
f0115cdd:	6a 00                	push   $0x0
f0115cdf:	6a 00                	push   $0x0
f0115ce1:	68 07 0e 00 00       	push   $0xe07
f0115ce6:	68 05 0e 00 00       	push   $0xe05
f0115ceb:	6a 01                	push   $0x1
f0115ced:	50                   	push   %eax
f0115cee:	68 00 f0 3f 40       	push   $0x403ff000
f0115cf3:	6a 00                	push   $0x0
f0115cf5:	ff 75 cc             	pushl  -0x34(%ebp)
f0115cf8:	e8 b5 18 00 00       	call   f01175b2 <CCP>
f0115cfd:	83 c4 30             	add    $0x30,%esp
f0115d00:	85 c0                	test   %eax,%eax
f0115d02:	75 25                	jne    f0115d29 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115d04:	83 ec 04             	sub    $0x4,%esp
f0115d07:	68 ac c9 12 f0       	push   $0xf012c9ac
f0115d0c:	68 f0 05 00 00       	push   $0x5f0
f0115d11:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115d16:	e8 bb a7 fe ff       	call   f01004d6 <_warn>
f0115d1b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115d1e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115d22:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0115d29:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115d2d:	74 04                	je     f0115d33 <test_allocate_chunk+0x8af>
f0115d2f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115d33:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0115d37:	83 ec 0c             	sub    $0xc,%esp
f0115d3a:	68 83 cb 12 f0       	push   $0xf012cb83
f0115d3f:	e8 47 b2 fe ff       	call   f0100f8b <cprintf>
f0115d44:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115d47:	83 ec 08             	sub    $0x8,%esp
f0115d4a:	ff 75 e0             	pushl  -0x20(%ebp)
f0115d4d:	68 94 cb 12 f0       	push   $0xf012cb94
f0115d52:	e8 34 b2 fe ff       	call   f0100f8b <cprintf>
f0115d57:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115d5a:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0115d5e:	75 10                	jne    f0115d70 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115d60:	83 ec 0c             	sub    $0xc,%esp
f0115d63:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0115d68:	e8 1e b2 fe ff       	call   f0100f8b <cprintf>
f0115d6d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115d70:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f0115d75:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115d78:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d7b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115d7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115d83:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115d86:	5b                   	pop    %ebx
f0115d87:	5e                   	pop    %esi
f0115d88:	5f                   	pop    %edi
f0115d89:	5d                   	pop    %ebp
f0115d8a:	c3                   	ret    

f0115d8b <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0115d8b:	55                   	push   %ebp
f0115d8c:	89 e5                	mov    %esp,%ebp
f0115d8e:	57                   	push   %edi
f0115d8f:	56                   	push   %esi
f0115d90:	53                   	push   %ebx
f0115d91:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115d97:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115d9a:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f0115d9f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115da4:	89 c7                	mov    %eax,%edi
f0115da6:	89 de                	mov    %ebx,%esi
f0115da8:	89 d1                	mov    %edx,%ecx
f0115daa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115dac:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115daf:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115db4:	b0 00                	mov    $0x0,%al
f0115db6:	89 d7                	mov    %edx,%edi
f0115db8:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115dba:	6a 00                	push   $0x0
f0115dbc:	6a 0a                	push   $0xa
f0115dbe:	6a 14                	push   $0x14
f0115dc0:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115dc3:	50                   	push   %eax
f0115dc4:	e8 fd 56 ff ff       	call   f010b4c6 <env_create>
f0115dc9:	83 c4 10             	add    $0x10,%esp
f0115dcc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115dcf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115dd2:	8b 40 64             	mov    0x64(%eax),%eax
f0115dd5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115dd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115ddb:	8b 40 68             	mov    0x68(%eax),%eax
f0115dde:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115de1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115de4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115de7:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115dee:	75 70 20 
f0115df1:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115df8:	00 00 00 
f0115dfb:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0115dfe:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115e03:	b8 00 00 00 00       	mov    $0x0,%eax
f0115e08:	89 d7                	mov    %edx,%edi
f0115e0a:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0115e0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115e0f:	8b 40 10             	mov    0x10(%eax),%eax
f0115e12:	83 ec 08             	sub    $0x8,%esp
f0115e15:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115e1b:	52                   	push   %edx
f0115e1c:	50                   	push   %eax
f0115e1d:	e8 bf c5 00 00       	call   f01223e1 <ltostr>
f0115e22:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115e25:	83 ec 04             	sub    $0x4,%esp
f0115e28:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e2e:	50                   	push   %eax
f0115e2f:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115e35:	50                   	push   %eax
f0115e36:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0115e3c:	50                   	push   %eax
f0115e3d:	e8 78 c6 00 00       	call   f01224ba <strcconcat>
f0115e42:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115e45:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0115e4c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115e53:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f0115e5a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115e61:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115e65:	83 ec 0c             	sub    $0xc,%esp
f0115e68:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e6b:	e8 0e 17 00 00       	call   f011757e <ClearUserSpace>
f0115e70:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115e73:	83 ec 0c             	sub    $0xc,%esp
f0115e76:	68 08 cc 12 f0       	push   $0xf012cc08
f0115e7b:	e8 0b b1 fe ff       	call   f0100f8b <cprintf>
f0115e80:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115e83:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e86:	c1 e0 03             	shl    $0x3,%eax
f0115e89:	83 ec 04             	sub    $0x4,%esp
f0115e8c:	50                   	push   %eax
f0115e8d:	6a 00                	push   $0x0
f0115e8f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e92:	e8 70 51 ff ff       	call   f010b007 <calculate_required_frames>
f0115e97:	83 c4 10             	add    $0x10,%esp
f0115e9a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115e9d:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115ea1:	74 23                	je     f0115ec6 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115ea3:	83 ec 0c             	sub    $0xc,%esp
f0115ea6:	6a 03                	push   $0x3
f0115ea8:	ff 75 c8             	pushl  -0x38(%ebp)
f0115eab:	68 3c cc 12 f0       	push   $0xf012cc3c
f0115eb0:	68 29 06 00 00       	push   $0x629
f0115eb5:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115eba:	e8 17 a6 fe ff       	call   f01004d6 <_warn>
f0115ebf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ec2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ec6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115eca:	74 04                	je     f0115ed0 <test_calculate_required_frames+0x145>
f0115ecc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ed0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115ed4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ed7:	c1 e0 02             	shl    $0x2,%eax
f0115eda:	83 ec 04             	sub    $0x4,%esp
f0115edd:	50                   	push   %eax
f0115ede:	6a 00                	push   $0x0
f0115ee0:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ee3:	e8 1f 51 ff ff       	call   f010b007 <calculate_required_frames>
f0115ee8:	83 c4 10             	add    $0x10,%esp
f0115eeb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f0115eee:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0115ef5:	74 26                	je     f0115f1d <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0115ef7:	83 ec 0c             	sub    $0xc,%esp
f0115efa:	68 01 04 00 00       	push   $0x401
f0115eff:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f02:	68 3c cc 12 f0       	push   $0xf012cc3c
f0115f07:	68 33 06 00 00       	push   $0x633
f0115f0c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115f11:	e8 c0 a5 fe ff       	call   f01004d6 <_warn>
f0115f16:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f19:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f1d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f21:	74 04                	je     f0115f27 <test_calculate_required_frames+0x19c>
f0115f23:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f27:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115f2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f2e:	c1 e0 0a             	shl    $0xa,%eax
f0115f31:	83 ec 04             	sub    $0x4,%esp
f0115f34:	50                   	push   %eax
f0115f35:	6a 00                	push   $0x0
f0115f37:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f3a:	e8 c8 50 ff ff       	call   f010b007 <calculate_required_frames>
f0115f3f:	83 c4 10             	add    $0x10,%esp
f0115f42:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115f45:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f48:	c1 e0 0a             	shl    $0xa,%eax
f0115f4b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115f4e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115f55:	99                   	cltd   
f0115f56:	f7 fb                	idiv   %ebx
f0115f58:	89 c1                	mov    %eax,%ecx
f0115f5a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f5d:	c1 e0 0a             	shl    $0xa,%eax
f0115f60:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115f63:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115f6a:	99                   	cltd   
f0115f6b:	f7 fe                	idiv   %esi
f0115f6d:	01 c8                	add    %ecx,%eax
f0115f6f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f72:	74 4c                	je     f0115fc0 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115f74:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f77:	c1 e0 0a             	shl    $0xa,%eax
f0115f7a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115f7d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115f84:	99                   	cltd   
f0115f85:	f7 fb                	idiv   %ebx
f0115f87:	89 c1                	mov    %eax,%ecx
f0115f89:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115f8c:	c1 e0 0a             	shl    $0xa,%eax
f0115f8f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115f92:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115f99:	99                   	cltd   
f0115f9a:	f7 fe                	idiv   %esi
f0115f9c:	01 c8                	add    %ecx,%eax
f0115f9e:	83 ec 0c             	sub    $0xc,%esp
f0115fa1:	50                   	push   %eax
f0115fa2:	ff 75 c8             	pushl  -0x38(%ebp)
f0115fa5:	68 3c cc 12 f0       	push   $0xf012cc3c
f0115faa:	68 3d 06 00 00       	push   $0x63d
f0115faf:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0115fb4:	e8 1d a5 fe ff       	call   f01004d6 <_warn>
f0115fb9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fbc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115fc0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fc4:	74 04                	je     f0115fca <test_calculate_required_frames+0x23f>
f0115fc6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115fca:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115fce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115fd1:	89 d0                	mov    %edx,%eax
f0115fd3:	01 c0                	add    %eax,%eax
f0115fd5:	01 d0                	add    %edx,%eax
f0115fd7:	01 c0                	add    %eax,%eax
f0115fd9:	83 ec 04             	sub    $0x4,%esp
f0115fdc:	50                   	push   %eax
f0115fdd:	68 00 10 00 00       	push   $0x1000
f0115fe2:	ff 75 d8             	pushl  -0x28(%ebp)
f0115fe5:	e8 1d 50 ff ff       	call   f010b007 <calculate_required_frames>
f0115fea:	83 c4 10             	add    $0x10,%esp
f0115fed:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115ff0:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115ff4:	74 23                	je     f0116019 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115ff6:	83 ec 0c             	sub    $0xc,%esp
f0115ff9:	6a 03                	push   $0x3
f0115ffb:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ffe:	68 3c cc 12 f0       	push   $0xf012cc3c
f0116003:	68 49 06 00 00       	push   $0x649
f0116008:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011600d:	e8 c4 a4 fe ff       	call   f01004d6 <_warn>
f0116012:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116015:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116019:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011601d:	74 04                	je     f0116023 <test_calculate_required_frames+0x298>
f011601f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116023:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0116027:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011602a:	89 c2                	mov    %eax,%edx
f011602c:	01 d2                	add    %edx,%edx
f011602e:	01 d0                	add    %edx,%eax
f0116030:	83 ec 04             	sub    $0x4,%esp
f0116033:	50                   	push   %eax
f0116034:	68 00 18 00 00       	push   $0x1800
f0116039:	ff 75 d8             	pushl  -0x28(%ebp)
f011603c:	e8 c6 4f ff ff       	call   f010b007 <calculate_required_frames>
f0116041:	83 c4 10             	add    $0x10,%esp
f0116044:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0116047:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011604b:	74 23                	je     f0116070 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011604d:	83 ec 0c             	sub    $0xc,%esp
f0116050:	6a 03                	push   $0x3
f0116052:	ff 75 c8             	pushl  -0x38(%ebp)
f0116055:	68 3c cc 12 f0       	push   $0xf012cc3c
f011605a:	68 53 06 00 00       	push   $0x653
f011605f:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116064:	e8 6d a4 fe ff       	call   f01004d6 <_warn>
f0116069:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011606c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116070:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116074:	74 04                	je     f011607a <test_calculate_required_frames+0x2ef>
f0116076:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011607a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f011607e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116081:	89 d0                	mov    %edx,%eax
f0116083:	c1 e0 02             	shl    $0x2,%eax
f0116086:	01 d0                	add    %edx,%eax
f0116088:	01 c0                	add    %eax,%eax
f011608a:	83 ec 04             	sub    $0x4,%esp
f011608d:	50                   	push   %eax
f011608e:	68 00 00 40 00       	push   $0x400000
f0116093:	ff 75 d8             	pushl  -0x28(%ebp)
f0116096:	e8 6c 4f ff ff       	call   f010b007 <calculate_required_frames>
f011609b:	83 c4 10             	add    $0x10,%esp
f011609e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01160a1:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01160a8:	74 26                	je     f01160d0 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01160aa:	83 ec 0c             	sub    $0xc,%esp
f01160ad:	68 03 0a 00 00       	push   $0xa03
f01160b2:	ff 75 c8             	pushl  -0x38(%ebp)
f01160b5:	68 3c cc 12 f0       	push   $0xf012cc3c
f01160ba:	68 5d 06 00 00       	push   $0x65d
f01160bf:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01160c4:	e8 0d a4 fe ff       	call   f01004d6 <_warn>
f01160c9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160cc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160d0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160d4:	74 04                	je     f01160da <test_calculate_required_frames+0x34f>
f01160d6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160da:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01160de:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01160e1:	01 c0                	add    %eax,%eax
f01160e3:	83 ec 04             	sub    $0x4,%esp
f01160e6:	50                   	push   %eax
f01160e7:	68 00 00 70 00       	push   $0x700000
f01160ec:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ef:	e8 13 4f ff ff       	call   f010b007 <calculate_required_frames>
f01160f4:	83 c4 10             	add    $0x10,%esp
f01160f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f01160fa:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0116101:	74 26                	je     f0116129 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0116103:	83 ec 0c             	sub    $0xc,%esp
f0116106:	68 02 02 00 00       	push   $0x202
f011610b:	ff 75 c8             	pushl  -0x38(%ebp)
f011610e:	68 3c cc 12 f0       	push   $0xf012cc3c
f0116113:	68 69 06 00 00       	push   $0x669
f0116118:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011611d:	e8 b4 a3 fe ff       	call   f01004d6 <_warn>
f0116122:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116125:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116129:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011612d:	74 04                	je     f0116133 <test_calculate_required_frames+0x3a8>
f011612f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116133:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0116137:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011613a:	83 ec 04             	sub    $0x4,%esp
f011613d:	50                   	push   %eax
f011613e:	68 ff ff 3f 00       	push   $0x3fffff
f0116143:	ff 75 d8             	pushl  -0x28(%ebp)
f0116146:	e8 bc 4e ff ff       	call   f010b007 <calculate_required_frames>
f011614b:	83 c4 10             	add    $0x10,%esp
f011614e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0116151:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0116155:	74 23                	je     f011617a <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0116157:	83 ec 0c             	sub    $0xc,%esp
f011615a:	6a 04                	push   $0x4
f011615c:	ff 75 c8             	pushl  -0x38(%ebp)
f011615f:	68 3c cc 12 f0       	push   $0xf012cc3c
f0116164:	68 73 06 00 00       	push   $0x673
f0116169:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011616e:	e8 63 a3 fe ff       	call   f01004d6 <_warn>
f0116173:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116176:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011617a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011617e:	74 04                	je     f0116184 <test_calculate_required_frames+0x3f9>
f0116180:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116184:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116188:	83 ec 0c             	sub    $0xc,%esp
f011618b:	68 75 c7 12 f0       	push   $0xf012c775
f0116190:	e8 f6 ad fe ff       	call   f0100f8b <cprintf>
f0116195:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116198:	83 ec 0c             	sub    $0xc,%esp
f011619b:	68 94 cc 12 f0       	push   $0xf012cc94
f01161a0:	e8 e6 ad fe ff       	call   f0100f8b <cprintf>
f01161a5:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01161a8:	83 ec 04             	sub    $0x4,%esp
f01161ab:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01161b1:	50                   	push   %eax
f01161b2:	68 2e bb 12 f0       	push   $0xf012bb2e
f01161b7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161bd:	50                   	push   %eax
f01161be:	e8 f7 c2 00 00       	call   f01224ba <strcconcat>
f01161c3:	83 c4 10             	add    $0x10,%esp
f01161c6:	83 ec 0c             	sub    $0xc,%esp
f01161c9:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01161cf:	50                   	push   %eax
f01161d0:	e8 26 bd fe ff       	call   f0101efb <execute_command>
f01161d5:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01161d8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01161db:	c1 e0 03             	shl    $0x3,%eax
f01161de:	83 ec 04             	sub    $0x4,%esp
f01161e1:	50                   	push   %eax
f01161e2:	6a 00                	push   $0x0
f01161e4:	ff 75 d8             	pushl  -0x28(%ebp)
f01161e7:	e8 1b 4e ff ff       	call   f010b007 <calculate_required_frames>
f01161ec:	83 c4 10             	add    $0x10,%esp
f01161ef:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01161f2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01161f9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01161fc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01161ff:	74 24                	je     f0116225 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0116201:	83 ec 0c             	sub    $0xc,%esp
f0116204:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116207:	ff 75 c8             	pushl  -0x38(%ebp)
f011620a:	68 3c cc 12 f0       	push   $0xf012cc3c
f011620f:	68 87 06 00 00       	push   $0x687
f0116214:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116219:	e8 b8 a2 fe ff       	call   f01004d6 <_warn>
f011621e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116221:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116225:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116229:	74 04                	je     f011622f <test_calculate_required_frames+0x4a4>
f011622b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011622f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116233:	83 ec 04             	sub    $0x4,%esp
f0116236:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011623c:	50                   	push   %eax
f011623d:	68 3b bb 12 f0       	push   $0xf012bb3b
f0116242:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116248:	50                   	push   %eax
f0116249:	e8 6c c2 00 00       	call   f01224ba <strcconcat>
f011624e:	83 c4 10             	add    $0x10,%esp
f0116251:	83 ec 0c             	sub    $0xc,%esp
f0116254:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011625a:	50                   	push   %eax
f011625b:	e8 9b bc fe ff       	call   f0101efb <execute_command>
f0116260:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116263:	83 ec 04             	sub    $0x4,%esp
f0116266:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011626c:	50                   	push   %eax
f011626d:	68 c8 cc 12 f0       	push   $0xf012ccc8
f0116272:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116278:	50                   	push   %eax
f0116279:	e8 3c c2 00 00       	call   f01224ba <strcconcat>
f011627e:	83 c4 10             	add    $0x10,%esp
f0116281:	83 ec 0c             	sub    $0xc,%esp
f0116284:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011628a:	50                   	push   %eax
f011628b:	e8 6b bc fe ff       	call   f0101efb <execute_command>
f0116290:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0116293:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116296:	c1 e0 03             	shl    $0x3,%eax
f0116299:	83 ec 04             	sub    $0x4,%esp
f011629c:	50                   	push   %eax
f011629d:	6a 00                	push   $0x0
f011629f:	ff 75 d8             	pushl  -0x28(%ebp)
f01162a2:	e8 60 4d ff ff       	call   f010b007 <calculate_required_frames>
f01162a7:	83 c4 10             	add    $0x10,%esp
f01162aa:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01162ad:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01162b4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01162b7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01162ba:	74 24                	je     f01162e0 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01162bc:	83 ec 0c             	sub    $0xc,%esp
f01162bf:	ff 75 c4             	pushl  -0x3c(%ebp)
f01162c2:	ff 75 c8             	pushl  -0x38(%ebp)
f01162c5:	68 3c cc 12 f0       	push   $0xf012cc3c
f01162ca:	68 95 06 00 00       	push   $0x695
f01162cf:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01162d4:	e8 fd a1 fe ff       	call   f01004d6 <_warn>
f01162d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162dc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162e0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162e4:	74 04                	je     f01162ea <test_calculate_required_frames+0x55f>
f01162e6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162ea:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01162ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01162f1:	c1 e0 0a             	shl    $0xa,%eax
f01162f4:	83 ec 04             	sub    $0x4,%esp
f01162f7:	50                   	push   %eax
f01162f8:	6a 00                	push   $0x0
f01162fa:	ff 75 d8             	pushl  -0x28(%ebp)
f01162fd:	e8 05 4d ff ff       	call   f010b007 <calculate_required_frames>
f0116302:	83 c4 10             	add    $0x10,%esp
f0116305:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0116308:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011630b:	c1 e0 0a             	shl    $0xa,%eax
f011630e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116311:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0116318:	99                   	cltd   
f0116319:	f7 fb                	idiv   %ebx
f011631b:	89 c1                	mov    %eax,%ecx
f011631d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116320:	c1 e0 0a             	shl    $0xa,%eax
f0116323:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116326:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011632d:	99                   	cltd   
f011632e:	f7 fe                	idiv   %esi
f0116330:	01 c8                	add    %ecx,%eax
f0116332:	83 e8 05             	sub    $0x5,%eax
f0116335:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0116338:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011633b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011633e:	74 24                	je     f0116364 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0116340:	83 ec 0c             	sub    $0xc,%esp
f0116343:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116346:	ff 75 c8             	pushl  -0x38(%ebp)
f0116349:	68 3c cc 12 f0       	push   $0xf012cc3c
f011634e:	68 a0 06 00 00       	push   $0x6a0
f0116353:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116358:	e8 79 a1 fe ff       	call   f01004d6 <_warn>
f011635d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116360:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116364:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116368:	74 04                	je     f011636e <test_calculate_required_frames+0x5e3>
f011636a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011636e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116372:	83 ec 04             	sub    $0x4,%esp
f0116375:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011637b:	50                   	push   %eax
f011637c:	68 d4 cc 12 f0       	push   $0xf012ccd4
f0116381:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116387:	50                   	push   %eax
f0116388:	e8 2d c1 00 00       	call   f01224ba <strcconcat>
f011638d:	83 c4 10             	add    $0x10,%esp
f0116390:	83 ec 0c             	sub    $0xc,%esp
f0116393:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0116399:	50                   	push   %eax
f011639a:	e8 5c bb fe ff       	call   f0101efb <execute_command>
f011639f:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01163a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01163a5:	89 c2                	mov    %eax,%edx
f01163a7:	01 d2                	add    %edx,%edx
f01163a9:	01 d0                	add    %edx,%eax
f01163ab:	83 ec 04             	sub    $0x4,%esp
f01163ae:	50                   	push   %eax
f01163af:	68 00 18 00 00       	push   $0x1800
f01163b4:	ff 75 d8             	pushl  -0x28(%ebp)
f01163b7:	e8 4b 4c ff ff       	call   f010b007 <calculate_required_frames>
f01163bc:	83 c4 10             	add    $0x10,%esp
f01163bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01163c2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01163c9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01163cc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01163cf:	74 24                	je     f01163f5 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01163d1:	83 ec 0c             	sub    $0xc,%esp
f01163d4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01163d7:	ff 75 c8             	pushl  -0x38(%ebp)
f01163da:	68 3c cc 12 f0       	push   $0xf012cc3c
f01163df:	68 af 06 00 00       	push   $0x6af
f01163e4:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01163e9:	e8 e8 a0 fe ff       	call   f01004d6 <_warn>
f01163ee:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163f1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01163f5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163f9:	74 04                	je     f01163ff <test_calculate_required_frames+0x674>
f01163fb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01163ff:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116403:	83 ec 04             	sub    $0x4,%esp
f0116406:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011640c:	50                   	push   %eax
f011640d:	68 94 bd 12 f0       	push   $0xf012bd94
f0116412:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116418:	50                   	push   %eax
f0116419:	e8 9c c0 00 00       	call   f01224ba <strcconcat>
f011641e:	83 c4 10             	add    $0x10,%esp
f0116421:	83 ec 0c             	sub    $0xc,%esp
f0116424:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011642a:	50                   	push   %eax
f011642b:	e8 cb ba fe ff       	call   f0101efb <execute_command>
f0116430:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0116433:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116436:	89 d0                	mov    %edx,%eax
f0116438:	c1 e0 02             	shl    $0x2,%eax
f011643b:	01 d0                	add    %edx,%eax
f011643d:	01 c0                	add    %eax,%eax
f011643f:	83 ec 04             	sub    $0x4,%esp
f0116442:	50                   	push   %eax
f0116443:	68 00 00 40 00       	push   $0x400000
f0116448:	ff 75 d8             	pushl  -0x28(%ebp)
f011644b:	e8 b7 4b ff ff       	call   f010b007 <calculate_required_frames>
f0116450:	83 c4 10             	add    $0x10,%esp
f0116453:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0116456:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011645d:	74 26                	je     f0116485 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011645f:	83 ec 0c             	sub    $0xc,%esp
f0116462:	68 03 0a 00 00       	push   $0xa03
f0116467:	ff 75 c8             	pushl  -0x38(%ebp)
f011646a:	68 3c cc 12 f0       	push   $0xf012cc3c
f011646f:	68 bb 06 00 00       	push   $0x6bb
f0116474:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116479:	e8 58 a0 fe ff       	call   f01004d6 <_warn>
f011647e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116481:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116485:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116489:	74 04                	je     f011648f <test_calculate_required_frames+0x704>
f011648b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011648f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116493:	83 ec 04             	sub    $0x4,%esp
f0116496:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011649c:	50                   	push   %eax
f011649d:	68 9e bd 12 f0       	push   $0xf012bd9e
f01164a2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164a8:	50                   	push   %eax
f01164a9:	e8 0c c0 00 00       	call   f01224ba <strcconcat>
f01164ae:	83 c4 10             	add    $0x10,%esp
f01164b1:	83 ec 0c             	sub    $0xc,%esp
f01164b4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01164ba:	50                   	push   %eax
f01164bb:	e8 3b ba fe ff       	call   f0101efb <execute_command>
f01164c0:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01164c3:	83 ec 04             	sub    $0x4,%esp
f01164c6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01164cc:	50                   	push   %eax
f01164cd:	68 dc cc 12 f0       	push   $0xf012ccdc
f01164d2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01164d8:	50                   	push   %eax
f01164d9:	e8 dc bf 00 00       	call   f01224ba <strcconcat>
f01164de:	83 c4 10             	add    $0x10,%esp
f01164e1:	83 ec 0c             	sub    $0xc,%esp
f01164e4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01164ea:	50                   	push   %eax
f01164eb:	e8 0b ba fe ff       	call   f0101efb <execute_command>
f01164f0:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01164f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01164f6:	01 c0                	add    %eax,%eax
f01164f8:	83 ec 04             	sub    $0x4,%esp
f01164fb:	50                   	push   %eax
f01164fc:	68 00 00 70 00       	push   $0x700000
f0116501:	ff 75 d8             	pushl  -0x28(%ebp)
f0116504:	e8 fe 4a ff ff       	call   f010b007 <calculate_required_frames>
f0116509:	83 c4 10             	add    $0x10,%esp
f011650c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011650f:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0116516:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116519:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011651c:	74 24                	je     f0116542 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011651e:	83 ec 0c             	sub    $0xc,%esp
f0116521:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116524:	ff 75 c8             	pushl  -0x38(%ebp)
f0116527:	68 3c cc 12 f0       	push   $0xf012cc3c
f011652c:	68 cb 06 00 00       	push   $0x6cb
f0116531:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116536:	e8 9b 9f fe ff       	call   f01004d6 <_warn>
f011653b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011653e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116542:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116546:	74 04                	je     f011654c <test_calculate_required_frames+0x7c1>
f0116548:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011654c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0116550:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116553:	83 ec 04             	sub    $0x4,%esp
f0116556:	50                   	push   %eax
f0116557:	68 ff ff 3f 00       	push   $0x3fffff
f011655c:	ff 75 d8             	pushl  -0x28(%ebp)
f011655f:	e8 a3 4a ff ff       	call   f010b007 <calculate_required_frames>
f0116564:	83 c4 10             	add    $0x10,%esp
f0116567:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011656a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0116571:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116574:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116577:	74 24                	je     f011659d <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0116579:	83 ec 0c             	sub    $0xc,%esp
f011657c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011657f:	ff 75 c8             	pushl  -0x38(%ebp)
f0116582:	68 3c cc 12 f0       	push   $0xf012cc3c
f0116587:	68 d6 06 00 00       	push   $0x6d6
f011658c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116591:	e8 40 9f fe ff       	call   f01004d6 <_warn>
f0116596:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116599:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011659d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165a1:	74 04                	je     f01165a7 <test_calculate_required_frames+0x81c>
f01165a3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01165a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01165ab:	83 ec 0c             	sub    $0xc,%esp
f01165ae:	68 4f bd 12 f0       	push   $0xf012bd4f
f01165b3:	e8 d3 a9 fe ff       	call   f0100f8b <cprintf>
f01165b8:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f01165bb:	83 ec 08             	sub    $0x8,%esp
f01165be:	ff 75 e4             	pushl  -0x1c(%ebp)
f01165c1:	68 e8 cc 12 f0       	push   $0xf012cce8
f01165c6:	e8 c0 a9 fe ff       	call   f0100f8b <cprintf>
f01165cb:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01165ce:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01165d2:	75 10                	jne    f01165e4 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f01165d4:	83 ec 0c             	sub    $0xc,%esp
f01165d7:	68 28 cd 12 f0       	push   $0xf012cd28
f01165dc:	e8 aa a9 fe ff       	call   f0100f8b <cprintf>
f01165e1:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01165e4:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f01165e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01165ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01165ef:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01165f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01165f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01165fa:	5b                   	pop    %ebx
f01165fb:	5e                   	pop    %esi
f01165fc:	5f                   	pop    %edi
f01165fd:	5d                   	pop    %ebp
f01165fe:	c3                   	ret    

f01165ff <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f01165ff:	55                   	push   %ebp
f0116600:	89 e5                	mov    %esp,%ebp
f0116602:	57                   	push   %edi
f0116603:	56                   	push   %esi
f0116604:	53                   	push   %ebx
f0116605:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011660b:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011660e:	bb c4 ba 12 f0       	mov    $0xf012bac4,%ebx
f0116613:	ba 0f 00 00 00       	mov    $0xf,%edx
f0116618:	89 c7                	mov    %eax,%edi
f011661a:	89 de                	mov    %ebx,%esi
f011661c:	89 d1                	mov    %edx,%ecx
f011661e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116620:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0116623:	b9 23 00 00 00       	mov    $0x23,%ecx
f0116628:	b0 00                	mov    $0x0,%al
f011662a:	89 d7                	mov    %edx,%edi
f011662c:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011662e:	6a 00                	push   $0x0
f0116630:	6a 0a                	push   $0xa
f0116632:	6a 14                	push   $0x14
f0116634:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0116637:	50                   	push   %eax
f0116638:	e8 89 4e ff ff       	call   f010b4c6 <env_create>
f011663d:	83 c4 10             	add    $0x10,%esp
f0116640:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116643:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116646:	8b 40 64             	mov    0x64(%eax),%eax
f0116649:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011664c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011664f:	8b 40 68             	mov    0x68(%eax),%eax
f0116652:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116655:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116658:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011665b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116662:	75 70 20 
f0116665:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011666c:	00 00 00 
f011666f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116672:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116677:	b8 00 00 00 00       	mov    $0x0,%eax
f011667c:	89 d7                	mov    %edx,%edi
f011667e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116680:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116683:	8b 40 10             	mov    0x10(%eax),%eax
f0116686:	83 ec 08             	sub    $0x8,%esp
f0116689:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011668f:	52                   	push   %edx
f0116690:	50                   	push   %eax
f0116691:	e8 4b bd 00 00       	call   f01223e1 <ltostr>
f0116696:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116699:	83 ec 04             	sub    $0x4,%esp
f011669c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01166a2:	50                   	push   %eax
f01166a3:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01166a9:	50                   	push   %eax
f01166aa:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01166b0:	50                   	push   %eax
f01166b1:	e8 04 be 00 00       	call   f01224ba <strcconcat>
f01166b6:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01166b9:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01166c0:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01166c7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f01166ce:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f01166d2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01166d9:	00 00 00 
	uint32 num_tables = 0;
f01166dc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01166e3:	00 00 00 
	ClearUserSpace(proc_directory);
f01166e6:	83 ec 0c             	sub    $0xc,%esp
f01166e9:	ff 75 d8             	pushl  -0x28(%ebp)
f01166ec:	e8 8d 0e 00 00       	call   f011757e <ClearUserSpace>
f01166f1:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01166f4:	83 ec 0c             	sub    $0xc,%esp
f01166f7:	68 08 cc 12 f0       	push   $0xf012cc08
f01166fc:	e8 8a a8 fe ff       	call   f0100f8b <cprintf>
f0116701:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116704:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116707:	c1 e0 03             	shl    $0x3,%eax
f011670a:	89 c2                	mov    %eax,%edx
f011670c:	83 ec 0c             	sub    $0xc,%esp
f011670f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116715:	50                   	push   %eax
f0116716:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011671c:	50                   	push   %eax
f011671d:	52                   	push   %edx
f011671e:	6a 00                	push   $0x0
f0116720:	ff 75 d8             	pushl  -0x28(%ebp)
f0116723:	e8 c5 48 ff ff       	call   f010afed <calculate_allocated_space>
f0116728:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011672b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116731:	85 c0                	test   %eax,%eax
f0116733:	74 27                	je     f011675c <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116735:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011673b:	83 ec 0c             	sub    $0xc,%esp
f011673e:	6a 00                	push   $0x0
f0116740:	50                   	push   %eax
f0116741:	68 74 cd 12 f0       	push   $0xf012cd74
f0116746:	68 0b 07 00 00       	push   $0x70b
f011674b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116750:	e8 81 9d fe ff       	call   f01004d6 <_warn>
f0116755:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116758:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011675c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116762:	85 c0                	test   %eax,%eax
f0116764:	74 27                	je     f011678d <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116766:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011676c:	83 ec 0c             	sub    $0xc,%esp
f011676f:	6a 00                	push   $0x0
f0116771:	50                   	push   %eax
f0116772:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116777:	68 10 07 00 00       	push   $0x710
f011677c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116781:	e8 50 9d fe ff       	call   f01004d6 <_warn>
f0116786:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116789:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011678d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116791:	74 04                	je     f0116797 <test_calculate_allocated_space+0x198>
f0116793:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116797:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f011679b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01167a2:	00 00 00 
		num_pages = 0;
f01167a5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01167ac:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01167af:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01167b2:	c1 e0 02             	shl    $0x2,%eax
f01167b5:	89 c2                	mov    %eax,%edx
f01167b7:	83 ec 0c             	sub    $0xc,%esp
f01167ba:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167c0:	50                   	push   %eax
f01167c1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167c7:	50                   	push   %eax
f01167c8:	52                   	push   %edx
f01167c9:	6a 00                	push   $0x0
f01167cb:	ff 75 d8             	pushl  -0x28(%ebp)
f01167ce:	e8 1a 48 ff ff       	call   f010afed <calculate_allocated_space>
f01167d3:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01167d6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167dc:	85 c0                	test   %eax,%eax
f01167de:	74 27                	je     f0116807 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01167e0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167e6:	83 ec 0c             	sub    $0xc,%esp
f01167e9:	6a 00                	push   $0x0
f01167eb:	50                   	push   %eax
f01167ec:	68 74 cd 12 f0       	push   $0xf012cd74
f01167f1:	68 1c 07 00 00       	push   $0x71c
f01167f6:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01167fb:	e8 d6 9c fe ff       	call   f01004d6 <_warn>
f0116800:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116803:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116807:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011680d:	85 c0                	test   %eax,%eax
f011680f:	74 27                	je     f0116838 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116811:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116817:	83 ec 0c             	sub    $0xc,%esp
f011681a:	6a 00                	push   $0x0
f011681c:	50                   	push   %eax
f011681d:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116822:	68 21 07 00 00       	push   $0x721
f0116827:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011682c:	e8 a5 9c fe ff       	call   f01004d6 <_warn>
f0116831:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116834:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116838:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011683c:	74 04                	je     f0116842 <test_calculate_allocated_space+0x243>
f011683e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116842:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116846:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011684d:	00 00 00 
		num_pages = 0;
f0116850:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116857:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011685a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011685d:	c1 e0 0a             	shl    $0xa,%eax
f0116860:	89 c2                	mov    %eax,%edx
f0116862:	83 ec 0c             	sub    $0xc,%esp
f0116865:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011686b:	50                   	push   %eax
f011686c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116872:	50                   	push   %eax
f0116873:	52                   	push   %edx
f0116874:	6a 00                	push   $0x0
f0116876:	ff 75 d8             	pushl  -0x28(%ebp)
f0116879:	e8 6f 47 ff ff       	call   f010afed <calculate_allocated_space>
f011687e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116881:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116887:	85 c0                	test   %eax,%eax
f0116889:	74 27                	je     f01168b2 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011688b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116891:	83 ec 0c             	sub    $0xc,%esp
f0116894:	6a 00                	push   $0x0
f0116896:	50                   	push   %eax
f0116897:	68 74 cd 12 f0       	push   $0xf012cd74
f011689c:	68 2d 07 00 00       	push   $0x72d
f01168a1:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01168a6:	e8 2b 9c fe ff       	call   f01004d6 <_warn>
f01168ab:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168ae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01168b2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168b8:	85 c0                	test   %eax,%eax
f01168ba:	74 27                	je     f01168e3 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01168bc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168c2:	83 ec 0c             	sub    $0xc,%esp
f01168c5:	6a 00                	push   $0x0
f01168c7:	50                   	push   %eax
f01168c8:	68 d4 cd 12 f0       	push   $0xf012cdd4
f01168cd:	68 32 07 00 00       	push   $0x732
f01168d2:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01168d7:	e8 fa 9b fe ff       	call   f01004d6 <_warn>
f01168dc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168df:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01168e3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01168e7:	74 04                	je     f01168ed <test_calculate_allocated_space+0x2ee>
f01168e9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01168ed:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01168f1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01168f8:	00 00 00 
		num_pages = 0;
f01168fb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116902:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0116905:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0116908:	89 d0                	mov    %edx,%eax
f011690a:	01 c0                	add    %eax,%eax
f011690c:	01 d0                	add    %edx,%eax
f011690e:	01 c0                	add    %eax,%eax
f0116910:	05 00 10 00 00       	add    $0x1000,%eax
f0116915:	89 c2                	mov    %eax,%edx
f0116917:	83 ec 0c             	sub    $0xc,%esp
f011691a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116920:	50                   	push   %eax
f0116921:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116927:	50                   	push   %eax
f0116928:	52                   	push   %edx
f0116929:	68 00 10 00 00       	push   $0x1000
f011692e:	ff 75 d8             	pushl  -0x28(%ebp)
f0116931:	e8 b7 46 ff ff       	call   f010afed <calculate_allocated_space>
f0116936:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116939:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011693f:	85 c0                	test   %eax,%eax
f0116941:	74 27                	je     f011696a <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116943:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116949:	83 ec 0c             	sub    $0xc,%esp
f011694c:	6a 00                	push   $0x0
f011694e:	50                   	push   %eax
f011694f:	68 74 cd 12 f0       	push   $0xf012cd74
f0116954:	68 3f 07 00 00       	push   $0x73f
f0116959:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011695e:	e8 73 9b fe ff       	call   f01004d6 <_warn>
f0116963:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116966:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011696a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116970:	85 c0                	test   %eax,%eax
f0116972:	74 27                	je     f011699b <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116974:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011697a:	83 ec 0c             	sub    $0xc,%esp
f011697d:	6a 00                	push   $0x0
f011697f:	50                   	push   %eax
f0116980:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116985:	68 44 07 00 00       	push   $0x744
f011698a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011698f:	e8 42 9b fe ff       	call   f01004d6 <_warn>
f0116994:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116997:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011699b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011699f:	74 04                	je     f01169a5 <test_calculate_allocated_space+0x3a6>
f01169a1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01169a5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f01169a9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01169b0:	00 00 00 
		num_pages = 0;
f01169b3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01169ba:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01169bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01169c0:	89 c2                	mov    %eax,%edx
f01169c2:	01 d2                	add    %edx,%edx
f01169c4:	01 d0                	add    %edx,%eax
f01169c6:	05 00 18 00 00       	add    $0x1800,%eax
f01169cb:	89 c2                	mov    %eax,%edx
f01169cd:	83 ec 0c             	sub    $0xc,%esp
f01169d0:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01169d6:	50                   	push   %eax
f01169d7:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01169dd:	50                   	push   %eax
f01169de:	52                   	push   %edx
f01169df:	68 00 18 00 00       	push   $0x1800
f01169e4:	ff 75 d8             	pushl  -0x28(%ebp)
f01169e7:	e8 01 46 ff ff       	call   f010afed <calculate_allocated_space>
f01169ec:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01169ef:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169f5:	85 c0                	test   %eax,%eax
f01169f7:	74 27                	je     f0116a20 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01169f9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169ff:	83 ec 0c             	sub    $0xc,%esp
f0116a02:	6a 00                	push   $0x0
f0116a04:	50                   	push   %eax
f0116a05:	68 74 cd 12 f0       	push   $0xf012cd74
f0116a0a:	68 50 07 00 00       	push   $0x750
f0116a0f:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116a14:	e8 bd 9a fe ff       	call   f01004d6 <_warn>
f0116a19:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a1c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116a20:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116a26:	85 c0                	test   %eax,%eax
f0116a28:	74 27                	je     f0116a51 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116a2a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116a30:	83 ec 0c             	sub    $0xc,%esp
f0116a33:	6a 00                	push   $0x0
f0116a35:	50                   	push   %eax
f0116a36:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116a3b:	68 55 07 00 00       	push   $0x755
f0116a40:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116a45:	e8 8c 9a fe ff       	call   f01004d6 <_warn>
f0116a4a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a4d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116a51:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a55:	74 04                	je     f0116a5b <test_calculate_allocated_space+0x45c>
f0116a57:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116a5b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0116a5f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a66:	00 00 00 
		num_pages = 0;
f0116a69:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a70:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116a73:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116a76:	89 d0                	mov    %edx,%eax
f0116a78:	c1 e0 02             	shl    $0x2,%eax
f0116a7b:	01 d0                	add    %edx,%eax
f0116a7d:	01 c0                	add    %eax,%eax
f0116a7f:	05 00 00 40 00       	add    $0x400000,%eax
f0116a84:	89 c2                	mov    %eax,%edx
f0116a86:	83 ec 0c             	sub    $0xc,%esp
f0116a89:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a8f:	50                   	push   %eax
f0116a90:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a96:	50                   	push   %eax
f0116a97:	52                   	push   %edx
f0116a98:	68 00 00 40 00       	push   $0x400000
f0116a9d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116aa0:	e8 48 45 ff ff       	call   f010afed <calculate_allocated_space>
f0116aa5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116aa8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116aae:	85 c0                	test   %eax,%eax
f0116ab0:	74 27                	je     f0116ad9 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116ab2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ab8:	83 ec 0c             	sub    $0xc,%esp
f0116abb:	6a 00                	push   $0x0
f0116abd:	50                   	push   %eax
f0116abe:	68 74 cd 12 f0       	push   $0xf012cd74
f0116ac3:	68 61 07 00 00       	push   $0x761
f0116ac8:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116acd:	e8 04 9a fe ff       	call   f01004d6 <_warn>
f0116ad2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ad5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116ad9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116adf:	85 c0                	test   %eax,%eax
f0116ae1:	74 27                	je     f0116b0a <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116ae3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ae9:	83 ec 0c             	sub    $0xc,%esp
f0116aec:	6a 00                	push   $0x0
f0116aee:	50                   	push   %eax
f0116aef:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116af4:	68 66 07 00 00       	push   $0x766
f0116af9:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116afe:	e8 d3 99 fe ff       	call   f01004d6 <_warn>
f0116b03:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b06:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116b0a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116b0e:	74 04                	je     f0116b14 <test_calculate_allocated_space+0x515>
f0116b10:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116b14:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0116b18:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116b1f:	00 00 00 
		num_pages = 0;
f0116b22:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116b29:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116b2c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116b2f:	05 00 00 38 00       	add    $0x380000,%eax
f0116b34:	01 c0                	add    %eax,%eax
f0116b36:	89 c2                	mov    %eax,%edx
f0116b38:	83 ec 0c             	sub    $0xc,%esp
f0116b3b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116b41:	50                   	push   %eax
f0116b42:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116b48:	50                   	push   %eax
f0116b49:	52                   	push   %edx
f0116b4a:	68 00 00 70 00       	push   $0x700000
f0116b4f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116b52:	e8 96 44 ff ff       	call   f010afed <calculate_allocated_space>
f0116b57:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116b5a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116b60:	85 c0                	test   %eax,%eax
f0116b62:	74 27                	je     f0116b8b <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116b64:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116b6a:	83 ec 0c             	sub    $0xc,%esp
f0116b6d:	6a 00                	push   $0x0
f0116b6f:	50                   	push   %eax
f0116b70:	68 74 cd 12 f0       	push   $0xf012cd74
f0116b75:	68 73 07 00 00       	push   $0x773
f0116b7a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116b7f:	e8 52 99 fe ff       	call   f01004d6 <_warn>
f0116b84:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b87:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116b8b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116b91:	85 c0                	test   %eax,%eax
f0116b93:	74 27                	je     f0116bbc <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116b95:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116b9b:	83 ec 0c             	sub    $0xc,%esp
f0116b9e:	6a 00                	push   $0x0
f0116ba0:	50                   	push   %eax
f0116ba1:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116ba6:	68 78 07 00 00       	push   $0x778
f0116bab:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116bb0:	e8 21 99 fe ff       	call   f01004d6 <_warn>
f0116bb5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116bb8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116bbc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116bc0:	74 04                	je     f0116bc6 <test_calculate_allocated_space+0x5c7>
f0116bc2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116bc6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0116bca:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116bd1:	00 00 00 
		num_pages = 0;
f0116bd4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116bdb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116bde:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116be1:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116be6:	89 c2                	mov    %eax,%edx
f0116be8:	83 ec 0c             	sub    $0xc,%esp
f0116beb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116bf1:	50                   	push   %eax
f0116bf2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116bf8:	50                   	push   %eax
f0116bf9:	52                   	push   %edx
f0116bfa:	68 ff ff 3f 00       	push   $0x3fffff
f0116bff:	ff 75 d8             	pushl  -0x28(%ebp)
f0116c02:	e8 e6 43 ff ff       	call   f010afed <calculate_allocated_space>
f0116c07:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116c0a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c10:	85 c0                	test   %eax,%eax
f0116c12:	74 27                	je     f0116c3b <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116c14:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c1a:	83 ec 0c             	sub    $0xc,%esp
f0116c1d:	6a 00                	push   $0x0
f0116c1f:	50                   	push   %eax
f0116c20:	68 74 cd 12 f0       	push   $0xf012cd74
f0116c25:	68 84 07 00 00       	push   $0x784
f0116c2a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116c2f:	e8 a2 98 fe ff       	call   f01004d6 <_warn>
f0116c34:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c37:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116c3b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116c41:	85 c0                	test   %eax,%eax
f0116c43:	74 27                	je     f0116c6c <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116c45:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116c4b:	83 ec 0c             	sub    $0xc,%esp
f0116c4e:	6a 00                	push   $0x0
f0116c50:	50                   	push   %eax
f0116c51:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116c56:	68 89 07 00 00       	push   $0x789
f0116c5b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116c60:	e8 71 98 fe ff       	call   f01004d6 <_warn>
f0116c65:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c68:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116c6c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116c70:	74 04                	je     f0116c76 <test_calculate_allocated_space+0x677>
f0116c72:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116c76:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0116c7a:	83 ec 0c             	sub    $0xc,%esp
f0116c7d:	68 75 c7 12 f0       	push   $0xf012c775
f0116c82:	e8 04 a3 fe ff       	call   f0100f8b <cprintf>
f0116c87:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0116c8a:	83 ec 0c             	sub    $0xc,%esp
f0116c8d:	68 94 cc 12 f0       	push   $0xf012cc94
f0116c92:	e8 f4 a2 fe ff       	call   f0100f8b <cprintf>
f0116c97:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0116c9a:	83 ec 04             	sub    $0x4,%esp
f0116c9d:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116ca3:	50                   	push   %eax
f0116ca4:	68 2e bb 12 f0       	push   $0xf012bb2e
f0116ca9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116caf:	50                   	push   %eax
f0116cb0:	e8 05 b8 00 00       	call   f01224ba <strcconcat>
f0116cb5:	83 c4 10             	add    $0x10,%esp
f0116cb8:	83 ec 0c             	sub    $0xc,%esp
f0116cbb:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116cc1:	50                   	push   %eax
f0116cc2:	e8 34 b2 fe ff       	call   f0101efb <execute_command>
f0116cc7:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0116cca:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116cd1:	00 00 00 
		num_pages = 0;
f0116cd4:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116cdb:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0116cde:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116ce1:	c1 e0 03             	shl    $0x3,%eax
f0116ce4:	89 c2                	mov    %eax,%edx
f0116ce6:	83 ec 0c             	sub    $0xc,%esp
f0116ce9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116cef:	50                   	push   %eax
f0116cf0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116cf6:	50                   	push   %eax
f0116cf7:	52                   	push   %edx
f0116cf8:	6a 00                	push   $0x0
f0116cfa:	ff 75 d8             	pushl  -0x28(%ebp)
f0116cfd:	e8 eb 42 ff ff       	call   f010afed <calculate_allocated_space>
f0116d02:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116d05:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0116d0c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116d13:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116d19:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116d1c:	74 28                	je     f0116d46 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116d1e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116d24:	83 ec 0c             	sub    $0xc,%esp
f0116d27:	ff 75 c8             	pushl  -0x38(%ebp)
f0116d2a:	50                   	push   %eax
f0116d2b:	68 74 cd 12 f0       	push   $0xf012cd74
f0116d30:	68 a0 07 00 00       	push   $0x7a0
f0116d35:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116d3a:	e8 97 97 fe ff       	call   f01004d6 <_warn>
f0116d3f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116d42:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116d46:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116d4c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116d4f:	74 28                	je     f0116d79 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116d51:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116d57:	83 ec 0c             	sub    $0xc,%esp
f0116d5a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116d5d:	50                   	push   %eax
f0116d5e:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116d63:	68 a5 07 00 00       	push   $0x7a5
f0116d68:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116d6d:	e8 64 97 fe ff       	call   f01004d6 <_warn>
f0116d72:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116d75:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116d79:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116d7d:	74 04                	je     f0116d83 <test_calculate_allocated_space+0x784>
f0116d7f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116d83:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116d87:	83 ec 04             	sub    $0x4,%esp
f0116d8a:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116d90:	50                   	push   %eax
f0116d91:	68 3b bb 12 f0       	push   $0xf012bb3b
f0116d96:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116d9c:	50                   	push   %eax
f0116d9d:	e8 18 b7 00 00       	call   f01224ba <strcconcat>
f0116da2:	83 c4 10             	add    $0x10,%esp
f0116da5:	83 ec 0c             	sub    $0xc,%esp
f0116da8:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116dae:	50                   	push   %eax
f0116daf:	e8 47 b1 fe ff       	call   f0101efb <execute_command>
f0116db4:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116db7:	83 ec 04             	sub    $0x4,%esp
f0116dba:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116dc0:	50                   	push   %eax
f0116dc1:	68 c8 cc 12 f0       	push   $0xf012ccc8
f0116dc6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116dcc:	50                   	push   %eax
f0116dcd:	e8 e8 b6 00 00       	call   f01224ba <strcconcat>
f0116dd2:	83 c4 10             	add    $0x10,%esp
f0116dd5:	83 ec 0c             	sub    $0xc,%esp
f0116dd8:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116dde:	50                   	push   %eax
f0116ddf:	e8 17 b1 fe ff       	call   f0101efb <execute_command>
f0116de4:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0116de7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116dee:	00 00 00 
		num_pages = 0;
f0116df1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116df8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0116dfb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116dfe:	c1 e0 03             	shl    $0x3,%eax
f0116e01:	89 c2                	mov    %eax,%edx
f0116e03:	83 ec 0c             	sub    $0xc,%esp
f0116e06:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116e0c:	50                   	push   %eax
f0116e0d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116e13:	50                   	push   %eax
f0116e14:	52                   	push   %edx
f0116e15:	6a 00                	push   $0x0
f0116e17:	ff 75 d8             	pushl  -0x28(%ebp)
f0116e1a:	e8 ce 41 ff ff       	call   f010afed <calculate_allocated_space>
f0116e1f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116e22:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0116e29:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116e30:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116e36:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116e39:	74 28                	je     f0116e63 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116e3b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116e41:	83 ec 0c             	sub    $0xc,%esp
f0116e44:	ff 75 c8             	pushl  -0x38(%ebp)
f0116e47:	50                   	push   %eax
f0116e48:	68 74 cd 12 f0       	push   $0xf012cd74
f0116e4d:	68 b6 07 00 00       	push   $0x7b6
f0116e52:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116e57:	e8 7a 96 fe ff       	call   f01004d6 <_warn>
f0116e5c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116e5f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116e63:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116e69:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116e6c:	74 28                	je     f0116e96 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116e6e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116e74:	83 ec 0c             	sub    $0xc,%esp
f0116e77:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116e7a:	50                   	push   %eax
f0116e7b:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116e80:	68 bb 07 00 00       	push   $0x7bb
f0116e85:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116e8a:	e8 47 96 fe ff       	call   f01004d6 <_warn>
f0116e8f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116e92:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116e96:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116e9a:	74 04                	je     f0116ea0 <test_calculate_allocated_space+0x8a1>
f0116e9c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116ea0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116ea4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116eab:	00 00 00 
		num_pages = 0;
f0116eae:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116eb5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116eb8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116ebb:	c1 e0 0a             	shl    $0xa,%eax
f0116ebe:	89 c2                	mov    %eax,%edx
f0116ec0:	83 ec 0c             	sub    $0xc,%esp
f0116ec3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116ec9:	50                   	push   %eax
f0116eca:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116ed0:	50                   	push   %eax
f0116ed1:	52                   	push   %edx
f0116ed2:	6a 00                	push   $0x0
f0116ed4:	ff 75 d8             	pushl  -0x28(%ebp)
f0116ed7:	e8 11 41 ff ff       	call   f010afed <calculate_allocated_space>
f0116edc:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f0116edf:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0116ee6:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116eed:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ef3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116ef6:	74 28                	je     f0116f20 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116ef8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116efe:	83 ec 0c             	sub    $0xc,%esp
f0116f01:	ff 75 c8             	pushl  -0x38(%ebp)
f0116f04:	50                   	push   %eax
f0116f05:	68 74 cd 12 f0       	push   $0xf012cd74
f0116f0a:	68 c9 07 00 00       	push   $0x7c9
f0116f0f:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116f14:	e8 bd 95 fe ff       	call   f01004d6 <_warn>
f0116f19:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116f1c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116f20:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116f26:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116f29:	74 28                	je     f0116f53 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116f2b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116f31:	83 ec 0c             	sub    $0xc,%esp
f0116f34:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116f37:	50                   	push   %eax
f0116f38:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0116f3d:	68 ce 07 00 00       	push   $0x7ce
f0116f42:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0116f47:	e8 8a 95 fe ff       	call   f01004d6 <_warn>
f0116f4c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116f4f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116f53:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116f57:	74 04                	je     f0116f5d <test_calculate_allocated_space+0x95e>
f0116f59:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116f5d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116f61:	83 ec 04             	sub    $0x4,%esp
f0116f64:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116f6a:	50                   	push   %eax
f0116f6b:	68 d4 cc 12 f0       	push   $0xf012ccd4
f0116f70:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116f76:	50                   	push   %eax
f0116f77:	e8 3e b5 00 00       	call   f01224ba <strcconcat>
f0116f7c:	83 c4 10             	add    $0x10,%esp
f0116f7f:	83 ec 0c             	sub    $0xc,%esp
f0116f82:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116f88:	50                   	push   %eax
f0116f89:	e8 6d af fe ff       	call   f0101efb <execute_command>
f0116f8e:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116f91:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116f98:	00 00 00 
		num_pages = 0;
f0116f9b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116fa2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116fa5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116fa8:	89 c2                	mov    %eax,%edx
f0116faa:	01 d2                	add    %edx,%edx
f0116fac:	01 d0                	add    %edx,%eax
f0116fae:	05 00 18 00 00       	add    $0x1800,%eax
f0116fb3:	89 c2                	mov    %eax,%edx
f0116fb5:	83 ec 0c             	sub    $0xc,%esp
f0116fb8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116fbe:	50                   	push   %eax
f0116fbf:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116fc5:	50                   	push   %eax
f0116fc6:	52                   	push   %edx
f0116fc7:	68 00 18 00 00       	push   $0x1800
f0116fcc:	ff 75 d8             	pushl  -0x28(%ebp)
f0116fcf:	e8 19 40 ff ff       	call   f010afed <calculate_allocated_space>
f0116fd4:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116fd7:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116fde:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116fe5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116feb:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116fee:	74 28                	je     f0117018 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116ff0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ff6:	83 ec 0c             	sub    $0xc,%esp
f0116ff9:	ff 75 c8             	pushl  -0x38(%ebp)
f0116ffc:	50                   	push   %eax
f0116ffd:	68 74 cd 12 f0       	push   $0xf012cd74
f0117002:	68 df 07 00 00       	push   $0x7df
f0117007:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011700c:	e8 c5 94 fe ff       	call   f01004d6 <_warn>
f0117011:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117014:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117018:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011701e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117021:	74 28                	je     f011704b <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117023:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117029:	83 ec 0c             	sub    $0xc,%esp
f011702c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011702f:	50                   	push   %eax
f0117030:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0117035:	68 e4 07 00 00       	push   $0x7e4
f011703a:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011703f:	e8 92 94 fe ff       	call   f01004d6 <_warn>
f0117044:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117047:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011704b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011704f:	74 04                	je     f0117055 <test_calculate_allocated_space+0xa56>
f0117051:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117055:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0117059:	83 ec 04             	sub    $0x4,%esp
f011705c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117062:	50                   	push   %eax
f0117063:	68 94 bd 12 f0       	push   $0xf012bd94
f0117068:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011706e:	50                   	push   %eax
f011706f:	e8 46 b4 00 00       	call   f01224ba <strcconcat>
f0117074:	83 c4 10             	add    $0x10,%esp
f0117077:	83 ec 0c             	sub    $0xc,%esp
f011707a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0117080:	50                   	push   %eax
f0117081:	e8 75 ae fe ff       	call   f0101efb <execute_command>
f0117086:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0117089:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0117090:	00 00 00 
		num_pages = 0;
f0117093:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011709a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f011709d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01170a0:	89 d0                	mov    %edx,%eax
f01170a2:	c1 e0 02             	shl    $0x2,%eax
f01170a5:	01 d0                	add    %edx,%eax
f01170a7:	01 c0                	add    %eax,%eax
f01170a9:	05 00 00 40 00       	add    $0x400000,%eax
f01170ae:	89 c2                	mov    %eax,%edx
f01170b0:	83 ec 0c             	sub    $0xc,%esp
f01170b3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01170b9:	50                   	push   %eax
f01170ba:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01170c0:	50                   	push   %eax
f01170c1:	52                   	push   %edx
f01170c2:	68 00 00 40 00       	push   $0x400000
f01170c7:	ff 75 d8             	pushl  -0x28(%ebp)
f01170ca:	e8 1e 3f ff ff       	call   f010afed <calculate_allocated_space>
f01170cf:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01170d2:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01170d9:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01170e0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01170e6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01170e9:	74 28                	je     f0117113 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01170eb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01170f1:	83 ec 0c             	sub    $0xc,%esp
f01170f4:	ff 75 c8             	pushl  -0x38(%ebp)
f01170f7:	50                   	push   %eax
f01170f8:	68 74 cd 12 f0       	push   $0xf012cd74
f01170fd:	68 f4 07 00 00       	push   $0x7f4
f0117102:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117107:	e8 ca 93 fe ff       	call   f01004d6 <_warn>
f011710c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011710f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117113:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117119:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011711c:	74 28                	je     f0117146 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011711e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117124:	83 ec 0c             	sub    $0xc,%esp
f0117127:	ff 75 c4             	pushl  -0x3c(%ebp)
f011712a:	50                   	push   %eax
f011712b:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0117130:	68 f9 07 00 00       	push   $0x7f9
f0117135:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011713a:	e8 97 93 fe ff       	call   f01004d6 <_warn>
f011713f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117142:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0117146:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011714a:	74 04                	je     f0117150 <test_calculate_allocated_space+0xb51>
f011714c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0117150:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0117154:	83 ec 04             	sub    $0x4,%esp
f0117157:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011715d:	50                   	push   %eax
f011715e:	68 9e bd 12 f0       	push   $0xf012bd9e
f0117163:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117169:	50                   	push   %eax
f011716a:	e8 4b b3 00 00       	call   f01224ba <strcconcat>
f011716f:	83 c4 10             	add    $0x10,%esp
f0117172:	83 ec 0c             	sub    $0xc,%esp
f0117175:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011717b:	50                   	push   %eax
f011717c:	e8 7a ad fe ff       	call   f0101efb <execute_command>
f0117181:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0117184:	83 ec 04             	sub    $0x4,%esp
f0117187:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011718d:	50                   	push   %eax
f011718e:	68 dc cc 12 f0       	push   $0xf012ccdc
f0117193:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0117199:	50                   	push   %eax
f011719a:	e8 1b b3 00 00       	call   f01224ba <strcconcat>
f011719f:	83 c4 10             	add    $0x10,%esp
f01171a2:	83 ec 0c             	sub    $0xc,%esp
f01171a5:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01171ab:	50                   	push   %eax
f01171ac:	e8 4a ad fe ff       	call   f0101efb <execute_command>
f01171b1:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f01171b4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01171bb:	00 00 00 
		num_pages = 0;
f01171be:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01171c5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01171c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01171cb:	05 00 00 38 00       	add    $0x380000,%eax
f01171d0:	01 c0                	add    %eax,%eax
f01171d2:	89 c2                	mov    %eax,%edx
f01171d4:	83 ec 0c             	sub    $0xc,%esp
f01171d7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01171dd:	50                   	push   %eax
f01171de:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01171e4:	50                   	push   %eax
f01171e5:	52                   	push   %edx
f01171e6:	68 00 00 70 00       	push   $0x700000
f01171eb:	ff 75 d8             	pushl  -0x28(%ebp)
f01171ee:	e8 fa 3d ff ff       	call   f010afed <calculate_allocated_space>
f01171f3:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01171f6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f01171fd:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0117204:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011720a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011720d:	74 28                	je     f0117237 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011720f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0117215:	83 ec 0c             	sub    $0xc,%esp
f0117218:	ff 75 c8             	pushl  -0x38(%ebp)
f011721b:	50                   	push   %eax
f011721c:	68 74 cd 12 f0       	push   $0xf012cd74
f0117221:	68 0b 08 00 00       	push   $0x80b
f0117226:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011722b:	e8 a6 92 fe ff       	call   f01004d6 <_warn>
f0117230:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117233:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0117237:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011723d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117240:	74 28                	je     f011726a <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117242:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0117248:	83 ec 0c             	sub    $0xc,%esp
f011724b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011724e:	50                   	push   %eax
f011724f:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0117254:	68 10 08 00 00       	push   $0x810
f0117259:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011725e:	e8 73 92 fe ff       	call   f01004d6 <_warn>
f0117263:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117266:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011726a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011726e:	74 04                	je     f0117274 <test_calculate_allocated_space+0xc75>
f0117270:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117274:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0117278:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011727f:	00 00 00 
		num_pages = 0;
f0117282:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0117289:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011728c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011728f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0117294:	89 c2                	mov    %eax,%edx
f0117296:	83 ec 0c             	sub    $0xc,%esp
f0117299:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011729f:	50                   	push   %eax
f01172a0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01172a6:	50                   	push   %eax
f01172a7:	52                   	push   %edx
f01172a8:	68 ff ff 3f 00       	push   $0x3fffff
f01172ad:	ff 75 d8             	pushl  -0x28(%ebp)
f01172b0:	e8 38 3d ff ff       	call   f010afed <calculate_allocated_space>
f01172b5:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01172b8:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01172bf:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01172c6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01172cc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01172cf:	74 28                	je     f01172f9 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01172d1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01172d7:	83 ec 0c             	sub    $0xc,%esp
f01172da:	ff 75 c8             	pushl  -0x38(%ebp)
f01172dd:	50                   	push   %eax
f01172de:	68 74 cd 12 f0       	push   $0xf012cd74
f01172e3:	68 1e 08 00 00       	push   $0x81e
f01172e8:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01172ed:	e8 e4 91 fe ff       	call   f01004d6 <_warn>
f01172f2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01172f5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01172f9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01172ff:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0117302:	74 28                	je     f011732c <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0117304:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011730a:	83 ec 0c             	sub    $0xc,%esp
f011730d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0117310:	50                   	push   %eax
f0117311:	68 d4 cd 12 f0       	push   $0xf012cdd4
f0117316:	68 23 08 00 00       	push   $0x823
f011731b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117320:	e8 b1 91 fe ff       	call   f01004d6 <_warn>
f0117325:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0117328:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011732c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0117330:	74 04                	je     f0117336 <test_calculate_allocated_space+0xd37>
f0117332:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0117336:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011733a:	83 ec 0c             	sub    $0xc,%esp
f011733d:	68 4f bd 12 f0       	push   $0xf012bd4f
f0117342:	e8 44 9c fe ff       	call   f0100f8b <cprintf>
f0117347:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011734a:	83 ec 08             	sub    $0x8,%esp
f011734d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117350:	68 30 ce 12 f0       	push   $0xf012ce30
f0117355:	e8 31 9c fe ff       	call   f0100f8b <cprintf>
f011735a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011735d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0117361:	75 10                	jne    f0117373 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0117363:	83 ec 0c             	sub    $0xc,%esp
f0117366:	68 70 ce 12 f0       	push   $0xf012ce70
f011736b:	e8 1b 9c fe ff       	call   f0100f8b <cprintf>
f0117370:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0117373:	a1 c8 5f 74 f0       	mov    0xf0745fc8,%eax
f0117378:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011737b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011737e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0117381:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117386:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0117389:	5b                   	pop    %ebx
f011738a:	5e                   	pop    %esi
f011738b:	5f                   	pop    %edi
f011738c:	5d                   	pop    %ebp
f011738d:	c3                   	ret    

f011738e <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f011738e:	55                   	push   %ebp
f011738f:	89 e5                	mov    %esp,%ebp
f0117391:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0117394:	8b 45 10             	mov    0x10(%ebp),%eax
f0117397:	ba 01 00 00 00       	mov    $0x1,%edx
f011739c:	88 c1                	mov    %al,%cl
f011739e:	d3 e2                	shl    %cl,%edx
f01173a0:	89 d0                	mov    %edx,%eax
f01173a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01173a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01173a8:	c1 e8 16             	shr    $0x16,%eax
f01173ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01173b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01173b5:	01 d0                	add    %edx,%eax
f01173b7:	8b 00                	mov    (%eax),%eax
f01173b9:	83 e0 01             	and    $0x1,%eax
f01173bc:	85 c0                	test   %eax,%eax
f01173be:	75 07                	jne    f01173c7 <CB+0x39>
f01173c0:	b8 00 00 00 00       	mov    $0x0,%eax
f01173c5:	eb 76                	jmp    f011743d <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01173c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01173ca:	c1 e8 16             	shr    $0x16,%eax
f01173cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01173d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01173d7:	01 d0                	add    %edx,%eax
f01173d9:	8b 00                	mov    (%eax),%eax
f01173db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01173e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01173e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01173e6:	c1 e8 0c             	shr    $0xc,%eax
f01173e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01173ec:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f01173f1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01173f4:	72 17                	jb     f011740d <CB+0x7f>
f01173f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01173f9:	68 bc ce 12 f0       	push   $0xf012cebc
f01173fe:	68 3e 08 00 00       	push   $0x83e
f0117403:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117408:	e8 2c 8f fe ff       	call   f0100339 <_panic>
f011740d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117410:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0117415:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0117418:	8b 45 0c             	mov    0xc(%ebp),%eax
f011741b:	c1 e8 0c             	shr    $0xc,%eax
f011741e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0117423:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011742a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011742d:	01 d0                	add    %edx,%eax
f011742f:	8b 00                	mov    (%eax),%eax
f0117431:	23 45 f4             	and    -0xc(%ebp),%eax
f0117434:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0117437:	0f 94 c0             	sete   %al
f011743a:	0f b6 c0             	movzbl %al,%eax
}
f011743d:	c9                   	leave  
f011743e:	c3                   	ret    

f011743f <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011743f:	55                   	push   %ebp
f0117440:	89 e5                	mov    %esp,%ebp
f0117442:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117445:	68 eb ce 12 f0       	push   $0xf012ceeb
f011744a:	68 fa ce 12 f0       	push   $0xf012cefa
f011744f:	68 43 08 00 00       	push   $0x843
f0117454:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117459:	e8 db 8e fe ff       	call   f0100339 <_panic>

f011745e <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f011745e:	55                   	push   %ebp
f011745f:	89 e5                	mov    %esp,%ebp
f0117461:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117464:	68 eb ce 12 f0       	push   $0xf012ceeb
f0117469:	68 fa ce 12 f0       	push   $0xf012cefa
f011746e:	68 4d 08 00 00       	push   $0x84d
f0117473:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117478:	e8 bc 8e fe ff       	call   f0100339 <_panic>

f011747d <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f011747d:	55                   	push   %ebp
f011747e:	89 e5                	mov    %esp,%ebp
f0117480:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117483:	68 eb ce 12 f0       	push   $0xf012ceeb
f0117488:	68 fa ce 12 f0       	push   $0xf012cefa
f011748d:	68 5c 08 00 00       	push   $0x85c
f0117492:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117497:	e8 9d 8e fe ff       	call   f0100339 <_panic>

f011749c <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f011749c:	55                   	push   %ebp
f011749d:	89 e5                	mov    %esp,%ebp
f011749f:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01174a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01174a5:	c1 e8 16             	shr    $0x16,%eax
f01174a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01174af:	8b 45 08             	mov    0x8(%ebp),%eax
f01174b2:	01 d0                	add    %edx,%eax
f01174b4:	8b 00                	mov    (%eax),%eax
f01174b6:	83 e0 01             	and    $0x1,%eax
f01174b9:	85 c0                	test   %eax,%eax
f01174bb:	75 07                	jne    f01174c4 <CE+0x28>
f01174bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01174c2:	eb 7a                	jmp    f011753e <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01174c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01174c7:	c1 e8 16             	shr    $0x16,%eax
f01174ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01174d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01174d4:	01 d0                	add    %edx,%eax
f01174d6:	8b 00                	mov    (%eax),%eax
f01174d8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01174dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01174e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01174e3:	c1 e8 0c             	shr    $0xc,%eax
f01174e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01174e9:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f01174ee:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01174f1:	72 17                	jb     f011750a <CE+0x6e>
f01174f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01174f6:	68 bc ce 12 f0       	push   $0xf012cebc
f01174fb:	68 65 08 00 00       	push   $0x865
f0117500:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117505:	e8 2f 8e fe ff       	call   f0100339 <_panic>
f011750a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011750d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0117512:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0117515:	8b 45 0c             	mov    0xc(%ebp),%eax
f0117518:	c1 e8 0c             	shr    $0xc,%eax
f011751b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0117520:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117527:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011752a:	01 d0                	add    %edx,%eax
f011752c:	8b 00                	mov    (%eax),%eax
f011752e:	85 c0                	test   %eax,%eax
f0117530:	74 07                	je     f0117539 <CE+0x9d>
f0117532:	b8 00 00 00 00       	mov    $0x0,%eax
f0117537:	eb 05                	jmp    f011753e <CE+0xa2>
	return 1;
f0117539:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011753e:	c9                   	leave  
f011753f:	c3                   	ret    

f0117540 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0117540:	55                   	push   %ebp
f0117541:	89 e5                	mov    %esp,%ebp
f0117543:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117546:	68 eb ce 12 f0       	push   $0xf012ceeb
f011754b:	68 fa ce 12 f0       	push   $0xf012cefa
f0117550:	68 6c 08 00 00       	push   $0x86c
f0117555:	68 c2 b3 12 f0       	push   $0xf012b3c2
f011755a:	e8 da 8d fe ff       	call   f0100339 <_panic>

f011755f <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f011755f:	55                   	push   %ebp
f0117560:	89 e5                	mov    %esp,%ebp
f0117562:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117565:	68 eb ce 12 f0       	push   $0xf012ceeb
f011756a:	68 fa ce 12 f0       	push   $0xf012cefa
f011756f:	68 7c 08 00 00       	push   $0x87c
f0117574:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117579:	e8 bb 8d fe ff       	call   f0100339 <_panic>

f011757e <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f011757e:	55                   	push   %ebp
f011757f:	89 e5                	mov    %esp,%ebp
f0117581:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0117584:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011758b:	eb 18                	jmp    f01175a5 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f011758d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0117590:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117597:	8b 45 08             	mov    0x8(%ebp),%eax
f011759a:	01 d0                	add    %edx,%eax
f011759c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f01175a2:	ff 45 fc             	incl   -0x4(%ebp)
f01175a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01175a8:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f01175ad:	76 de                	jbe    f011758d <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f01175af:	90                   	nop
f01175b0:	c9                   	leave  
f01175b1:	c3                   	ret    

f01175b2 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f01175b2:	55                   	push   %ebp
f01175b3:	89 e5                	mov    %esp,%ebp
f01175b5:	83 ec 38             	sub    $0x38,%esp
f01175b8:	8b 45 2c             	mov    0x2c(%ebp),%eax
f01175bb:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f01175be:	8b 45 0c             	mov    0xc(%ebp),%eax
f01175c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01175c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f01175c9:	8b 45 10             	mov    0x10(%ebp),%eax
f01175cc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01175d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01175d4:	e9 ea 01 00 00       	jmp    f01177c3 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f01175d9:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01175dd:	74 44                	je     f0117623 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f01175df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01175e2:	83 ec 04             	sub    $0x4,%esp
f01175e5:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01175e8:	52                   	push   %edx
f01175e9:	50                   	push   %eax
f01175ea:	ff 75 08             	pushl  0x8(%ebp)
f01175ed:	e8 71 18 ff ff       	call   f0108e63 <get_frame_info>
f01175f2:	83 c4 10             	add    $0x10,%esp
f01175f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f01175f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01175fb:	85 c0                	test   %eax,%eax
f01175fd:	75 24                	jne    f0117623 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f01175ff:	83 ec 04             	sub    $0x4,%esp
f0117602:	68 10 cf 12 f0       	push   $0xf012cf10
f0117607:	68 99 08 00 00       	push   $0x899
f011760c:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117611:	e8 c0 8e fe ff       	call   f01004d6 <_warn>
f0117616:	83 c4 10             	add    $0x10,%esp
				return 0;
f0117619:	b8 00 00 00 00       	mov    $0x0,%eax
f011761e:	e9 b6 01 00 00       	jmp    f01177d9 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0117623:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117626:	83 ec 04             	sub    $0x4,%esp
f0117629:	8d 55 d8             	lea    -0x28(%ebp),%edx
f011762c:	52                   	push   %edx
f011762d:	50                   	push   %eax
f011762e:	ff 75 08             	pushl  0x8(%ebp)
f0117631:	e8 2d 18 ff ff       	call   f0108e63 <get_frame_info>
f0117636:	83 c4 10             	add    $0x10,%esp
f0117639:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f011763c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011763f:	85 c0                	test   %eax,%eax
f0117641:	75 24                	jne    f0117667 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0117643:	83 ec 04             	sub    $0x4,%esp
f0117646:	68 3c cf 12 f0       	push   $0xf012cf3c
f011764b:	68 a0 08 00 00       	push   $0x8a0
f0117650:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117655:	e8 7c 8e fe ff       	call   f01004d6 <_warn>
f011765a:	83 c4 10             	add    $0x10,%esp
			return 0;
f011765d:	b8 00 00 00 00       	mov    $0x0,%eax
f0117662:	e9 72 01 00 00       	jmp    f01177d9 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0117667:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011766b:	75 70                	jne    f01176dd <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011766d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117670:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117673:	c1 ea 0c             	shr    $0xc,%edx
f0117676:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011767c:	c1 e2 02             	shl    $0x2,%edx
f011767f:	01 d0                	add    %edx,%eax
f0117681:	8b 00                	mov    (%eax),%eax
f0117683:	c1 e8 0c             	shr    $0xc,%eax
f0117686:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0117689:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011768c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011768f:	c1 ea 0c             	shr    $0xc,%edx
f0117692:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117698:	c1 e2 02             	shl    $0x2,%edx
f011769b:	01 d0                	add    %edx,%eax
f011769d:	8b 00                	mov    (%eax),%eax
f011769f:	c1 e8 0c             	shr    $0xc,%eax
f01176a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f01176a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01176a8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01176ab:	74 30                	je     f01176dd <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f01176ad:	83 ec 04             	sub    $0x4,%esp
f01176b0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01176b3:	ff 75 e8             	pushl  -0x18(%ebp)
f01176b6:	ff 75 f0             	pushl  -0x10(%ebp)
f01176b9:	ff 75 f4             	pushl  -0xc(%ebp)
f01176bc:	68 68 cf 12 f0       	push   $0xf012cf68
f01176c1:	68 aa 08 00 00       	push   $0x8aa
f01176c6:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01176cb:	e8 06 8e fe ff       	call   f01004d6 <_warn>
f01176d0:	83 c4 20             	add    $0x20,%esp
				return 0;
f01176d3:	b8 00 00 00 00       	mov    $0x0,%eax
f01176d8:	e9 fc 00 00 00       	jmp    f01177d9 <CCP+0x227>
			}
		}
		if (ref != -1)
f01176dd:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f01176e1:	74 52                	je     f0117735 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f01176e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01176e7:	74 0e                	je     f01176f7 <CCP+0x145>
f01176e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01176ec:	8b 40 08             	mov    0x8(%eax),%eax
f01176ef:	0f b7 c0             	movzwl %ax,%eax
f01176f2:	3b 45 18             	cmp    0x18(%ebp),%eax
f01176f5:	74 3e                	je     f0117735 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f01176f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01176fb:	74 0b                	je     f0117708 <CCP+0x156>
f01176fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117700:	8b 40 08             	mov    0x8(%eax),%eax
f0117703:	0f b7 c0             	movzwl %ax,%eax
f0117706:	eb 05                	jmp    f011770d <CCP+0x15b>
f0117708:	b8 00 00 00 00       	mov    $0x0,%eax
f011770d:	83 ec 0c             	sub    $0xc,%esp
f0117710:	50                   	push   %eax
f0117711:	ff 75 f0             	pushl  -0x10(%ebp)
f0117714:	68 c4 cf 12 f0       	push   $0xf012cfc4
f0117719:	68 b2 08 00 00       	push   $0x8b2
f011771e:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117723:	e8 ae 8d fe ff       	call   f01004d6 <_warn>
f0117728:	83 c4 20             	add    $0x20,%esp
				return 0;
f011772b:	b8 00 00 00 00       	mov    $0x0,%eax
f0117730:	e9 a4 00 00 00       	jmp    f01177d9 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0117735:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117738:	ff 75 20             	pushl  0x20(%ebp)
f011773b:	ff 75 1c             	pushl  0x1c(%ebp)
f011773e:	50                   	push   %eax
f011773f:	ff 75 08             	pushl  0x8(%ebp)
f0117742:	e8 17 fd ff ff       	call   f011745e <CPs>
f0117747:	83 c4 10             	add    $0x10,%esp
f011774a:	85 c0                	test   %eax,%eax
f011774c:	7f 21                	jg     f011776f <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011774e:	83 ec 04             	sub    $0x4,%esp
f0117751:	68 34 d0 12 f0       	push   $0xf012d034
f0117756:	68 b8 08 00 00       	push   $0x8b8
f011775b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f0117760:	e8 71 8d fe ff       	call   f01004d6 <_warn>
f0117765:	83 c4 10             	add    $0x10,%esp
			return 0;
f0117768:	b8 00 00 00 00       	mov    $0x0,%eax
f011776d:	eb 6a                	jmp    f01177d9 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f011776f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117773:	74 3a                	je     f01177af <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0117775:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117778:	ff 75 28             	pushl  0x28(%ebp)
f011777b:	ff 75 24             	pushl  0x24(%ebp)
f011777e:	50                   	push   %eax
f011777f:	ff 75 08             	pushl  0x8(%ebp)
f0117782:	e8 d7 fc ff ff       	call   f011745e <CPs>
f0117787:	83 c4 10             	add    $0x10,%esp
f011778a:	85 c0                	test   %eax,%eax
f011778c:	7f 21                	jg     f01177af <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f011778e:	83 ec 04             	sub    $0x4,%esp
f0117791:	68 7c d0 12 f0       	push   $0xf012d07c
f0117796:	68 bf 08 00 00       	push   $0x8bf
f011779b:	68 c2 b3 12 f0       	push   $0xf012b3c2
f01177a0:	e8 31 8d fe ff       	call   f01004d6 <_warn>
f01177a5:	83 c4 10             	add    $0x10,%esp
				return 0;
f01177a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01177ad:	eb 2a                	jmp    f01177d9 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f01177af:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01177b3:	74 07                	je     f01177bc <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f01177b5:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f01177bc:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f01177c3:	8b 55 10             	mov    0x10(%ebp),%edx
f01177c6:	8b 45 14             	mov    0x14(%ebp),%eax
f01177c9:	01 d0                	add    %edx,%eax
f01177cb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01177ce:	0f 87 05 fe ff ff    	ja     f01175d9 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f01177d4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01177d9:	c9                   	leave  
f01177da:	c3                   	ret    

f01177db <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f01177db:	55                   	push   %ebp
f01177dc:	89 e5                	mov    %esp,%ebp
f01177de:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01177e1:	83 ec 04             	sub    $0x4,%esp
f01177e4:	68 bc d0 12 f0       	push   $0xf012d0bc
f01177e9:	6a 0e                	push   $0xe
f01177eb:	68 cc d0 12 f0       	push   $0xf012d0cc
f01177f0:	e8 44 8b fe ff       	call   f0100339 <_panic>

f01177f5 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f01177f5:	55                   	push   %ebp
f01177f6:	89 e5                	mov    %esp,%ebp
f01177f8:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01177fb:	83 ec 04             	sub    $0x4,%esp
f01177fe:	68 bc d0 12 f0       	push   $0xf012d0bc
f0117803:	68 d7 00 00 00       	push   $0xd7
f0117808:	68 cc d0 12 f0       	push   $0xf012d0cc
f011780d:	e8 27 8b fe ff       	call   f0100339 <_panic>

f0117812 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0117812:	55                   	push   %ebp
f0117813:	89 e5                	mov    %esp,%ebp
f0117815:	57                   	push   %edi
f0117816:	53                   	push   %ebx
f0117817:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011781d:	83 ec 0c             	sub    $0xc,%esp
f0117820:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0117825:	e8 61 97 fe ff       	call   f0100f8b <cprintf>
f011782a:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011782d:	83 ec 0c             	sub    $0xc,%esp
f0117830:	68 18 d1 12 f0       	push   $0xf012d118
f0117835:	e8 51 97 fe ff       	call   f0100f8b <cprintf>
f011783a:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011783d:	83 ec 0c             	sub    $0xc,%esp
f0117840:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0117845:	e8 41 97 fe ff       	call   f0100f8b <cprintf>
f011784a:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011784d:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0117851:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0117855:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f011785b:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0117861:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0117868:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011786f:	e8 c0 75 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117874:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0117877:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011787e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0117885:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f011788b:	b9 14 00 00 00       	mov    $0x14,%ecx
f0117890:	b8 00 00 00 00       	mov    $0x0,%eax
f0117895:	89 d7                	mov    %edx,%edi
f0117897:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0117899:	83 ec 0c             	sub    $0xc,%esp
f011789c:	68 71 d1 12 f0       	push   $0xf012d171
f01178a1:	e8 e5 96 fe ff       	call   f0100f8b <cprintf>
f01178a6:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01178a9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f01178b0:	e8 7f 75 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01178b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01178b8:	e8 fb d1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01178bd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f01178c0:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f01178c7:	83 ec 0c             	sub    $0xc,%esp
f01178ca:	ff 75 cc             	pushl  -0x34(%ebp)
f01178cd:	e8 98 23 ff ff       	call   f0109c6a <kmalloc>
f01178d2:	83 c4 10             	add    $0x10,%esp
f01178d5:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f01178db:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01178e1:	85 c0                	test   %eax,%eax
f01178e3:	74 17                	je     f01178fc <test_kmalloc+0xea>
f01178e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178ec:	83 ec 0c             	sub    $0xc,%esp
f01178ef:	68 90 d1 12 f0       	push   $0xf012d190
f01178f4:	e8 92 96 fe ff       	call   f0100f8b <cprintf>
f01178f9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178fc:	e8 b7 d1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117901:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117904:	74 17                	je     f011791d <test_kmalloc+0x10b>
f0117906:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011790d:	83 ec 0c             	sub    $0xc,%esp
f0117910:	68 c4 d1 12 f0       	push   $0xf012d1c4
f0117915:	e8 71 96 fe ff       	call   f0100f8b <cprintf>
f011791a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011791d:	e8 12 75 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117922:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0117925:	74 17                	je     f011793e <test_kmalloc+0x12c>
f0117927:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011792e:	83 ec 0c             	sub    $0xc,%esp
f0117931:	68 30 d2 12 f0       	push   $0xf012d230
f0117936:	e8 50 96 fe ff       	call   f0100f8b <cprintf>
f011793b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011793e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117942:	74 04                	je     f0117948 <test_kmalloc+0x136>
f0117944:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0117948:	83 ec 0c             	sub    $0xc,%esp
f011794b:	68 74 d2 12 f0       	push   $0xf012d274
f0117950:	e8 36 96 fe ff       	call   f0100f8b <cprintf>
f0117955:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117958:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011795f:	e8 d0 74 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117964:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117967:	e8 4c d1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011796c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011796f:	83 ec 0c             	sub    $0xc,%esp
f0117972:	68 00 fc 1f 00       	push   $0x1ffc00
f0117977:	e8 ee 22 ff ff       	call   f0109c6a <kmalloc>
f011797c:	83 c4 10             	add    $0x10,%esp
f011797f:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117985:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011798b:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117990:	74 17                	je     f01179a9 <test_kmalloc+0x197>
f0117992:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117999:	83 ec 0c             	sub    $0xc,%esp
f011799c:	68 b8 d2 12 f0       	push   $0xf012d2b8
f01179a1:	e8 e5 95 fe ff       	call   f0100f8b <cprintf>
f01179a6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179a9:	e8 0a d1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01179ae:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01179b1:	74 17                	je     f01179ca <test_kmalloc+0x1b8>
f01179b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179ba:	83 ec 0c             	sub    $0xc,%esp
f01179bd:	68 0c d3 12 f0       	push   $0xf012d30c
f01179c2:	e8 c4 95 fe ff       	call   f0100f8b <cprintf>
f01179c7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01179ca:	e8 65 74 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01179cf:	89 c2                	mov    %eax,%edx
f01179d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01179d4:	29 d0                	sub    %edx,%eax
f01179d6:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01179db:	7f 17                	jg     f01179f4 <test_kmalloc+0x1e2>
f01179dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179e4:	83 ec 0c             	sub    $0xc,%esp
f01179e7:	68 78 d3 12 f0       	push   $0xf012d378
f01179ec:	e8 9a 95 fe ff       	call   f0100f8b <cprintf>
f01179f1:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01179f4:	e8 3b 74 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01179f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179fc:	e8 b7 d0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117a01:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0117a04:	83 ec 0c             	sub    $0xc,%esp
f0117a07:	68 00 fc 1f 00       	push   $0x1ffc00
f0117a0c:	e8 59 22 ff ff       	call   f0109c6a <kmalloc>
f0117a11:	83 c4 10             	add    $0x10,%esp
f0117a14:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117a1a:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117a20:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0117a25:	74 17                	je     f0117a3e <test_kmalloc+0x22c>
f0117a27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a2e:	83 ec 0c             	sub    $0xc,%esp
f0117a31:	68 bc d3 12 f0       	push   $0xf012d3bc
f0117a36:	e8 50 95 fe ff       	call   f0100f8b <cprintf>
f0117a3b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a3e:	e8 75 d0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117a43:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117a46:	74 17                	je     f0117a5f <test_kmalloc+0x24d>
f0117a48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a4f:	83 ec 0c             	sub    $0xc,%esp
f0117a52:	68 10 d4 12 f0       	push   $0xf012d410
f0117a57:	e8 2f 95 fe ff       	call   f0100f8b <cprintf>
f0117a5c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117a5f:	e8 d0 73 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117a64:	89 c2                	mov    %eax,%edx
f0117a66:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117a69:	29 d0                	sub    %edx,%eax
f0117a6b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117a70:	7f 17                	jg     f0117a89 <test_kmalloc+0x277>
f0117a72:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a79:	83 ec 0c             	sub    $0xc,%esp
f0117a7c:	68 7c d4 12 f0       	push   $0xf012d47c
f0117a81:	e8 05 95 fe ff       	call   f0100f8b <cprintf>
f0117a86:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0117a89:	e8 a6 73 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117a8e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a91:	e8 22 d0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117a96:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0117a99:	83 ec 0c             	sub    $0xc,%esp
f0117a9c:	68 ff 07 00 00       	push   $0x7ff
f0117aa1:	e8 c4 21 ff ff       	call   f0109c6a <kmalloc>
f0117aa6:	83 c4 10             	add    $0x10,%esp
f0117aa9:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0117aaf:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117ab5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117aba:	76 28                	jbe    f0117ae4 <test_kmalloc+0x2d2>
f0117abc:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0117ac2:	83 ec 0c             	sub    $0xc,%esp
f0117ac5:	6a 00                	push   $0x0
f0117ac7:	e8 af 20 ff ff       	call   f0109b7b <sbrk>
f0117acc:	83 c4 10             	add    $0x10,%esp
f0117acf:	39 c3                	cmp    %eax,%ebx
f0117ad1:	73 11                	jae    f0117ae4 <test_kmalloc+0x2d2>
f0117ad3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117ad9:	89 c2                	mov    %eax,%edx
f0117adb:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f0117ae0:	39 c2                	cmp    %eax,%edx
f0117ae2:	72 17                	jb     f0117afb <test_kmalloc+0x2e9>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117aeb:	83 ec 0c             	sub    $0xc,%esp
f0117aee:	68 c0 d4 12 f0       	push   $0xf012d4c0
f0117af3:	e8 93 94 fe ff       	call   f0100f8b <cprintf>
f0117af8:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117afb:	e8 b8 cf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117b00:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117b03:	74 17                	je     f0117b1c <test_kmalloc+0x30a>
f0117b05:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b0c:	83 ec 0c             	sub    $0xc,%esp
f0117b0f:	68 4c d5 12 f0       	push   $0xf012d54c
f0117b14:	e8 72 94 fe ff       	call   f0100f8b <cprintf>
f0117b19:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b1c:	e8 97 cf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117b21:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0117b24:	83 ec 0c             	sub    $0xc,%esp
f0117b27:	68 ff 07 00 00       	push   $0x7ff
f0117b2c:	e8 39 21 ff ff       	call   f0109c6a <kmalloc>
f0117b31:	83 c4 10             	add    $0x10,%esp
f0117b34:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0117b3a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117b40:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117b45:	76 28                	jbe    f0117b6f <test_kmalloc+0x35d>
f0117b47:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0117b4d:	83 ec 0c             	sub    $0xc,%esp
f0117b50:	6a 00                	push   $0x0
f0117b52:	e8 24 20 ff ff       	call   f0109b7b <sbrk>
f0117b57:	83 c4 10             	add    $0x10,%esp
f0117b5a:	39 c3                	cmp    %eax,%ebx
f0117b5c:	73 11                	jae    f0117b6f <test_kmalloc+0x35d>
f0117b5e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117b64:	89 c2                	mov    %eax,%edx
f0117b66:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f0117b6b:	39 c2                	cmp    %eax,%edx
f0117b6d:	72 17                	jb     f0117b86 <test_kmalloc+0x374>
			{ correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117b6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b76:	83 ec 0c             	sub    $0xc,%esp
f0117b79:	68 b8 d5 12 f0       	push   $0xf012d5b8
f0117b7e:	e8 08 94 fe ff       	call   f0100f8b <cprintf>
f0117b83:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b86:	e8 2d cf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117b8b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117b8e:	74 17                	je     f0117ba7 <test_kmalloc+0x395>
f0117b90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b97:	83 ec 0c             	sub    $0xc,%esp
f0117b9a:	68 44 d6 12 f0       	push   $0xf012d644
f0117b9f:	e8 e7 93 fe ff       	call   f0100f8b <cprintf>
f0117ba4:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n"); }
f0117ba7:	e8 88 72 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117bac:	89 c2                	mov    %eax,%edx
f0117bae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117bb1:	29 d0                	sub    %edx,%eax
f0117bb3:	83 f8 01             	cmp    $0x1,%eax
f0117bb6:	74 17                	je     f0117bcf <test_kmalloc+0x3bd>
f0117bb8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117bbf:	83 ec 0c             	sub    $0xc,%esp
f0117bc2:	68 b0 d6 12 f0       	push   $0xf012d6b0
f0117bc7:	e8 bf 93 fe ff       	call   f0100f8b <cprintf>
f0117bcc:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bcf:	e8 60 72 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117bd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117bd7:	e8 dc ce fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117bdc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0117bdf:	83 ec 0c             	sub    $0xc,%esp
f0117be2:	68 00 1c 00 00       	push   $0x1c00
f0117be7:	e8 7e 20 ff ff       	call   f0109c6a <kmalloc>
f0117bec:	83 c4 10             	add    $0x10,%esp
f0117bef:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117bf5:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117bfb:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117c00:	74 17                	je     f0117c19 <test_kmalloc+0x407>
f0117c02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c09:	83 ec 0c             	sub    $0xc,%esp
f0117c0c:	68 d0 d6 12 f0       	push   $0xf012d6d0
f0117c11:	e8 75 93 fe ff       	call   f0100f8b <cprintf>
f0117c16:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c19:	e8 9a ce fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117c1e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117c21:	74 17                	je     f0117c3a <test_kmalloc+0x428>
f0117c23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c2a:	83 ec 0c             	sub    $0xc,%esp
f0117c2d:	68 24 d7 12 f0       	push   $0xf012d724
f0117c32:	e8 54 93 fe ff       	call   f0100f8b <cprintf>
f0117c37:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117c3a:	e8 f5 71 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117c3f:	89 c2                	mov    %eax,%edx
f0117c41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117c44:	29 d0                	sub    %edx,%eax
f0117c46:	83 f8 01             	cmp    $0x1,%eax
f0117c49:	7f 17                	jg     f0117c62 <test_kmalloc+0x450>
f0117c4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c52:	83 ec 0c             	sub    $0xc,%esp
f0117c55:	68 90 d7 12 f0       	push   $0xf012d790
f0117c5a:	e8 2c 93 fe ff       	call   f0100f8b <cprintf>
f0117c5f:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c62:	e8 cd 71 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117c67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c6a:	e8 49 ce fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117c6f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f0117c72:	83 ec 0c             	sub    $0xc,%esp
f0117c75:	68 00 fc 2f 00       	push   $0x2ffc00
f0117c7a:	e8 eb 1f ff ff       	call   f0109c6a <kmalloc>
f0117c7f:	83 c4 10             	add    $0x10,%esp
f0117c82:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117c88:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0117c8e:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117c93:	74 17                	je     f0117cac <test_kmalloc+0x49a>
f0117c95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c9c:	83 ec 0c             	sub    $0xc,%esp
f0117c9f:	68 d4 d7 12 f0       	push   $0xf012d7d4
f0117ca4:	e8 e2 92 fe ff       	call   f0100f8b <cprintf>
f0117ca9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117cac:	e8 07 ce fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117cb1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117cb4:	74 17                	je     f0117ccd <test_kmalloc+0x4bb>
f0117cb6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cbd:	83 ec 0c             	sub    $0xc,%esp
f0117cc0:	68 28 d8 12 f0       	push   $0xf012d828
f0117cc5:	e8 c1 92 fe ff       	call   f0100f8b <cprintf>
f0117cca:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117ccd:	e8 62 71 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117cd2:	89 c2                	mov    %eax,%edx
f0117cd4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117cd7:	29 d0                	sub    %edx,%eax
f0117cd9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117cde:	7f 17                	jg     f0117cf7 <test_kmalloc+0x4e5>
f0117ce0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ce7:	83 ec 0c             	sub    $0xc,%esp
f0117cea:	68 94 d8 12 f0       	push   $0xf012d894
f0117cef:	e8 97 92 fe ff       	call   f0100f8b <cprintf>
f0117cf4:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117cf7:	e8 38 71 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117cfc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117cff:	e8 b4 cd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117d04:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f0117d07:	83 ec 0c             	sub    $0xc,%esp
f0117d0a:	68 00 fc 5f 00       	push   $0x5ffc00
f0117d0f:	e8 56 1f ff ff       	call   f0109c6a <kmalloc>
f0117d14:	83 c4 10             	add    $0x10,%esp
f0117d17:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117d1d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117d23:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0117d28:	74 17                	je     f0117d41 <test_kmalloc+0x52f>
f0117d2a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d31:	83 ec 0c             	sub    $0xc,%esp
f0117d34:	68 d8 d8 12 f0       	push   $0xf012d8d8
f0117d39:	e8 4d 92 fe ff       	call   f0100f8b <cprintf>
f0117d3e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117d41:	e8 72 cd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117d46:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117d49:	74 17                	je     f0117d62 <test_kmalloc+0x550>
f0117d4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d52:	83 ec 0c             	sub    $0xc,%esp
f0117d55:	68 2c d9 12 f0       	push   $0xf012d92c
f0117d5a:	e8 2c 92 fe ff       	call   f0100f8b <cprintf>
f0117d5f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117d62:	e8 cd 70 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117d67:	89 c2                	mov    %eax,%edx
f0117d69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117d6c:	29 d0                	sub    %edx,%eax
f0117d6e:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0117d73:	7f 17                	jg     f0117d8c <test_kmalloc+0x57a>
f0117d75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d7c:	83 ec 0c             	sub    $0xc,%esp
f0117d7f:	68 98 d9 12 f0       	push   $0xf012d998
f0117d84:	e8 02 92 fe ff       	call   f0100f8b <cprintf>
f0117d89:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117d8c:	e8 a3 70 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117d91:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117d94:	e8 1f cd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117d99:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0117d9c:	83 ec 0c             	sub    $0xc,%esp
f0117d9f:	68 00 38 00 00       	push   $0x3800
f0117da4:	e8 c1 1e ff ff       	call   f0109c6a <kmalloc>
f0117da9:	83 c4 10             	add    $0x10,%esp
f0117dac:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0117db2:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117db8:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0117dbd:	74 17                	je     f0117dd6 <test_kmalloc+0x5c4>
f0117dbf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dc6:	83 ec 0c             	sub    $0xc,%esp
f0117dc9:	68 dc d9 12 f0       	push   $0xf012d9dc
f0117dce:	e8 b8 91 fe ff       	call   f0100f8b <cprintf>
f0117dd3:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117dd6:	e8 dd cc fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117ddb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0117dde:	74 17                	je     f0117df7 <test_kmalloc+0x5e5>
f0117de0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117de7:	83 ec 0c             	sub    $0xc,%esp
f0117dea:	68 30 da 12 f0       	push   $0xf012da30
f0117def:	e8 97 91 fe ff       	call   f0100f8b <cprintf>
f0117df4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0117df7:	e8 38 70 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117dfc:	89 c2                	mov    %eax,%edx
f0117dfe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117e01:	29 d0                	sub    %edx,%eax
f0117e03:	83 f8 03             	cmp    $0x3,%eax
f0117e06:	7f 17                	jg     f0117e1f <test_kmalloc+0x60d>
f0117e08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117e0f:	83 ec 0c             	sub    $0xc,%esp
f0117e12:	68 9c da 12 f0       	push   $0xf012da9c
f0117e17:	e8 6f 91 fe ff       	call   f0100f8b <cprintf>
f0117e1c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117e1f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117e23:	74 04                	je     f0117e29 <test_kmalloc+0x617>
f0117e25:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0117e29:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f0117e30:	83 ec 0c             	sub    $0xc,%esp
f0117e33:	68 e0 da 12 f0       	push   $0xf012dae0
f0117e38:	e8 4e 91 fe ff       	call   f0100f8b <cprintf>
f0117e3d:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0117e40:	e8 ef 6f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0117e45:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117e48:	e8 6b cc fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0117e4d:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0117e50:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0117e57:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0117e5d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0117e60:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117e63:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117e66:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0117e68:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117e6b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117e6e:	01 c2                	add    %eax,%edx
f0117e70:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117e73:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0117e75:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0117e7b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0117e7e:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0117e85:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117e88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117e8b:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0117e8e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117e91:	01 c0                	add    %eax,%eax
f0117e93:	89 c2                	mov    %eax,%edx
f0117e95:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117e98:	01 c2                	add    %eax,%edx
f0117e9a:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117e9e:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f0117ea1:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0117ea7:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0117eaa:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f0117eb1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117eb4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117eb7:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0117eb9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117ebc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117ec3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117ec6:	01 c2                	add    %eax,%edx
f0117ec8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117ecb:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0117ecd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0117ed3:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0117ed6:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0117edd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117ee0:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117ee3:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0117ee5:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0117ee8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117eeb:	01 c2                	add    %eax,%edx
f0117eed:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117ef0:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f0117ef2:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0117ef8:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f0117efb:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f0117f02:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117f05:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117f08:	88 10                	mov    %dl,(%eax)
f0117f0a:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0117f0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117f10:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117f14:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117f17:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0117f1a:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f0117f1d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117f20:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117f27:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117f2a:	01 c2                	add    %eax,%edx
f0117f2c:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117f2f:	88 02                	mov    %al,(%edx)
f0117f31:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117f34:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117f3b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117f3e:	01 c2                	add    %eax,%edx
f0117f40:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117f44:	66 89 42 02          	mov    %ax,0x2(%edx)
f0117f48:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117f4b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0117f52:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117f55:	01 c2                	add    %eax,%edx
f0117f57:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117f5a:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0117f5d:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f0117f64:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0117f6a:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0117f6d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117f70:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0117f73:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0117f75:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117f78:	89 c2                	mov    %eax,%edx
f0117f7a:	c1 ea 1f             	shr    $0x1f,%edx
f0117f7d:	01 d0                	add    %edx,%eax
f0117f7f:	d1 f8                	sar    %eax
f0117f81:	89 c2                	mov    %eax,%edx
f0117f83:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117f86:	01 c2                	add    %eax,%edx
f0117f88:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117f8b:	88 c1                	mov    %al,%cl
f0117f8d:	c0 e9 07             	shr    $0x7,%cl
f0117f90:	01 c8                	add    %ecx,%eax
f0117f92:	d0 f8                	sar    %al
f0117f94:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0117f96:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117f99:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0117f9c:	01 c2                	add    %eax,%edx
f0117f9e:	8a 45 ea             	mov    -0x16(%ebp),%al
f0117fa1:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f0117fa3:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0117fa9:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0117fac:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f0117fb3:	8b 55 98             	mov    -0x68(%ebp),%edx
f0117fb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117fb9:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0117fbc:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0117fbf:	01 c0                	add    %eax,%eax
f0117fc1:	89 c2                	mov    %eax,%edx
f0117fc3:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117fc6:	01 c2                	add    %eax,%edx
f0117fc8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0117fcc:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f0117fcf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117fd2:	8a 00                	mov    (%eax),%al
f0117fd4:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0117fd7:	75 0f                	jne    f0117fe8 <test_kmalloc+0x7d6>
f0117fd9:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117fdc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0117fdf:	01 d0                	add    %edx,%eax
f0117fe1:	8a 00                	mov    (%eax),%al
f0117fe3:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0117fe6:	74 17                	je     f0117fff <test_kmalloc+0x7ed>
f0117fe8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117fef:	83 ec 0c             	sub    $0xc,%esp
f0117ff2:	68 18 db 12 f0       	push   $0xf012db18
f0117ff7:	e8 8f 8f fe ff       	call   f0100f8b <cprintf>
f0117ffc:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f0117fff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118002:	66 8b 00             	mov    (%eax),%ax
f0118005:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0118009:	75 15                	jne    f0118020 <test_kmalloc+0x80e>
f011800b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011800e:	01 c0                	add    %eax,%eax
f0118010:	89 c2                	mov    %eax,%edx
f0118012:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118015:	01 d0                	add    %edx,%eax
f0118017:	66 8b 00             	mov    (%eax),%ax
f011801a:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011801e:	74 17                	je     f0118037 <test_kmalloc+0x825>
f0118020:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118027:	83 ec 0c             	sub    $0xc,%esp
f011802a:	68 50 db 12 f0       	push   $0xf012db50
f011802f:	e8 57 8f fe ff       	call   f0100f8b <cprintf>
f0118034:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0118037:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011803a:	8b 00                	mov    (%eax),%eax
f011803c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011803f:	75 16                	jne    f0118057 <test_kmalloc+0x845>
f0118041:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118044:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011804b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011804e:	01 d0                	add    %edx,%eax
f0118050:	8b 00                	mov    (%eax),%eax
f0118052:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118055:	74 17                	je     f011806e <test_kmalloc+0x85c>
f0118057:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011805e:	83 ec 0c             	sub    $0xc,%esp
f0118061:	68 8c db 12 f0       	push   $0xf012db8c
f0118066:	e8 20 8f fe ff       	call   f0100f8b <cprintf>
f011806b:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f011806e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118071:	8a 00                	mov    (%eax),%al
f0118073:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118076:	75 0f                	jne    f0118087 <test_kmalloc+0x875>
f0118078:	8b 55 ac             	mov    -0x54(%ebp),%edx
f011807b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011807e:	01 d0                	add    %edx,%eax
f0118080:	8a 00                	mov    (%eax),%al
f0118082:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118085:	74 17                	je     f011809e <test_kmalloc+0x88c>
f0118087:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011808e:	83 ec 0c             	sub    $0xc,%esp
f0118091:	68 c8 db 12 f0       	push   $0xf012dbc8
f0118096:	e8 f0 8e fe ff       	call   f0100f8b <cprintf>
f011809b:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f011809e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01180a1:	8a 00                	mov    (%eax),%al
f01180a3:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01180a6:	75 16                	jne    f01180be <test_kmalloc+0x8ac>
f01180a8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01180ab:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01180b2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01180b5:	01 d0                	add    %edx,%eax
f01180b7:	8a 00                	mov    (%eax),%al
f01180b9:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01180bc:	74 17                	je     f01180d5 <test_kmalloc+0x8c3>
f01180be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01180c5:	83 ec 0c             	sub    $0xc,%esp
f01180c8:	68 04 dc 12 f0       	push   $0xf012dc04
f01180cd:	e8 b9 8e fe ff       	call   f0100f8b <cprintf>
f01180d2:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f01180d5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01180d8:	66 8b 40 02          	mov    0x2(%eax),%ax
f01180dc:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01180e0:	75 19                	jne    f01180fb <test_kmalloc+0x8e9>
f01180e2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01180e5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01180ec:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01180ef:	01 d0                	add    %edx,%eax
f01180f1:	66 8b 40 02          	mov    0x2(%eax),%ax
f01180f5:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01180f9:	74 17                	je     f0118112 <test_kmalloc+0x900>
f01180fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118102:	83 ec 0c             	sub    $0xc,%esp
f0118105:	68 40 dc 12 f0       	push   $0xf012dc40
f011810a:	e8 7c 8e fe ff       	call   f0100f8b <cprintf>
f011810f:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f0118112:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118115:	8b 40 04             	mov    0x4(%eax),%eax
f0118118:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011811b:	75 17                	jne    f0118134 <test_kmalloc+0x922>
f011811d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118120:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118127:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011812a:	01 d0                	add    %edx,%eax
f011812c:	8b 40 04             	mov    0x4(%eax),%eax
f011812f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118132:	74 17                	je     f011814b <test_kmalloc+0x939>
f0118134:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011813b:	83 ec 0c             	sub    $0xc,%esp
f011813e:	68 7c dc 12 f0       	push   $0xf012dc7c
f0118143:	e8 43 8e fe ff       	call   f0100f8b <cprintf>
f0118148:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011814b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011814e:	8a 00                	mov    (%eax),%al
f0118150:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118153:	75 34                	jne    f0118189 <test_kmalloc+0x977>
f0118155:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118158:	89 c2                	mov    %eax,%edx
f011815a:	c1 ea 1f             	shr    $0x1f,%edx
f011815d:	01 d0                	add    %edx,%eax
f011815f:	d1 f8                	sar    %eax
f0118161:	89 c2                	mov    %eax,%edx
f0118163:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118166:	01 d0                	add    %edx,%eax
f0118168:	8a 10                	mov    (%eax),%dl
f011816a:	8a 45 ea             	mov    -0x16(%ebp),%al
f011816d:	88 c1                	mov    %al,%cl
f011816f:	c0 e9 07             	shr    $0x7,%cl
f0118172:	01 c8                	add    %ecx,%eax
f0118174:	d0 f8                	sar    %al
f0118176:	38 c2                	cmp    %al,%dl
f0118178:	75 0f                	jne    f0118189 <test_kmalloc+0x977>
f011817a:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011817d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118180:	01 d0                	add    %edx,%eax
f0118182:	8a 00                	mov    (%eax),%al
f0118184:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118187:	74 17                	je     f01181a0 <test_kmalloc+0x98e>
f0118189:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118190:	83 ec 0c             	sub    $0xc,%esp
f0118193:	68 b8 dc 12 f0       	push   $0xf012dcb8
f0118198:	e8 ee 8d fe ff       	call   f0100f8b <cprintf>
f011819d:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f01181a0:	8b 45 98             	mov    -0x68(%ebp),%eax
f01181a3:	66 8b 00             	mov    (%eax),%ax
f01181a6:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01181aa:	75 15                	jne    f01181c1 <test_kmalloc+0x9af>
f01181ac:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01181af:	01 c0                	add    %eax,%eax
f01181b1:	89 c2                	mov    %eax,%edx
f01181b3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01181b6:	01 d0                	add    %edx,%eax
f01181b8:	66 8b 00             	mov    (%eax),%ax
f01181bb:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01181bf:	74 17                	je     f01181d8 <test_kmalloc+0x9c6>
f01181c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181c8:	83 ec 0c             	sub    $0xc,%esp
f01181cb:	68 f0 dc 12 f0       	push   $0xf012dcf0
f01181d0:	e8 b6 8d fe ff       	call   f0100f8b <cprintf>
f01181d5:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01181d8:	e8 57 6c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01181dd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01181e0:	74 17                	je     f01181f9 <test_kmalloc+0x9e7>
f01181e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01181e9:	83 ec 0c             	sub    $0xc,%esp
f01181ec:	68 2c dd 12 f0       	push   $0xf012dd2c
f01181f1:	e8 95 8d fe ff       	call   f0100f8b <cprintf>
f01181f6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01181f9:	e8 ba c8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01181fe:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118201:	74 17                	je     f011821a <test_kmalloc+0xa08>
f0118203:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011820a:	83 ec 0c             	sub    $0xc,%esp
f011820d:	68 70 dd 12 f0       	push   $0xf012dd70
f0118212:	e8 74 8d fe ff       	call   f0100f8b <cprintf>
f0118217:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f011821a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011821e:	74 04                	je     f0118224 <test_kmalloc+0xa12>
f0118220:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0118224:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f011822b:	83 ec 0c             	sub    $0xc,%esp
f011822e:	68 dc dd 12 f0       	push   $0xf012dddc
f0118233:	e8 53 8d fe ff       	call   f0100f8b <cprintf>
f0118238:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011823b:	e8 f4 6b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118240:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118243:	e8 70 c8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118248:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f011824b:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f0118252:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118255:	40                   	inc    %eax
f0118256:	83 ec 0c             	sub    $0xc,%esp
f0118259:	50                   	push   %eax
f011825a:	e8 0b 1a ff ff       	call   f0109c6a <kmalloc>
f011825f:	83 c4 10             	add    $0x10,%esp
f0118262:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0118268:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011826e:	85 c0                	test   %eax,%eax
f0118270:	74 17                	je     f0118289 <test_kmalloc+0xa77>
f0118272:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118279:	83 ec 0c             	sub    $0xc,%esp
f011827c:	68 00 de 12 f0       	push   $0xf012de00
f0118281:	e8 05 8d fe ff       	call   f0100f8b <cprintf>
f0118286:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118289:	e8 2a c8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011828e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118291:	74 17                	je     f01182aa <test_kmalloc+0xa98>
f0118293:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011829a:	83 ec 0c             	sub    $0xc,%esp
f011829d:	68 38 de 12 f0       	push   $0xf012de38
f01182a2:	e8 e4 8c fe ff       	call   f0100f8b <cprintf>
f01182a7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01182aa:	e8 85 6b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01182af:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01182b2:	74 17                	je     f01182cb <test_kmalloc+0xab9>
f01182b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182bb:	83 ec 0c             	sub    $0xc,%esp
f01182be:	68 a4 de 12 f0       	push   $0xf012dea4
f01182c3:	e8 c3 8c fe ff       	call   f0100f8b <cprintf>
f01182c8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01182cb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01182cf:	74 04                	je     f01182d5 <test_kmalloc+0xac3>
f01182d1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01182d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f01182dc:	83 ec 0c             	sub    $0xc,%esp
f01182df:	68 e8 de 12 f0       	push   $0xf012dee8
f01182e4:	e8 a2 8c fe ff       	call   f0100f8b <cprintf>
f01182e9:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f01182ec:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01182f2:	05 00 40 00 00       	add    $0x4000,%eax
f01182f7:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01182fa:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0118301:	eb 6a                	jmp    f011836d <test_kmalloc+0xb5b>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0118303:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0118308:	83 ec 04             	sub    $0x4,%esp
f011830b:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0118311:	52                   	push   %edx
f0118312:	ff 75 ec             	pushl  -0x14(%ebp)
f0118315:	50                   	push   %eax
f0118316:	e8 c5 07 ff ff       	call   f0108ae0 <get_page_table>
f011831b:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f011831e:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0118324:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118327:	c1 ea 0c             	shr    $0xc,%edx
f011832a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118330:	c1 e2 02             	shl    $0x2,%edx
f0118333:	01 d0                	add    %edx,%eax
f0118335:	8b 00                	mov    (%eax),%eax
f0118337:	25 ff 0f 00 00       	and    $0xfff,%eax
f011833c:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011833f:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118342:	83 e0 04             	and    $0x4,%eax
f0118345:	85 c0                	test   %eax,%eax
f0118347:	74 1d                	je     f0118366 <test_kmalloc+0xb54>
			{
				if (correct)
f0118349:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011834d:	74 17                	je     f0118366 <test_kmalloc+0xb54>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011834f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118356:	83 ec 0c             	sub    $0xc,%esp
f0118359:	68 2c df 12 f0       	push   $0xf012df2c
f011835e:	e8 28 8c fe ff       	call   f0100f8b <cprintf>
f0118363:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0118366:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f011836d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118370:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0118373:	72 8e                	jb     f0118303 <test_kmalloc+0xaf1>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0118375:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118379:	74 04                	je     f011837f <test_kmalloc+0xb6d>
f011837b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011837f:	83 ec 08             	sub    $0x8,%esp
f0118382:	ff 75 f4             	pushl  -0xc(%ebp)
f0118385:	68 7c df 12 f0       	push   $0xf012df7c
f011838a:	e8 fc 8b fe ff       	call   f0100f8b <cprintf>
f011838f:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118392:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0118397:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011839a:	5b                   	pop    %ebx
f011839b:	5f                   	pop    %edi
f011839c:	5d                   	pop    %ebp
f011839d:	c3                   	ret    

f011839e <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f011839e:	55                   	push   %ebp
f011839f:	89 e5                	mov    %esp,%ebp
f01183a1:	57                   	push   %edi
f01183a2:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01183a5:	83 ec 0c             	sub    $0xc,%esp
f01183a8:	68 e8 d0 12 f0       	push   $0xf012d0e8
f01183ad:	e8 d9 8b fe ff       	call   f0100f8b <cprintf>
f01183b2:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01183b5:	83 ec 0c             	sub    $0xc,%esp
f01183b8:	68 18 d1 12 f0       	push   $0xf012d118
f01183bd:	e8 c9 8b fe ff       	call   f0100f8b <cprintf>
f01183c2:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01183c5:	83 ec 0c             	sub    $0xc,%esp
f01183c8:	68 e8 d0 12 f0       	push   $0xf012d0e8
f01183cd:	e8 b9 8b fe ff       	call   f0100f8b <cprintf>
f01183d2:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01183d5:	8d 55 98             	lea    -0x68(%ebp),%edx
f01183d8:	b9 14 00 00 00       	mov    $0x14,%ecx
f01183dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01183e2:	89 d7                	mov    %edx,%edi
f01183e4:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01183e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01183ed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01183f4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f01183fb:	83 ec 0c             	sub    $0xc,%esp
f01183fe:	68 a8 df 12 f0       	push   $0xf012dfa8
f0118403:	e8 83 8b fe ff       	call   f0100f8b <cprintf>
f0118408:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011840b:	e8 24 6a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118410:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118413:	e8 a0 c6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118418:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f011841b:	83 ec 0c             	sub    $0xc,%esp
f011841e:	68 00 fc 0f 00       	push   $0xffc00
f0118423:	e8 42 18 ff ff       	call   f0109c6a <kmalloc>
f0118428:	83 c4 10             	add    $0x10,%esp
f011842b:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f011842e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118431:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118436:	74 17                	je     f011844f <test_kmalloc_firstfit1+0xb1>
f0118438:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011843f:	83 ec 0c             	sub    $0xc,%esp
f0118442:	68 e8 df 12 f0       	push   $0xf012dfe8
f0118447:	e8 3f 8b fe ff       	call   f0100f8b <cprintf>
f011844c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011844f:	e8 64 c6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118454:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118457:	74 17                	je     f0118470 <test_kmalloc_firstfit1+0xd2>
f0118459:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118460:	83 ec 0c             	sub    $0xc,%esp
f0118463:	68 0c d3 12 f0       	push   $0xf012d30c
f0118468:	e8 1e 8b fe ff       	call   f0100f8b <cprintf>
f011846d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f0118470:	e8 bf 69 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118475:	89 c2                	mov    %eax,%edx
f0118477:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011847a:	29 d0                	sub    %edx,%eax
f011847c:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118481:	7f 17                	jg     f011849a <test_kmalloc_firstfit1+0xfc>
f0118483:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011848a:	83 ec 0c             	sub    $0xc,%esp
f011848d:	68 1b e0 12 f0       	push   $0xf012e01b
f0118492:	e8 f4 8a fe ff       	call   f0100f8b <cprintf>
f0118497:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011849a:	e8 95 69 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011849f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184a2:	e8 11 c6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01184a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f01184aa:	83 ec 0c             	sub    $0xc,%esp
f01184ad:	68 00 fc 0f 00       	push   $0xffc00
f01184b2:	e8 b3 17 ff ff       	call   f0109c6a <kmalloc>
f01184b7:	83 c4 10             	add    $0x10,%esp
f01184ba:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f01184bd:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01184c0:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01184c5:	74 17                	je     f01184de <test_kmalloc_firstfit1+0x140>
f01184c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184ce:	83 ec 0c             	sub    $0xc,%esp
f01184d1:	68 34 e0 12 f0       	push   $0xf012e034
f01184d6:	e8 b0 8a fe ff       	call   f0100f8b <cprintf>
f01184db:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184de:	e8 d5 c5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01184e3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01184e6:	74 17                	je     f01184ff <test_kmalloc_firstfit1+0x161>
f01184e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184ef:	83 ec 0c             	sub    $0xc,%esp
f01184f2:	68 10 d4 12 f0       	push   $0xf012d410
f01184f7:	e8 8f 8a fe ff       	call   f0100f8b <cprintf>
f01184fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01184ff:	e8 30 69 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118504:	89 c2                	mov    %eax,%edx
f0118506:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118509:	29 d0                	sub    %edx,%eax
f011850b:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118510:	7f 17                	jg     f0118529 <test_kmalloc_firstfit1+0x18b>
f0118512:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118519:	83 ec 0c             	sub    $0xc,%esp
f011851c:	68 67 e0 12 f0       	push   $0xf012e067
f0118521:	e8 65 8a fe ff       	call   f0100f8b <cprintf>
f0118526:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118529:	e8 06 69 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011852e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118531:	e8 82 c5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118536:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0118539:	83 ec 0c             	sub    $0xc,%esp
f011853c:	68 00 fc 0f 00       	push   $0xffc00
f0118541:	e8 24 17 ff ff       	call   f0109c6a <kmalloc>
f0118546:	83 c4 10             	add    $0x10,%esp
f0118549:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f011854c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011854f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118554:	74 17                	je     f011856d <test_kmalloc_firstfit1+0x1cf>
f0118556:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011855d:	83 ec 0c             	sub    $0xc,%esp
f0118560:	68 80 e0 12 f0       	push   $0xf012e080
f0118565:	e8 21 8a fe ff       	call   f0100f8b <cprintf>
f011856a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011856d:	e8 46 c5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118572:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118575:	74 17                	je     f011858e <test_kmalloc_firstfit1+0x1f0>
f0118577:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011857e:	83 ec 0c             	sub    $0xc,%esp
f0118581:	68 4c d5 12 f0       	push   $0xf012d54c
f0118586:	e8 00 8a fe ff       	call   f0100f8b <cprintf>
f011858b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f011858e:	e8 a1 68 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118593:	89 c2                	mov    %eax,%edx
f0118595:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118598:	29 d0                	sub    %edx,%eax
f011859a:	3d ff 00 00 00       	cmp    $0xff,%eax
f011859f:	7f 17                	jg     f01185b8 <test_kmalloc_firstfit1+0x21a>
f01185a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185a8:	83 ec 0c             	sub    $0xc,%esp
f01185ab:	68 b3 e0 12 f0       	push   $0xf012e0b3
f01185b0:	e8 d6 89 fe ff       	call   f0100f8b <cprintf>
f01185b5:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01185b8:	e8 77 68 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01185bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185c0:	e8 f3 c4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01185c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f01185c8:	83 ec 0c             	sub    $0xc,%esp
f01185cb:	68 00 fc 0f 00       	push   $0xffc00
f01185d0:	e8 95 16 ff ff       	call   f0109c6a <kmalloc>
f01185d5:	83 c4 10             	add    $0x10,%esp
f01185d8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01185db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01185de:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f01185e3:	74 17                	je     f01185fc <test_kmalloc_firstfit1+0x25e>
f01185e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185ec:	83 ec 0c             	sub    $0xc,%esp
f01185ef:	68 cc e0 12 f0       	push   $0xf012e0cc
f01185f4:	e8 92 89 fe ff       	call   f0100f8b <cprintf>
f01185f9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185fc:	e8 b7 c4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118601:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118604:	74 17                	je     f011861d <test_kmalloc_firstfit1+0x27f>
f0118606:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011860d:	83 ec 0c             	sub    $0xc,%esp
f0118610:	68 44 d6 12 f0       	push   $0xf012d644
f0118615:	e8 71 89 fe ff       	call   f0100f8b <cprintf>
f011861a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f011861d:	e8 12 68 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118622:	89 c2                	mov    %eax,%edx
f0118624:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118627:	29 d0                	sub    %edx,%eax
f0118629:	3d ff 00 00 00       	cmp    $0xff,%eax
f011862e:	7f 17                	jg     f0118647 <test_kmalloc_firstfit1+0x2a9>
f0118630:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118637:	83 ec 0c             	sub    $0xc,%esp
f011863a:	68 ff e0 12 f0       	push   $0xf012e0ff
f011863f:	e8 47 89 fe ff       	call   f0100f8b <cprintf>
f0118644:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118647:	e8 e8 67 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011864c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011864f:	e8 64 c4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118654:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0118657:	83 ec 0c             	sub    $0xc,%esp
f011865a:	68 00 fc 1f 00       	push   $0x1ffc00
f011865f:	e8 06 16 ff ff       	call   f0109c6a <kmalloc>
f0118664:	83 c4 10             	add    $0x10,%esp
f0118667:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f011866a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011866d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118672:	74 17                	je     f011868b <test_kmalloc_firstfit1+0x2ed>
f0118674:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011867b:	83 ec 0c             	sub    $0xc,%esp
f011867e:	68 18 e1 12 f0       	push   $0xf012e118
f0118683:	e8 03 89 fe ff       	call   f0100f8b <cprintf>
f0118688:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011868b:	e8 28 c4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118690:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118693:	74 17                	je     f01186ac <test_kmalloc_firstfit1+0x30e>
f0118695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011869c:	83 ec 0c             	sub    $0xc,%esp
f011869f:	68 24 d7 12 f0       	push   $0xf012d724
f01186a4:	e8 e2 88 fe ff       	call   f0100f8b <cprintf>
f01186a9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f01186ac:	e8 83 67 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01186b1:	89 c2                	mov    %eax,%edx
f01186b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01186b6:	29 d0                	sub    %edx,%eax
f01186b8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01186bd:	7f 17                	jg     f01186d6 <test_kmalloc_firstfit1+0x338>
f01186bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186c6:	83 ec 0c             	sub    $0xc,%esp
f01186c9:	68 4b e1 12 f0       	push   $0xf012e14b
f01186ce:	e8 b8 88 fe ff       	call   f0100f8b <cprintf>
f01186d3:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186d6:	e8 59 67 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01186db:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186de:	e8 d5 c3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01186e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f01186e6:	83 ec 0c             	sub    $0xc,%esp
f01186e9:	68 00 fc 1f 00       	push   $0x1ffc00
f01186ee:	e8 77 15 ff ff       	call   f0109c6a <kmalloc>
f01186f3:	83 c4 10             	add    $0x10,%esp
f01186f6:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f01186f9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01186fc:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0118701:	74 17                	je     f011871a <test_kmalloc_firstfit1+0x37c>
f0118703:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011870a:	83 ec 0c             	sub    $0xc,%esp
f011870d:	68 64 e1 12 f0       	push   $0xf012e164
f0118712:	e8 74 88 fe ff       	call   f0100f8b <cprintf>
f0118717:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011871a:	e8 99 c3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011871f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118722:	74 17                	je     f011873b <test_kmalloc_firstfit1+0x39d>
f0118724:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011872b:	83 ec 0c             	sub    $0xc,%esp
f011872e:	68 28 d8 12 f0       	push   $0xf012d828
f0118733:	e8 53 88 fe ff       	call   f0100f8b <cprintf>
f0118738:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f011873b:	e8 f4 66 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118740:	89 c2                	mov    %eax,%edx
f0118742:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118745:	29 d0                	sub    %edx,%eax
f0118747:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011874c:	7f 17                	jg     f0118765 <test_kmalloc_firstfit1+0x3c7>
f011874e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118755:	83 ec 0c             	sub    $0xc,%esp
f0118758:	68 97 e1 12 f0       	push   $0xf012e197
f011875d:	e8 29 88 fe ff       	call   f0100f8b <cprintf>
f0118762:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118765:	e8 ca 66 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011876a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011876d:	e8 46 c3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118772:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0118775:	83 ec 0c             	sub    $0xc,%esp
f0118778:	68 00 fc 2f 00       	push   $0x2ffc00
f011877d:	e8 e8 14 ff ff       	call   f0109c6a <kmalloc>
f0118782:	83 c4 10             	add    $0x10,%esp
f0118785:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0118788:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011878b:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118790:	74 17                	je     f01187a9 <test_kmalloc_firstfit1+0x40b>
f0118792:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118799:	83 ec 0c             	sub    $0xc,%esp
f011879c:	68 b0 e1 12 f0       	push   $0xf012e1b0
f01187a1:	e8 e5 87 fe ff       	call   f0100f8b <cprintf>
f01187a6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187a9:	e8 0a c3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01187ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01187b1:	74 17                	je     f01187ca <test_kmalloc_firstfit1+0x42c>
f01187b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187ba:	83 ec 0c             	sub    $0xc,%esp
f01187bd:	68 2c d9 12 f0       	push   $0xf012d92c
f01187c2:	e8 c4 87 fe ff       	call   f0100f8b <cprintf>
f01187c7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f01187ca:	e8 65 66 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01187cf:	89 c2                	mov    %eax,%edx
f01187d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01187d4:	29 d0                	sub    %edx,%eax
f01187d6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01187db:	7f 17                	jg     f01187f4 <test_kmalloc_firstfit1+0x456>
f01187dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e4:	83 ec 0c             	sub    $0xc,%esp
f01187e7:	68 e3 e1 12 f0       	push   $0xf012e1e3
f01187ec:	e8 9a 87 fe ff       	call   f0100f8b <cprintf>
f01187f1:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01187f4:	e8 3b 66 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01187f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187fc:	e8 b7 c2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118801:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0118804:	83 ec 0c             	sub    $0xc,%esp
f0118807:	68 00 fc 2f 00       	push   $0x2ffc00
f011880c:	e8 59 14 ff ff       	call   f0109c6a <kmalloc>
f0118811:	83 c4 10             	add    $0x10,%esp
f0118814:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0118817:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011881a:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011881f:	74 17                	je     f0118838 <test_kmalloc_firstfit1+0x49a>
f0118821:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118828:	83 ec 0c             	sub    $0xc,%esp
f011882b:	68 fc e1 12 f0       	push   $0xf012e1fc
f0118830:	e8 56 87 fe ff       	call   f0100f8b <cprintf>
f0118835:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118838:	e8 7b c2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011883d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118840:	74 17                	je     f0118859 <test_kmalloc_firstfit1+0x4bb>
f0118842:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118849:	83 ec 0c             	sub    $0xc,%esp
f011884c:	68 30 da 12 f0       	push   $0xf012da30
f0118851:	e8 35 87 fe ff       	call   f0100f8b <cprintf>
f0118856:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0118859:	e8 d6 65 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011885e:	89 c2                	mov    %eax,%edx
f0118860:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118863:	29 d0                	sub    %edx,%eax
f0118865:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011886a:	7f 17                	jg     f0118883 <test_kmalloc_firstfit1+0x4e5>
f011886c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118873:	83 ec 0c             	sub    $0xc,%esp
f0118876:	68 2f e2 12 f0       	push   $0xf012e22f
f011887b:	e8 0b 87 fe ff       	call   f0100f8b <cprintf>
f0118880:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118883:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118887:	74 04                	je     f011888d <test_kmalloc_firstfit1+0x4ef>
f0118889:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011888d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0118894:	83 ec 0c             	sub    $0xc,%esp
f0118897:	68 48 e2 12 f0       	push   $0xf012e248
f011889c:	e8 ea 86 fe ff       	call   f0100f8b <cprintf>
f01188a1:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01188a4:	e8 8b 65 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01188a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01188ac:	e8 07 c2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01188b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01188b4:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01188b7:	83 ec 0c             	sub    $0xc,%esp
f01188ba:	50                   	push   %eax
f01188bb:	e8 14 16 ff ff       	call   f0109ed4 <kfree>
f01188c0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01188c3:	e8 f0 c1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01188c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01188cb:	74 17                	je     f01188e4 <test_kmalloc_firstfit1+0x546>
f01188cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188d4:	83 ec 0c             	sub    $0xc,%esp
f01188d7:	68 70 e2 12 f0       	push   $0xf012e270
f01188dc:	e8 aa 86 fe ff       	call   f0100f8b <cprintf>
f01188e1:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f01188e4:	e8 4b 65 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01188e9:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01188ec:	3d ff 00 00 00       	cmp    $0xff,%eax
f01188f1:	7f 17                	jg     f011890a <test_kmalloc_firstfit1+0x56c>
f01188f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01188fa:	83 ec 0c             	sub    $0xc,%esp
f01188fd:	68 db e2 12 f0       	push   $0xf012e2db
f0118902:	e8 84 86 fe ff       	call   f0100f8b <cprintf>
f0118907:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011890a:	e8 25 65 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011890f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118912:	e8 a1 c1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118917:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f011891a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011891d:	83 ec 0c             	sub    $0xc,%esp
f0118920:	50                   	push   %eax
f0118921:	e8 ae 15 ff ff       	call   f0109ed4 <kfree>
f0118926:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118929:	e8 8a c1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011892e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118931:	74 17                	je     f011894a <test_kmalloc_firstfit1+0x5ac>
f0118933:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011893a:	83 ec 0c             	sub    $0xc,%esp
f011893d:	68 ec e2 12 f0       	push   $0xf012e2ec
f0118942:	e8 44 86 fe ff       	call   f0100f8b <cprintf>
f0118947:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f011894a:	e8 e5 64 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011894f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118952:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118957:	7f 17                	jg     f0118970 <test_kmalloc_firstfit1+0x5d2>
f0118959:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118960:	83 ec 0c             	sub    $0xc,%esp
f0118963:	68 58 e3 12 f0       	push   $0xf012e358
f0118968:	e8 1e 86 fe ff       	call   f0100f8b <cprintf>
f011896d:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118970:	e8 bf 64 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118975:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118978:	e8 3b c1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011897d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0118980:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118983:	83 ec 0c             	sub    $0xc,%esp
f0118986:	50                   	push   %eax
f0118987:	e8 48 15 ff ff       	call   f0109ed4 <kfree>
f011898c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011898f:	e8 24 c1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118994:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118997:	74 17                	je     f01189b0 <test_kmalloc_firstfit1+0x612>
f0118999:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189a0:	83 ec 0c             	sub    $0xc,%esp
f01189a3:	68 6c e3 12 f0       	push   $0xf012e36c
f01189a8:	e8 de 85 fe ff       	call   f0100f8b <cprintf>
f01189ad:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f01189b0:	e8 7f 64 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01189b5:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01189b8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01189bd:	7f 17                	jg     f01189d6 <test_kmalloc_firstfit1+0x638>
f01189bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189c6:	83 ec 0c             	sub    $0xc,%esp
f01189c9:	68 d8 e3 12 f0       	push   $0xf012e3d8
f01189ce:	e8 b8 85 fe ff       	call   f0100f8b <cprintf>
f01189d3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01189d6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01189da:	74 04                	je     f01189e0 <test_kmalloc_firstfit1+0x642>
f01189dc:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01189e0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f01189e7:	83 ec 0c             	sub    $0xc,%esp
f01189ea:	68 ec e3 12 f0       	push   $0xf012e3ec
f01189ef:	e8 97 85 fe ff       	call   f0100f8b <cprintf>
f01189f4:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01189f7:	e8 38 64 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01189fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01189ff:	e8 b4 c0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118a04:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0118a07:	83 ec 0c             	sub    $0xc,%esp
f0118a0a:	68 00 fc 07 00       	push   $0x7fc00
f0118a0f:	e8 56 12 ff ff       	call   f0109c6a <kmalloc>
f0118a14:	83 c4 10             	add    $0x10,%esp
f0118a17:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0118a1a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118a1d:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0118a22:	74 17                	je     f0118a3b <test_kmalloc_firstfit1+0x69d>
f0118a24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a2b:	83 ec 0c             	sub    $0xc,%esp
f0118a2e:	68 18 e4 12 f0       	push   $0xf012e418
f0118a33:	e8 53 85 fe ff       	call   f0100f8b <cprintf>
f0118a38:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a3b:	e8 78 c0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118a40:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118a43:	74 17                	je     f0118a5c <test_kmalloc_firstfit1+0x6be>
f0118a45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a4c:	83 ec 0c             	sub    $0xc,%esp
f0118a4f:	68 4c e4 12 f0       	push   $0xf012e44c
f0118a54:	e8 32 85 fe ff       	call   f0100f8b <cprintf>
f0118a59:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0118a5c:	e8 d3 63 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118a61:	89 c2                	mov    %eax,%edx
f0118a63:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118a66:	29 d0                	sub    %edx,%eax
f0118a68:	83 f8 7f             	cmp    $0x7f,%eax
f0118a6b:	7f 17                	jg     f0118a84 <test_kmalloc_firstfit1+0x6e6>
f0118a6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a74:	83 ec 0c             	sub    $0xc,%esp
f0118a77:	68 b8 e4 12 f0       	push   $0xf012e4b8
f0118a7c:	e8 0a 85 fe ff       	call   f0100f8b <cprintf>
f0118a81:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118a84:	e8 ab 63 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118a89:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118a8c:	e8 27 c0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118a91:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0118a94:	83 ec 0c             	sub    $0xc,%esp
f0118a97:	68 00 fc 0f 00       	push   $0xffc00
f0118a9c:	e8 c9 11 ff ff       	call   f0109c6a <kmalloc>
f0118aa1:	83 c4 10             	add    $0x10,%esp
f0118aa4:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0118aa7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118aaa:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118aaf:	74 17                	je     f0118ac8 <test_kmalloc_firstfit1+0x72a>
f0118ab1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ab8:	83 ec 0c             	sub    $0xc,%esp
f0118abb:	68 d0 e4 12 f0       	push   $0xf012e4d0
f0118ac0:	e8 c6 84 fe ff       	call   f0100f8b <cprintf>
f0118ac5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ac8:	e8 eb bf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118acd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118ad0:	74 17                	je     f0118ae9 <test_kmalloc_firstfit1+0x74b>
f0118ad2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ad9:	83 ec 0c             	sub    $0xc,%esp
f0118adc:	68 04 e5 12 f0       	push   $0xf012e504
f0118ae1:	e8 a5 84 fe ff       	call   f0100f8b <cprintf>
f0118ae6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0118ae9:	e8 46 63 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118aee:	89 c2                	mov    %eax,%edx
f0118af0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118af3:	29 d0                	sub    %edx,%eax
f0118af5:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118afa:	7f 17                	jg     f0118b13 <test_kmalloc_firstfit1+0x775>
f0118afc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b03:	83 ec 0c             	sub    $0xc,%esp
f0118b06:	68 70 e5 12 f0       	push   $0xf012e570
f0118b0b:	e8 7b 84 fe ff       	call   f0100f8b <cprintf>
f0118b10:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118b13:	e8 1c 63 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118b18:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118b1b:	e8 98 bf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118b20:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0118b23:	83 ec 0c             	sub    $0xc,%esp
f0118b26:	68 00 fc 03 00       	push   $0x3fc00
f0118b2b:	e8 3a 11 ff ff       	call   f0109c6a <kmalloc>
f0118b30:	83 c4 10             	add    $0x10,%esp
f0118b33:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0118b36:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118b39:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0118b3e:	74 17                	je     f0118b57 <test_kmalloc_firstfit1+0x7b9>
f0118b40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b47:	83 ec 0c             	sub    $0xc,%esp
f0118b4a:	68 88 e5 12 f0       	push   $0xf012e588
f0118b4f:	e8 37 84 fe ff       	call   f0100f8b <cprintf>
f0118b54:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b57:	e8 5c bf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118b5c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118b5f:	74 17                	je     f0118b78 <test_kmalloc_firstfit1+0x7da>
f0118b61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b68:	83 ec 0c             	sub    $0xc,%esp
f0118b6b:	68 bc e5 12 f0       	push   $0xf012e5bc
f0118b70:	e8 16 84 fe ff       	call   f0100f8b <cprintf>
f0118b75:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0118b78:	e8 b7 62 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118b7d:	89 c2                	mov    %eax,%edx
f0118b7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118b82:	29 d0                	sub    %edx,%eax
f0118b84:	83 f8 3f             	cmp    $0x3f,%eax
f0118b87:	7f 17                	jg     f0118ba0 <test_kmalloc_firstfit1+0x802>
f0118b89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b90:	83 ec 0c             	sub    $0xc,%esp
f0118b93:	68 28 e6 12 f0       	push   $0xf012e628
f0118b98:	e8 ee 83 fe ff       	call   f0100f8b <cprintf>
f0118b9d:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ba0:	e8 8f 62 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118ba5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ba8:	e8 0b bf fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118bad:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0118bb0:	83 ec 0c             	sub    $0xc,%esp
f0118bb3:	68 00 00 20 00       	push   $0x200000
f0118bb8:	e8 ad 10 ff ff       	call   f0109c6a <kmalloc>
f0118bbd:	83 c4 10             	add    $0x10,%esp
f0118bc0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0118bc3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118bc6:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0118bcb:	74 17                	je     f0118be4 <test_kmalloc_firstfit1+0x846>
f0118bcd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bd4:	83 ec 0c             	sub    $0xc,%esp
f0118bd7:	68 40 e6 12 f0       	push   $0xf012e640
f0118bdc:	e8 aa 83 fe ff       	call   f0100f8b <cprintf>
f0118be1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0118be4:	e8 4b 62 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118be9:	89 c2                	mov    %eax,%edx
f0118beb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118bee:	29 d0                	sub    %edx,%eax
f0118bf0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118bf5:	7f 17                	jg     f0118c0e <test_kmalloc_firstfit1+0x870>
f0118bf7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bfe:	83 ec 0c             	sub    $0xc,%esp
f0118c01:	68 74 e6 12 f0       	push   $0xf012e674
f0118c06:	e8 80 83 fe ff       	call   f0100f8b <cprintf>
f0118c0b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c0e:	e8 a5 be fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118c13:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c16:	74 17                	je     f0118c2f <test_kmalloc_firstfit1+0x891>
f0118c18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c1f:	83 ec 0c             	sub    $0xc,%esp
f0118c22:	68 8c e6 12 f0       	push   $0xf012e68c
f0118c27:	e8 5f 83 fe ff       	call   f0100f8b <cprintf>
f0118c2c:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0118c2f:	e8 00 62 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118c34:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118c37:	e8 7c be fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118c3c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0118c3f:	83 ec 0c             	sub    $0xc,%esp
f0118c42:	68 00 fc 3f 00       	push   $0x3ffc00
f0118c47:	e8 1e 10 ff ff       	call   f0109c6a <kmalloc>
f0118c4c:	83 c4 10             	add    $0x10,%esp
f0118c4f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f0118c52:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118c55:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0118c5a:	74 17                	je     f0118c73 <test_kmalloc_firstfit1+0x8d5>
f0118c5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c63:	83 ec 0c             	sub    $0xc,%esp
f0118c66:	68 f8 e6 12 f0       	push   $0xf012e6f8
f0118c6b:	e8 1b 83 fe ff       	call   f0100f8b <cprintf>
f0118c70:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c73:	e8 40 be fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118c78:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118c7b:	74 17                	je     f0118c94 <test_kmalloc_firstfit1+0x8f6>
f0118c7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c84:	83 ec 0c             	sub    $0xc,%esp
f0118c87:	68 2c e7 12 f0       	push   $0xf012e72c
f0118c8c:	e8 fa 82 fe ff       	call   f0100f8b <cprintf>
f0118c91:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f0118c94:	e8 9b 61 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118c99:	89 c2                	mov    %eax,%edx
f0118c9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118c9e:	29 d0                	sub    %edx,%eax
f0118ca0:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0118ca5:	7f 17                	jg     f0118cbe <test_kmalloc_firstfit1+0x920>
f0118ca7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cae:	83 ec 0c             	sub    $0xc,%esp
f0118cb1:	68 98 e7 12 f0       	push   $0xf012e798
f0118cb6:	e8 d0 82 fe ff       	call   f0100f8b <cprintf>
f0118cbb:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0118cbe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118cc2:	74 04                	je     f0118cc8 <test_kmalloc_firstfit1+0x92a>
f0118cc4:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0118cc8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f0118ccf:	83 ec 0c             	sub    $0xc,%esp
f0118cd2:	68 b0 e7 12 f0       	push   $0xf012e7b0
f0118cd7:	e8 af 82 fe ff       	call   f0100f8b <cprintf>
f0118cdc:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0118cdf:	e8 50 61 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118ce4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ce7:	e8 cc bd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118cec:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0118cef:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118cf2:	83 ec 0c             	sub    $0xc,%esp
f0118cf5:	50                   	push   %eax
f0118cf6:	e8 d9 11 ff ff       	call   f0109ed4 <kfree>
f0118cfb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118cfe:	e8 b5 bd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118d03:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d06:	74 17                	je     f0118d1f <test_kmalloc_firstfit1+0x981>
f0118d08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d0f:	83 ec 0c             	sub    $0xc,%esp
f0118d12:	68 70 dd 12 f0       	push   $0xf012dd70
f0118d17:	e8 6f 82 fe ff       	call   f0100f8b <cprintf>
f0118d1c:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f0118d1f:	e8 10 61 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118d24:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118d27:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118d2c:	7f 17                	jg     f0118d45 <test_kmalloc_firstfit1+0x9a7>
f0118d2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d35:	83 ec 0c             	sub    $0xc,%esp
f0118d38:	68 e4 e7 12 f0       	push   $0xf012e7e4
f0118d3d:	e8 49 82 fe ff       	call   f0100f8b <cprintf>
f0118d42:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0118d45:	e8 ea 60 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118d4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d4d:	e8 66 bd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118d52:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0118d55:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118d58:	83 ec 0c             	sub    $0xc,%esp
f0118d5b:	50                   	push   %eax
f0118d5c:	e8 73 11 ff ff       	call   f0109ed4 <kfree>
f0118d61:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d64:	e8 4f bd fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118d69:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118d6c:	74 17                	je     f0118d85 <test_kmalloc_firstfit1+0x9e7>
f0118d6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d75:	83 ec 0c             	sub    $0xc,%esp
f0118d78:	68 38 de 12 f0       	push   $0xf012de38
f0118d7d:	e8 09 82 fe ff       	call   f0100f8b <cprintf>
f0118d82:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0118d85:	e8 aa 60 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118d8a:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0118d8d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118d92:	7f 17                	jg     f0118dab <test_kmalloc_firstfit1+0xa0d>
f0118d94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118d9b:	83 ec 0c             	sub    $0xc,%esp
f0118d9e:	68 f5 e7 12 f0       	push   $0xf012e7f5
f0118da3:	e8 e3 81 fe ff       	call   f0100f8b <cprintf>
f0118da8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118dab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118daf:	74 04                	je     f0118db5 <test_kmalloc_firstfit1+0xa17>
f0118db1:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118db5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0118dbc:	83 ec 0c             	sub    $0xc,%esp
f0118dbf:	68 08 e8 12 f0       	push   $0xf012e808
f0118dc4:	e8 c2 81 fe ff       	call   f0100f8b <cprintf>
f0118dc9:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118dcc:	e8 63 60 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118dd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118dd4:	e8 df bc fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118dd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0118ddc:	83 ec 0c             	sub    $0xc,%esp
f0118ddf:	68 00 00 10 00       	push   $0x100000
f0118de4:	e8 81 0e ff ff       	call   f0109c6a <kmalloc>
f0118de9:	83 c4 10             	add    $0x10,%esp
f0118dec:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0118def:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118df2:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0118df7:	74 17                	je     f0118e10 <test_kmalloc_firstfit1+0xa72>
f0118df9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e00:	83 ec 0c             	sub    $0xc,%esp
f0118e03:	68 48 e8 12 f0       	push   $0xf012e848
f0118e08:	e8 7e 81 fe ff       	call   f0100f8b <cprintf>
f0118e0d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e10:	e8 a3 bc fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118e15:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e18:	74 17                	je     f0118e31 <test_kmalloc_firstfit1+0xa93>
f0118e1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e21:	83 ec 0c             	sub    $0xc,%esp
f0118e24:	68 7c e8 12 f0       	push   $0xf012e87c
f0118e29:	e8 5d 81 fe ff       	call   f0100f8b <cprintf>
f0118e2e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0118e31:	e8 fe 5f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118e36:	89 c2                	mov    %eax,%edx
f0118e38:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118e3b:	29 d0                	sub    %edx,%eax
f0118e3d:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118e42:	7f 17                	jg     f0118e5b <test_kmalloc_firstfit1+0xabd>
f0118e44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e4b:	83 ec 0c             	sub    $0xc,%esp
f0118e4e:	68 e8 e8 12 f0       	push   $0xf012e8e8
f0118e53:	e8 33 81 fe ff       	call   f0100f8b <cprintf>
f0118e58:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0118e5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118e5f:	74 04                	je     f0118e65 <test_kmalloc_firstfit1+0xac7>
f0118e61:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0118e65:	83 ec 08             	sub    $0x8,%esp
f0118e68:	ff 75 f4             	pushl  -0xc(%ebp)
f0118e6b:	68 00 e9 12 f0       	push   $0xf012e900
f0118e70:	e8 16 81 fe ff       	call   f0100f8b <cprintf>
f0118e75:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118e78:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0118e7d:	8b 7d fc             	mov    -0x4(%ebp),%edi
f0118e80:	c9                   	leave  
f0118e81:	c3                   	ret    

f0118e82 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f0118e82:	55                   	push   %ebp
f0118e83:	89 e5                	mov    %esp,%ebp
f0118e85:	57                   	push   %edi
f0118e86:	53                   	push   %ebx
f0118e87:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118e8a:	83 ec 0c             	sub    $0xc,%esp
f0118e8d:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0118e92:	e8 f4 80 fe ff       	call   f0100f8b <cprintf>
f0118e97:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118e9a:	83 ec 0c             	sub    $0xc,%esp
f0118e9d:	68 18 d1 12 f0       	push   $0xf012d118
f0118ea2:	e8 e4 80 fe ff       	call   f0100f8b <cprintf>
f0118ea7:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118eaa:	83 ec 0c             	sub    $0xc,%esp
f0118ead:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0118eb2:	e8 d4 80 fe ff       	call   f0100f8b <cprintf>
f0118eb7:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118eba:	8d 55 98             	lea    -0x68(%ebp),%edx
f0118ebd:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118ec2:	b8 00 00 00 00       	mov    $0x0,%eax
f0118ec7:	89 d7                	mov    %edx,%edi
f0118ec9:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f0118ecb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118ed2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118ed9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f0118ee0:	83 ec 0c             	sub    $0xc,%esp
f0118ee3:	68 38 e9 12 f0       	push   $0xf012e938
f0118ee8:	e8 9e 80 fe ff       	call   f0100f8b <cprintf>
f0118eed:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0118ef0:	83 ec 0c             	sub    $0xc,%esp
f0118ef3:	68 01 e0 ff 07       	push   $0x7ffe001
f0118ef8:	e8 6d 0d ff ff       	call   f0109c6a <kmalloc>
f0118efd:	83 c4 10             	add    $0x10,%esp
f0118f00:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f0118f03:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118f06:	85 c0                	test   %eax,%eax
f0118f08:	74 17                	je     f0118f21 <test_kmalloc_firstfit2+0x9f>
f0118f0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f11:	83 ec 0c             	sub    $0xc,%esp
f0118f14:	68 6c e9 12 f0       	push   $0xf012e96c
f0118f19:	e8 6d 80 fe ff       	call   f0100f8b <cprintf>
f0118f1e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118f21:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118f25:	74 04                	je     f0118f2b <test_kmalloc_firstfit2+0xa9>
f0118f27:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118f2b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f0118f32:	83 ec 0c             	sub    $0xc,%esp
f0118f35:	68 b4 e9 12 f0       	push   $0xf012e9b4
f0118f3a:	e8 4c 80 fe ff       	call   f0100f8b <cprintf>
f0118f3f:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f42:	e8 ed 5e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118f47:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f4a:	e8 69 bb fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118f4f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118f52:	83 ec 0c             	sub    $0xc,%esp
f0118f55:	68 00 fc 1f 00       	push   $0x1ffc00
f0118f5a:	e8 0b 0d ff ff       	call   f0109c6a <kmalloc>
f0118f5f:	83 c4 10             	add    $0x10,%esp
f0118f62:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0118f65:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118f68:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118f6d:	74 17                	je     f0118f86 <test_kmalloc_firstfit2+0x104>
f0118f6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f76:	83 ec 0c             	sub    $0xc,%esp
f0118f79:	68 34 e0 12 f0       	push   $0xf012e034
f0118f7e:	e8 08 80 fe ff       	call   f0100f8b <cprintf>
f0118f83:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f86:	e8 2d bb fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118f8b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f8e:	74 17                	je     f0118fa7 <test_kmalloc_firstfit2+0x125>
f0118f90:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f97:	83 ec 0c             	sub    $0xc,%esp
f0118f9a:	68 10 d4 12 f0       	push   $0xf012d410
f0118f9f:	e8 e7 7f fe ff       	call   f0100f8b <cprintf>
f0118fa4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0118fa7:	e8 88 5e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118fac:	89 c2                	mov    %eax,%edx
f0118fae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118fb1:	29 d0                	sub    %edx,%eax
f0118fb3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118fb8:	7f 17                	jg     f0118fd1 <test_kmalloc_firstfit2+0x14f>
f0118fba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fc1:	83 ec 0c             	sub    $0xc,%esp
f0118fc4:	68 67 e0 12 f0       	push   $0xf012e067
f0118fc9:	e8 bd 7f fe ff       	call   f0100f8b <cprintf>
f0118fce:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118fd1:	e8 5e 5e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0118fd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118fd9:	e8 da ba fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0118fde:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0118fe1:	83 ec 0c             	sub    $0xc,%esp
f0118fe4:	68 00 fc 1f 00       	push   $0x1ffc00
f0118fe9:	e8 7c 0c ff ff       	call   f0109c6a <kmalloc>
f0118fee:	83 c4 10             	add    $0x10,%esp
f0118ff1:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0118ff4:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118ff7:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118ffc:	74 17                	je     f0119015 <test_kmalloc_firstfit2+0x193>
f0118ffe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119005:	83 ec 0c             	sub    $0xc,%esp
f0119008:	68 80 e0 12 f0       	push   $0xf012e080
f011900d:	e8 79 7f fe ff       	call   f0100f8b <cprintf>
f0119012:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119015:	e8 9e ba fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011901a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011901d:	74 17                	je     f0119036 <test_kmalloc_firstfit2+0x1b4>
f011901f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119026:	83 ec 0c             	sub    $0xc,%esp
f0119029:	68 4c d5 12 f0       	push   $0xf012d54c
f011902e:	e8 58 7f fe ff       	call   f0100f8b <cprintf>
f0119033:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0119036:	e8 f9 5d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011903b:	89 c2                	mov    %eax,%edx
f011903d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119040:	29 d0                	sub    %edx,%eax
f0119042:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119047:	7f 17                	jg     f0119060 <test_kmalloc_firstfit2+0x1de>
f0119049:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119050:	83 ec 0c             	sub    $0xc,%esp
f0119053:	68 b3 e0 12 f0       	push   $0xf012e0b3
f0119058:	e8 2e 7f fe ff       	call   f0100f8b <cprintf>
f011905d:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119060:	e8 cf 5d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119065:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119068:	e8 4b ba fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011906d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0119070:	83 ec 0c             	sub    $0xc,%esp
f0119073:	68 00 1c 00 00       	push   $0x1c00
f0119078:	e8 ed 0b ff ff       	call   f0109c6a <kmalloc>
f011907d:	83 c4 10             	add    $0x10,%esp
f0119080:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f0119083:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119086:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011908b:	74 17                	je     f01190a4 <test_kmalloc_firstfit2+0x222>
f011908d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119094:	83 ec 0c             	sub    $0xc,%esp
f0119097:	68 cc e0 12 f0       	push   $0xf012e0cc
f011909c:	e8 ea 7e fe ff       	call   f0100f8b <cprintf>
f01190a1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01190a4:	e8 0f ba fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01190a9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01190ac:	74 17                	je     f01190c5 <test_kmalloc_firstfit2+0x243>
f01190ae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190b5:	83 ec 0c             	sub    $0xc,%esp
f01190b8:	68 44 d6 12 f0       	push   $0xf012d644
f01190bd:	e8 c9 7e fe ff       	call   f0100f8b <cprintf>
f01190c2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01190c5:	e8 6a 5d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01190ca:	89 c2                	mov    %eax,%edx
f01190cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01190cf:	29 d0                	sub    %edx,%eax
f01190d1:	83 f8 01             	cmp    $0x1,%eax
f01190d4:	7f 17                	jg     f01190ed <test_kmalloc_firstfit2+0x26b>
f01190d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190dd:	83 ec 0c             	sub    $0xc,%esp
f01190e0:	68 ff e0 12 f0       	push   $0xf012e0ff
f01190e5:	e8 a1 7e fe ff       	call   f0100f8b <cprintf>
f01190ea:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01190ed:	e8 42 5d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01190f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01190f5:	e8 be b9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01190fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f01190fd:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119100:	83 ec 0c             	sub    $0xc,%esp
f0119103:	50                   	push   %eax
f0119104:	e8 cb 0d ff ff       	call   f0109ed4 <kfree>
f0119109:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011910c:	e8 a7 b9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119111:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119114:	74 17                	je     f011912d <test_kmalloc_firstfit2+0x2ab>
f0119116:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011911d:	83 ec 0c             	sub    $0xc,%esp
f0119120:	68 24 d7 12 f0       	push   $0xf012d724
f0119125:	e8 61 7e fe ff       	call   f0100f8b <cprintf>
f011912a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f011912d:	e8 02 5d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119132:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119135:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011913a:	7f 17                	jg     f0119153 <test_kmalloc_firstfit2+0x2d1>
f011913c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119143:	83 ec 0c             	sub    $0xc,%esp
f0119146:	68 fa e9 12 f0       	push   $0xf012e9fa
f011914b:	e8 3b 7e fe ff       	call   f0100f8b <cprintf>
f0119150:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119153:	e8 dc 5c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119158:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011915b:	e8 58 b9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119160:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0119163:	83 ec 0c             	sub    $0xc,%esp
f0119166:	68 00 fc 2f 00       	push   $0x2ffc00
f011916b:	e8 fa 0a ff ff       	call   f0109c6a <kmalloc>
f0119170:	83 c4 10             	add    $0x10,%esp
f0119173:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0119176:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119179:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011917e:	74 17                	je     f0119197 <test_kmalloc_firstfit2+0x315>
f0119180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119187:	83 ec 0c             	sub    $0xc,%esp
f011918a:	68 64 e1 12 f0       	push   $0xf012e164
f011918f:	e8 f7 7d fe ff       	call   f0100f8b <cprintf>
f0119194:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119197:	e8 1c b9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011919c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011919f:	74 17                	je     f01191b8 <test_kmalloc_firstfit2+0x336>
f01191a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191a8:	83 ec 0c             	sub    $0xc,%esp
f01191ab:	68 28 d8 12 f0       	push   $0xf012d828
f01191b0:	e8 d6 7d fe ff       	call   f0100f8b <cprintf>
f01191b5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f01191b8:	e8 77 5c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01191bd:	89 c2                	mov    %eax,%edx
f01191bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01191c2:	29 d0                	sub    %edx,%eax
f01191c4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01191c9:	7f 17                	jg     f01191e2 <test_kmalloc_firstfit2+0x360>
f01191cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191d2:	83 ec 0c             	sub    $0xc,%esp
f01191d5:	68 97 e1 12 f0       	push   $0xf012e197
f01191da:	e8 ac 7d fe ff       	call   f0100f8b <cprintf>
f01191df:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01191e2:	e8 4d 5c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01191e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01191ea:	e8 c9 b8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01191ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f01191f2:	83 ec 0c             	sub    $0xc,%esp
f01191f5:	68 00 18 20 00       	push   $0x201800
f01191fa:	e8 6b 0a ff ff       	call   f0109c6a <kmalloc>
f01191ff:	83 c4 10             	add    $0x10,%esp
f0119202:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0119205:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119208:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011920d:	74 17                	je     f0119226 <test_kmalloc_firstfit2+0x3a4>
f011920f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119216:	83 ec 0c             	sub    $0xc,%esp
f0119219:	68 b0 e1 12 f0       	push   $0xf012e1b0
f011921e:	e8 68 7d fe ff       	call   f0100f8b <cprintf>
f0119223:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119226:	e8 8d b8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011922b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011922e:	74 17                	je     f0119247 <test_kmalloc_firstfit2+0x3c5>
f0119230:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119237:	83 ec 0c             	sub    $0xc,%esp
f011923a:	68 2c d9 12 f0       	push   $0xf012d92c
f011923f:	e8 47 7d fe ff       	call   f0100f8b <cprintf>
f0119244:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0119247:	e8 e8 5b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011924c:	89 c2                	mov    %eax,%edx
f011924e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119251:	29 d0                	sub    %edx,%eax
f0119253:	3d 01 02 00 00       	cmp    $0x201,%eax
f0119258:	7f 17                	jg     f0119271 <test_kmalloc_firstfit2+0x3ef>
f011925a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119261:	83 ec 0c             	sub    $0xc,%esp
f0119264:	68 e3 e1 12 f0       	push   $0xf012e1e3
f0119269:	e8 1d 7d fe ff       	call   f0100f8b <cprintf>
f011926e:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119271:	e8 be 5b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119276:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119279:	e8 3a b8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011927e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0119281:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119284:	83 ec 0c             	sub    $0xc,%esp
f0119287:	50                   	push   %eax
f0119288:	e8 47 0c ff ff       	call   f0109ed4 <kfree>
f011928d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119290:	e8 23 b8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119295:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119298:	74 17                	je     f01192b1 <test_kmalloc_firstfit2+0x42f>
f011929a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192a1:	83 ec 0c             	sub    $0xc,%esp
f01192a4:	68 30 da 12 f0       	push   $0xf012da30
f01192a9:	e8 dd 7c fe ff       	call   f0100f8b <cprintf>
f01192ae:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f01192b1:	e8 7e 5b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01192b6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01192b9:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01192be:	7f 17                	jg     f01192d7 <test_kmalloc_firstfit2+0x455>
f01192c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192c7:	83 ec 0c             	sub    $0xc,%esp
f01192ca:	68 0a ea 12 f0       	push   $0xf012ea0a
f01192cf:	e8 b7 7c fe ff       	call   f0100f8b <cprintf>
f01192d4:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01192d7:	e8 58 5b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01192dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01192df:	e8 d4 b7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01192e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01192e7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01192ea:	83 ec 0c             	sub    $0xc,%esp
f01192ed:	50                   	push   %eax
f01192ee:	e8 e1 0b ff ff       	call   f0109ed4 <kfree>
f01192f3:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f01192f6:	e8 39 5b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01192fb:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01192fe:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119303:	7f 17                	jg     f011931c <test_kmalloc_firstfit2+0x49a>
f0119305:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011930c:	83 ec 0c             	sub    $0xc,%esp
f011930f:	68 db e2 12 f0       	push   $0xf012e2db
f0119314:	e8 72 7c fe ff       	call   f0100f8b <cprintf>
f0119319:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011931c:	e8 97 b7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119321:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119324:	74 17                	je     f011933d <test_kmalloc_firstfit2+0x4bb>
f0119326:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011932d:	83 ec 0c             	sub    $0xc,%esp
f0119330:	68 70 e2 12 f0       	push   $0xf012e270
f0119335:	e8 51 7c fe ff       	call   f0100f8b <cprintf>
f011933a:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011933d:	e8 f2 5a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119342:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119345:	e8 6e b7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011934a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f011934d:	83 ec 0c             	sub    $0xc,%esp
f0119350:	68 00 fc 4f 00       	push   $0x4ffc00
f0119355:	e8 10 09 ff ff       	call   f0109c6a <kmalloc>
f011935a:	83 c4 10             	add    $0x10,%esp
f011935d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f0119360:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119363:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0119368:	74 17                	je     f0119381 <test_kmalloc_firstfit2+0x4ff>
f011936a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119371:	83 ec 0c             	sub    $0xc,%esp
f0119374:	68 1c ea 12 f0       	push   $0xf012ea1c
f0119379:	e8 0d 7c fe ff       	call   f0100f8b <cprintf>
f011937e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119381:	e8 32 b7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119386:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119389:	74 17                	je     f01193a2 <test_kmalloc_firstfit2+0x520>
f011938b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119392:	83 ec 0c             	sub    $0xc,%esp
f0119395:	68 ec e2 12 f0       	push   $0xf012e2ec
f011939a:	e8 ec 7b fe ff       	call   f0100f8b <cprintf>
f011939f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f01193a2:	e8 8d 5a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01193a7:	89 c2                	mov    %eax,%edx
f01193a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01193ac:	29 d0                	sub    %edx,%eax
f01193ae:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f01193b3:	7f 17                	jg     f01193cc <test_kmalloc_firstfit2+0x54a>
f01193b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193bc:	83 ec 0c             	sub    $0xc,%esp
f01193bf:	68 50 ea 12 f0       	push   $0xf012ea50
f01193c4:	e8 c2 7b fe ff       	call   f0100f8b <cprintf>
f01193c9:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01193cc:	e8 63 5a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01193d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01193d4:	e8 df b6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01193d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f01193dc:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01193df:	83 ec 0c             	sub    $0xc,%esp
f01193e2:	50                   	push   %eax
f01193e3:	e8 ec 0a ff ff       	call   f0109ed4 <kfree>
f01193e8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193eb:	e8 c8 b6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01193f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193f3:	74 17                	je     f011940c <test_kmalloc_firstfit2+0x58a>
f01193f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193fc:	83 ec 0c             	sub    $0xc,%esp
f01193ff:	68 6c e3 12 f0       	push   $0xf012e36c
f0119404:	e8 82 7b fe ff       	call   f0100f8b <cprintf>
f0119409:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f011940c:	e8 23 5a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119411:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119414:	83 f8 01             	cmp    $0x1,%eax
f0119417:	7f 17                	jg     f0119430 <test_kmalloc_firstfit2+0x5ae>
f0119419:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119420:	83 ec 0c             	sub    $0xc,%esp
f0119423:	68 d8 e3 12 f0       	push   $0xf012e3d8
f0119428:	e8 5e 7b fe ff       	call   f0100f8b <cprintf>
f011942d:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f0119430:	e8 ff 59 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119435:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119438:	e8 7b b6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011943d:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0119440:	83 ec 0c             	sub    $0xc,%esp
f0119443:	68 00 04 00 00       	push   $0x400
f0119448:	e8 1d 08 ff ff       	call   f0109c6a <kmalloc>
f011944d:	83 c4 10             	add    $0x10,%esp
f0119450:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119453:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0119456:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011945b:	76 22                	jbe    f011947f <test_kmalloc_firstfit2+0x5fd>
f011945d:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f0119460:	83 ec 0c             	sub    $0xc,%esp
f0119463:	6a 00                	push   $0x0
f0119465:	e8 11 07 ff ff       	call   f0109b7b <sbrk>
f011946a:	83 c4 10             	add    $0x10,%esp
f011946d:	39 c3                	cmp    %eax,%ebx
f011946f:	73 0e                	jae    f011947f <test_kmalloc_firstfit2+0x5fd>
f0119471:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0119474:	89 c2                	mov    %eax,%edx
f0119476:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011947b:	39 c2                	cmp    %eax,%edx
f011947d:	72 17                	jb     f0119496 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011947f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119486:	83 ec 0c             	sub    $0xc,%esp
f0119489:	68 68 ea 12 f0       	push   $0xf012ea68
f011948e:	e8 f8 7a fe ff       	call   f0100f8b <cprintf>
f0119493:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119496:	e8 1d b6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011949b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011949e:	74 17                	je     f01194b7 <test_kmalloc_firstfit2+0x635>
f01194a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194a7:	83 ec 0c             	sub    $0xc,%esp
f01194aa:	68 4c e4 12 f0       	push   $0xf012e44c
f01194af:	e8 d7 7a fe ff       	call   f0100f8b <cprintf>
f01194b4:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01194b7:	e8 fc b5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01194bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f01194bf:	83 ec 0c             	sub    $0xc,%esp
f01194c2:	68 00 08 00 00       	push   $0x800
f01194c7:	e8 9e 07 ff ff       	call   f0109c6a <kmalloc>
f01194cc:	83 c4 10             	add    $0x10,%esp
f01194cf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01194d2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01194d5:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01194da:	76 22                	jbe    f01194fe <test_kmalloc_firstfit2+0x67c>
f01194dc:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01194df:	83 ec 0c             	sub    $0xc,%esp
f01194e2:	6a 00                	push   $0x0
f01194e4:	e8 92 06 ff ff       	call   f0109b7b <sbrk>
f01194e9:	83 c4 10             	add    $0x10,%esp
f01194ec:	39 c3                	cmp    %eax,%ebx
f01194ee:	73 0e                	jae    f01194fe <test_kmalloc_firstfit2+0x67c>
f01194f0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01194f3:	89 c2                	mov    %eax,%edx
f01194f5:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f01194fa:	39 c2                	cmp    %eax,%edx
f01194fc:	72 17                	jb     f0119515 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01194fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119505:	83 ec 0c             	sub    $0xc,%esp
f0119508:	68 f4 ea 12 f0       	push   $0xf012eaf4
f011950d:	e8 79 7a fe ff       	call   f0100f8b <cprintf>
f0119512:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119515:	e8 9e b5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011951a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011951d:	74 17                	je     f0119536 <test_kmalloc_firstfit2+0x6b4>
f011951f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119526:	83 ec 0c             	sub    $0xc,%esp
f0119529:	68 04 e5 12 f0       	push   $0xf012e504
f011952e:	e8 58 7a fe ff       	call   f0100f8b <cprintf>
f0119533:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119536:	e8 7d b5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011953b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f011953e:	83 ec 0c             	sub    $0xc,%esp
f0119541:	68 00 04 00 00       	push   $0x400
f0119546:	e8 1f 07 ff ff       	call   f0109c6a <kmalloc>
f011954b:	83 c4 10             	add    $0x10,%esp
f011954e:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0119551:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119554:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119559:	76 22                	jbe    f011957d <test_kmalloc_firstfit2+0x6fb>
f011955b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011955e:	83 ec 0c             	sub    $0xc,%esp
f0119561:	6a 00                	push   $0x0
f0119563:	e8 13 06 ff ff       	call   f0109b7b <sbrk>
f0119568:	83 c4 10             	add    $0x10,%esp
f011956b:	39 c3                	cmp    %eax,%ebx
f011956d:	73 0e                	jae    f011957d <test_kmalloc_firstfit2+0x6fb>
f011956f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119572:	89 c2                	mov    %eax,%edx
f0119574:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f0119579:	39 c2                	cmp    %eax,%edx
f011957b:	72 17                	jb     f0119594 <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011957d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119584:	83 ec 0c             	sub    $0xc,%esp
f0119587:	68 80 eb 12 f0       	push   $0xf012eb80
f011958c:	e8 fa 79 fe ff       	call   f0100f8b <cprintf>
f0119591:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119594:	e8 1f b5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119599:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011959c:	74 17                	je     f01195b5 <test_kmalloc_firstfit2+0x733>
f011959e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195a5:	83 ec 0c             	sub    $0xc,%esp
f01195a8:	68 bc e5 12 f0       	push   $0xf012e5bc
f01195ad:	e8 d9 79 fe ff       	call   f0100f8b <cprintf>
f01195b2:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f01195b5:	e8 7a 58 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01195ba:	89 c2                	mov    %eax,%edx
f01195bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01195bf:	29 d0                	sub    %edx,%eax
f01195c1:	83 f8 01             	cmp    $0x1,%eax
f01195c4:	74 17                	je     f01195dd <test_kmalloc_firstfit2+0x75b>
f01195c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195cd:	83 ec 0c             	sub    $0xc,%esp
f01195d0:	68 0c ec 12 f0       	push   $0xf012ec0c
f01195d5:	e8 b1 79 fe ff       	call   f0100f8b <cprintf>
f01195da:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f01195dd:	e8 52 58 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01195e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01195e5:	e8 ce b4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01195ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f01195ed:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01195f0:	83 ec 0c             	sub    $0xc,%esp
f01195f3:	50                   	push   %eax
f01195f4:	e8 db 08 ff ff       	call   f0109ed4 <kfree>
f01195f9:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195fc:	e8 b7 b4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119601:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119604:	74 17                	je     f011961d <test_kmalloc_firstfit2+0x79b>
f0119606:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011960d:	83 ec 0c             	sub    $0xc,%esp
f0119610:	68 8c e6 12 f0       	push   $0xf012e68c
f0119615:	e8 71 79 fe ff       	call   f0100f8b <cprintf>
f011961a:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011961d:	e8 12 58 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119622:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119625:	74 17                	je     f011963e <test_kmalloc_firstfit2+0x7bc>
f0119627:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011962e:	83 ec 0c             	sub    $0xc,%esp
f0119631:	68 30 ec 12 f0       	push   $0xf012ec30
f0119636:	e8 50 79 fe ff       	call   f0100f8b <cprintf>
f011963b:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f011963e:	e8 f1 57 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119643:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119646:	e8 6d b4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011964b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f011964e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119651:	83 ec 0c             	sub    $0xc,%esp
f0119654:	50                   	push   %eax
f0119655:	e8 7a 08 ff ff       	call   f0109ed4 <kfree>
f011965a:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011965d:	e8 56 b4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119662:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119665:	74 17                	je     f011967e <test_kmalloc_firstfit2+0x7fc>
f0119667:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011966e:	83 ec 0c             	sub    $0xc,%esp
f0119671:	68 2c e7 12 f0       	push   $0xf012e72c
f0119676:	e8 10 79 fe ff       	call   f0100f8b <cprintf>
f011967b:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011967e:	e8 b1 57 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119683:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119686:	74 17                	je     f011969f <test_kmalloc_firstfit2+0x81d>
f0119688:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011968f:	83 ec 0c             	sub    $0xc,%esp
f0119692:	68 90 ec 12 f0       	push   $0xf012ec90
f0119697:	e8 ef 78 fe ff       	call   f0100f8b <cprintf>
f011969c:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f011969f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01196a3:	74 04                	je     f01196a9 <test_kmalloc_firstfit2+0x827>
f01196a5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f01196a9:	83 ec 0c             	sub    $0xc,%esp
f01196ac:	68 f0 ec 12 f0       	push   $0xf012ecf0
f01196b1:	e8 d5 78 fe ff       	call   f0100f8b <cprintf>
f01196b6:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01196b9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01196c0:	e8 6f 57 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01196c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01196c8:	e8 eb b3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01196cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f01196d0:	83 ec 0c             	sub    $0xc,%esp
f01196d3:	68 00 08 00 00       	push   $0x800
f01196d8:	e8 8d 05 ff ff       	call   f0109c6a <kmalloc>
f01196dd:	83 c4 10             	add    $0x10,%esp
f01196e0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f01196e3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01196e6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01196e9:	39 c2                	cmp    %eax,%edx
f01196eb:	74 17                	je     f0119704 <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f01196ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01196f4:	83 ec 0c             	sub    $0xc,%esp
f01196f7:	68 28 ed 12 f0       	push   $0xf012ed28
f01196fc:	e8 8a 78 fe ff       	call   f0100f8b <cprintf>
f0119701:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119704:	e8 af b3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119709:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011970c:	74 17                	je     f0119725 <test_kmalloc_firstfit2+0x8a3>
f011970e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119715:	83 ec 0c             	sub    $0xc,%esp
f0119718:	68 70 dd 12 f0       	push   $0xf012dd70
f011971d:	e8 69 78 fe ff       	call   f0100f8b <cprintf>
f0119722:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0119725:	e8 0a 57 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011972a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011972d:	74 17                	je     f0119746 <test_kmalloc_firstfit2+0x8c4>
f011972f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119736:	83 ec 0c             	sub    $0xc,%esp
f0119739:	68 5c ed 12 f0       	push   $0xf012ed5c
f011973e:	e8 48 78 fe ff       	call   f0100f8b <cprintf>
f0119743:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119746:	e8 e9 56 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011974b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011974e:	e8 65 b3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119753:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0119756:	83 ec 0c             	sub    $0xc,%esp
f0119759:	68 00 04 00 00       	push   $0x400
f011975e:	e8 07 05 ff ff       	call   f0109c6a <kmalloc>
f0119763:	83 c4 10             	add    $0x10,%esp
f0119766:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0119769:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011976c:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011976f:	81 c2 08 08 00 00    	add    $0x808,%edx
f0119775:	39 d0                	cmp    %edx,%eax
f0119777:	74 17                	je     f0119790 <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0119779:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119780:	83 ec 0c             	sub    $0xc,%esp
f0119783:	68 74 ed 12 f0       	push   $0xf012ed74
f0119788:	e8 fe 77 fe ff       	call   f0100f8b <cprintf>
f011978d:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119790:	e8 23 b3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119795:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119798:	74 17                	je     f01197b1 <test_kmalloc_firstfit2+0x92f>
f011979a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01197a1:	83 ec 0c             	sub    $0xc,%esp
f01197a4:	68 38 de 12 f0       	push   $0xf012de38
f01197a9:	e8 dd 77 fe ff       	call   f0100f8b <cprintf>
f01197ae:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f01197b1:	e8 7e 56 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01197b6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01197b9:	74 17                	je     f01197d2 <test_kmalloc_firstfit2+0x950>
f01197bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01197c2:	83 ec 0c             	sub    $0xc,%esp
f01197c5:	68 a8 ed 12 f0       	push   $0xf012eda8
f01197ca:	e8 bc 77 fe ff       	call   f0100f8b <cprintf>
f01197cf:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f01197d2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01197d6:	74 04                	je     f01197dc <test_kmalloc_firstfit2+0x95a>
f01197d8:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f01197dc:	83 ec 0c             	sub    $0xc,%esp
f01197df:	68 c0 ed 12 f0       	push   $0xf012edc0
f01197e4:	e8 a2 77 fe ff       	call   f0100f8b <cprintf>
f01197e9:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f01197ec:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01197f3:	e8 3c 56 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01197f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01197fb:	e8 b8 b2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119800:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0119803:	83 ec 0c             	sub    $0xc,%esp
f0119806:	68 00 04 70 00       	push   $0x700400
f011980b:	e8 5a 04 ff ff       	call   f0109c6a <kmalloc>
f0119810:	83 c4 10             	add    $0x10,%esp
f0119813:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0119816:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119819:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011981e:	74 17                	je     f0119837 <test_kmalloc_firstfit2+0x9b5>
f0119820:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119827:	83 ec 0c             	sub    $0xc,%esp
f011982a:	68 48 e8 12 f0       	push   $0xf012e848
f011982f:	e8 57 77 fe ff       	call   f0100f8b <cprintf>
f0119834:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119837:	e8 7c b2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011983c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011983f:	74 17                	je     f0119858 <test_kmalloc_firstfit2+0x9d6>
f0119841:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119848:	83 ec 0c             	sub    $0xc,%esp
f011984b:	68 7c e8 12 f0       	push   $0xf012e87c
f0119850:	e8 36 77 fe ff       	call   f0100f8b <cprintf>
f0119855:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0119858:	e8 d7 55 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011985d:	89 c2                	mov    %eax,%edx
f011985f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119862:	29 d0                	sub    %edx,%eax
f0119864:	3d 00 07 00 00       	cmp    $0x700,%eax
f0119869:	7f 17                	jg     f0119882 <test_kmalloc_firstfit2+0xa00>
f011986b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119872:	83 ec 0c             	sub    $0xc,%esp
f0119875:	68 e8 e8 12 f0       	push   $0xf012e8e8
f011987a:	e8 0c 77 fe ff       	call   f0100f8b <cprintf>
f011987f:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119882:	e8 ad 55 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119887:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011988a:	e8 29 b2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011988f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0119892:	83 ec 0c             	sub    $0xc,%esp
f0119895:	68 00 0c 00 00       	push   $0xc00
f011989a:	e8 cb 03 ff ff       	call   f0109c6a <kmalloc>
f011989f:	83 c4 10             	add    $0x10,%esp
f01198a2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f01198a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01198a8:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f01198ad:	74 17                	je     f01198c6 <test_kmalloc_firstfit2+0xa44>
f01198af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198b6:	83 ec 0c             	sub    $0xc,%esp
f01198b9:	68 f4 ed 12 f0       	push   $0xf012edf4
f01198be:	e8 c8 76 fe ff       	call   f0100f8b <cprintf>
f01198c3:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198c6:	e8 ed b1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01198cb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01198ce:	74 17                	je     f01198e7 <test_kmalloc_firstfit2+0xa65>
f01198d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198d7:	83 ec 0c             	sub    $0xc,%esp
f01198da:	68 28 ee 12 f0       	push   $0xf012ee28
f01198df:	e8 a7 76 fe ff       	call   f0100f8b <cprintf>
f01198e4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f01198e7:	e8 48 55 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01198ec:	89 c2                	mov    %eax,%edx
f01198ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01198f1:	29 d0                	sub    %edx,%eax
f01198f3:	85 c0                	test   %eax,%eax
f01198f5:	7f 17                	jg     f011990e <test_kmalloc_firstfit2+0xa8c>
f01198f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198fe:	83 ec 0c             	sub    $0xc,%esp
f0119901:	68 94 ee 12 f0       	push   $0xf012ee94
f0119906:	e8 80 76 fe ff       	call   f0100f8b <cprintf>
f011990b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011990e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119912:	74 04                	je     f0119918 <test_kmalloc_firstfit2+0xa96>
f0119914:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0119918:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f011991f:	83 ec 0c             	sub    $0xc,%esp
f0119922:	68 ac ee 12 f0       	push   $0xf012eeac
f0119927:	e8 5f 76 fe ff       	call   f0100f8b <cprintf>
f011992c:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011992f:	83 ec 0c             	sub    $0xc,%esp
f0119932:	68 00 e0 1f 07       	push   $0x71fe000
f0119937:	e8 2e 03 ff ff       	call   f0109c6a <kmalloc>
f011993c:	83 c4 10             	add    $0x10,%esp
f011993f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0119942:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119945:	85 c0                	test   %eax,%eax
f0119947:	74 17                	je     f0119960 <test_kmalloc_firstfit2+0xade>
f0119949:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119950:	83 ec 0c             	sub    $0xc,%esp
f0119953:	68 00 ef 12 f0       	push   $0xf012ef00
f0119958:	e8 2e 76 fe ff       	call   f0100f8b <cprintf>
f011995d:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0119960:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119964:	74 04                	je     f011996a <test_kmalloc_firstfit2+0xae8>
f0119966:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011996a:	83 ec 08             	sub    $0x8,%esp
f011996d:	ff 75 f4             	pushl  -0xc(%ebp)
f0119970:	68 68 ef 12 f0       	push   $0xf012ef68
f0119975:	e8 11 76 fe ff       	call   f0100f8b <cprintf>
f011997a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011997d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0119982:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0119985:	5b                   	pop    %ebx
f0119986:	5f                   	pop    %edi
f0119987:	5d                   	pop    %ebp
f0119988:	c3                   	ret    

f0119989 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0119989:	55                   	push   %ebp
f011998a:	89 e5                	mov    %esp,%ebp
f011998c:	53                   	push   %ebx
f011998d:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119990:	83 ec 0c             	sub    $0xc,%esp
f0119993:	68 e8 d0 12 f0       	push   $0xf012d0e8
f0119998:	e8 ee 75 fe ff       	call   f0100f8b <cprintf>
f011999d:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01199a0:	83 ec 0c             	sub    $0xc,%esp
f01199a3:	68 18 d1 12 f0       	push   $0xf012d118
f01199a8:	e8 de 75 fe ff       	call   f0100f8b <cprintf>
f01199ad:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01199b0:	83 ec 0c             	sub    $0xc,%esp
f01199b3:	68 e8 d0 12 f0       	push   $0xf012d0e8
f01199b8:	e8 ce 75 fe ff       	call   f0100f8b <cprintf>
f01199bd:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f01199c0:	e8 6f 54 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f01199c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f01199c8:	e8 eb b0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f01199cd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f01199d0:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f01199d7:	83 ec 0c             	sub    $0xc,%esp
f01199da:	68 9d ef 12 f0       	push   $0xf012ef9d
f01199df:	e8 a7 75 fe ff       	call   f0100f8b <cprintf>
f01199e4:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f01199e7:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f01199ec:	ba 00 00 00 00       	mov    $0x0,%edx
f01199f1:	f7 75 e4             	divl   -0x1c(%ebp)
f01199f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f01199f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199fe:	eb 1d                	jmp    f0119a1d <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0119a00:	83 ec 0c             	sub    $0xc,%esp
f0119a03:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119a06:	e8 5f 02 ff ff       	call   f0109c6a <kmalloc>
f0119a0b:	83 c4 10             	add    $0x10,%esp
f0119a0e:	89 c2                	mov    %eax,%edx
f0119a10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a13:	89 14 85 a0 d5 71 f0 	mov    %edx,-0xf8e2a60(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0119a1a:	ff 45 f4             	incl   -0xc(%ebp)
f0119a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a20:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0119a23:	7c db                	jl     f0119a00 <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0119a25:	83 ec 0c             	sub    $0xc,%esp
f0119a28:	68 a1 ef 12 f0       	push   $0xf012efa1
f0119a2d:	e8 59 75 fe ff       	call   f0100f8b <cprintf>
f0119a32:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0119a35:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0119a3a:	ba 00 00 00 00       	mov    $0x0,%edx
f0119a3f:	f7 75 e4             	divl   -0x1c(%ebp)
f0119a42:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0119a45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0119a49:	74 1e                	je     f0119a69 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0119a4b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0119a4e:	8d 43 01             	lea    0x1(%ebx),%eax
f0119a51:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0119a54:	83 ec 0c             	sub    $0xc,%esp
f0119a57:	ff 75 e0             	pushl  -0x20(%ebp)
f0119a5a:	e8 0b 02 ff ff       	call   f0109c6a <kmalloc>
f0119a5f:	83 c4 10             	add    $0x10,%esp
f0119a62:	89 04 9d a0 d5 71 f0 	mov    %eax,-0xf8e2a60(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0119a69:	83 ec 04             	sub    $0x4,%esp
f0119a6c:	ff 75 f0             	pushl  -0x10(%ebp)
f0119a6f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119a72:	68 a8 ef 12 f0       	push   $0xf012efa8
f0119a77:	e8 0f 75 fe ff       	call   f0100f8b <cprintf>
f0119a7c:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0119a7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a86:	eb 36                	jmp    f0119abe <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0119a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a8b:	8b 04 85 a0 d5 71 f0 	mov    -0xf8e2a60(,%eax,4),%eax
f0119a92:	89 c2                	mov    %eax,%edx
f0119a94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a97:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119a9b:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0119aa0:	39 c2                	cmp    %eax,%edx
f0119aa2:	74 17                	je     f0119abb <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0119aa4:	83 ec 04             	sub    $0x4,%esp
f0119aa7:	68 f0 ef 12 f0       	push   $0xf012eff0
f0119aac:	68 e3 02 00 00       	push   $0x2e3
f0119ab1:	68 33 f0 12 f0       	push   $0xf012f033
f0119ab6:	e8 7e 68 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0119abb:	ff 45 f4             	incl   -0xc(%ebp)
f0119abe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119ac1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0119ac4:	7c c2                	jl     f0119a88 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119ac6:	e8 ed af fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119acb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ace:	74 17                	je     f0119ae7 <test_fastfirstfit+0x15e>
f0119ad0:	83 ec 04             	sub    $0x4,%esp
f0119ad3:	68 4c f0 12 f0       	push   $0xf012f04c
f0119ad8:	68 e6 02 00 00       	push   $0x2e6
f0119add:	68 33 f0 12 f0       	push   $0xf012f033
f0119ae2:	e8 52 68 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0119ae7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119aea:	e8 45 53 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119aef:	29 c3                	sub    %eax,%ebx
f0119af1:	89 d8                	mov    %ebx,%eax
f0119af3:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0119af8:	77 17                	ja     f0119b11 <test_fastfirstfit+0x188>
f0119afa:	83 ec 04             	sub    $0x4,%esp
f0119afd:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119b02:	68 e7 02 00 00       	push   $0x2e7
f0119b07:	68 33 f0 12 f0       	push   $0xf012f033
f0119b0c:	e8 28 68 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0119b11:	e8 a2 af fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119b16:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0119b19:	e8 16 53 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119b1e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0119b21:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0119b25:	7f 17                	jg     f0119b3e <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0119b27:	83 ec 04             	sub    $0x4,%esp
f0119b2a:	68 c8 f0 12 f0       	push   $0xf012f0c8
f0119b2f:	68 ee 02 00 00       	push   $0x2ee
f0119b34:	68 33 f0 12 f0       	push   $0xf012f033
f0119b39:	e8 fb 67 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0119b3e:	a1 a0 d5 71 f0       	mov    0xf071d5a0,%eax
f0119b43:	83 ec 0c             	sub    $0xc,%esp
f0119b46:	50                   	push   %eax
f0119b47:	e8 88 03 ff ff       	call   f0109ed4 <kfree>
f0119b4c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0119b4f:	a1 a8 d5 71 f0       	mov    0xf071d5a8,%eax
f0119b54:	83 ec 0c             	sub    $0xc,%esp
f0119b57:	50                   	push   %eax
f0119b58:	e8 77 03 ff ff       	call   f0109ed4 <kfree>
f0119b5d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0119b60:	a1 ac d5 71 f0       	mov    0xf071d5ac,%eax
f0119b65:	83 ec 0c             	sub    $0xc,%esp
f0119b68:	50                   	push   %eax
f0119b69:	e8 66 03 ff ff       	call   f0109ed4 <kfree>
f0119b6e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0119b71:	a1 b4 d5 71 f0       	mov    0xf071d5b4,%eax
f0119b76:	83 ec 0c             	sub    $0xc,%esp
f0119b79:	50                   	push   %eax
f0119b7a:	e8 55 03 ff ff       	call   f0109ed4 <kfree>
f0119b7f:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0119b82:	a1 c8 d5 71 f0       	mov    0xf071d5c8,%eax
f0119b87:	83 ec 0c             	sub    $0xc,%esp
f0119b8a:	50                   	push   %eax
f0119b8b:	e8 44 03 ff ff       	call   f0109ed4 <kfree>
f0119b90:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0119b93:	a1 d0 d5 71 f0       	mov    0xf071d5d0,%eax
f0119b98:	83 ec 0c             	sub    $0xc,%esp
f0119b9b:	50                   	push   %eax
f0119b9c:	e8 33 03 ff ff       	call   f0109ed4 <kfree>
f0119ba1:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0119ba4:	a1 cc d5 71 f0       	mov    0xf071d5cc,%eax
f0119ba9:	83 ec 0c             	sub    $0xc,%esp
f0119bac:	50                   	push   %eax
f0119bad:	e8 22 03 ff ff       	call   f0109ed4 <kfree>
f0119bb2:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0119bb5:	a1 f0 d5 71 f0       	mov    0xf071d5f0,%eax
f0119bba:	83 ec 0c             	sub    $0xc,%esp
f0119bbd:	50                   	push   %eax
f0119bbe:	e8 11 03 ff ff       	call   f0109ed4 <kfree>
f0119bc3:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0119bc6:	a1 04 d6 71 f0       	mov    0xf071d604,%eax
f0119bcb:	83 ec 0c             	sub    $0xc,%esp
f0119bce:	50                   	push   %eax
f0119bcf:	e8 00 03 ff ff       	call   f0109ed4 <kfree>
f0119bd4:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0119bd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119bda:	83 e8 02             	sub    $0x2,%eax
f0119bdd:	8b 04 85 a0 d5 71 f0 	mov    -0xf8e2a60(,%eax,4),%eax
f0119be4:	83 ec 0c             	sub    $0xc,%esp
f0119be7:	50                   	push   %eax
f0119be8:	e8 e7 02 ff ff       	call   f0109ed4 <kfree>
f0119bed:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0119bf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119bf3:	83 e8 03             	sub    $0x3,%eax
f0119bf6:	8b 04 85 a0 d5 71 f0 	mov    -0xf8e2a60(,%eax,4),%eax
f0119bfd:	83 ec 0c             	sub    $0xc,%esp
f0119c00:	50                   	push   %eax
f0119c01:	e8 ce 02 ff ff       	call   f0109ed4 <kfree>
f0119c06:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119c09:	e8 aa ae fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119c0e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119c11:	74 17                	je     f0119c2a <test_fastfirstfit+0x2a1>
f0119c13:	83 ec 04             	sub    $0x4,%esp
f0119c16:	68 4c f0 12 f0       	push   $0xf012f04c
f0119c1b:	68 fb 02 00 00       	push   $0x2fb
f0119c20:	68 33 f0 12 f0       	push   $0xf012f033
f0119c25:	e8 0f 67 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0119c2a:	e8 05 52 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119c2f:	89 c2                	mov    %eax,%edx
f0119c31:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119c34:	89 d1                	mov    %edx,%ecx
f0119c36:	29 c1                	sub    %eax,%ecx
f0119c38:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119c3b:	89 d0                	mov    %edx,%eax
f0119c3d:	c1 e0 02             	shl    $0x2,%eax
f0119c40:	01 d0                	add    %edx,%eax
f0119c42:	01 c0                	add    %eax,%eax
f0119c44:	01 d0                	add    %edx,%eax
f0119c46:	c1 e8 0c             	shr    $0xc,%eax
f0119c49:	39 c1                	cmp    %eax,%ecx
f0119c4b:	74 17                	je     f0119c64 <test_fastfirstfit+0x2db>
f0119c4d:	83 ec 04             	sub    $0x4,%esp
f0119c50:	68 04 f1 12 f0       	push   $0xf012f104
f0119c55:	68 fc 02 00 00       	push   $0x2fc
f0119c5a:	68 33 f0 12 f0       	push   $0xf012f033
f0119c5f:	e8 d5 66 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f0119c64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119c67:	01 c0                	add    %eax,%eax
f0119c69:	89 c2                	mov    %eax,%edx
f0119c6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119c6e:	d1 e8                	shr    %eax
f0119c70:	01 d0                	add    %edx,%eax
f0119c72:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119c75:	e8 3e ae fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119c7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119c7d:	e8 b2 51 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119c82:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119c85:	83 ec 0c             	sub    $0xc,%esp
f0119c88:	ff 75 dc             	pushl  -0x24(%ebp)
f0119c8b:	e8 da ff fe ff       	call   f0109c6a <kmalloc>
f0119c90:	83 c4 10             	add    $0x10,%esp
f0119c93:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0119c96:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119c99:	89 d0                	mov    %edx,%eax
f0119c9b:	c1 e0 02             	shl    $0x2,%eax
f0119c9e:	01 d0                	add    %edx,%eax
f0119ca0:	01 c0                	add    %eax,%eax
f0119ca2:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119ca8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119cab:	39 c2                	cmp    %eax,%edx
f0119cad:	74 17                	je     f0119cc6 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f0119caf:	83 ec 04             	sub    $0x4,%esp
f0119cb2:	68 44 f1 12 f0       	push   $0xf012f144
f0119cb7:	68 07 03 00 00       	push   $0x307
f0119cbc:	68 33 f0 12 f0       	push   $0xf012f033
f0119cc1:	e8 73 66 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119cc6:	e8 ed ad fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119ccb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119cce:	74 17                	je     f0119ce7 <test_fastfirstfit+0x35e>
f0119cd0:	83 ec 04             	sub    $0x4,%esp
f0119cd3:	68 4c f0 12 f0       	push   $0xf012f04c
f0119cd8:	68 08 03 00 00       	push   $0x308
f0119cdd:	68 33 f0 12 f0       	push   $0xf012f033
f0119ce2:	e8 52 66 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119ce7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119cea:	e8 45 51 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119cef:	29 c3                	sub    %eax,%ebx
f0119cf1:	89 da                	mov    %ebx,%edx
f0119cf3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119cf6:	c1 e8 0c             	shr    $0xc,%eax
f0119cf9:	39 c2                	cmp    %eax,%edx
f0119cfb:	73 17                	jae    f0119d14 <test_fastfirstfit+0x38b>
f0119cfd:	83 ec 04             	sub    $0x4,%esp
f0119d00:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119d05:	68 09 03 00 00       	push   $0x309
f0119d0a:	68 33 f0 12 f0       	push   $0xf012f033
f0119d0f:	e8 25 66 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f0119d14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119d17:	01 c0                	add    %eax,%eax
f0119d19:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119d1c:	e8 97 ad fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119d21:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119d24:	e8 0b 51 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119d29:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119d2c:	83 ec 0c             	sub    $0xc,%esp
f0119d2f:	ff 75 dc             	pushl  -0x24(%ebp)
f0119d32:	e8 33 ff fe ff       	call   f0109c6a <kmalloc>
f0119d37:	83 c4 10             	add    $0x10,%esp
f0119d3a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0119d3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119d40:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0119d45:	01 c0                	add    %eax,%eax
f0119d47:	89 c2                	mov    %eax,%edx
f0119d49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119d4c:	39 c2                	cmp    %eax,%edx
f0119d4e:	74 17                	je     f0119d67 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f0119d50:	83 ec 04             	sub    $0x4,%esp
f0119d53:	68 44 f1 12 f0       	push   $0xf012f144
f0119d58:	68 13 03 00 00       	push   $0x313
f0119d5d:	68 33 f0 12 f0       	push   $0xf012f033
f0119d62:	e8 d2 65 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119d67:	e8 4c ad fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119d6c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119d6f:	74 17                	je     f0119d88 <test_fastfirstfit+0x3ff>
f0119d71:	83 ec 04             	sub    $0x4,%esp
f0119d74:	68 4c f0 12 f0       	push   $0xf012f04c
f0119d79:	68 14 03 00 00       	push   $0x314
f0119d7e:	68 33 f0 12 f0       	push   $0xf012f033
f0119d83:	e8 b1 65 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119d88:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119d8b:	e8 a4 50 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119d90:	29 c3                	sub    %eax,%ebx
f0119d92:	89 da                	mov    %ebx,%edx
f0119d94:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119d97:	c1 e8 0c             	shr    $0xc,%eax
f0119d9a:	39 c2                	cmp    %eax,%edx
f0119d9c:	73 17                	jae    f0119db5 <test_fastfirstfit+0x42c>
f0119d9e:	83 ec 04             	sub    $0x4,%esp
f0119da1:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119da6:	68 15 03 00 00       	push   $0x315
f0119dab:	68 33 f0 12 f0       	push   $0xf012f033
f0119db0:	e8 84 65 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0119db5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119db8:	89 c2                	mov    %eax,%edx
f0119dba:	01 d2                	add    %edx,%edx
f0119dbc:	01 d0                	add    %edx,%eax
f0119dbe:	d1 e8                	shr    %eax
f0119dc0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119dc3:	e8 f0 ac fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119dc8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119dcb:	e8 64 50 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119dd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0119dd3:	83 ec 0c             	sub    $0xc,%esp
f0119dd6:	ff 75 dc             	pushl  -0x24(%ebp)
f0119dd9:	e8 8c fe fe ff       	call   f0109c6a <kmalloc>
f0119dde:	83 c4 10             	add    $0x10,%esp
f0119de1:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f0119de4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119de7:	83 e8 03             	sub    $0x3,%eax
f0119dea:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0119dee:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119df4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119df7:	39 c2                	cmp    %eax,%edx
f0119df9:	74 17                	je     f0119e12 <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f0119dfb:	83 ec 04             	sub    $0x4,%esp
f0119dfe:	68 44 f1 12 f0       	push   $0xf012f144
f0119e03:	68 1f 03 00 00       	push   $0x31f
f0119e08:	68 33 f0 12 f0       	push   $0xf012f033
f0119e0d:	e8 27 65 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119e12:	e8 a1 ac fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119e17:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e1a:	74 17                	je     f0119e33 <test_fastfirstfit+0x4aa>
f0119e1c:	83 ec 04             	sub    $0x4,%esp
f0119e1f:	68 4c f0 12 f0       	push   $0xf012f04c
f0119e24:	68 20 03 00 00       	push   $0x320
f0119e29:	68 33 f0 12 f0       	push   $0xf012f033
f0119e2e:	e8 06 65 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0119e33:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119e36:	e8 f9 4f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119e3b:	29 c3                	sub    %eax,%ebx
f0119e3d:	89 da                	mov    %ebx,%edx
f0119e3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0119e42:	c1 e8 0c             	shr    $0xc,%eax
f0119e45:	39 c2                	cmp    %eax,%edx
f0119e47:	73 17                	jae    f0119e60 <test_fastfirstfit+0x4d7>
f0119e49:	83 ec 04             	sub    $0x4,%esp
f0119e4c:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119e51:	68 21 03 00 00       	push   $0x321
f0119e56:	68 33 f0 12 f0       	push   $0xf012f033
f0119e5b:	e8 d9 64 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e60:	e8 53 ac fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119e65:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119e68:	e8 c7 4f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119e6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119e70:	83 ec 0c             	sub    $0xc,%esp
f0119e73:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119e76:	e8 ef fd fe ff       	call   f0109c6a <kmalloc>
f0119e7b:	83 c4 10             	add    $0x10,%esp
f0119e7e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f0119e81:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119e84:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119e89:	74 17                	je     f0119ea2 <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0119e8b:	83 ec 04             	sub    $0x4,%esp
f0119e8e:	68 44 f1 12 f0       	push   $0xf012f144
f0119e93:	68 2a 03 00 00       	push   $0x32a
f0119e98:	68 33 f0 12 f0       	push   $0xf012f033
f0119e9d:	e8 97 64 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119ea2:	e8 11 ac fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119ea7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119eaa:	74 17                	je     f0119ec3 <test_fastfirstfit+0x53a>
f0119eac:	83 ec 04             	sub    $0x4,%esp
f0119eaf:	68 4c f0 12 f0       	push   $0xf012f04c
f0119eb4:	68 2b 03 00 00       	push   $0x32b
f0119eb9:	68 33 f0 12 f0       	push   $0xf012f033
f0119ebe:	e8 76 64 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119ec3:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119ec6:	e8 69 4f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119ecb:	29 c3                	sub    %eax,%ebx
f0119ecd:	89 da                	mov    %ebx,%edx
f0119ecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119ed2:	c1 e8 0c             	shr    $0xc,%eax
f0119ed5:	39 c2                	cmp    %eax,%edx
f0119ed7:	73 17                	jae    f0119ef0 <test_fastfirstfit+0x567>
f0119ed9:	83 ec 04             	sub    $0x4,%esp
f0119edc:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119ee1:	68 2c 03 00 00       	push   $0x32c
f0119ee6:	68 33 f0 12 f0       	push   $0xf012f033
f0119eeb:	e8 49 64 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119ef0:	e8 c3 ab fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119ef5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119ef8:	e8 37 4f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119efd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119f00:	83 ec 0c             	sub    $0xc,%esp
f0119f03:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119f06:	e8 5f fd fe ff       	call   f0109c6a <kmalloc>
f0119f0b:	83 c4 10             	add    $0x10,%esp
f0119f0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f0119f11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119f14:	89 d0                	mov    %edx,%eax
f0119f16:	c1 e0 02             	shl    $0x2,%eax
f0119f19:	01 d0                	add    %edx,%eax
f0119f1b:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119f21:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119f24:	39 c2                	cmp    %eax,%edx
f0119f26:	74 17                	je     f0119f3f <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0119f28:	83 ec 04             	sub    $0x4,%esp
f0119f2b:	68 44 f1 12 f0       	push   $0xf012f144
f0119f30:	68 35 03 00 00       	push   $0x335
f0119f35:	68 33 f0 12 f0       	push   $0xf012f033
f0119f3a:	e8 fa 63 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119f3f:	e8 74 ab fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119f44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119f47:	74 17                	je     f0119f60 <test_fastfirstfit+0x5d7>
f0119f49:	83 ec 04             	sub    $0x4,%esp
f0119f4c:	68 4c f0 12 f0       	push   $0xf012f04c
f0119f51:	68 36 03 00 00       	push   $0x336
f0119f56:	68 33 f0 12 f0       	push   $0xf012f033
f0119f5b:	e8 d9 63 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0119f60:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0119f63:	e8 cc 4e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119f68:	29 c3                	sub    %eax,%ebx
f0119f6a:	89 da                	mov    %ebx,%edx
f0119f6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119f6f:	c1 e8 0c             	shr    $0xc,%eax
f0119f72:	39 c2                	cmp    %eax,%edx
f0119f74:	73 17                	jae    f0119f8d <test_fastfirstfit+0x604>
f0119f76:	83 ec 04             	sub    $0x4,%esp
f0119f79:	68 b4 f0 12 f0       	push   $0xf012f0b4
f0119f7e:	68 37 03 00 00       	push   $0x337
f0119f83:	68 33 f0 12 f0       	push   $0xf012f033
f0119f88:	e8 ac 63 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0119f8d:	e8 26 ab fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119f92:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0119f95:	e8 9a 4e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f0119f9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0119f9d:	83 ec 0c             	sub    $0xc,%esp
f0119fa0:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119fa3:	e8 c2 fc fe ff       	call   f0109c6a <kmalloc>
f0119fa8:	83 c4 10             	add    $0x10,%esp
f0119fab:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0119fae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0119fb1:	89 d0                	mov    %edx,%eax
f0119fb3:	c1 e0 02             	shl    $0x2,%eax
f0119fb6:	01 d0                	add    %edx,%eax
f0119fb8:	c1 e0 02             	shl    $0x2,%eax
f0119fbb:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0119fc1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119fc4:	39 c2                	cmp    %eax,%edx
f0119fc6:	74 17                	je     f0119fdf <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f0119fc8:	83 ec 04             	sub    $0x4,%esp
f0119fcb:	68 44 f1 12 f0       	push   $0xf012f144
f0119fd0:	68 40 03 00 00       	push   $0x340
f0119fd5:	68 33 f0 12 f0       	push   $0xf012f033
f0119fda:	e8 5a 63 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0119fdf:	e8 d4 aa fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f0119fe4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119fe7:	74 17                	je     f011a000 <test_fastfirstfit+0x677>
f0119fe9:	83 ec 04             	sub    $0x4,%esp
f0119fec:	68 4c f0 12 f0       	push   $0xf012f04c
f0119ff1:	68 41 03 00 00       	push   $0x341
f0119ff6:	68 33 f0 12 f0       	push   $0xf012f033
f0119ffb:	e8 39 63 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011a000:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011a003:	e8 2c 4e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a008:	29 c3                	sub    %eax,%ebx
f011a00a:	89 da                	mov    %ebx,%edx
f011a00c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a00f:	c1 e8 0c             	shr    $0xc,%eax
f011a012:	39 c2                	cmp    %eax,%edx
f011a014:	73 17                	jae    f011a02d <test_fastfirstfit+0x6a4>
f011a016:	83 ec 04             	sub    $0x4,%esp
f011a019:	68 b4 f0 12 f0       	push   $0xf012f0b4
f011a01e:	68 42 03 00 00       	push   $0x342
f011a023:	68 33 f0 12 f0       	push   $0xf012f033
f011a028:	e8 0c 63 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011a02d:	e8 86 aa fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a032:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011a035:	e8 fa 4d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a03a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011a03d:	83 ec 0c             	sub    $0xc,%esp
f011a040:	ff 75 e4             	pushl  -0x1c(%ebp)
f011a043:	e8 22 fc fe ff       	call   f0109c6a <kmalloc>
f011a048:	83 c4 10             	add    $0x10,%esp
f011a04b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f011a04e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011a051:	89 d0                	mov    %edx,%eax
f011a053:	c1 e0 02             	shl    $0x2,%eax
f011a056:	01 d0                	add    %edx,%eax
f011a058:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a05f:	01 d0                	add    %edx,%eax
f011a061:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011a067:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a06a:	39 c2                	cmp    %eax,%edx
f011a06c:	74 17                	je     f011a085 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f011a06e:	83 ec 04             	sub    $0x4,%esp
f011a071:	68 44 f1 12 f0       	push   $0xf012f144
f011a076:	68 4b 03 00 00       	push   $0x34b
f011a07b:	68 33 f0 12 f0       	push   $0xf012f033
f011a080:	e8 b4 62 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011a085:	e8 2e aa fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a08a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a08d:	74 17                	je     f011a0a6 <test_fastfirstfit+0x71d>
f011a08f:	83 ec 04             	sub    $0x4,%esp
f011a092:	68 4c f0 12 f0       	push   $0xf012f04c
f011a097:	68 4c 03 00 00       	push   $0x34c
f011a09c:	68 33 f0 12 f0       	push   $0xf012f033
f011a0a1:	e8 93 62 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011a0a6:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011a0a9:	e8 86 4d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a0ae:	29 c3                	sub    %eax,%ebx
f011a0b0:	89 da                	mov    %ebx,%edx
f011a0b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a0b5:	c1 e8 0c             	shr    $0xc,%eax
f011a0b8:	39 c2                	cmp    %eax,%edx
f011a0ba:	73 17                	jae    f011a0d3 <test_fastfirstfit+0x74a>
f011a0bc:	83 ec 04             	sub    $0x4,%esp
f011a0bf:	68 b4 f0 12 f0       	push   $0xf012f0b4
f011a0c4:	68 4d 03 00 00       	push   $0x34d
f011a0c9:	68 33 f0 12 f0       	push   $0xf012f033
f011a0ce:	e8 66 62 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011a0d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a0d6:	d1 e8                	shr    %eax
f011a0d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a0db:	e8 d8 a9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a0e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011a0e3:	e8 4c 4d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a0e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011a0eb:	83 ec 0c             	sub    $0xc,%esp
f011a0ee:	ff 75 dc             	pushl  -0x24(%ebp)
f011a0f1:	e8 74 fb fe ff       	call   f0109c6a <kmalloc>
f011a0f6:	83 c4 10             	add    $0x10,%esp
f011a0f9:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f011a0fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011a0ff:	89 d0                	mov    %edx,%eax
f011a101:	c1 e0 02             	shl    $0x2,%eax
f011a104:	01 d0                	add    %edx,%eax
f011a106:	01 c0                	add    %eax,%eax
f011a108:	89 c1                	mov    %eax,%ecx
f011a10a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011a10d:	89 d0                	mov    %edx,%eax
f011a10f:	c1 e0 02             	shl    $0x2,%eax
f011a112:	01 d0                	add    %edx,%eax
f011a114:	d1 e8                	shr    %eax
f011a116:	01 c8                	add    %ecx,%eax
f011a118:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011a11e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a121:	39 c2                	cmp    %eax,%edx
f011a123:	74 17                	je     f011a13c <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f011a125:	83 ec 04             	sub    $0x4,%esp
f011a128:	68 44 f1 12 f0       	push   $0xf012f144
f011a12d:	68 57 03 00 00       	push   $0x357
f011a132:	68 33 f0 12 f0       	push   $0xf012f033
f011a137:	e8 fd 61 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011a13c:	e8 77 a9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a141:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a144:	74 17                	je     f011a15d <test_fastfirstfit+0x7d4>
f011a146:	83 ec 04             	sub    $0x4,%esp
f011a149:	68 4c f0 12 f0       	push   $0xf012f04c
f011a14e:	68 58 03 00 00       	push   $0x358
f011a153:	68 33 f0 12 f0       	push   $0xf012f033
f011a158:	e8 dc 61 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011a15d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011a160:	e8 cf 4c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a165:	29 c3                	sub    %eax,%ebx
f011a167:	89 da                	mov    %ebx,%edx
f011a169:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a16c:	c1 e8 0c             	shr    $0xc,%eax
f011a16f:	39 c2                	cmp    %eax,%edx
f011a171:	73 17                	jae    f011a18a <test_fastfirstfit+0x801>
f011a173:	83 ec 04             	sub    $0x4,%esp
f011a176:	68 b4 f0 12 f0       	push   $0xf012f0b4
f011a17b:	68 59 03 00 00       	push   $0x359
f011a180:	68 33 f0 12 f0       	push   $0xf012f033
f011a185:	e8 af 61 fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f011a18a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a18d:	d1 e8                	shr    %eax
f011a18f:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a192:	e8 21 a9 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a197:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f011a19a:	e8 95 4c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a19f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011a1a2:	83 ec 0c             	sub    $0xc,%esp
f011a1a5:	ff 75 dc             	pushl  -0x24(%ebp)
f011a1a8:	e8 bd fa fe ff       	call   f0109c6a <kmalloc>
f011a1ad:	83 c4 10             	add    $0x10,%esp
f011a1b0:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f011a1b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a1b6:	83 e8 03             	sub    $0x3,%eax
f011a1b9:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f011a1bd:	89 c2                	mov    %eax,%edx
f011a1bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a1c2:	89 c1                	mov    %eax,%ecx
f011a1c4:	01 c9                	add    %ecx,%ecx
f011a1c6:	01 c8                	add    %ecx,%eax
f011a1c8:	d1 e8                	shr    %eax
f011a1ca:	01 d0                	add    %edx,%eax
f011a1cc:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011a1d2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011a1d5:	39 c2                	cmp    %eax,%edx
f011a1d7:	74 17                	je     f011a1f0 <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f011a1d9:	83 ec 04             	sub    $0x4,%esp
f011a1dc:	68 44 f1 12 f0       	push   $0xf012f144
f011a1e1:	68 63 03 00 00       	push   $0x363
f011a1e6:	68 33 f0 12 f0       	push   $0xf012f033
f011a1eb:	e8 49 61 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011a1f0:	e8 c3 a8 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a1f5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a1f8:	74 17                	je     f011a211 <test_fastfirstfit+0x888>
f011a1fa:	83 ec 04             	sub    $0x4,%esp
f011a1fd:	68 4c f0 12 f0       	push   $0xf012f04c
f011a202:	68 64 03 00 00       	push   $0x364
f011a207:	68 33 f0 12 f0       	push   $0xf012f033
f011a20c:	e8 28 61 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011a211:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011a214:	e8 1b 4c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a219:	29 c3                	sub    %eax,%ebx
f011a21b:	89 da                	mov    %ebx,%edx
f011a21d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a220:	c1 e8 0c             	shr    $0xc,%eax
f011a223:	39 c2                	cmp    %eax,%edx
f011a225:	73 17                	jae    f011a23e <test_fastfirstfit+0x8b5>
f011a227:	83 ec 04             	sub    $0x4,%esp
f011a22a:	68 b4 f0 12 f0       	push   $0xf012f0b4
f011a22f:	68 65 03 00 00       	push   $0x365
f011a234:	68 33 f0 12 f0       	push   $0xf012f033
f011a239:	e8 fb 60 fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f011a23e:	83 ec 0c             	sub    $0xc,%esp
f011a241:	68 64 f1 12 f0       	push   $0xf012f164
f011a246:	e8 40 6d fe ff       	call   f0100f8b <cprintf>
f011a24b:	83 c4 10             	add    $0x10,%esp
	return 1;
f011a24e:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011a253:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011a256:	c9                   	leave  
f011a257:	c3                   	ret    

f011a258 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011a258:	55                   	push   %ebp
f011a259:	89 e5                	mov    %esp,%ebp
f011a25b:	57                   	push   %edi
f011a25c:	53                   	push   %ebx
f011a25d:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a263:	83 ec 0c             	sub    $0xc,%esp
f011a266:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011a26b:	e8 1b 6d fe ff       	call   f0100f8b <cprintf>
f011a270:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a273:	83 ec 0c             	sub    $0xc,%esp
f011a276:	68 18 d1 12 f0       	push   $0xf012d118
f011a27b:	e8 0b 6d fe ff       	call   f0100f8b <cprintf>
f011a280:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a283:	83 ec 0c             	sub    $0xc,%esp
f011a286:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011a28b:	e8 fb 6c fe ff       	call   f0100f8b <cprintf>
f011a290:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a293:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011a297:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f011a29b:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011a2a1:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011a2a7:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a2ae:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a2b5:	e8 7a 4b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a2ba:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a2bd:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f011a2c3:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a2c8:	b8 00 00 00 00       	mov    $0x0,%eax
f011a2cd:	89 d7                	mov    %edx,%edi
f011a2cf:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a2d1:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011a2d7:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a2dc:	b8 00 00 00 00       	mov    $0x0,%eax
f011a2e1:	89 d7                	mov    %edx,%edi
f011a2e3:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011a2e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a2ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011a2f3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a2fa:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011a300:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a305:	b8 00 00 00 00       	mov    $0x0,%eax
f011a30a:	89 d7                	mov    %edx,%edi
f011a30c:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f011a30e:	83 ec 0c             	sub    $0xc,%esp
f011a311:	68 a8 f1 12 f0       	push   $0xf012f1a8
f011a316:	e8 70 6c fe ff       	call   f0100f8b <cprintf>
f011a31b:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a31e:	e8 11 4b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a323:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a326:	e8 8d a7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a32b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a32e:	83 ec 0c             	sub    $0xc,%esp
f011a331:	68 00 fc 1f 00       	push   $0x1ffc00
f011a336:	e8 2f f9 fe ff       	call   f0109c6a <kmalloc>
f011a33b:	83 c4 10             	add    $0x10,%esp
f011a33e:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a344:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011a34a:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a34f:	74 17                	je     f011a368 <test_kfree_bestfirstfit+0x110>
f011a351:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a358:	83 ec 0c             	sub    $0xc,%esp
f011a35b:	68 e0 f1 12 f0       	push   $0xf012f1e0
f011a360:	e8 26 6c fe ff       	call   f0100f8b <cprintf>
f011a365:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a368:	e8 4b a7 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a36d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a370:	74 17                	je     f011a389 <test_kfree_bestfirstfit+0x131>
f011a372:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a379:	83 ec 0c             	sub    $0xc,%esp
f011a37c:	68 34 f2 12 f0       	push   $0xf012f234
f011a381:	e8 05 6c fe ff       	call   f0100f8b <cprintf>
f011a386:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a389:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a38c:	e8 a3 4a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a391:	29 c3                	sub    %eax,%ebx
f011a393:	89 d8                	mov    %ebx,%eax
f011a395:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a39a:	77 17                	ja     f011a3b3 <test_kfree_bestfirstfit+0x15b>
f011a39c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3a3:	83 ec 0c             	sub    $0xc,%esp
f011a3a6:	68 a4 f2 12 f0       	push   $0xf012f2a4
f011a3ab:	e8 db 6b fe ff       	call   f0100f8b <cprintf>
f011a3b0:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011a3b3:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f011a3ba:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a3bd:	e8 72 4a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a3c2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3c5:	e8 ee a6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a3ca:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a3cd:	83 ec 0c             	sub    $0xc,%esp
f011a3d0:	68 00 fc 1f 00       	push   $0x1ffc00
f011a3d5:	e8 90 f8 fe ff       	call   f0109c6a <kmalloc>
f011a3da:	83 c4 10             	add    $0x10,%esp
f011a3dd:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a3e3:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a3e9:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a3ee:	74 17                	je     f011a407 <test_kfree_bestfirstfit+0x1af>
f011a3f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3f7:	83 ec 0c             	sub    $0xc,%esp
f011a3fa:	68 ec f2 12 f0       	push   $0xf012f2ec
f011a3ff:	e8 87 6b fe ff       	call   f0100f8b <cprintf>
f011a404:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a407:	e8 ac a6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a40c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a40f:	74 17                	je     f011a428 <test_kfree_bestfirstfit+0x1d0>
f011a411:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a418:	83 ec 0c             	sub    $0xc,%esp
f011a41b:	68 40 f3 12 f0       	push   $0xf012f340
f011a420:	e8 66 6b fe ff       	call   f0100f8b <cprintf>
f011a425:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a428:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a42b:	e8 04 4a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a430:	29 c3                	sub    %eax,%ebx
f011a432:	89 d8                	mov    %ebx,%eax
f011a434:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a439:	77 17                	ja     f011a452 <test_kfree_bestfirstfit+0x1fa>
f011a43b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a442:	83 ec 0c             	sub    $0xc,%esp
f011a445:	68 b0 f3 12 f0       	push   $0xf012f3b0
f011a44a:	e8 3c 6b fe ff       	call   f0100f8b <cprintf>
f011a44f:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011a452:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011a459:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011a45c:	e8 d3 49 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a461:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a464:	e8 4f a6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a469:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011a46c:	83 ec 0c             	sub    $0xc,%esp
f011a46f:	68 00 1c 00 00       	push   $0x1c00
f011a474:	e8 f1 f7 fe ff       	call   f0109c6a <kmalloc>
f011a479:	83 c4 10             	add    $0x10,%esp
f011a47c:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a482:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a488:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a48d:	74 17                	je     f011a4a6 <test_kfree_bestfirstfit+0x24e>
f011a48f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a496:	83 ec 0c             	sub    $0xc,%esp
f011a499:	68 f8 f3 12 f0       	push   $0xf012f3f8
f011a49e:	e8 e8 6a fe ff       	call   f0100f8b <cprintf>
f011a4a3:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a4a6:	e8 0d a6 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a4ab:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a4ae:	74 17                	je     f011a4c7 <test_kfree_bestfirstfit+0x26f>
f011a4b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4b7:	83 ec 0c             	sub    $0xc,%esp
f011a4ba:	68 4c f4 12 f0       	push   $0xf012f44c
f011a4bf:	e8 c7 6a fe ff       	call   f0100f8b <cprintf>
f011a4c4:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a4c7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a4ca:	e8 65 49 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a4cf:	29 c3                	sub    %eax,%ebx
f011a4d1:	89 d8                	mov    %ebx,%eax
f011a4d3:	83 f8 01             	cmp    $0x1,%eax
f011a4d6:	77 17                	ja     f011a4ef <test_kfree_bestfirstfit+0x297>
f011a4d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4df:	83 ec 0c             	sub    $0xc,%esp
f011a4e2:	68 bc f4 12 f0       	push   $0xf012f4bc
f011a4e7:	e8 9f 6a fe ff       	call   f0100f8b <cprintf>
f011a4ec:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011a4ef:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f011a4f6:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011a4f9:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a4ff:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011a502:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a509:	eb 0e                	jmp    f011a519 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f011a50b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a50e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a511:	01 d0                	add    %edx,%eax
f011a513:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011a516:	ff 45 f4             	incl   -0xc(%ebp)
f011a519:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a51f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a522:	7f e7                	jg     f011a50b <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011a524:	e8 0b 49 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a529:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a52c:	e8 87 a5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a531:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011a534:	83 ec 0c             	sub    $0xc,%esp
f011a537:	68 00 fc 2f 00       	push   $0x2ffc00
f011a53c:	e8 29 f7 fe ff       	call   f0109c6a <kmalloc>
f011a541:	83 c4 10             	add    $0x10,%esp
f011a544:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a54a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a550:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a555:	74 17                	je     f011a56e <test_kfree_bestfirstfit+0x316>
f011a557:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a55e:	83 ec 0c             	sub    $0xc,%esp
f011a561:	68 04 f5 12 f0       	push   $0xf012f504
f011a566:	e8 20 6a fe ff       	call   f0100f8b <cprintf>
f011a56b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a56e:	e8 45 a5 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a573:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a576:	74 17                	je     f011a58f <test_kfree_bestfirstfit+0x337>
f011a578:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a57f:	83 ec 0c             	sub    $0xc,%esp
f011a582:	68 58 f5 12 f0       	push   $0xf012f558
f011a587:	e8 ff 69 fe ff       	call   f0100f8b <cprintf>
f011a58c:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a58f:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a592:	e8 9d 48 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a597:	29 c3                	sub    %eax,%ebx
f011a599:	89 d8                	mov    %ebx,%eax
f011a59b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a5a0:	77 17                	ja     f011a5b9 <test_kfree_bestfirstfit+0x361>
f011a5a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5a9:	83 ec 0c             	sub    $0xc,%esp
f011a5ac:	68 c8 f5 12 f0       	push   $0xf012f5c8
f011a5b1:	e8 d5 69 fe ff       	call   f0100f8b <cprintf>
f011a5b6:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011a5b9:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f011a5c0:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011a5c3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a5c9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011a5cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a5d3:	eb 0e                	jmp    f011a5e3 <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f011a5d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a5d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a5db:	01 d0                	add    %edx,%eax
f011a5dd:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011a5e0:	ff 45 f4             	incl   -0xc(%ebp)
f011a5e3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a5e9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a5ec:	7f e7                	jg     f011a5d5 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011a5ee:	e8 41 48 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a5f3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a5f6:	e8 bd a4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a5fb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011a5fe:	83 ec 0c             	sub    $0xc,%esp
f011a601:	68 00 fc 5f 00       	push   $0x5ffc00
f011a606:	e8 5f f6 fe ff       	call   f0109c6a <kmalloc>
f011a60b:	83 c4 10             	add    $0x10,%esp
f011a60e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a614:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a61a:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a61f:	74 17                	je     f011a638 <test_kfree_bestfirstfit+0x3e0>
f011a621:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a628:	83 ec 0c             	sub    $0xc,%esp
f011a62b:	68 10 f6 12 f0       	push   $0xf012f610
f011a630:	e8 56 69 fe ff       	call   f0100f8b <cprintf>
f011a635:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a638:	e8 7b a4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a63d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a640:	74 17                	je     f011a659 <test_kfree_bestfirstfit+0x401>
f011a642:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a649:	83 ec 0c             	sub    $0xc,%esp
f011a64c:	68 64 f6 12 f0       	push   $0xf012f664
f011a651:	e8 35 69 fe ff       	call   f0100f8b <cprintf>
f011a656:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a659:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a65c:	e8 d3 47 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a661:	29 c3                	sub    %eax,%ebx
f011a663:	89 d8                	mov    %ebx,%eax
f011a665:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a66a:	77 17                	ja     f011a683 <test_kfree_bestfirstfit+0x42b>
f011a66c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a673:	83 ec 0c             	sub    $0xc,%esp
f011a676:	68 d4 f6 12 f0       	push   $0xf012f6d4
f011a67b:	e8 0b 69 fe ff       	call   f0100f8b <cprintf>
f011a680:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f011a683:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f011a68a:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f011a68d:	e8 a2 47 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a692:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a695:	e8 1e a4 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a69a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f011a69d:	83 ec 0c             	sub    $0xc,%esp
f011a6a0:	68 00 38 00 00       	push   $0x3800
f011a6a5:	e8 c0 f5 fe ff       	call   f0109c6a <kmalloc>
f011a6aa:	83 c4 10             	add    $0x10,%esp
f011a6ad:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a6b3:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a6b9:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a6be:	74 17                	je     f011a6d7 <test_kfree_bestfirstfit+0x47f>
f011a6c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6c7:	83 ec 0c             	sub    $0xc,%esp
f011a6ca:	68 1c f7 12 f0       	push   $0xf012f71c
f011a6cf:	e8 b7 68 fe ff       	call   f0100f8b <cprintf>
f011a6d4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a6d7:	e8 dc a3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a6dc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a6df:	74 17                	je     f011a6f8 <test_kfree_bestfirstfit+0x4a0>
f011a6e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6e8:	83 ec 0c             	sub    $0xc,%esp
f011a6eb:	68 70 f7 12 f0       	push   $0xf012f770
f011a6f0:	e8 96 68 fe ff       	call   f0100f8b <cprintf>
f011a6f5:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a6f8:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a6fb:	e8 34 47 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a700:	29 c3                	sub    %eax,%ebx
f011a702:	89 d8                	mov    %ebx,%eax
f011a704:	83 f8 03             	cmp    $0x3,%eax
f011a707:	77 17                	ja     f011a720 <test_kfree_bestfirstfit+0x4c8>
f011a709:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a710:	83 ec 0c             	sub    $0xc,%esp
f011a713:	68 e0 f7 12 f0       	push   $0xf012f7e0
f011a718:	e8 6e 68 fe ff       	call   f0100f8b <cprintf>
f011a71d:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011a720:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f011a727:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a72d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011a730:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a737:	eb 0e                	jmp    f011a747 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f011a739:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a73c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a73f:	01 d0                	add    %edx,%eax
f011a741:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f011a744:	ff 45 f4             	incl   -0xc(%ebp)
f011a747:	8b 45 80             	mov    -0x80(%ebp),%eax
f011a74a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a74d:	7f ea                	jg     f011a739 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f011a74f:	e8 e0 46 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a754:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f011a757:	e8 5c a3 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a75c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011a75f:	83 ec 0c             	sub    $0xc,%esp
f011a762:	68 00 08 00 00       	push   $0x800
f011a767:	e8 fe f4 fe ff       	call   f0109c6a <kmalloc>
f011a76c:	83 c4 10             	add    $0x10,%esp
f011a76f:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a775:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a77b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a780:	76 28                	jbe    f011a7aa <test_kfree_bestfirstfit+0x552>
f011a782:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f011a788:	83 ec 0c             	sub    $0xc,%esp
f011a78b:	6a 00                	push   $0x0
f011a78d:	e8 e9 f3 fe ff       	call   f0109b7b <sbrk>
f011a792:	83 c4 10             	add    $0x10,%esp
f011a795:	39 c3                	cmp    %eax,%ebx
f011a797:	73 11                	jae    f011a7aa <test_kfree_bestfirstfit+0x552>
f011a799:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a79f:	89 c2                	mov    %eax,%edx
f011a7a1:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011a7a6:	39 c2                	cmp    %eax,%edx
f011a7a8:	72 17                	jb     f011a7c1 <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a7aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7b1:	83 ec 0c             	sub    $0xc,%esp
f011a7b4:	68 28 f8 12 f0       	push   $0xf012f828
f011a7b9:	e8 cd 67 fe ff       	call   f0100f8b <cprintf>
f011a7be:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7c1:	e8 f2 a2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a7c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7c9:	74 17                	je     f011a7e2 <test_kfree_bestfirstfit+0x58a>
f011a7cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7d2:	83 ec 0c             	sub    $0xc,%esp
f011a7d5:	68 b4 f8 12 f0       	push   $0xf012f8b4
f011a7da:	e8 ac 67 fe ff       	call   f0100f8b <cprintf>
f011a7df:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011a7e2:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f011a7e9:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011a7ec:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a7f2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011a7f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a7fc:	eb 0e                	jmp    f011a80c <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f011a7fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a801:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a804:	01 d0                	add    %edx,%eax
f011a806:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011a809:	ff 45 f4             	incl   -0xc(%ebp)
f011a80c:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a812:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a815:	7f e7                	jg     f011a7fe <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f011a817:	e8 9c a2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a81c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a81f:	83 ec 0c             	sub    $0xc,%esp
f011a822:	68 00 08 00 00       	push   $0x800
f011a827:	e8 3e f4 fe ff       	call   f0109c6a <kmalloc>
f011a82c:	83 c4 10             	add    $0x10,%esp
f011a82f:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a835:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a83b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a840:	76 28                	jbe    f011a86a <test_kfree_bestfirstfit+0x612>
f011a842:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011a848:	83 ec 0c             	sub    $0xc,%esp
f011a84b:	6a 00                	push   $0x0
f011a84d:	e8 29 f3 fe ff       	call   f0109b7b <sbrk>
f011a852:	83 c4 10             	add    $0x10,%esp
f011a855:	39 c3                	cmp    %eax,%ebx
f011a857:	73 11                	jae    f011a86a <test_kfree_bestfirstfit+0x612>
f011a859:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a85f:	89 c2                	mov    %eax,%edx
f011a861:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011a866:	39 c2                	cmp    %eax,%edx
f011a868:	72 17                	jb     f011a881 <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a86a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a871:	83 ec 0c             	sub    $0xc,%esp
f011a874:	68 24 f9 12 f0       	push   $0xf012f924
f011a879:	e8 0d 67 fe ff       	call   f0100f8b <cprintf>
f011a87e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a881:	e8 32 a2 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a886:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a889:	74 17                	je     f011a8a2 <test_kfree_bestfirstfit+0x64a>
f011a88b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a892:	83 ec 0c             	sub    $0xc,%esp
f011a895:	68 b0 f9 12 f0       	push   $0xf012f9b0
f011a89a:	e8 ec 66 fe ff       	call   f0100f8b <cprintf>
f011a89f:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011a8a2:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011a8a9:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011a8ac:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a8b2:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011a8b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a8bc:	eb 0e                	jmp    f011a8cc <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f011a8be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a8c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a8c4:	01 d0                	add    %edx,%eax
f011a8c6:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011a8c9:	ff 45 f4             	incl   -0xc(%ebp)
f011a8cc:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a8d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a8d5:	7f e7                	jg     f011a8be <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f011a8d7:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a8da:	e8 55 45 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a8df:	29 c3                	sub    %eax,%ebx
f011a8e1:	89 d8                	mov    %ebx,%eax
f011a8e3:	83 f8 01             	cmp    $0x1,%eax
f011a8e6:	74 17                	je     f011a8ff <test_kfree_bestfirstfit+0x6a7>
f011a8e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8ef:	83 ec 0c             	sub    $0xc,%esp
f011a8f2:	68 20 fa 12 f0       	push   $0xf012fa20
f011a8f7:	e8 8f 66 fe ff       	call   f0100f8b <cprintf>
f011a8fc:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f011a8ff:	83 ec 0c             	sub    $0xc,%esp
f011a902:	68 44 fa 12 f0       	push   $0xf012fa44
f011a907:	e8 7f 66 fe ff       	call   f0100f8b <cprintf>
f011a90c:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a90f:	e8 20 45 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a914:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a917:	e8 9c a1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a91c:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a91f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011a925:	83 ec 0c             	sub    $0xc,%esp
f011a928:	50                   	push   %eax
f011a929:	e8 a6 f5 fe ff       	call   f0109ed4 <kfree>
f011a92e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a931:	e8 82 a1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a936:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a939:	74 17                	je     f011a952 <test_kfree_bestfirstfit+0x6fa>
f011a93b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a942:	83 ec 0c             	sub    $0xc,%esp
f011a945:	68 74 fa 12 f0       	push   $0xf012fa74
f011a94a:	e8 3c 66 fe ff       	call   f0100f8b <cprintf>
f011a94f:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a952:	e8 dd 44 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a957:	89 c2                	mov    %eax,%edx
f011a959:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a95c:	29 c2                	sub    %eax,%edx
f011a95e:	89 d0                	mov    %edx,%eax
f011a960:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a965:	77 17                	ja     f011a97e <test_kfree_bestfirstfit+0x726>
f011a967:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a96e:	83 ec 0c             	sub    $0xc,%esp
f011a971:	68 e4 fa 12 f0       	push   $0xf012fae4
f011a976:	e8 10 66 fe ff       	call   f0100f8b <cprintf>
f011a97b:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f011a97e:	e8 b1 44 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a983:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a986:	e8 2d a1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a98b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a98e:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a994:	83 ec 0c             	sub    $0xc,%esp
f011a997:	50                   	push   %eax
f011a998:	e8 37 f5 fe ff       	call   f0109ed4 <kfree>
f011a99d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9a0:	e8 13 a1 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a9a5:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a9a8:	74 17                	je     f011a9c1 <test_kfree_bestfirstfit+0x769>
f011a9aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9b1:	83 ec 0c             	sub    $0xc,%esp
f011a9b4:	68 20 fb 12 f0       	push   $0xf012fb20
f011a9b9:	e8 cd 65 fe ff       	call   f0100f8b <cprintf>
f011a9be:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a9c1:	e8 6e 44 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a9c6:	89 c2                	mov    %eax,%edx
f011a9c8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a9cb:	39 c2                	cmp    %eax,%edx
f011a9cd:	74 17                	je     f011a9e6 <test_kfree_bestfirstfit+0x78e>
f011a9cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9d6:	83 ec 0c             	sub    $0xc,%esp
f011a9d9:	68 90 fb 12 f0       	push   $0xf012fb90
f011a9de:	e8 a8 65 fe ff       	call   f0100f8b <cprintf>
f011a9e3:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a9e6:	e8 49 44 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011a9eb:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a9ee:	e8 c5 a0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011a9f3:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a9f6:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a9fc:	83 ec 0c             	sub    $0xc,%esp
f011a9ff:	50                   	push   %eax
f011aa00:	e8 cf f4 fe ff       	call   f0109ed4 <kfree>
f011aa05:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa08:	e8 ab a0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011aa0d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011aa10:	74 17                	je     f011aa29 <test_kfree_bestfirstfit+0x7d1>
f011aa12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa19:	83 ec 0c             	sub    $0xc,%esp
f011aa1c:	68 f0 fb 12 f0       	push   $0xf012fbf0
f011aa21:	e8 65 65 fe ff       	call   f0100f8b <cprintf>
f011aa26:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa29:	e8 06 44 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011aa2e:	89 c2                	mov    %eax,%edx
f011aa30:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aa33:	29 c2                	sub    %eax,%edx
f011aa35:	89 d0                	mov    %edx,%eax
f011aa37:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aa3c:	77 17                	ja     f011aa55 <test_kfree_bestfirstfit+0x7fd>
f011aa3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa45:	83 ec 0c             	sub    $0xc,%esp
f011aa48:	68 60 fc 12 f0       	push   $0xf012fc60
f011aa4d:	e8 39 65 fe ff       	call   f0100f8b <cprintf>
f011aa52:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011aa55:	e8 da 43 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011aa5a:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aa5d:	e8 56 a0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011aa62:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011aa65:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011aa6b:	83 ec 0c             	sub    $0xc,%esp
f011aa6e:	50                   	push   %eax
f011aa6f:	e8 60 f4 fe ff       	call   f0109ed4 <kfree>
f011aa74:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa77:	e8 3c a0 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011aa7c:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011aa7f:	74 17                	je     f011aa98 <test_kfree_bestfirstfit+0x840>
f011aa81:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa88:	83 ec 0c             	sub    $0xc,%esp
f011aa8b:	68 9c fc 12 f0       	push   $0xf012fc9c
f011aa90:	e8 f6 64 fe ff       	call   f0100f8b <cprintf>
f011aa95:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa98:	e8 97 43 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011aa9d:	89 c2                	mov    %eax,%edx
f011aa9f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aaa2:	29 c2                	sub    %eax,%edx
f011aaa4:	89 d0                	mov    %edx,%eax
f011aaa6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011aaab:	77 17                	ja     f011aac4 <test_kfree_bestfirstfit+0x86c>
f011aaad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aab4:	83 ec 0c             	sub    $0xc,%esp
f011aab7:	68 0c fd 12 f0       	push   $0xf012fd0c
f011aabc:	e8 ca 64 fe ff       	call   f0100f8b <cprintf>
f011aac1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011aac4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aac8:	74 04                	je     f011aace <test_kfree_bestfirstfit+0x876>
f011aaca:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011aace:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f011aad5:	83 ec 0c             	sub    $0xc,%esp
f011aad8:	68 48 fd 12 f0       	push   $0xf012fd48
f011aadd:	e8 a9 64 fe ff       	call   f0100f8b <cprintf>
f011aae2:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011aae5:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011aaeb:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011aaee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aaf5:	eb 1e                	jmp    f011ab15 <test_kfree_bestfirstfit+0x8bd>
		{
			sums[3] += ptr[i] ;
f011aaf7:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011aafd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab00:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab03:	01 c8                	add    %ecx,%eax
f011ab05:	8a 00                	mov    (%eax),%al
f011ab07:	0f be c0             	movsbl %al,%eax
f011ab0a:	01 d0                	add    %edx,%eax
f011ab0c:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011ab12:	ff 45 f4             	incl   -0xc(%ebp)
f011ab15:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011ab1b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab1e:	7f d7                	jg     f011aaf7 <test_kfree_bestfirstfit+0x89f>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f011ab20:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f011ab26:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011ab2c:	89 c1                	mov    %eax,%ecx
f011ab2e:	01 c9                	add    %ecx,%ecx
f011ab30:	01 c8                	add    %ecx,%eax
f011ab32:	39 c2                	cmp    %eax,%edx
f011ab34:	74 17                	je     f011ab4d <test_kfree_bestfirstfit+0x8f5>
f011ab36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab3d:	83 ec 0c             	sub    $0xc,%esp
f011ab40:	68 90 fd 12 f0       	push   $0xf012fd90
f011ab45:	e8 41 64 fe ff       	call   f0100f8b <cprintf>
f011ab4a:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011ab4d:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011ab53:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011ab56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab5d:	eb 1e                	jmp    f011ab7d <test_kfree_bestfirstfit+0x925>
		{
			sums[4] += ptr[i] ;
f011ab5f:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011ab65:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab68:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab6b:	01 c8                	add    %ecx,%eax
f011ab6d:	8a 00                	mov    (%eax),%al
f011ab6f:	0f be c0             	movsbl %al,%eax
f011ab72:	01 d0                	add    %edx,%eax
f011ab74:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011ab7a:	ff 45 f4             	incl   -0xc(%ebp)
f011ab7d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011ab83:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab86:	7f d7                	jg     f011ab5f <test_kfree_bestfirstfit+0x907>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f011ab88:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011ab8e:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f011ab94:	c1 e2 02             	shl    $0x2,%edx
f011ab97:	39 d0                	cmp    %edx,%eax
f011ab99:	74 17                	je     f011abb2 <test_kfree_bestfirstfit+0x95a>
f011ab9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aba2:	83 ec 0c             	sub    $0xc,%esp
f011aba5:	68 c8 fd 12 f0       	push   $0xf012fdc8
f011abaa:	e8 dc 63 fe ff       	call   f0100f8b <cprintf>
f011abaf:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011abb2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011abb8:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011abbb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abc2:	eb 1e                	jmp    f011abe2 <test_kfree_bestfirstfit+0x98a>
		{
			sums[5] += ptr[i] ;
f011abc4:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011abca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abcd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abd0:	01 c8                	add    %ecx,%eax
f011abd2:	8a 00                	mov    (%eax),%al
f011abd4:	0f be c0             	movsbl %al,%eax
f011abd7:	01 d0                	add    %edx,%eax
f011abd9:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011abdf:	ff 45 f4             	incl   -0xc(%ebp)
f011abe2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011abe8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abeb:	7f d7                	jg     f011abc4 <test_kfree_bestfirstfit+0x96c>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f011abed:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011abf3:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011abf9:	89 d0                	mov    %edx,%eax
f011abfb:	c1 e0 02             	shl    $0x2,%eax
f011abfe:	01 d0                	add    %edx,%eax
f011ac00:	39 c1                	cmp    %eax,%ecx
f011ac02:	74 17                	je     f011ac1b <test_kfree_bestfirstfit+0x9c3>
f011ac04:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac0b:	83 ec 0c             	sub    $0xc,%esp
f011ac0e:	68 00 fe 12 f0       	push   $0xf012fe00
f011ac13:	e8 73 63 fe ff       	call   f0100f8b <cprintf>
f011ac18:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011ac1b:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011ac21:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011ac24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac2b:	eb 1e                	jmp    f011ac4b <test_kfree_bestfirstfit+0x9f3>
		{
			sums[7] += ptr[i] ;
f011ac2d:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011ac33:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac36:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac39:	01 c8                	add    %ecx,%eax
f011ac3b:	8a 00                	mov    (%eax),%al
f011ac3d:	0f be c0             	movsbl %al,%eax
f011ac40:	01 d0                	add    %edx,%eax
f011ac42:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011ac48:	ff 45 f4             	incl   -0xc(%ebp)
f011ac4b:	8b 45 80             	mov    -0x80(%ebp),%eax
f011ac4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac51:	7f da                	jg     f011ac2d <test_kfree_bestfirstfit+0x9d5>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011ac53:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f011ac59:	8b 55 80             	mov    -0x80(%ebp),%edx
f011ac5c:	89 d0                	mov    %edx,%eax
f011ac5e:	01 c0                	add    %eax,%eax
f011ac60:	01 d0                	add    %edx,%eax
f011ac62:	01 c0                	add    %eax,%eax
f011ac64:	01 d0                	add    %edx,%eax
f011ac66:	39 c1                	cmp    %eax,%ecx
f011ac68:	74 17                	je     f011ac81 <test_kfree_bestfirstfit+0xa29>
f011ac6a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac71:	83 ec 0c             	sub    $0xc,%esp
f011ac74:	68 38 fe 12 f0       	push   $0xf012fe38
f011ac79:	e8 0d 63 fe ff       	call   f0100f8b <cprintf>
f011ac7e:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011ac81:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac85:	74 04                	je     f011ac8b <test_kfree_bestfirstfit+0xa33>
f011ac87:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011ac8b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f011ac92:	83 ec 0c             	sub    $0xc,%esp
f011ac95:	68 70 fe 12 f0       	push   $0xf012fe70
f011ac9a:	e8 ec 62 fe ff       	call   f0100f8b <cprintf>
f011ac9f:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011aca2:	e8 8d 41 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011aca7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011acaa:	e8 09 9e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011acaf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011acb2:	83 ec 0c             	sub    $0xc,%esp
f011acb5:	68 00 04 00 00       	push   $0x400
f011acba:	e8 ab ef fe ff       	call   f0109c6a <kmalloc>
f011acbf:	83 c4 10             	add    $0x10,%esp
f011acc2:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f011acc8:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f011acce:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011acd4:	39 c2                	cmp    %eax,%edx
f011acd6:	74 17                	je     f011acef <test_kfree_bestfirstfit+0xa97>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011acd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acdf:	83 ec 0c             	sub    $0xc,%esp
f011ace2:	68 90 fe 12 f0       	push   $0xf012fe90
f011ace7:	e8 9f 62 fe ff       	call   f0100f8b <cprintf>
f011acec:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011acef:	e8 c4 9d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011acf4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011acf7:	74 17                	je     f011ad10 <test_kfree_bestfirstfit+0xab8>
f011acf9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad00:	83 ec 0c             	sub    $0xc,%esp
f011ad03:	68 e4 fe 12 f0       	push   $0xf012fee4
f011ad08:	e8 7e 62 fe ff       	call   f0100f8b <cprintf>
f011ad0d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ad10:	e8 1f 41 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ad15:	89 c2                	mov    %eax,%edx
f011ad17:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ad1a:	39 c2                	cmp    %eax,%edx
f011ad1c:	74 17                	je     f011ad35 <test_kfree_bestfirstfit+0xadd>
f011ad1e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad25:	83 ec 0c             	sub    $0xc,%esp
f011ad28:	68 54 ff 12 f0       	push   $0xf012ff54
f011ad2d:	e8 59 62 fe ff       	call   f0100f8b <cprintf>
f011ad32:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011ad35:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f011ad3c:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011ad42:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011ad45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad4c:	eb 0e                	jmp    f011ad5c <test_kfree_bestfirstfit+0xb04>
		{
			ptr[i] = 9 ;
f011ad4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad51:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad54:	01 d0                	add    %edx,%eax
f011ad56:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011ad59:	ff 45 f4             	incl   -0xc(%ebp)
f011ad5c:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ad5f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad62:	7f ea                	jg     f011ad4e <test_kfree_bestfirstfit+0xaf6>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ad64:	e8 cb 40 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ad69:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ad6c:	e8 47 9d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ad71:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011ad74:	83 ec 0c             	sub    $0xc,%esp
f011ad77:	68 00 00 30 00       	push   $0x300000
f011ad7c:	e8 e9 ee fe ff       	call   f0109c6a <kmalloc>
f011ad81:	83 c4 10             	add    $0x10,%esp
f011ad84:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ad8a:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011ad90:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ad95:	74 17                	je     f011adae <test_kfree_bestfirstfit+0xb56>
f011ad97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad9e:	83 ec 0c             	sub    $0xc,%esp
f011ada1:	68 d0 ff 12 f0       	push   $0xf012ffd0
f011ada6:	e8 e0 61 fe ff       	call   f0100f8b <cprintf>
f011adab:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011adae:	e8 05 9d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011adb3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011adb6:	74 17                	je     f011adcf <test_kfree_bestfirstfit+0xb77>
f011adb8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adbf:	83 ec 0c             	sub    $0xc,%esp
f011adc2:	68 24 00 13 f0       	push   $0xf0130024
f011adc7:	e8 bf 61 fe ff       	call   f0100f8b <cprintf>
f011adcc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011adcf:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011add2:	e8 5d 40 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011add7:	29 c3                	sub    %eax,%ebx
f011add9:	89 d8                	mov    %ebx,%eax
f011addb:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ade0:	77 17                	ja     f011adf9 <test_kfree_bestfirstfit+0xba1>
f011ade2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ade9:	83 ec 0c             	sub    $0xc,%esp
f011adec:	68 94 00 13 f0       	push   $0xf0130094
f011adf1:	e8 95 61 fe ff       	call   f0100f8b <cprintf>
f011adf6:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011adf9:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011ae00:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011ae06:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011ae09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ae10:	eb 0e                	jmp    f011ae20 <test_kfree_bestfirstfit+0xbc8>
		{
			ptr[i] = 8 ;
f011ae12:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ae15:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ae18:	01 d0                	add    %edx,%eax
f011ae1a:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011ae1d:	ff 45 f4             	incl   -0xc(%ebp)
f011ae20:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011ae23:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ae26:	7f ea                	jg     f011ae12 <test_kfree_bestfirstfit+0xbba>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011ae28:	e8 07 40 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ae2d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae30:	e8 83 9c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ae35:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011ae38:	83 ec 0c             	sub    $0xc,%esp
f011ae3b:	68 00 00 10 00       	push   $0x100000
f011ae40:	e8 25 ee fe ff       	call   f0109c6a <kmalloc>
f011ae45:	83 c4 10             	add    $0x10,%esp
f011ae48:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae4e:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae54:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011ae59:	74 17                	je     f011ae72 <test_kfree_bestfirstfit+0xc1a>
f011ae5b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae62:	83 ec 0c             	sub    $0xc,%esp
f011ae65:	68 dc 00 13 f0       	push   $0xf01300dc
f011ae6a:	e8 1c 61 fe ff       	call   f0100f8b <cprintf>
f011ae6f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae72:	e8 41 9c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ae77:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ae7a:	74 17                	je     f011ae93 <test_kfree_bestfirstfit+0xc3b>
f011ae7c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae83:	83 ec 0c             	sub    $0xc,%esp
f011ae86:	68 30 01 13 f0       	push   $0xf0130130
f011ae8b:	e8 fb 60 fe ff       	call   f0100f8b <cprintf>
f011ae90:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ae93:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ae96:	e8 99 3f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ae9b:	29 c3                	sub    %eax,%ebx
f011ae9d:	89 d8                	mov    %ebx,%eax
f011ae9f:	3d ff 00 00 00       	cmp    $0xff,%eax
f011aea4:	77 17                	ja     f011aebd <test_kfree_bestfirstfit+0xc65>
f011aea6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aead:	83 ec 0c             	sub    $0xc,%esp
f011aeb0:	68 a0 01 13 f0       	push   $0xf01301a0
f011aeb5:	e8 d1 60 fe ff       	call   f0100f8b <cprintf>
f011aeba:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011aebd:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f011aec4:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aeca:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011aecd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aed4:	eb 0e                	jmp    f011aee4 <test_kfree_bestfirstfit+0xc8c>
		{
			ptr[i] = 10 ;
f011aed6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aed9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aedc:	01 d0                	add    %edx,%eax
f011aede:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011aee1:	ff 45 f4             	incl   -0xc(%ebp)
f011aee4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aee7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aeea:	7f ea                	jg     f011aed6 <test_kfree_bestfirstfit+0xc7e>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f011aeec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aef0:	74 04                	je     f011aef6 <test_kfree_bestfirstfit+0xc9e>
f011aef2:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aef6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f011aefd:	83 ec 0c             	sub    $0xc,%esp
f011af00:	68 e8 01 13 f0       	push   $0xf01301e8
f011af05:	e8 81 60 fe ff       	call   f0100f8b <cprintf>
f011af0a:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f011af0d:	e8 22 3f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011af12:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011af15:	e8 9e 9b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011af1a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f011af1d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011af23:	83 ec 0c             	sub    $0xc,%esp
f011af26:	50                   	push   %eax
f011af27:	e8 a8 ef fe ff       	call   f0109ed4 <kfree>
f011af2c:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af2f:	e8 84 9b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011af34:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011af37:	74 17                	je     f011af50 <test_kfree_bestfirstfit+0xcf8>
f011af39:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af40:	83 ec 0c             	sub    $0xc,%esp
f011af43:	68 14 02 13 f0       	push   $0xf0130214
f011af48:	e8 3e 60 fe ff       	call   f0100f8b <cprintf>
f011af4d:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011af50:	e8 df 3e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011af55:	89 c2                	mov    %eax,%edx
f011af57:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011af5a:	29 c2                	sub    %eax,%edx
f011af5c:	89 d0                	mov    %edx,%eax
f011af5e:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011af63:	77 17                	ja     f011af7c <test_kfree_bestfirstfit+0xd24>
f011af65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af6c:	83 ec 0c             	sub    $0xc,%esp
f011af6f:	68 84 02 13 f0       	push   $0xf0130284
f011af74:	e8 12 60 fe ff       	call   f0100f8b <cprintf>
f011af79:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f011af7c:	e8 b3 3e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011af81:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011af84:	e8 2f 9b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011af89:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f011af8c:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011af92:	83 ec 0c             	sub    $0xc,%esp
f011af95:	50                   	push   %eax
f011af96:	e8 39 ef fe ff       	call   f0109ed4 <kfree>
f011af9b:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af9e:	e8 15 9b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011afa3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011afa6:	74 17                	je     f011afbf <test_kfree_bestfirstfit+0xd67>
f011afa8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afaf:	83 ec 0c             	sub    $0xc,%esp
f011afb2:	68 c0 02 13 f0       	push   $0xf01302c0
f011afb7:	e8 cf 5f fe ff       	call   f0100f8b <cprintf>
f011afbc:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011afbf:	e8 70 3e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011afc4:	89 c2                	mov    %eax,%edx
f011afc6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011afc9:	29 c2                	sub    %eax,%edx
f011afcb:	89 d0                	mov    %edx,%eax
f011afcd:	83 f8 01             	cmp    $0x1,%eax
f011afd0:	77 17                	ja     f011afe9 <test_kfree_bestfirstfit+0xd91>
f011afd2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afd9:	83 ec 0c             	sub    $0xc,%esp
f011afdc:	68 30 03 13 f0       	push   $0xf0130330
f011afe1:	e8 a5 5f fe ff       	call   f0100f8b <cprintf>
f011afe6:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f011afe9:	e8 46 3e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011afee:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011aff1:	e8 c2 9a fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011aff6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f011aff9:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011afff:	83 ec 0c             	sub    $0xc,%esp
f011b002:	50                   	push   %eax
f011b003:	e8 cc ee fe ff       	call   f0109ed4 <kfree>
f011b008:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b00b:	e8 a8 9a fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b010:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b013:	74 17                	je     f011b02c <test_kfree_bestfirstfit+0xdd4>
f011b015:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b01c:	83 ec 0c             	sub    $0xc,%esp
f011b01f:	68 6c 03 13 f0       	push   $0xf013036c
f011b024:	e8 62 5f fe ff       	call   f0100f8b <cprintf>
f011b029:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b02c:	e8 03 3e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b031:	89 c2                	mov    %eax,%edx
f011b033:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b036:	29 c2                	sub    %eax,%edx
f011b038:	89 d0                	mov    %edx,%eax
f011b03a:	83 f8 03             	cmp    $0x3,%eax
f011b03d:	77 17                	ja     f011b056 <test_kfree_bestfirstfit+0xdfe>
f011b03f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b046:	83 ec 0c             	sub    $0xc,%esp
f011b049:	68 dc 03 13 f0       	push   $0xf01303dc
f011b04e:	e8 38 5f fe ff       	call   f0100f8b <cprintf>
f011b053:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f011b056:	e8 d9 3d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b05b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b05e:	e8 55 9a fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b063:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f011b066:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011b06c:	83 ec 0c             	sub    $0xc,%esp
f011b06f:	50                   	push   %eax
f011b070:	e8 5f ee fe ff       	call   f0109ed4 <kfree>
f011b075:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b078:	e8 3b 9a fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b07d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b080:	74 17                	je     f011b099 <test_kfree_bestfirstfit+0xe41>
f011b082:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b089:	83 ec 0c             	sub    $0xc,%esp
f011b08c:	68 18 04 13 f0       	push   $0xf0130418
f011b091:	e8 f5 5e fe ff       	call   f0100f8b <cprintf>
f011b096:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b099:	e8 96 3d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b09e:	89 c2                	mov    %eax,%edx
f011b0a0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b0a3:	29 c2                	sub    %eax,%edx
f011b0a5:	89 d0                	mov    %edx,%eax
f011b0a7:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b0ac:	77 17                	ja     f011b0c5 <test_kfree_bestfirstfit+0xe6d>
f011b0ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0b5:	83 ec 0c             	sub    $0xc,%esp
f011b0b8:	68 88 04 13 f0       	push   $0xf0130488
f011b0bd:	e8 c9 5e fe ff       	call   f0100f8b <cprintf>
f011b0c2:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f011b0c5:	e8 6a 3d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b0ca:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b0cd:	e8 e6 99 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b0d2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f011b0d5:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011b0db:	83 ec 0c             	sub    $0xc,%esp
f011b0de:	50                   	push   %eax
f011b0df:	e8 f0 ed fe ff       	call   f0109ed4 <kfree>
f011b0e4:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0e7:	e8 cc 99 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b0ec:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b0ef:	74 17                	je     f011b108 <test_kfree_bestfirstfit+0xeb0>
f011b0f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0f8:	83 ec 0c             	sub    $0xc,%esp
f011b0fb:	68 c4 04 13 f0       	push   $0xf01304c4
f011b100:	e8 86 5e fe ff       	call   f0100f8b <cprintf>
f011b105:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b108:	e8 27 3d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b10d:	89 c2                	mov    %eax,%edx
f011b10f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b112:	29 c2                	sub    %eax,%edx
f011b114:	89 d0                	mov    %edx,%eax
f011b116:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b11b:	77 17                	ja     f011b134 <test_kfree_bestfirstfit+0xedc>
f011b11d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b124:	83 ec 0c             	sub    $0xc,%esp
f011b127:	68 34 05 13 f0       	push   $0xf0130534
f011b12c:	e8 5a 5e fe ff       	call   f0100f8b <cprintf>
f011b131:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011b134:	e8 fb 3c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b139:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b13c:	e8 77 99 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b141:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011b144:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011b14a:	83 ec 0c             	sub    $0xc,%esp
f011b14d:	50                   	push   %eax
f011b14e:	e8 81 ed fe ff       	call   f0109ed4 <kfree>
f011b153:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b156:	e8 5d 99 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b15b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b15e:	74 17                	je     f011b177 <test_kfree_bestfirstfit+0xf1f>
f011b160:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b167:	83 ec 0c             	sub    $0xc,%esp
f011b16a:	68 70 05 13 f0       	push   $0xf0130570
f011b16f:	e8 17 5e fe ff       	call   f0100f8b <cprintf>
f011b174:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b177:	e8 b8 3c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b17c:	89 c2                	mov    %eax,%edx
f011b17e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b181:	39 c2                	cmp    %eax,%edx
f011b183:	74 17                	je     f011b19c <test_kfree_bestfirstfit+0xf44>
f011b185:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b18c:	83 ec 0c             	sub    $0xc,%esp
f011b18f:	68 e0 05 13 f0       	push   $0xf01305e0
f011b194:	e8 f2 5d fe ff       	call   f0100f8b <cprintf>
f011b199:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f011b19c:	e8 93 3c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b1a1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b1a4:	e8 0f 99 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b1a9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f011b1ac:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011b1b2:	83 ec 0c             	sub    $0xc,%esp
f011b1b5:	50                   	push   %eax
f011b1b6:	e8 19 ed fe ff       	call   f0109ed4 <kfree>
f011b1bb:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b1be:	e8 f5 98 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b1c3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b1c6:	74 17                	je     f011b1df <test_kfree_bestfirstfit+0xf87>
f011b1c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1cf:	83 ec 0c             	sub    $0xc,%esp
f011b1d2:	68 1c 06 13 f0       	push   $0xf013061c
f011b1d7:	e8 af 5d fe ff       	call   f0100f8b <cprintf>
f011b1dc:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011b1df:	e8 50 3c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b1e4:	89 c2                	mov    %eax,%edx
f011b1e6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b1e9:	39 c2                	cmp    %eax,%edx
f011b1eb:	74 17                	je     f011b204 <test_kfree_bestfirstfit+0xfac>
f011b1ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1f4:	83 ec 0c             	sub    $0xc,%esp
f011b1f7:	68 8c 06 13 f0       	push   $0xf013068c
f011b1fc:	e8 8a 5d fe ff       	call   f0100f8b <cprintf>
f011b201:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011b204:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b208:	74 04                	je     f011b20e <test_kfree_bestfirstfit+0xfb6>
f011b20a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b20e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f011b215:	83 ec 0c             	sub    $0xc,%esp
f011b218:	68 ec 06 13 f0       	push   $0xf01306ec
f011b21d:	e8 69 5d fe ff       	call   f0100f8b <cprintf>
f011b222:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011b225:	83 ec 0c             	sub    $0xc,%esp
f011b228:	6a 03                	push   $0x3
f011b22a:	e8 e9 40 ff ff       	call   f010f318 <sys_bypassPageFault>
f011b22f:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011b232:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b239:	e9 af 00 00 00       	jmp    f011b2ed <test_kfree_bestfirstfit+0x1095>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011b23e:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011b242:	0f 84 a1 00 00 00    	je     f011b2e9 <test_kfree_bestfirstfit+0x1091>
f011b248:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011b24c:	0f 84 97 00 00 00    	je     f011b2e9 <test_kfree_bestfirstfit+0x1091>
f011b252:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011b256:	0f 84 8d 00 00 00    	je     f011b2e9 <test_kfree_bestfirstfit+0x1091>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011b25c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b25f:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f011b266:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011b269:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b26c:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011b26f:	e8 92 40 ff ff       	call   f010f306 <sys_rcr2>
f011b274:	89 c2                	mov    %eax,%edx
f011b276:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b279:	39 c2                	cmp    %eax,%edx
f011b27b:	74 1d                	je     f011b29a <test_kfree_bestfirstfit+0x1042>
				if (correct)
f011b27d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b281:	74 17                	je     f011b29a <test_kfree_bestfirstfit+0x1042>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b283:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b28a:	83 ec 0c             	sub    $0xc,%esp
f011b28d:	68 2c 07 13 f0       	push   $0xf013072c
f011b292:	e8 f4 5c fe ff       	call   f0100f8b <cprintf>
f011b297:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011b29a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b29d:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011b2a4:	89 c2                	mov    %eax,%edx
f011b2a6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b2a9:	01 d0                	add    %edx,%eax
f011b2ab:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011b2ae:	e8 53 40 ff ff       	call   f010f306 <sys_rcr2>
f011b2b3:	89 c2                	mov    %eax,%edx
f011b2b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b2b8:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f011b2bf:	89 c1                	mov    %eax,%ecx
f011b2c1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b2c4:	01 c8                	add    %ecx,%eax
f011b2c6:	39 c2                	cmp    %eax,%edx
f011b2c8:	74 20                	je     f011b2ea <test_kfree_bestfirstfit+0x1092>
				if (correct)
f011b2ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2ce:	74 1a                	je     f011b2ea <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b2d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2d7:	83 ec 0c             	sub    $0xc,%esp
f011b2da:	68 78 07 13 f0       	push   $0xf0130778
f011b2df:	e8 a7 5c fe ff       	call   f0100f8b <cprintf>
f011b2e4:	83 c4 10             	add    $0x10,%esp
f011b2e7:	eb 01                	jmp    f011b2ea <test_kfree_bestfirstfit+0x1092>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011b2e9:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011b2ea:	ff 45 f4             	incl   -0xc(%ebp)
f011b2ed:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011b2f1:	0f 8e 47 ff ff ff    	jle    f011b23e <test_kfree_bestfirstfit+0xfe6>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011b2f7:	83 ec 0c             	sub    $0xc,%esp
f011b2fa:	6a 00                	push   $0x0
f011b2fc:	e8 17 40 ff ff       	call   f010f318 <sys_bypassPageFault>
f011b301:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011b304:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b308:	74 04                	je     f011b30e <test_kfree_bestfirstfit+0x10b6>
f011b30a:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b30e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f011b315:	83 ec 0c             	sub    $0xc,%esp
f011b318:	68 c4 07 13 f0       	push   $0xf01307c4
f011b31d:	e8 69 5c fe ff       	call   f0100f8b <cprintf>
f011b322:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011b325:	e8 0a 3b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b32a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b32d:	e8 86 97 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b332:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f011b335:	83 ec 0c             	sub    $0xc,%esp
f011b338:	68 00 04 00 00       	push   $0x400
f011b33d:	e8 28 e9 fe ff       	call   f0109c6a <kmalloc>
f011b342:	83 c4 10             	add    $0x10,%esp
f011b345:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f011b34b:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011b351:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011b357:	39 c2                	cmp    %eax,%edx
f011b359:	74 17                	je     f011b372 <test_kfree_bestfirstfit+0x111a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b35b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b362:	83 ec 0c             	sub    $0xc,%esp
f011b365:	68 e8 07 13 f0       	push   $0xf01307e8
f011b36a:	e8 1c 5c fe ff       	call   f0100f8b <cprintf>
f011b36f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b372:	e8 41 97 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b377:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b37a:	74 17                	je     f011b393 <test_kfree_bestfirstfit+0x113b>
f011b37c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b383:	83 ec 0c             	sub    $0xc,%esp
f011b386:	68 3c 08 13 f0       	push   $0xf013083c
f011b38b:	e8 fb 5b fe ff       	call   f0100f8b <cprintf>
f011b390:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b393:	e8 9c 3a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b398:	89 c2                	mov    %eax,%edx
f011b39a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b39d:	39 c2                	cmp    %eax,%edx
f011b39f:	74 17                	je     f011b3b8 <test_kfree_bestfirstfit+0x1160>
f011b3a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b3a8:	83 ec 0c             	sub    $0xc,%esp
f011b3ab:	68 ac 08 13 f0       	push   $0xf01308ac
f011b3b0:	e8 d6 5b fe ff       	call   f0100f8b <cprintf>
f011b3b5:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011b3b8:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f011b3bf:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b3c5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011b3c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b3cf:	eb 0e                	jmp    f011b3df <test_kfree_bestfirstfit+0x1187>
			{
				ptr[i] = 11 ;
f011b3d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b3d4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b3d7:	01 d0                	add    %edx,%eax
f011b3d9:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011b3dc:	ff 45 f4             	incl   -0xc(%ebp)
f011b3df:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b3e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b3e5:	7f ea                	jg     f011b3d1 <test_kfree_bestfirstfit+0x1179>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011b3e7:	e8 48 3a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b3ec:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b3ef:	e8 c4 96 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b3f4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f011b3f7:	83 ec 0c             	sub    $0xc,%esp
f011b3fa:	68 00 08 00 00       	push   $0x800
f011b3ff:	e8 66 e8 fe ff       	call   f0109c6a <kmalloc>
f011b404:	83 c4 10             	add    $0x10,%esp
f011b407:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f011b40d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011b413:	05 08 04 00 00       	add    $0x408,%eax
f011b418:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f011b41b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b421:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b424:	74 35                	je     f011b45b <test_kfree_bestfirstfit+0x1203>
			{
				correct = 0;
f011b426:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011b42d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b433:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011b439:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011b43f:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f011b445:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b44b:	50                   	push   %eax
f011b44c:	51                   	push   %ecx
f011b44d:	52                   	push   %edx
f011b44e:	68 28 09 13 f0       	push   $0xf0130928
f011b453:	e8 33 5b fe ff       	call   f0100f8b <cprintf>
f011b458:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b45b:	e8 58 96 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b460:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b463:	74 17                	je     f011b47c <test_kfree_bestfirstfit+0x1224>
f011b465:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b46c:	83 ec 0c             	sub    $0xc,%esp
f011b46f:	68 9c 09 13 f0       	push   $0xf013099c
f011b474:	e8 12 5b fe ff       	call   f0100f8b <cprintf>
f011b479:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b47c:	e8 b3 39 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b481:	89 c2                	mov    %eax,%edx
f011b483:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b486:	39 c2                	cmp    %eax,%edx
f011b488:	74 17                	je     f011b4a1 <test_kfree_bestfirstfit+0x1249>
f011b48a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b491:	83 ec 0c             	sub    $0xc,%esp
f011b494:	68 0c 0a 13 f0       	push   $0xf0130a0c
f011b499:	e8 ed 5a fe ff       	call   f0100f8b <cprintf>
f011b49e:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011b4a1:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f011b4a8:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b4ae:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011b4b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b4b8:	eb 0e                	jmp    f011b4c8 <test_kfree_bestfirstfit+0x1270>
			{
				ptr[i] = 12 ;
f011b4ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b4bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b4c0:	01 d0                	add    %edx,%eax
f011b4c2:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011b4c5:	ff 45 f4             	incl   -0xc(%ebp)
f011b4c8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b4cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b4ce:	7f ea                	jg     f011b4ba <test_kfree_bestfirstfit+0x1262>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011b4d0:	e8 5f 39 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b4d5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b4d8:	e8 db 95 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b4dd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011b4e0:	83 ec 0c             	sub    $0xc,%esp
f011b4e3:	68 00 06 00 00       	push   $0x600
f011b4e8:	e8 7d e7 fe ff       	call   f0109c6a <kmalloc>
f011b4ed:	83 c4 10             	add    $0x10,%esp
f011b4f0:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f011b4f6:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011b4fc:	05 10 0c 00 00       	add    $0xc10,%eax
f011b501:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011b504:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b50a:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b50d:	74 17                	je     f011b526 <test_kfree_bestfirstfit+0x12ce>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b50f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b516:	83 ec 0c             	sub    $0xc,%esp
f011b519:	68 88 0a 13 f0       	push   $0xf0130a88
f011b51e:	e8 68 5a fe ff       	call   f0100f8b <cprintf>
f011b523:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b526:	e8 8d 95 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b52b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b52e:	74 17                	je     f011b547 <test_kfree_bestfirstfit+0x12ef>
f011b530:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b537:	83 ec 0c             	sub    $0xc,%esp
f011b53a:	68 dc 0a 13 f0       	push   $0xf0130adc
f011b53f:	e8 47 5a fe ff       	call   f0100f8b <cprintf>
f011b544:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b547:	e8 e8 38 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b54c:	89 c2                	mov    %eax,%edx
f011b54e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b551:	39 c2                	cmp    %eax,%edx
f011b553:	74 17                	je     f011b56c <test_kfree_bestfirstfit+0x1314>
f011b555:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b55c:	83 ec 0c             	sub    $0xc,%esp
f011b55f:	68 4c 0b 13 f0       	push   $0xf0130b4c
f011b564:	e8 22 5a fe ff       	call   f0100f8b <cprintf>
f011b569:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011b56c:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011b573:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b579:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011b57c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b583:	eb 0e                	jmp    f011b593 <test_kfree_bestfirstfit+0x133b>
			{
				ptr[i] = 13 ;
f011b585:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b588:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b58b:	01 d0                	add    %edx,%eax
f011b58d:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011b590:	ff 45 f4             	incl   -0xc(%ebp)
f011b593:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b596:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b599:	7f ea                	jg     f011b585 <test_kfree_bestfirstfit+0x132d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f011b59b:	e8 94 38 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b5a0:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011b5a3:	e8 10 95 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b5a8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f011b5ab:	83 ec 0c             	sub    $0xc,%esp
f011b5ae:	68 00 00 e0 01       	push   $0x1e00000
f011b5b3:	e8 b2 e6 fe ff       	call   f0109c6a <kmalloc>
f011b5b8:	83 c4 10             	add    $0x10,%esp
f011b5bb:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b5c1:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011b5c7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b5cc:	74 17                	je     f011b5e5 <test_kfree_bestfirstfit+0x138d>
f011b5ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5d5:	83 ec 0c             	sub    $0xc,%esp
f011b5d8:	68 c8 0b 13 f0       	push   $0xf0130bc8
f011b5dd:	e8 a9 59 fe ff       	call   f0100f8b <cprintf>
f011b5e2:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5e5:	e8 ce 94 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b5ea:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b5ed:	74 17                	je     f011b606 <test_kfree_bestfirstfit+0x13ae>
f011b5ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5f6:	83 ec 0c             	sub    $0xc,%esp
f011b5f9:	68 1c 0c 13 f0       	push   $0xf0130c1c
f011b5fe:	e8 88 59 fe ff       	call   f0100f8b <cprintf>
f011b603:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b606:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011b609:	e8 26 38 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b60e:	29 c3                	sub    %eax,%ebx
f011b610:	89 d8                	mov    %ebx,%eax
f011b612:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011b617:	77 17                	ja     f011b630 <test_kfree_bestfirstfit+0x13d8>
f011b619:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b620:	83 ec 0c             	sub    $0xc,%esp
f011b623:	68 8c 0c 13 f0       	push   $0xf0130c8c
f011b628:	e8 5e 59 fe ff       	call   f0100f8b <cprintf>
f011b62d:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011b630:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f011b637:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011b63d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011b640:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b647:	eb 0e                	jmp    f011b657 <test_kfree_bestfirstfit+0x13ff>
			{
				ptr[i] = 10 ;
f011b649:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b64c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b64f:	01 d0                	add    %edx,%eax
f011b651:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011b654:	ff 45 f4             	incl   -0xc(%ebp)
f011b657:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011b65a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b65d:	7f ea                	jg     f011b649 <test_kfree_bestfirstfit+0x13f1>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f011b65f:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011b665:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f011b668:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b66f:	eb 1e                	jmp    f011b68f <test_kfree_bestfirstfit+0x1437>
			{
				sums[10] += ptr[i] ;
f011b671:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011b677:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b67a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b67d:	01 c8                	add    %ecx,%eax
f011b67f:	8a 00                	mov    (%eax),%al
f011b681:	0f be c0             	movsbl %al,%eax
f011b684:	01 d0                	add    %edx,%eax
f011b686:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f011b68c:	ff 45 f4             	incl   -0xc(%ebp)
f011b68f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011b692:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b695:	7f da                	jg     f011b671 <test_kfree_bestfirstfit+0x1419>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f011b697:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f011b69d:	8b 55 8c             	mov    -0x74(%ebp),%edx
f011b6a0:	89 d0                	mov    %edx,%eax
f011b6a2:	c1 e0 02             	shl    $0x2,%eax
f011b6a5:	01 d0                	add    %edx,%eax
f011b6a7:	01 c0                	add    %eax,%eax
f011b6a9:	39 c1                	cmp    %eax,%ecx
f011b6ab:	74 17                	je     f011b6c4 <test_kfree_bestfirstfit+0x146c>
f011b6ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6b4:	83 ec 0c             	sub    $0xc,%esp
f011b6b7:	68 d4 0c 13 f0       	push   $0xf0130cd4
f011b6bc:	e8 ca 58 fe ff       	call   f0100f8b <cprintf>
f011b6c1:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f011b6c4:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b6ca:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f011b6cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b6d4:	eb 1e                	jmp    f011b6f4 <test_kfree_bestfirstfit+0x149c>
			{
				sums[11] += ptr[i] ;
f011b6d6:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011b6dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b6df:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b6e2:	01 c8                	add    %ecx,%eax
f011b6e4:	8a 00                	mov    (%eax),%al
f011b6e6:	0f be c0             	movsbl %al,%eax
f011b6e9:	01 d0                	add    %edx,%eax
f011b6eb:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f011b6f1:	ff 45 f4             	incl   -0xc(%ebp)
f011b6f4:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b6f7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b6fa:	7f da                	jg     f011b6d6 <test_kfree_bestfirstfit+0x147e>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f011b6fc:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011b702:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b705:	89 d0                	mov    %edx,%eax
f011b707:	c1 e0 02             	shl    $0x2,%eax
f011b70a:	01 d0                	add    %edx,%eax
f011b70c:	01 c0                	add    %eax,%eax
f011b70e:	01 d0                	add    %edx,%eax
f011b710:	39 c1                	cmp    %eax,%ecx
f011b712:	74 17                	je     f011b72b <test_kfree_bestfirstfit+0x14d3>
f011b714:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b71b:	83 ec 0c             	sub    $0xc,%esp
f011b71e:	68 04 0d 13 f0       	push   $0xf0130d04
f011b723:	e8 63 58 fe ff       	call   f0100f8b <cprintf>
f011b728:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f011b72b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b731:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f011b734:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b73b:	eb 1e                	jmp    f011b75b <test_kfree_bestfirstfit+0x1503>
			{
				sums[12] += ptr[i] ;
f011b73d:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011b743:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b746:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b749:	01 c8                	add    %ecx,%eax
f011b74b:	8a 00                	mov    (%eax),%al
f011b74d:	0f be c0             	movsbl %al,%eax
f011b750:	01 d0                	add    %edx,%eax
f011b752:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f011b758:	ff 45 f4             	incl   -0xc(%ebp)
f011b75b:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b75e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b761:	7f da                	jg     f011b73d <test_kfree_bestfirstfit+0x14e5>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f011b763:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011b769:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011b76c:	89 d0                	mov    %edx,%eax
f011b76e:	01 c0                	add    %eax,%eax
f011b770:	01 d0                	add    %edx,%eax
f011b772:	c1 e0 02             	shl    $0x2,%eax
f011b775:	39 c1                	cmp    %eax,%ecx
f011b777:	74 17                	je     f011b790 <test_kfree_bestfirstfit+0x1538>
f011b779:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b780:	83 ec 0c             	sub    $0xc,%esp
f011b783:	68 34 0d 13 f0       	push   $0xf0130d34
f011b788:	e8 fe 57 fe ff       	call   f0100f8b <cprintf>
f011b78d:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f011b790:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b796:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f011b799:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b7a0:	eb 1e                	jmp    f011b7c0 <test_kfree_bestfirstfit+0x1568>
			{
				sums[13] += ptr[i] ;
f011b7a2:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011b7a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b7ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b7ae:	01 c8                	add    %ecx,%eax
f011b7b0:	8a 00                	mov    (%eax),%al
f011b7b2:	0f be c0             	movsbl %al,%eax
f011b7b5:	01 d0                	add    %edx,%eax
f011b7b7:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f011b7bd:	ff 45 f4             	incl   -0xc(%ebp)
f011b7c0:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b7c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b7c6:	7f da                	jg     f011b7a2 <test_kfree_bestfirstfit+0x154a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f011b7c8:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011b7ce:	8b 55 98             	mov    -0x68(%ebp),%edx
f011b7d1:	89 d0                	mov    %edx,%eax
f011b7d3:	01 c0                	add    %eax,%eax
f011b7d5:	01 d0                	add    %edx,%eax
f011b7d7:	c1 e0 02             	shl    $0x2,%eax
f011b7da:	01 d0                	add    %edx,%eax
f011b7dc:	39 c1                	cmp    %eax,%ecx
f011b7de:	74 17                	je     f011b7f7 <test_kfree_bestfirstfit+0x159f>
f011b7e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7e7:	83 ec 0c             	sub    $0xc,%esp
f011b7ea:	68 64 0d 13 f0       	push   $0xf0130d64
f011b7ef:	e8 97 57 fe ff       	call   f0100f8b <cprintf>
f011b7f4:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f011b7f7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7fb:	74 04                	je     f011b801 <test_kfree_bestfirstfit+0x15a9>
f011b7fd:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b801:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f011b808:	83 ec 0c             	sub    $0xc,%esp
f011b80b:	68 91 0d 13 f0       	push   $0xf0130d91
f011b810:	e8 76 57 fe ff       	call   f0100f8b <cprintf>
f011b815:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b818:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011b81f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011b826:	eb 4e                	jmp    f011b876 <test_kfree_bestfirstfit+0x161e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011b828:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b82b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011b830:	83 ec 04             	sub    $0x4,%esp
f011b833:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f011b839:	51                   	push   %ecx
f011b83a:	52                   	push   %edx
f011b83b:	50                   	push   %eax
f011b83c:	e8 9f d2 fe ff       	call   f0108ae0 <get_page_table>
f011b841:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b844:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f011b84a:	85 c0                	test   %eax,%eax
f011b84c:	75 1d                	jne    f011b86b <test_kfree_bestfirstfit+0x1613>
			{
				if (correct)
f011b84e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b852:	74 17                	je     f011b86b <test_kfree_bestfirstfit+0x1613>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011b854:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b85b:	83 ec 0c             	sub    $0xc,%esp
f011b85e:	68 b0 0d 13 f0       	push   $0xf0130db0
f011b863:	e8 23 57 fe ff       	call   f0100f8b <cprintf>
f011b868:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b86b:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011b872:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011b876:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b87a:	78 ac                	js     f011b828 <test_kfree_bestfirstfit+0x15d0>
f011b87c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b880:	7f 09                	jg     f011b88b <test_kfree_bestfirstfit+0x1633>
f011b882:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011b889:	76 9d                	jbe    f011b828 <test_kfree_bestfirstfit+0x15d0>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011b88b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b88f:	74 04                	je     f011b895 <test_kfree_bestfirstfit+0x163d>
f011b891:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011b895:	83 ec 08             	sub    $0x8,%esp
f011b898:	ff 75 f0             	pushl  -0x10(%ebp)
f011b89b:	68 18 0e 13 f0       	push   $0xf0130e18
f011b8a0:	e8 e6 56 fe ff       	call   f0100f8b <cprintf>
f011b8a5:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b8a8:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b8ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b8b0:	5b                   	pop    %ebx
f011b8b1:	5f                   	pop    %edi
f011b8b2:	5d                   	pop    %ebp
f011b8b3:	c3                   	ret    

f011b8b4 <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011b8b4:	55                   	push   %ebp
f011b8b5:	89 e5                	mov    %esp,%ebp
f011b8b7:	57                   	push   %edi
f011b8b8:	53                   	push   %ebx
f011b8b9:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b8bf:	83 ec 0c             	sub    $0xc,%esp
f011b8c2:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011b8c7:	e8 bf 56 fe ff       	call   f0100f8b <cprintf>
f011b8cc:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b8cf:	83 ec 0c             	sub    $0xc,%esp
f011b8d2:	68 18 d1 12 f0       	push   $0xf012d118
f011b8d7:	e8 af 56 fe ff       	call   f0100f8b <cprintf>
f011b8dc:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b8df:	83 ec 0c             	sub    $0xc,%esp
f011b8e2:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011b8e7:	e8 9f 56 fe ff       	call   f0100f8b <cprintf>
f011b8ec:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b8ef:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011b8f3:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011b8f7:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b8fd:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b903:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b90a:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b911:	e8 1e 35 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b916:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011b919:	83 ec 0c             	sub    $0xc,%esp
f011b91c:	68 3c 0e 13 f0       	push   $0xf0130e3c
f011b921:	e8 65 56 fe ff       	call   f0100f8b <cprintf>
f011b926:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b929:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f011b92f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b934:	b8 00 00 00 00       	mov    $0x0,%eax
f011b939:	89 d7                	mov    %edx,%edi
f011b93b:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b93d:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f011b943:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b948:	b8 00 00 00 00       	mov    $0x0,%eax
f011b94d:	89 d7                	mov    %edx,%edi
f011b94f:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b951:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b958:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b95f:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011b965:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b96a:	b8 00 00 00 00       	mov    $0x0,%eax
f011b96f:	89 d7                	mov    %edx,%edi
f011b971:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b973:	e8 bc 34 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b978:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b97b:	e8 38 91 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b980:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b983:	83 ec 0c             	sub    $0xc,%esp
f011b986:	68 00 fc 1f 00       	push   $0x1ffc00
f011b98b:	e8 da e2 fe ff       	call   f0109c6a <kmalloc>
f011b990:	83 c4 10             	add    $0x10,%esp
f011b993:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b999:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b99f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b9a4:	74 17                	je     f011b9bd <test_kheap_phys_addr+0x109>
f011b9a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9ad:	83 ec 0c             	sub    $0xc,%esp
f011b9b0:	68 e0 f1 12 f0       	push   $0xf012f1e0
f011b9b5:	e8 d1 55 fe ff       	call   f0100f8b <cprintf>
f011b9ba:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b9bd:	e8 f6 90 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011b9c2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b9c5:	74 17                	je     f011b9de <test_kheap_phys_addr+0x12a>
f011b9c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9ce:	83 ec 0c             	sub    $0xc,%esp
f011b9d1:	68 34 f2 12 f0       	push   $0xf012f234
f011b9d6:	e8 b0 55 fe ff       	call   f0100f8b <cprintf>
f011b9db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b9de:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b9e1:	e8 4e 34 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011b9e6:	29 c3                	sub    %eax,%ebx
f011b9e8:	89 d8                	mov    %ebx,%eax
f011b9ea:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b9ef:	77 17                	ja     f011ba08 <test_kheap_phys_addr+0x154>
f011b9f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9f8:	83 ec 0c             	sub    $0xc,%esp
f011b9fb:	68 a4 f2 12 f0       	push   $0xf012f2a4
f011ba00:	e8 86 55 fe ff       	call   f0100f8b <cprintf>
f011ba05:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ba08:	e8 27 34 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ba0d:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ba10:	e8 a3 90 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ba15:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011ba18:	83 ec 0c             	sub    $0xc,%esp
f011ba1b:	68 00 fc 1f 00       	push   $0x1ffc00
f011ba20:	e8 45 e2 fe ff       	call   f0109c6a <kmalloc>
f011ba25:	83 c4 10             	add    $0x10,%esp
f011ba28:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ba2e:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ba34:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ba39:	74 17                	je     f011ba52 <test_kheap_phys_addr+0x19e>
f011ba3b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba42:	83 ec 0c             	sub    $0xc,%esp
f011ba45:	68 ec f2 12 f0       	push   $0xf012f2ec
f011ba4a:	e8 3c 55 fe ff       	call   f0100f8b <cprintf>
f011ba4f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba52:	e8 61 90 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ba57:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ba5a:	74 17                	je     f011ba73 <test_kheap_phys_addr+0x1bf>
f011ba5c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba63:	83 ec 0c             	sub    $0xc,%esp
f011ba66:	68 40 f3 12 f0       	push   $0xf012f340
f011ba6b:	e8 1b 55 fe ff       	call   f0100f8b <cprintf>
f011ba70:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ba73:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ba76:	e8 b9 33 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ba7b:	29 c3                	sub    %eax,%ebx
f011ba7d:	89 d8                	mov    %ebx,%eax
f011ba7f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ba84:	77 17                	ja     f011ba9d <test_kheap_phys_addr+0x1e9>
f011ba86:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba8d:	83 ec 0c             	sub    $0xc,%esp
f011ba90:	68 b0 f3 12 f0       	push   $0xf012f3b0
f011ba95:	e8 f1 54 fe ff       	call   f0100f8b <cprintf>
f011ba9a:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011ba9d:	e8 92 33 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011baa2:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011baa5:	e8 0e 90 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011baaa:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011baad:	83 ec 0c             	sub    $0xc,%esp
f011bab0:	68 00 04 00 00       	push   $0x400
f011bab5:	e8 b0 e1 fe ff       	call   f0109c6a <kmalloc>
f011baba:	83 c4 10             	add    $0x10,%esp
f011babd:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011bac3:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011bac9:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bace:	76 28                	jbe    f011baf8 <test_kheap_phys_addr+0x244>
f011bad0:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011bad6:	83 ec 0c             	sub    $0xc,%esp
f011bad9:	6a 00                	push   $0x0
f011badb:	e8 9b e0 fe ff       	call   f0109b7b <sbrk>
f011bae0:	83 c4 10             	add    $0x10,%esp
f011bae3:	39 c3                	cmp    %eax,%ebx
f011bae5:	73 11                	jae    f011baf8 <test_kheap_phys_addr+0x244>
f011bae7:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011baed:	89 c2                	mov    %eax,%edx
f011baef:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011baf4:	39 c2                	cmp    %eax,%edx
f011baf6:	72 17                	jb     f011bb0f <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011baf8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011baff:	83 ec 0c             	sub    $0xc,%esp
f011bb02:	68 6c 0e 13 f0       	push   $0xf0130e6c
f011bb07:	e8 7f 54 fe ff       	call   f0100f8b <cprintf>
f011bb0c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb0f:	e8 a4 8f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bb14:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bb17:	74 17                	je     f011bb30 <test_kheap_phys_addr+0x27c>
f011bb19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb20:	83 ec 0c             	sub    $0xc,%esp
f011bb23:	68 4c f4 12 f0       	push   $0xf012f44c
f011bb28:	e8 5e 54 fe ff       	call   f0100f8b <cprintf>
f011bb2d:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011bb30:	e8 ff 32 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bb35:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bb38:	e8 7b 8f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bb3d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011bb40:	83 ec 0c             	sub    $0xc,%esp
f011bb43:	68 00 08 00 00       	push   $0x800
f011bb48:	e8 1d e1 fe ff       	call   f0109c6a <kmalloc>
f011bb4d:	83 c4 10             	add    $0x10,%esp
f011bb50:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011bb56:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bb5c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bb61:	76 28                	jbe    f011bb8b <test_kheap_phys_addr+0x2d7>
f011bb63:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011bb69:	83 ec 0c             	sub    $0xc,%esp
f011bb6c:	6a 00                	push   $0x0
f011bb6e:	e8 08 e0 fe ff       	call   f0109b7b <sbrk>
f011bb73:	83 c4 10             	add    $0x10,%esp
f011bb76:	39 c3                	cmp    %eax,%ebx
f011bb78:	73 11                	jae    f011bb8b <test_kheap_phys_addr+0x2d7>
f011bb7a:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bb80:	89 c2                	mov    %eax,%edx
f011bb82:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011bb87:	39 c2                	cmp    %eax,%edx
f011bb89:	72 17                	jb     f011bba2 <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bb8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb92:	83 ec 0c             	sub    $0xc,%esp
f011bb95:	68 f8 0e 13 f0       	push   $0xf0130ef8
f011bb9a:	e8 ec 53 fe ff       	call   f0100f8b <cprintf>
f011bb9f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bba2:	e8 11 8f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bba7:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bbaa:	74 17                	je     f011bbc3 <test_kheap_phys_addr+0x30f>
f011bbac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bbb3:	83 ec 0c             	sub    $0xc,%esp
f011bbb6:	68 58 f5 12 f0       	push   $0xf012f558
f011bbbb:	e8 cb 53 fe ff       	call   f0100f8b <cprintf>
f011bbc0:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011bbc3:	e8 6c 32 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bbc8:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bbcb:	e8 e8 8e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bbd0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011bbd3:	83 ec 0c             	sub    $0xc,%esp
f011bbd6:	68 00 06 00 00       	push   $0x600
f011bbdb:	e8 8a e0 fe ff       	call   f0109c6a <kmalloc>
f011bbe0:	83 c4 10             	add    $0x10,%esp
f011bbe3:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011bbe9:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bbef:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bbf4:	76 28                	jbe    f011bc1e <test_kheap_phys_addr+0x36a>
f011bbf6:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011bbfc:	83 ec 0c             	sub    $0xc,%esp
f011bbff:	6a 00                	push   $0x0
f011bc01:	e8 75 df fe ff       	call   f0109b7b <sbrk>
f011bc06:	83 c4 10             	add    $0x10,%esp
f011bc09:	39 c3                	cmp    %eax,%ebx
f011bc0b:	73 11                	jae    f011bc1e <test_kheap_phys_addr+0x36a>
f011bc0d:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bc13:	89 c2                	mov    %eax,%edx
f011bc15:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011bc1a:	39 c2                	cmp    %eax,%edx
f011bc1c:	72 17                	jb     f011bc35 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bc1e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc25:	83 ec 0c             	sub    $0xc,%esp
f011bc28:	68 84 0f 13 f0       	push   $0xf0130f84
f011bc2d:	e8 59 53 fe ff       	call   f0100f8b <cprintf>
f011bc32:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc35:	e8 7e 8e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bc3a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bc3d:	74 17                	je     f011bc56 <test_kheap_phys_addr+0x3a2>
f011bc3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc46:	83 ec 0c             	sub    $0xc,%esp
f011bc49:	68 64 f6 12 f0       	push   $0xf012f664
f011bc4e:	e8 38 53 fe ff       	call   f0100f8b <cprintf>
f011bc53:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011bc56:	e8 d9 31 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bc5b:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc5e:	e8 55 8e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bc63:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bc66:	83 ec 0c             	sub    $0xc,%esp
f011bc69:	68 00 1c 00 00       	push   $0x1c00
f011bc6e:	e8 f7 df fe ff       	call   f0109c6a <kmalloc>
f011bc73:	83 c4 10             	add    $0x10,%esp
f011bc76:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc7c:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bc82:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bc87:	74 17                	je     f011bca0 <test_kheap_phys_addr+0x3ec>
f011bc89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc90:	83 ec 0c             	sub    $0xc,%esp
f011bc93:	68 1c f7 12 f0       	push   $0xf012f71c
f011bc98:	e8 ee 52 fe ff       	call   f0100f8b <cprintf>
f011bc9d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bca0:	e8 13 8e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bca5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bca8:	74 17                	je     f011bcc1 <test_kheap_phys_addr+0x40d>
f011bcaa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcb1:	83 ec 0c             	sub    $0xc,%esp
f011bcb4:	68 70 f7 12 f0       	push   $0xf012f770
f011bcb9:	e8 cd 52 fe ff       	call   f0100f8b <cprintf>
f011bcbe:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bcc1:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bcc4:	e8 6b 31 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bcc9:	29 c3                	sub    %eax,%ebx
f011bccb:	89 d8                	mov    %ebx,%eax
f011bccd:	83 f8 01             	cmp    $0x1,%eax
f011bcd0:	77 17                	ja     f011bce9 <test_kheap_phys_addr+0x435>
f011bcd2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcd9:	83 ec 0c             	sub    $0xc,%esp
f011bcdc:	68 e0 f7 12 f0       	push   $0xf012f7e0
f011bce1:	e8 a5 52 fe ff       	call   f0100f8b <cprintf>
f011bce6:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bce9:	e8 46 31 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bcee:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bcf1:	e8 c2 8d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bcf6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bcf9:	83 ec 0c             	sub    $0xc,%esp
f011bcfc:	68 00 fc 2f 00       	push   $0x2ffc00
f011bd01:	e8 64 df fe ff       	call   f0109c6a <kmalloc>
f011bd06:	83 c4 10             	add    $0x10,%esp
f011bd09:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bd0f:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bd15:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bd1a:	74 17                	je     f011bd33 <test_kheap_phys_addr+0x47f>
f011bd1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd23:	83 ec 0c             	sub    $0xc,%esp
f011bd26:	68 10 10 13 f0       	push   $0xf0131010
f011bd2b:	e8 5b 52 fe ff       	call   f0100f8b <cprintf>
f011bd30:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd33:	e8 80 8d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bd38:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bd3b:	74 17                	je     f011bd54 <test_kheap_phys_addr+0x4a0>
f011bd3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd44:	83 ec 0c             	sub    $0xc,%esp
f011bd47:	68 b4 f8 12 f0       	push   $0xf012f8b4
f011bd4c:	e8 3a 52 fe ff       	call   f0100f8b <cprintf>
f011bd51:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bd54:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bd57:	e8 d8 30 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bd5c:	29 c3                	sub    %eax,%ebx
f011bd5e:	89 d8                	mov    %ebx,%eax
f011bd60:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bd65:	77 17                	ja     f011bd7e <test_kheap_phys_addr+0x4ca>
f011bd67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd6e:	83 ec 0c             	sub    $0xc,%esp
f011bd71:	68 64 10 13 f0       	push   $0xf0131064
f011bd76:	e8 10 52 fe ff       	call   f0100f8b <cprintf>
f011bd7b:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd7e:	e8 b1 30 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bd83:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd86:	e8 2d 8d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bd8b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011bd8e:	83 ec 0c             	sub    $0xc,%esp
f011bd91:	68 00 fc 5f 00       	push   $0x5ffc00
f011bd96:	e8 cf de fe ff       	call   f0109c6a <kmalloc>
f011bd9b:	83 c4 10             	add    $0x10,%esp
f011bd9e:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bda4:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011bdaa:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bdaf:	74 17                	je     f011bdc8 <test_kheap_phys_addr+0x514>
f011bdb1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bdb8:	83 ec 0c             	sub    $0xc,%esp
f011bdbb:	68 ac 10 13 f0       	push   $0xf01310ac
f011bdc0:	e8 c6 51 fe ff       	call   f0100f8b <cprintf>
f011bdc5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bdc8:	e8 eb 8c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011bdcd:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bdd0:	74 17                	je     f011bde9 <test_kheap_phys_addr+0x535>
f011bdd2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bdd9:	83 ec 0c             	sub    $0xc,%esp
f011bddc:	68 b0 f9 12 f0       	push   $0xf012f9b0
f011bde1:	e8 a5 51 fe ff       	call   f0100f8b <cprintf>
f011bde6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bde9:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bdec:	e8 43 30 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011bdf1:	29 c3                	sub    %eax,%ebx
f011bdf3:	89 d8                	mov    %ebx,%eax
f011bdf5:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bdfa:	77 17                	ja     f011be13 <test_kheap_phys_addr+0x55f>
f011bdfc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be03:	83 ec 0c             	sub    $0xc,%esp
f011be06:	68 00 11 13 f0       	push   $0xf0131100
f011be0b:	e8 7b 51 fe ff       	call   f0100f8b <cprintf>
f011be10:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011be13:	e8 1c 30 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011be18:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011be1b:	e8 98 8c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011be20:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011be23:	83 ec 0c             	sub    $0xc,%esp
f011be26:	68 00 38 00 00       	push   $0x3800
f011be2b:	e8 3a de fe ff       	call   f0109c6a <kmalloc>
f011be30:	83 c4 10             	add    $0x10,%esp
f011be33:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011be39:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011be3f:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011be44:	74 17                	je     f011be5d <test_kheap_phys_addr+0x5a9>
f011be46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be4d:	83 ec 0c             	sub    $0xc,%esp
f011be50:	68 48 11 13 f0       	push   $0xf0131148
f011be55:	e8 31 51 fe ff       	call   f0100f8b <cprintf>
f011be5a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be5d:	e8 56 8c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011be62:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011be65:	74 17                	je     f011be7e <test_kheap_phys_addr+0x5ca>
f011be67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be6e:	83 ec 0c             	sub    $0xc,%esp
f011be71:	68 9c 11 13 f0       	push   $0xf013119c
f011be76:	e8 10 51 fe ff       	call   f0100f8b <cprintf>
f011be7b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011be7e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011be81:	e8 ae 2f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011be86:	29 c3                	sub    %eax,%ebx
f011be88:	89 d8                	mov    %ebx,%eax
f011be8a:	83 f8 03             	cmp    $0x3,%eax
f011be8d:	77 17                	ja     f011bea6 <test_kheap_phys_addr+0x5f2>
f011be8f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be96:	83 ec 0c             	sub    $0xc,%esp
f011be99:	68 0c 12 13 f0       	push   $0xf013120c
f011be9e:	e8 e8 50 fe ff       	call   f0100f8b <cprintf>
f011bea3:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011bea6:	83 ec 0c             	sub    $0xc,%esp
f011bea9:	68 54 12 13 f0       	push   $0xf0131254
f011beae:	e8 d8 50 fe ff       	call   f0100f8b <cprintf>
f011beb3:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011beb6:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011bebd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011bec4:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011becb:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011bed0:	05 00 10 00 00       	add    $0x1000,%eax
f011bed5:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011bed8:	8b 45 98             	mov    -0x68(%ebp),%eax
f011bedb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bede:	eb 2e                	jmp    f011bf0e <test_kheap_phys_addr+0x65a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011bee0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011bee3:	8d 43 01             	lea    0x1(%ebx),%eax
f011bee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011bee9:	83 ec 0c             	sub    $0xc,%esp
f011beec:	ff 75 e8             	pushl  -0x18(%ebp)
f011beef:	e8 0d e1 fe ff       	call   f010a001 <kheap_physical_address>
f011bef4:	83 c4 10             	add    $0x10,%esp
f011bef7:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011befe:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011bf01:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf04:	01 d0                	add    %edx,%eax
f011bf06:	05 00 10 00 00       	add    $0x1000,%eax
f011bf0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bf0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf11:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bf14:	72 ca                	jb     f011bee0 <test_kheap_phys_addr+0x62c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011bf16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bf19:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011bf1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011bf23:	8b 45 98             	mov    -0x68(%ebp),%eax
f011bf26:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bf29:	e9 ce 00 00 00       	jmp    f011bffc <test_kheap_phys_addr+0x748>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bf2e:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011bf33:	83 ec 04             	sub    $0x4,%esp
f011bf36:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bf3c:	52                   	push   %edx
f011bf3d:	ff 75 e8             	pushl  -0x18(%ebp)
f011bf40:	50                   	push   %eax
f011bf41:	e8 9a cb fe ff       	call   f0108ae0 <get_page_table>
f011bf46:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bf49:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bf4f:	85 c0                	test   %eax,%eax
f011bf51:	75 1e                	jne    f011bf71 <test_kheap_phys_addr+0x6bd>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bf53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bf5a:	83 ec 04             	sub    $0x4,%esp
f011bf5d:	68 a0 12 13 f0       	push   $0xf01312a0
f011bf62:	68 e7 05 00 00       	push   $0x5e7
f011bf67:	68 33 f0 12 f0       	push   $0xf012f033
f011bf6c:	e8 c8 43 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bf71:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf74:	c1 e8 0c             	shr    $0xc,%eax
f011bf77:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bf7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011bf7f:	eb 62                	jmp    f011bfe3 <test_kheap_phys_addr+0x72f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011bf81:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011bf87:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011bf8a:	c1 e2 02             	shl    $0x2,%edx
f011bf8d:	01 d0                	add    %edx,%eax
f011bf8f:	8b 00                	mov    (%eax),%eax
f011bf91:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bf96:	89 c2                	mov    %eax,%edx
f011bf98:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf9b:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bfa0:	01 c2                	add    %eax,%edx
f011bfa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bfa5:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011bfac:	39 c2                	cmp    %eax,%edx
f011bfae:	74 1d                	je     f011bfcd <test_kheap_phys_addr+0x719>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bfb0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bfb4:	74 17                	je     f011bfcd <test_kheap_phys_addr+0x719>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011bfb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bfbd:	83 ec 0c             	sub    $0xc,%esp
f011bfc0:	68 00 13 13 f0       	push   $0xf0131300
f011bfc5:	e8 c1 4f fe ff       	call   f0100f8b <cprintf>
f011bfca:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011bfcd:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011bfd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfd3:	01 d0                	add    %edx,%eax
f011bfd5:	05 00 10 00 00       	add    $0x1000,%eax
f011bfda:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bfdd:	ff 45 e4             	incl   -0x1c(%ebp)
f011bfe0:	ff 45 f4             	incl   -0xc(%ebp)
f011bfe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bfe6:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011bfe9:	7d 11                	jge    f011bffc <test_kheap_phys_addr+0x748>
f011bfeb:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011bff2:	7f 08                	jg     f011bffc <test_kheap_phys_addr+0x748>
f011bff4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bff7:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bffa:	72 85                	jb     f011bf81 <test_kheap_phys_addr+0x6cd>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bffc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfff:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011c002:	0f 82 26 ff ff ff    	jb     f011bf2e <test_kheap_phys_addr+0x67a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011c008:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c00c:	74 04                	je     f011c012 <test_kheap_phys_addr+0x75e>
f011c00e:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011c012:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011c019:	83 ec 0c             	sub    $0xc,%esp
f011c01c:	68 24 13 13 f0       	push   $0xf0131324
f011c021:	e8 65 4f fe ff       	call   f0100f8b <cprintf>
f011c026:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011c029:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011c030:	e9 b0 00 00 00       	jmp    f011c0e5 <test_kheap_phys_addr+0x831>
		{
			va = (uint32)ptr_allocations[i];
f011c035:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c038:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011c03f:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011c042:	83 ec 0c             	sub    $0xc,%esp
f011c045:	ff 75 90             	pushl  -0x70(%ebp)
f011c048:	e8 b4 df fe ff       	call   f010a001 <kheap_physical_address>
f011c04d:	83 c4 10             	add    $0x10,%esp
f011c050:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c053:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011c058:	83 ec 04             	sub    $0x4,%esp
f011c05b:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c061:	52                   	push   %edx
f011c062:	ff 75 90             	pushl  -0x70(%ebp)
f011c065:	50                   	push   %eax
f011c066:	e8 75 ca fe ff       	call   f0108ae0 <get_page_table>
f011c06b:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c06e:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c074:	85 c0                	test   %eax,%eax
f011c076:	75 1e                	jne    f011c096 <test_kheap_phys_addr+0x7e2>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c078:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c07f:	83 ec 04             	sub    $0x4,%esp
f011c082:	68 74 13 13 f0       	push   $0xf0131374
f011c087:	68 04 06 00 00       	push   $0x604
f011c08c:	68 33 f0 12 f0       	push   $0xf012f033
f011c091:	e8 a3 42 fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c096:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c09c:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c09f:	c1 ea 0c             	shr    $0xc,%edx
f011c0a2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c0a8:	c1 e2 02             	shl    $0x2,%edx
f011c0ab:	01 d0                	add    %edx,%eax
f011c0ad:	8b 00                	mov    (%eax),%eax
f011c0af:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c0b4:	89 c2                	mov    %eax,%edx
f011c0b6:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c0b9:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c0be:	01 d0                	add    %edx,%eax
f011c0c0:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c0c3:	74 1d                	je     f011c0e2 <test_kheap_phys_addr+0x82e>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c0c5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c0c9:	74 17                	je     f011c0e2 <test_kheap_phys_addr+0x82e>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011c0cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c0d2:	83 ec 0c             	sub    $0xc,%esp
f011c0d5:	68 d4 13 13 f0       	push   $0xf01313d4
f011c0da:	e8 ac 4e fe ff       	call   f0100f8b <cprintf>
f011c0df:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011c0e2:	ff 45 e0             	incl   -0x20(%ebp)
f011c0e5:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011c0e9:	0f 8e 46 ff ff ff    	jle    f011c035 <test_kheap_phys_addr+0x781>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011c0ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c0f3:	74 04                	je     f011c0f9 <test_kheap_phys_addr+0x845>
f011c0f5:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011c0f9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011c100:	83 ec 0c             	sub    $0xc,%esp
f011c103:	68 f8 13 13 f0       	push   $0xf01313f8
f011c108:	e8 7e 4e fe ff       	call   f0100f8b <cprintf>
f011c10d:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c110:	e8 1f 2d ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c115:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c118:	e8 9b 89 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c11d:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c120:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c126:	83 ec 0c             	sub    $0xc,%esp
f011c129:	50                   	push   %eax
f011c12a:	e8 a5 dd fe ff       	call   f0109ed4 <kfree>
f011c12f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c132:	e8 81 89 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c137:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c13a:	74 17                	je     f011c153 <test_kheap_phys_addr+0x89f>
f011c13c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c143:	83 ec 0c             	sub    $0xc,%esp
f011c146:	68 e4 fe 12 f0       	push   $0xf012fee4
f011c14b:	e8 3b 4e fe ff       	call   f0100f8b <cprintf>
f011c150:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c153:	e8 dc 2c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c158:	89 c2                	mov    %eax,%edx
f011c15a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c15d:	29 c2                	sub    %eax,%edx
f011c15f:	89 d0                	mov    %edx,%eax
f011c161:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c166:	77 17                	ja     f011c17f <test_kheap_phys_addr+0x8cb>
f011c168:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c16f:	83 ec 0c             	sub    $0xc,%esp
f011c172:	68 20 14 13 f0       	push   $0xf0131420
f011c177:	e8 0f 4e fe ff       	call   f0100f8b <cprintf>
f011c17c:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c17f:	e8 b0 2c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c184:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c187:	e8 2c 89 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c18c:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c18f:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c195:	83 ec 0c             	sub    $0xc,%esp
f011c198:	50                   	push   %eax
f011c199:	e8 36 dd fe ff       	call   f0109ed4 <kfree>
f011c19e:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c1a1:	e8 12 89 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c1a6:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c1a9:	74 17                	je     f011c1c2 <test_kheap_phys_addr+0x90e>
f011c1ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1b2:	83 ec 0c             	sub    $0xc,%esp
f011c1b5:	68 24 00 13 f0       	push   $0xf0130024
f011c1ba:	e8 cc 4d fe ff       	call   f0100f8b <cprintf>
f011c1bf:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c1c2:	e8 6d 2c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c1c7:	89 c2                	mov    %eax,%edx
f011c1c9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c1cc:	29 c2                	sub    %eax,%edx
f011c1ce:	89 d0                	mov    %edx,%eax
f011c1d0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c1d5:	77 17                	ja     f011c1ee <test_kheap_phys_addr+0x93a>
f011c1d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1de:	83 ec 0c             	sub    $0xc,%esp
f011c1e1:	68 5c 14 13 f0       	push   $0xf013145c
f011c1e6:	e8 a0 4d fe ff       	call   f0100f8b <cprintf>
f011c1eb:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c1ee:	e8 41 2c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c1f3:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c1f6:	e8 bd 88 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c1fb:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c1fe:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011c204:	83 ec 0c             	sub    $0xc,%esp
f011c207:	50                   	push   %eax
f011c208:	e8 c7 dc fe ff       	call   f0109ed4 <kfree>
f011c20d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c210:	e8 a3 88 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c215:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c218:	74 17                	je     f011c231 <test_kheap_phys_addr+0x97d>
f011c21a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c221:	83 ec 0c             	sub    $0xc,%esp
f011c224:	68 30 01 13 f0       	push   $0xf0130130
f011c229:	e8 5d 4d fe ff       	call   f0100f8b <cprintf>
f011c22e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011c231:	e8 fe 2b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c236:	89 c2                	mov    %eax,%edx
f011c238:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c23b:	29 c2                	sub    %eax,%edx
f011c23d:	89 d0                	mov    %edx,%eax
f011c23f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c244:	77 17                	ja     f011c25d <test_kheap_phys_addr+0x9a9>
f011c246:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c24d:	83 ec 0c             	sub    $0xc,%esp
f011c250:	68 98 14 13 f0       	push   $0xf0131498
f011c255:	e8 31 4d fe ff       	call   f0100f8b <cprintf>
f011c25a:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011c25d:	83 ec 0c             	sub    $0xc,%esp
f011c260:	68 d4 14 13 f0       	push   $0xf01314d4
f011c265:	e8 21 4d fe ff       	call   f0100f8b <cprintf>
f011c26a:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c26d:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011c274:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011c27b:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011c282:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011c285:	8b 15 58 3e 18 f0    	mov    0xf0183e58,%edx
f011c28b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c291:	01 d0                	add    %edx,%eax
f011c293:	05 00 10 00 00       	add    $0x1000,%eax
f011c298:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c29e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c2a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011c2a7:	eb 25                	jmp    f011c2ce <test_kheap_phys_addr+0xa1a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011c2a9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011c2ac:	8d 43 01             	lea    0x1(%ebx),%eax
f011c2af:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011c2b2:	83 ec 0c             	sub    $0xc,%esp
f011c2b5:	ff 75 d8             	pushl  -0x28(%ebp)
f011c2b8:	e8 44 dd fe ff       	call   f010a001 <kheap_physical_address>
f011c2bd:	83 c4 10             	add    $0x10,%esp
f011c2c0:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c2c7:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011c2ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c2d1:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c2d4:	72 d3                	jb     f011c2a9 <test_kheap_phys_addr+0x9f5>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011c2d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c2d9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011c2df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c2e6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011c2ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011c2ef:	e9 f4 00 00 00       	jmp    f011c3e8 <test_kheap_phys_addr+0xb34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c2f4:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011c2f9:	83 ec 04             	sub    $0x4,%esp
f011c2fc:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c302:	52                   	push   %edx
f011c303:	ff 75 d8             	pushl  -0x28(%ebp)
f011c306:	50                   	push   %eax
f011c307:	e8 d4 c7 fe ff       	call   f0108ae0 <get_page_table>
f011c30c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c30f:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c315:	85 c0                	test   %eax,%eax
f011c317:	75 24                	jne    f011c33d <test_kheap_phys_addr+0xa89>
				if (correct)
f011c319:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c31d:	74 1e                	je     f011c33d <test_kheap_phys_addr+0xa89>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c31f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c326:	83 ec 04             	sub    $0x4,%esp
f011c329:	68 24 15 13 f0       	push   $0xf0131524
f011c32e:	68 42 06 00 00       	push   $0x642
f011c333:	68 33 f0 12 f0       	push   $0xf012f033
f011c338:	e8 fc 3f fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c33d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c340:	c1 e8 0c             	shr    $0xc,%eax
f011c343:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c348:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c34b:	eb 7b                	jmp    f011c3c8 <test_kheap_phys_addr+0xb14>
			{
				expected = 0 ;
f011c34d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011c354:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c35a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c35d:	c1 e2 02             	shl    $0x2,%edx
f011c360:	01 d0                	add    %edx,%eax
f011c362:	8b 00                	mov    (%eax),%eax
f011c364:	83 e0 01             	and    $0x1,%eax
f011c367:	85 c0                	test   %eax,%eax
f011c369:	74 24                	je     f011c38f <test_kheap_phys_addr+0xadb>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011c36b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c371:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c374:	c1 e2 02             	shl    $0x2,%edx
f011c377:	01 d0                	add    %edx,%eax
f011c379:	8b 00                	mov    (%eax),%eax
f011c37b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c380:	89 c2                	mov    %eax,%edx
f011c382:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c385:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c38a:	01 d0                	add    %edx,%eax
f011c38c:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011c38f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c392:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011c399:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011c39c:	74 1d                	je     f011c3bb <test_kheap_phys_addr+0xb07>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c39e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c3a2:	74 17                	je     f011c3bb <test_kheap_phys_addr+0xb07>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011c3a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3ab:	83 ec 0c             	sub    $0xc,%esp
f011c3ae:	68 84 15 13 f0       	push   $0xf0131584
f011c3b3:	e8 d3 4b fe ff       	call   f0100f8b <cprintf>
f011c3b8:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011c3bb:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c3c2:	ff 45 d4             	incl   -0x2c(%ebp)
f011c3c5:	ff 45 f4             	incl   -0xc(%ebp)
f011c3c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c3cb:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011c3d1:	7d 15                	jge    f011c3e8 <test_kheap_phys_addr+0xb34>
f011c3d3:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011c3da:	7f 0c                	jg     f011c3e8 <test_kheap_phys_addr+0xb34>
f011c3dc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c3df:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c3e2:	0f 82 65 ff ff ff    	jb     f011c34d <test_kheap_phys_addr+0xa99>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c3e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c3eb:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c3ee:	0f 82 00 ff ff ff    	jb     f011c2f4 <test_kheap_phys_addr+0xa40>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c3f4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c3f8:	74 04                	je     f011c3fe <test_kheap_phys_addr+0xb4a>
f011c3fa:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011c3fe:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011c405:	83 ec 0c             	sub    $0xc,%esp
f011c408:	68 a8 15 13 f0       	push   $0xf01315a8
f011c40d:	e8 79 4b fe ff       	call   f0100f8b <cprintf>
f011c412:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011c415:	83 ec 0c             	sub    $0xc,%esp
f011c418:	6a 00                	push   $0x0
f011c41a:	e8 5c d7 fe ff       	call   f0109b7b <sbrk>
f011c41f:	83 c4 10             	add    $0x10,%esp
f011c422:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011c427:	77 17                	ja     f011c440 <test_kheap_phys_addr+0xb8c>
f011c429:	83 ec 04             	sub    $0x4,%esp
f011c42c:	68 00 16 13 f0       	push   $0xf0131600
f011c431:	68 5d 06 00 00       	push   $0x65d
f011c436:	68 33 f0 12 f0       	push   $0xf012f033
f011c43b:	e8 f9 3e fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c440:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011c447:	e9 af 00 00 00       	jmp    f011c4fb <test_kheap_phys_addr+0xc47>
		{
			pa = kheap_physical_address(va);
f011c44c:	83 ec 0c             	sub    $0xc,%esp
f011c44f:	ff 75 d0             	pushl  -0x30(%ebp)
f011c452:	e8 aa db fe ff       	call   f010a001 <kheap_physical_address>
f011c457:	83 c4 10             	add    $0x10,%esp
f011c45a:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c460:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011c465:	83 ec 04             	sub    $0x4,%esp
f011c468:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011c46e:	52                   	push   %edx
f011c46f:	ff 75 d0             	pushl  -0x30(%ebp)
f011c472:	50                   	push   %eax
f011c473:	e8 68 c6 fe ff       	call   f0108ae0 <get_page_table>
f011c478:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c47b:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c481:	85 c0                	test   %eax,%eax
f011c483:	75 24                	jne    f011c4a9 <test_kheap_phys_addr+0xbf5>
				if (correct)
f011c485:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c489:	74 1e                	je     f011c4a9 <test_kheap_phys_addr+0xbf5>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c48b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c492:	83 ec 04             	sub    $0x4,%esp
f011c495:	68 1c 16 13 f0       	push   $0xf013161c
f011c49a:	68 65 06 00 00       	push   $0x665
f011c49f:	68 33 f0 12 f0       	push   $0xf012f033
f011c4a4:	e8 90 3e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c4a9:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c4af:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011c4b2:	c1 ea 0c             	shr    $0xc,%edx
f011c4b5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c4bb:	c1 e2 02             	shl    $0x2,%edx
f011c4be:	01 d0                	add    %edx,%eax
f011c4c0:	8b 00                	mov    (%eax),%eax
f011c4c2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c4c7:	89 c2                	mov    %eax,%edx
f011c4c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4cc:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c4d1:	01 d0                	add    %edx,%eax
f011c4d3:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011c4d9:	74 1d                	je     f011c4f8 <test_kheap_phys_addr+0xc44>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c4db:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c4df:	74 17                	je     f011c4f8 <test_kheap_phys_addr+0xc44>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011c4e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4e8:	83 ec 0c             	sub    $0xc,%esp
f011c4eb:	68 7c 16 13 f0       	push   $0xf013167c
f011c4f0:	e8 96 4a fe ff       	call   f0100f8b <cprintf>
f011c4f5:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c4f8:	ff 45 d0             	incl   -0x30(%ebp)
f011c4fb:	83 ec 0c             	sub    $0xc,%esp
f011c4fe:	6a 00                	push   $0x0
f011c500:	e8 76 d6 fe ff       	call   f0109b7b <sbrk>
f011c505:	83 c4 10             	add    $0x10,%esp
f011c508:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011c50b:	0f 87 3b ff ff ff    	ja     f011c44c <test_kheap_phys_addr+0xb98>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011c511:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c515:	74 04                	je     f011c51b <test_kheap_phys_addr+0xc67>
f011c517:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011c51b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011c522:	83 ec 0c             	sub    $0xc,%esp
f011c525:	68 a0 16 13 f0       	push   $0xf01316a0
f011c52a:	e8 5c 4a fe ff       	call   f0100f8b <cprintf>
f011c52f:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011c532:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011c539:	10 00 f9 
		i = 0;
f011c53c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c543:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011c549:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011c54c:	eb 0a                	jmp    f011c558 <test_kheap_phys_addr+0xca4>
		{
			i++;
f011c54e:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c551:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011c558:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011c55f:	76 ed                	jbe    f011c54e <test_kheap_phys_addr+0xc9a>
		{
			i++;
		}
		int ii = i ;
f011c561:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c564:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011c56a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c571:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011c577:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011c57a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011c581:	e9 cb 00 00 00       	jmp    f011c651 <test_kheap_phys_addr+0xd9d>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011c586:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011c589:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011c58e:	83 ec 04             	sub    $0x4,%esp
f011c591:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011c597:	51                   	push   %ecx
f011c598:	52                   	push   %edx
f011c599:	50                   	push   %eax
f011c59a:	e8 41 c5 fe ff       	call   f0108ae0 <get_page_table>
f011c59f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c5a2:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011c5a8:	85 c0                	test   %eax,%eax
f011c5aa:	75 24                	jne    f011c5d0 <test_kheap_phys_addr+0xd1c>
			{
				if (correct)
f011c5ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c5b0:	74 1e                	je     f011c5d0 <test_kheap_phys_addr+0xd1c>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c5b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c5b9:	83 ec 04             	sub    $0x4,%esp
f011c5bc:	68 dc 16 13 f0       	push   $0xf01316dc
f011c5c1:	68 87 06 00 00       	push   $0x687
f011c5c6:	68 33 f0 12 f0       	push   $0xf012f033
f011c5cb:	e8 69 3d fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c5d0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011c5d7:	eb 59                	jmp    f011c632 <test_kheap_phys_addr+0xd7e>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011c5d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c5dc:	c1 e0 0c             	shl    $0xc,%eax
f011c5df:	89 c2                	mov    %eax,%edx
f011c5e1:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011c5e7:	01 d0                	add    %edx,%eax
f011c5e9:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011c5ef:	83 ec 0c             	sub    $0xc,%esp
f011c5f2:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011c5f8:	e8 04 da fe ff       	call   f010a001 <kheap_physical_address>
f011c5fd:	83 c4 10             	add    $0x10,%esp
f011c600:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011c606:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011c60d:	74 1d                	je     f011c62c <test_kheap_phys_addr+0xd78>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c60f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c613:	74 17                	je     f011c62c <test_kheap_phys_addr+0xd78>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011c615:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c61c:	83 ec 0c             	sub    $0xc,%esp
f011c61f:	68 3c 17 13 f0       	push   $0xf013173c
f011c624:	e8 62 49 fe ff       	call   f0100f8b <cprintf>
f011c629:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c62c:	ff 45 c8             	incl   -0x38(%ebp)
f011c62f:	ff 45 f4             	incl   -0xc(%ebp)
f011c632:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c635:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011c63b:	7d 09                	jge    f011c646 <test_kheap_phys_addr+0xd92>
f011c63d:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011c644:	7e 93                	jle    f011c5d9 <test_kheap_phys_addr+0xd25>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c646:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011c64d:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011c651:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c655:	0f 88 2b ff ff ff    	js     f011c586 <test_kheap_phys_addr+0xcd2>
f011c65b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c65f:	7f 0d                	jg     f011c66e <test_kheap_phys_addr+0xdba>
f011c661:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011c668:	0f 86 18 ff ff ff    	jbe    f011c586 <test_kheap_phys_addr+0xcd2>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011c66e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c672:	74 04                	je     f011c678 <test_kheap_phys_addr+0xdc4>
f011c674:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011c678:	83 ec 08             	sub    $0x8,%esp
f011c67b:	ff 75 f0             	pushl  -0x10(%ebp)
f011c67e:	68 60 17 13 f0       	push   $0xf0131760
f011c683:	e8 03 49 fe ff       	call   f0100f8b <cprintf>
f011c688:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c68b:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011c690:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c693:	5b                   	pop    %ebx
f011c694:	5f                   	pop    %edi
f011c695:	5d                   	pop    %ebp
f011c696:	c3                   	ret    

f011c697 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011c697:	55                   	push   %ebp
f011c698:	89 e5                	mov    %esp,%ebp
f011c69a:	57                   	push   %edi
f011c69b:	56                   	push   %esi
f011c69c:	53                   	push   %ebx
f011c69d:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011c6a3:	89 e0                	mov    %esp,%eax
f011c6a5:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011c6a7:	83 ec 0c             	sub    $0xc,%esp
f011c6aa:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011c6af:	e8 d7 48 fe ff       	call   f0100f8b <cprintf>
f011c6b4:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c6b7:	83 ec 0c             	sub    $0xc,%esp
f011c6ba:	68 18 d1 12 f0       	push   $0xf012d118
f011c6bf:	e8 c7 48 fe ff       	call   f0100f8b <cprintf>
f011c6c4:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011c6c7:	83 ec 0c             	sub    $0xc,%esp
f011c6ca:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011c6cf:	e8 b7 48 fe ff       	call   f0100f8b <cprintf>
f011c6d4:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011c6d7:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011c6db:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011c6df:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011c6e5:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011c6eb:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011c6f2:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011c6f9:	e8 36 27 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c6fe:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011c701:	83 ec 0c             	sub    $0xc,%esp
f011c704:	68 3c 0e 13 f0       	push   $0xf0130e3c
f011c709:	e8 7d 48 fe ff       	call   f0100f8b <cprintf>
f011c70e:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011c711:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011c717:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c71c:	b8 00 00 00 00       	mov    $0x0,%eax
f011c721:	89 d7                	mov    %edx,%edi
f011c723:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011c725:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011c72b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c730:	b8 00 00 00 00       	mov    $0x0,%eax
f011c735:	89 d7                	mov    %edx,%edi
f011c737:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011c739:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c740:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011c747:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011c74d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c752:	b8 00 00 00 00       	mov    $0x0,%eax
f011c757:	89 d7                	mov    %edx,%edi
f011c759:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c75b:	e8 d4 26 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c760:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c763:	e8 50 83 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c768:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011c76b:	83 ec 0c             	sub    $0xc,%esp
f011c76e:	68 00 fc 1f 00       	push   $0x1ffc00
f011c773:	e8 f2 d4 fe ff       	call   f0109c6a <kmalloc>
f011c778:	83 c4 10             	add    $0x10,%esp
f011c77b:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c781:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c787:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c78c:	74 17                	je     f011c7a5 <test_kheap_virt_addr+0x10e>
f011c78e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c795:	83 ec 0c             	sub    $0xc,%esp
f011c798:	68 e0 f1 12 f0       	push   $0xf012f1e0
f011c79d:	e8 e9 47 fe ff       	call   f0100f8b <cprintf>
f011c7a2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7a5:	e8 0e 83 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c7aa:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c7ad:	74 17                	je     f011c7c6 <test_kheap_virt_addr+0x12f>
f011c7af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7b6:	83 ec 0c             	sub    $0xc,%esp
f011c7b9:	68 34 f2 12 f0       	push   $0xf012f234
f011c7be:	e8 c8 47 fe ff       	call   f0100f8b <cprintf>
f011c7c3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c7c6:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c7c9:	e8 66 26 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c7ce:	29 c3                	sub    %eax,%ebx
f011c7d0:	89 d8                	mov    %ebx,%eax
f011c7d2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c7d7:	77 17                	ja     f011c7f0 <test_kheap_virt_addr+0x159>
f011c7d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7e0:	83 ec 0c             	sub    $0xc,%esp
f011c7e3:	68 a4 f2 12 f0       	push   $0xf012f2a4
f011c7e8:	e8 9e 47 fe ff       	call   f0100f8b <cprintf>
f011c7ed:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c7f0:	e8 3f 26 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c7f5:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c7f8:	e8 bb 82 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c7fd:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c800:	83 ec 0c             	sub    $0xc,%esp
f011c803:	68 00 fc 1f 00       	push   $0x1ffc00
f011c808:	e8 5d d4 fe ff       	call   f0109c6a <kmalloc>
f011c80d:	83 c4 10             	add    $0x10,%esp
f011c810:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c816:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c81c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c821:	74 17                	je     f011c83a <test_kheap_virt_addr+0x1a3>
f011c823:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c82a:	83 ec 0c             	sub    $0xc,%esp
f011c82d:	68 ec f2 12 f0       	push   $0xf012f2ec
f011c832:	e8 54 47 fe ff       	call   f0100f8b <cprintf>
f011c837:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c83a:	e8 79 82 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c83f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c842:	74 17                	je     f011c85b <test_kheap_virt_addr+0x1c4>
f011c844:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c84b:	83 ec 0c             	sub    $0xc,%esp
f011c84e:	68 40 f3 12 f0       	push   $0xf012f340
f011c853:	e8 33 47 fe ff       	call   f0100f8b <cprintf>
f011c858:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c85b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c85e:	e8 d1 25 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c863:	29 c3                	sub    %eax,%ebx
f011c865:	89 d8                	mov    %ebx,%eax
f011c867:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c86c:	77 17                	ja     f011c885 <test_kheap_virt_addr+0x1ee>
f011c86e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c875:	83 ec 0c             	sub    $0xc,%esp
f011c878:	68 b0 f3 12 f0       	push   $0xf012f3b0
f011c87d:	e8 09 47 fe ff       	call   f0100f8b <cprintf>
f011c882:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011c885:	e8 aa 25 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c88a:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c88d:	e8 26 82 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c892:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011c895:	83 ec 0c             	sub    $0xc,%esp
f011c898:	68 00 04 00 00       	push   $0x400
f011c89d:	e8 c8 d3 fe ff       	call   f0109c6a <kmalloc>
f011c8a2:	83 c4 10             	add    $0x10,%esp
f011c8a5:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c8ab:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c8b1:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c8b6:	76 28                	jbe    f011c8e0 <test_kheap_virt_addr+0x249>
f011c8b8:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011c8be:	83 ec 0c             	sub    $0xc,%esp
f011c8c1:	6a 00                	push   $0x0
f011c8c3:	e8 b3 d2 fe ff       	call   f0109b7b <sbrk>
f011c8c8:	83 c4 10             	add    $0x10,%esp
f011c8cb:	39 c3                	cmp    %eax,%ebx
f011c8cd:	73 11                	jae    f011c8e0 <test_kheap_virt_addr+0x249>
f011c8cf:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c8d5:	89 c2                	mov    %eax,%edx
f011c8d7:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011c8dc:	39 c2                	cmp    %eax,%edx
f011c8de:	72 17                	jb     f011c8f7 <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c8e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8e7:	83 ec 0c             	sub    $0xc,%esp
f011c8ea:	68 6c 0e 13 f0       	push   $0xf0130e6c
f011c8ef:	e8 97 46 fe ff       	call   f0100f8b <cprintf>
f011c8f4:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c8f7:	e8 bc 81 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c8fc:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c8ff:	74 17                	je     f011c918 <test_kheap_virt_addr+0x281>
f011c901:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c908:	83 ec 0c             	sub    $0xc,%esp
f011c90b:	68 4c f4 12 f0       	push   $0xf012f44c
f011c910:	e8 76 46 fe ff       	call   f0100f8b <cprintf>
f011c915:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c918:	e8 17 25 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c91d:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c920:	e8 93 81 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c925:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c928:	83 ec 0c             	sub    $0xc,%esp
f011c92b:	68 00 08 00 00       	push   $0x800
f011c930:	e8 35 d3 fe ff       	call   f0109c6a <kmalloc>
f011c935:	83 c4 10             	add    $0x10,%esp
f011c938:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c93e:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c944:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c949:	76 28                	jbe    f011c973 <test_kheap_virt_addr+0x2dc>
f011c94b:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c951:	83 ec 0c             	sub    $0xc,%esp
f011c954:	6a 00                	push   $0x0
f011c956:	e8 20 d2 fe ff       	call   f0109b7b <sbrk>
f011c95b:	83 c4 10             	add    $0x10,%esp
f011c95e:	39 c3                	cmp    %eax,%ebx
f011c960:	73 11                	jae    f011c973 <test_kheap_virt_addr+0x2dc>
f011c962:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c968:	89 c2                	mov    %eax,%edx
f011c96a:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011c96f:	39 c2                	cmp    %eax,%edx
f011c971:	72 17                	jb     f011c98a <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c973:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c97a:	83 ec 0c             	sub    $0xc,%esp
f011c97d:	68 f8 0e 13 f0       	push   $0xf0130ef8
f011c982:	e8 04 46 fe ff       	call   f0100f8b <cprintf>
f011c987:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c98a:	e8 29 81 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c98f:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c992:	74 17                	je     f011c9ab <test_kheap_virt_addr+0x314>
f011c994:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c99b:	83 ec 0c             	sub    $0xc,%esp
f011c99e:	68 58 f5 12 f0       	push   $0xf012f558
f011c9a3:	e8 e3 45 fe ff       	call   f0100f8b <cprintf>
f011c9a8:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c9ab:	e8 84 24 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011c9b0:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c9b3:	e8 00 81 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011c9b8:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c9bb:	83 ec 0c             	sub    $0xc,%esp
f011c9be:	68 00 06 00 00       	push   $0x600
f011c9c3:	e8 a2 d2 fe ff       	call   f0109c6a <kmalloc>
f011c9c8:	83 c4 10             	add    $0x10,%esp
f011c9cb:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c9d1:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c9d7:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c9dc:	76 28                	jbe    f011ca06 <test_kheap_virt_addr+0x36f>
f011c9de:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c9e4:	83 ec 0c             	sub    $0xc,%esp
f011c9e7:	6a 00                	push   $0x0
f011c9e9:	e8 8d d1 fe ff       	call   f0109b7b <sbrk>
f011c9ee:	83 c4 10             	add    $0x10,%esp
f011c9f1:	39 c3                	cmp    %eax,%ebx
f011c9f3:	73 11                	jae    f011ca06 <test_kheap_virt_addr+0x36f>
f011c9f5:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c9fb:	89 c2                	mov    %eax,%edx
f011c9fd:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011ca02:	39 c2                	cmp    %eax,%edx
f011ca04:	72 17                	jb     f011ca1d <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ca06:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca0d:	83 ec 0c             	sub    $0xc,%esp
f011ca10:	68 84 0f 13 f0       	push   $0xf0130f84
f011ca15:	e8 71 45 fe ff       	call   f0100f8b <cprintf>
f011ca1a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca1d:	e8 96 80 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ca22:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ca25:	74 17                	je     f011ca3e <test_kheap_virt_addr+0x3a7>
f011ca27:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca2e:	83 ec 0c             	sub    $0xc,%esp
f011ca31:	68 64 f6 12 f0       	push   $0xf012f664
f011ca36:	e8 50 45 fe ff       	call   f0100f8b <cprintf>
f011ca3b:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011ca3e:	e8 f1 23 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ca43:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ca46:	e8 6d 80 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ca4b:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011ca4e:	83 ec 0c             	sub    $0xc,%esp
f011ca51:	68 00 1c 00 00       	push   $0x1c00
f011ca56:	e8 0f d2 fe ff       	call   f0109c6a <kmalloc>
f011ca5b:	83 c4 10             	add    $0x10,%esp
f011ca5e:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ca64:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011ca6a:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011ca6f:	74 17                	je     f011ca88 <test_kheap_virt_addr+0x3f1>
f011ca71:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca78:	83 ec 0c             	sub    $0xc,%esp
f011ca7b:	68 1c f7 12 f0       	push   $0xf012f71c
f011ca80:	e8 06 45 fe ff       	call   f0100f8b <cprintf>
f011ca85:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca88:	e8 2b 80 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ca8d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ca90:	74 17                	je     f011caa9 <test_kheap_virt_addr+0x412>
f011ca92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca99:	83 ec 0c             	sub    $0xc,%esp
f011ca9c:	68 70 f7 12 f0       	push   $0xf012f770
f011caa1:	e8 e5 44 fe ff       	call   f0100f8b <cprintf>
f011caa6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011caa9:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011caac:	e8 83 23 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cab1:	29 c3                	sub    %eax,%ebx
f011cab3:	89 d8                	mov    %ebx,%eax
f011cab5:	83 f8 01             	cmp    $0x1,%eax
f011cab8:	77 17                	ja     f011cad1 <test_kheap_virt_addr+0x43a>
f011caba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cac1:	83 ec 0c             	sub    $0xc,%esp
f011cac4:	68 e0 f7 12 f0       	push   $0xf012f7e0
f011cac9:	e8 bd 44 fe ff       	call   f0100f8b <cprintf>
f011cace:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011cad1:	e8 5e 23 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cad6:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cad9:	e8 da 7f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cade:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011cae1:	83 ec 0c             	sub    $0xc,%esp
f011cae4:	68 00 fc 2f 00       	push   $0x2ffc00
f011cae9:	e8 7c d1 fe ff       	call   f0109c6a <kmalloc>
f011caee:	83 c4 10             	add    $0x10,%esp
f011caf1:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011caf7:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011cafd:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011cb02:	74 17                	je     f011cb1b <test_kheap_virt_addr+0x484>
f011cb04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb0b:	83 ec 0c             	sub    $0xc,%esp
f011cb0e:	68 10 10 13 f0       	push   $0xf0131010
f011cb13:	e8 73 44 fe ff       	call   f0100f8b <cprintf>
f011cb18:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb1b:	e8 98 7f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cb20:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cb23:	74 17                	je     f011cb3c <test_kheap_virt_addr+0x4a5>
f011cb25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb2c:	83 ec 0c             	sub    $0xc,%esp
f011cb2f:	68 b4 f8 12 f0       	push   $0xf012f8b4
f011cb34:	e8 52 44 fe ff       	call   f0100f8b <cprintf>
f011cb39:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cb3c:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cb3f:	e8 f0 22 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cb44:	29 c3                	sub    %eax,%ebx
f011cb46:	89 d8                	mov    %ebx,%eax
f011cb48:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011cb4d:	77 17                	ja     f011cb66 <test_kheap_virt_addr+0x4cf>
f011cb4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb56:	83 ec 0c             	sub    $0xc,%esp
f011cb59:	68 64 10 13 f0       	push   $0xf0131064
f011cb5e:	e8 28 44 fe ff       	call   f0100f8b <cprintf>
f011cb63:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011cb66:	e8 c9 22 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cb6b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cb6e:	e8 45 7f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cb73:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011cb76:	83 ec 0c             	sub    $0xc,%esp
f011cb79:	68 00 fc 5f 00       	push   $0x5ffc00
f011cb7e:	e8 e7 d0 fe ff       	call   f0109c6a <kmalloc>
f011cb83:	83 c4 10             	add    $0x10,%esp
f011cb86:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cb8c:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011cb92:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011cb97:	74 17                	je     f011cbb0 <test_kheap_virt_addr+0x519>
f011cb99:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cba0:	83 ec 0c             	sub    $0xc,%esp
f011cba3:	68 ac 10 13 f0       	push   $0xf01310ac
f011cba8:	e8 de 43 fe ff       	call   f0100f8b <cprintf>
f011cbad:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cbb0:	e8 03 7f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cbb5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cbb8:	74 17                	je     f011cbd1 <test_kheap_virt_addr+0x53a>
f011cbba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbc1:	83 ec 0c             	sub    $0xc,%esp
f011cbc4:	68 b0 f9 12 f0       	push   $0xf012f9b0
f011cbc9:	e8 bd 43 fe ff       	call   f0100f8b <cprintf>
f011cbce:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cbd1:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cbd4:	e8 5b 22 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cbd9:	29 c3                	sub    %eax,%ebx
f011cbdb:	89 d8                	mov    %ebx,%eax
f011cbdd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011cbe2:	77 17                	ja     f011cbfb <test_kheap_virt_addr+0x564>
f011cbe4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbeb:	83 ec 0c             	sub    $0xc,%esp
f011cbee:	68 00 11 13 f0       	push   $0xf0131100
f011cbf3:	e8 93 43 fe ff       	call   f0100f8b <cprintf>
f011cbf8:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011cbfb:	e8 34 22 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cc00:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cc03:	e8 b0 7e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cc08:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011cc0b:	83 ec 0c             	sub    $0xc,%esp
f011cc0e:	68 00 38 00 00       	push   $0x3800
f011cc13:	e8 52 d0 fe ff       	call   f0109c6a <kmalloc>
f011cc18:	83 c4 10             	add    $0x10,%esp
f011cc1b:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cc21:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011cc27:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011cc2c:	74 17                	je     f011cc45 <test_kheap_virt_addr+0x5ae>
f011cc2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc35:	83 ec 0c             	sub    $0xc,%esp
f011cc38:	68 48 11 13 f0       	push   $0xf0131148
f011cc3d:	e8 49 43 fe ff       	call   f0100f8b <cprintf>
f011cc42:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cc45:	e8 6e 7e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cc4a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cc4d:	74 17                	je     f011cc66 <test_kheap_virt_addr+0x5cf>
f011cc4f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc56:	83 ec 0c             	sub    $0xc,%esp
f011cc59:	68 9c 11 13 f0       	push   $0xf013119c
f011cc5e:	e8 28 43 fe ff       	call   f0100f8b <cprintf>
f011cc63:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cc66:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cc69:	e8 c6 21 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cc6e:	29 c3                	sub    %eax,%ebx
f011cc70:	89 d8                	mov    %ebx,%eax
f011cc72:	83 f8 03             	cmp    $0x3,%eax
f011cc75:	77 17                	ja     f011cc8e <test_kheap_virt_addr+0x5f7>
f011cc77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc7e:	83 ec 0c             	sub    $0xc,%esp
f011cc81:	68 0c 12 13 f0       	push   $0xf013120c
f011cc86:	e8 00 43 fe ff       	call   f0100f8b <cprintf>
f011cc8b:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011cc8e:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011cc95:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011cc98:	c1 e8 0c             	shr    $0xc,%eax
f011cc9b:	89 c2                	mov    %eax,%edx
f011cc9d:	4a                   	dec    %edx
f011cc9e:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011cca1:	c1 e0 02             	shl    $0x2,%eax
f011cca4:	8d 50 03             	lea    0x3(%eax),%edx
f011cca7:	b8 10 00 00 00       	mov    $0x10,%eax
f011ccac:	48                   	dec    %eax
f011ccad:	01 d0                	add    %edx,%eax
f011ccaf:	bf 10 00 00 00       	mov    $0x10,%edi
f011ccb4:	ba 00 00 00 00       	mov    $0x0,%edx
f011ccb9:	f7 f7                	div    %edi
f011ccbb:	6b c0 10             	imul   $0x10,%eax,%eax
f011ccbe:	29 c4                	sub    %eax,%esp
f011ccc0:	89 e0                	mov    %esp,%eax
f011ccc2:	83 c0 03             	add    $0x3,%eax
f011ccc5:	c1 e8 02             	shr    $0x2,%eax
f011ccc8:	c1 e0 02             	shl    $0x2,%eax
f011cccb:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011ccce:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011ccd1:	c1 e8 0c             	shr    $0xc,%eax
f011ccd4:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011ccd7:	83 ec 0c             	sub    $0xc,%esp
f011ccda:	68 94 17 13 f0       	push   $0xf0131794
f011ccdf:	e8 a7 42 fe ff       	call   f0100f8b <cprintf>
f011cce4:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cce7:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ccee:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011ccf3:	05 00 10 00 00       	add    $0x1000,%eax
f011ccf8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011ccfb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011cd02:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cd05:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011cd08:	e9 2d 01 00 00       	jmp    f011ce3a <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011cd0d:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011cd12:	83 ec 04             	sub    $0x4,%esp
f011cd15:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011cd1b:	52                   	push   %edx
f011cd1c:	ff 75 dc             	pushl  -0x24(%ebp)
f011cd1f:	50                   	push   %eax
f011cd20:	e8 bb bd fe ff       	call   f0108ae0 <get_page_table>
f011cd25:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011cd28:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011cd2e:	85 c0                	test   %eax,%eax
f011cd30:	75 1e                	jne    f011cd50 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011cd32:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd39:	83 ec 04             	sub    $0x4,%esp
f011cd3c:	68 a0 12 13 f0       	push   $0xf01312a0
f011cd41:	68 26 07 00 00       	push   $0x726
f011cd46:	68 33 f0 12 f0       	push   $0xf012f033
f011cd4b:	e8 e9 35 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011cd50:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd53:	c1 e8 0c             	shr    $0xc,%eax
f011cd56:	25 ff 03 00 00       	and    $0x3ff,%eax
f011cd5b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011cd5e:	e9 ba 00 00 00       	jmp    f011ce1d <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011cd63:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cd66:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011cd69:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011cd6f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd72:	c1 e2 02             	shl    $0x2,%edx
f011cd75:	01 d0                	add    %edx,%eax
f011cd77:	8b 00                	mov    (%eax),%eax
f011cd79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011cd7e:	89 c2                	mov    %eax,%edx
f011cd80:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cd83:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011cd86:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cd89:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cd8c:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cd8f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cd92:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cd95:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cd98:	83 ec 0c             	sub    $0xc,%esp
f011cd9b:	50                   	push   %eax
f011cd9c:	e8 f1 d2 fe ff       	call   f010a092 <kheap_virtual_address>
f011cda1:	83 c4 10             	add    $0x10,%esp
f011cda4:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011cda7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011cdaa:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cdad:	01 d0                	add    %edx,%eax
f011cdaf:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cdb2:	74 5c                	je     f011ce10 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011cdb4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cdb8:	74 56                	je     f011ce10 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011cdba:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cdbd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cdc0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cdc3:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011cdc9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011cdcc:	c1 e1 02             	shl    $0x2,%ecx
f011cdcf:	01 ca                	add    %ecx,%edx
f011cdd1:	8b 12                	mov    (%edx),%edx
f011cdd3:	89 d1                	mov    %edx,%ecx
f011cdd5:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011cddb:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011cdde:	8b 55 90             	mov    -0x70(%ebp),%edx
f011cde1:	01 da                	add    %ebx,%edx
f011cde3:	83 ec 0c             	sub    $0xc,%esp
f011cde6:	50                   	push   %eax
f011cde7:	51                   	push   %ecx
f011cde8:	52                   	push   %edx
f011cde9:	ff 75 8c             	pushl  -0x74(%ebp)
f011cdec:	68 e0 17 13 f0       	push   $0xf01317e0
f011cdf1:	e8 95 41 fe ff       	call   f0100f8b <cprintf>
f011cdf6:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011cdf9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce00:	83 ec 0c             	sub    $0xc,%esp
f011ce03:	68 24 18 13 f0       	push   $0xf0131824
f011ce08:	e8 7e 41 fe ff       	call   f0100f8b <cprintf>
f011ce0d:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011ce10:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ce17:	ff 45 d4             	incl   -0x2c(%ebp)
f011ce1a:	ff 45 d8             	incl   -0x28(%ebp)
f011ce1d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ce20:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ce23:	7d 15                	jge    f011ce3a <test_kheap_virt_addr+0x7a3>
f011ce25:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011ce2c:	7f 0c                	jg     f011ce3a <test_kheap_virt_addr+0x7a3>
f011ce2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ce31:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011ce34:	0f 82 29 ff ff ff    	jb     f011cd63 <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011ce3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ce3d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011ce40:	0f 82 c7 fe ff ff    	jb     f011cd0d <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011ce46:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ce4a:	74 04                	je     f011ce50 <test_kheap_virt_addr+0x7b9>
f011ce4c:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011ce50:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011ce57:	83 ec 0c             	sub    $0xc,%esp
f011ce5a:	68 48 18 13 f0       	push   $0xf0131848
f011ce5f:	e8 27 41 fe ff       	call   f0100f8b <cprintf>
f011ce64:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011ce67:	e8 c8 1f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ce6c:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011ce6f:	e8 44 7c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ce74:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011ce77:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011ce7d:	83 ec 0c             	sub    $0xc,%esp
f011ce80:	50                   	push   %eax
f011ce81:	e8 4e d0 fe ff       	call   f0109ed4 <kfree>
f011ce86:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce89:	e8 2a 7c fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ce8e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ce91:	74 17                	je     f011ceaa <test_kheap_virt_addr+0x813>
f011ce93:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce9a:	83 ec 0c             	sub    $0xc,%esp
f011ce9d:	68 70 18 13 f0       	push   $0xf0131870
f011cea2:	e8 e4 40 fe ff       	call   f0100f8b <cprintf>
f011cea7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011ceaa:	e8 85 1f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ceaf:	89 c2                	mov    %eax,%edx
f011ceb1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ceb4:	29 c2                	sub    %eax,%edx
f011ceb6:	89 d0                	mov    %edx,%eax
f011ceb8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011cebd:	77 17                	ja     f011ced6 <test_kheap_virt_addr+0x83f>
f011cebf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cec6:	83 ec 0c             	sub    $0xc,%esp
f011cec9:	68 e0 18 13 f0       	push   $0xf01318e0
f011cece:	e8 b8 40 fe ff       	call   f0100f8b <cprintf>
f011ced3:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ced6:	e8 59 1f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cedb:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cede:	e8 d5 7b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cee3:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011cee6:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ceec:	83 ec 0c             	sub    $0xc,%esp
f011ceef:	50                   	push   %eax
f011cef0:	e8 df cf fe ff       	call   f0109ed4 <kfree>
f011cef5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cef8:	e8 bb 7b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cefd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cf00:	74 17                	je     f011cf19 <test_kheap_virt_addr+0x882>
f011cf02:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf09:	83 ec 0c             	sub    $0xc,%esp
f011cf0c:	68 1c 19 13 f0       	push   $0xf013191c
f011cf11:	e8 75 40 fe ff       	call   f0100f8b <cprintf>
f011cf16:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011cf19:	e8 16 1f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cf1e:	89 c2                	mov    %eax,%edx
f011cf20:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cf23:	29 c2                	sub    %eax,%edx
f011cf25:	89 d0                	mov    %edx,%eax
f011cf27:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011cf2c:	77 17                	ja     f011cf45 <test_kheap_virt_addr+0x8ae>
f011cf2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf35:	83 ec 0c             	sub    $0xc,%esp
f011cf38:	68 8c 19 13 f0       	push   $0xf013198c
f011cf3d:	e8 49 40 fe ff       	call   f0100f8b <cprintf>
f011cf42:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011cf45:	e8 ea 1e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cf4a:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cf4d:	e8 66 7b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cf52:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011cf55:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011cf5b:	83 ec 0c             	sub    $0xc,%esp
f011cf5e:	50                   	push   %eax
f011cf5f:	e8 70 cf fe ff       	call   f0109ed4 <kfree>
f011cf64:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cf67:	e8 4c 7b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011cf6c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cf6f:	74 17                	je     f011cf88 <test_kheap_virt_addr+0x8f1>
f011cf71:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf78:	83 ec 0c             	sub    $0xc,%esp
f011cf7b:	68 c8 19 13 f0       	push   $0xf01319c8
f011cf80:	e8 06 40 fe ff       	call   f0100f8b <cprintf>
f011cf85:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011cf88:	e8 a7 1e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011cf8d:	89 c2                	mov    %eax,%edx
f011cf8f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cf92:	29 c2                	sub    %eax,%edx
f011cf94:	89 d0                	mov    %edx,%eax
f011cf96:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011cf9b:	77 17                	ja     f011cfb4 <test_kheap_virt_addr+0x91d>
f011cf9d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfa4:	83 ec 0c             	sub    $0xc,%esp
f011cfa7:	68 38 1a 13 f0       	push   $0xf0131a38
f011cfac:	e8 da 3f fe ff       	call   f0100f8b <cprintf>
f011cfb1:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011cfb4:	83 ec 0c             	sub    $0xc,%esp
f011cfb7:	68 74 1a 13 f0       	push   $0xf0131a74
f011cfbc:	e8 ca 3f fe ff       	call   f0100f8b <cprintf>
f011cfc1:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cfc4:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011cfcb:	a1 58 3e 18 f0       	mov    0xf0183e58,%eax
f011cfd0:	05 00 10 00 00       	add    $0x1000,%eax
f011cfd5:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011cfdb:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011cfe2:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011cfe9:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011cfec:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cff2:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011cff5:	eb 44                	jmp    f011d03b <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cff7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cffa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cffd:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d000:	83 ec 0c             	sub    $0xc,%esp
f011d003:	50                   	push   %eax
f011d004:	e8 89 d0 fe ff       	call   f010a092 <kheap_virtual_address>
f011d009:	83 c4 10             	add    $0x10,%esp
f011d00c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011d012:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011d019:	74 1d                	je     f011d038 <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011d01b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d01f:	74 17                	je     f011d038 <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011d021:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d028:	83 ec 0c             	sub    $0xc,%esp
f011d02b:	68 c4 1a 13 f0       	push   $0xf0131ac4
f011d030:	e8 56 3f fe ff       	call   f0100f8b <cprintf>
f011d035:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011d038:	ff 45 d0             	incl   -0x30(%ebp)
f011d03b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d041:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011d047:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d04a:	39 c2                	cmp    %eax,%edx
f011d04c:	77 a9                	ja     f011cff7 <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d04e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d054:	05 00 04 00 00       	add    $0x400,%eax
f011d059:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d05c:	eb 64                	jmp    f011d0c2 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d05e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d061:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d064:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d067:	83 ec 0c             	sub    $0xc,%esp
f011d06a:	50                   	push   %eax
f011d06b:	e8 22 d0 fe ff       	call   f010a092 <kheap_virtual_address>
f011d070:	83 c4 10             	add    $0x10,%esp
f011d073:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011d079:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d07c:	c1 e0 0c             	shl    $0xc,%eax
f011d07f:	89 c2                	mov    %eax,%edx
f011d081:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d087:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011d08a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d08d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d090:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d093:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d098:	01 c8                	add    %ecx,%eax
f011d09a:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011d0a0:	74 1d                	je     f011d0bf <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011d0a2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d0a6:	74 17                	je     f011d0bf <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011d0a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0af:	83 ec 0c             	sub    $0xc,%esp
f011d0b2:	68 e8 1a 13 f0       	push   $0xf0131ae8
f011d0b7:	e8 cf 3e fe ff       	call   f0100f8b <cprintf>
f011d0bc:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d0bf:	ff 45 d0             	incl   -0x30(%ebp)
f011d0c2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d0c8:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011d0ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d0d1:	39 c2                	cmp    %eax,%edx
f011d0d3:	77 89                	ja     f011d05e <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d0d5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d0db:	05 02 07 00 00       	add    $0x702,%eax
f011d0e0:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d0e3:	eb 44                	jmp    f011d129 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d0e5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d0e8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d0eb:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d0ee:	83 ec 0c             	sub    $0xc,%esp
f011d0f1:	50                   	push   %eax
f011d0f2:	e8 9b cf fe ff       	call   f010a092 <kheap_virtual_address>
f011d0f7:	83 c4 10             	add    $0x10,%esp
f011d0fa:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011d100:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011d107:	74 1d                	je     f011d126 <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011d109:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d10d:	74 17                	je     f011d126 <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011d10f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d116:	83 ec 0c             	sub    $0xc,%esp
f011d119:	68 0c 1b 13 f0       	push   $0xf0131b0c
f011d11e:	e8 68 3e fe ff       	call   f0100f8b <cprintf>
f011d123:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d126:	ff 45 d0             	incl   -0x30(%ebp)
f011d129:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d12f:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011d135:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d138:	39 c2                	cmp    %eax,%edx
f011d13a:	77 a9                	ja     f011d0e5 <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d13c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d142:	05 02 0d 00 00       	add    $0xd02,%eax
f011d147:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d14a:	eb 64                	jmp    f011d1b0 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d14c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d14f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d152:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d155:	83 ec 0c             	sub    $0xc,%esp
f011d158:	50                   	push   %eax
f011d159:	e8 34 cf fe ff       	call   f010a092 <kheap_virtual_address>
f011d15e:	83 c4 10             	add    $0x10,%esp
f011d161:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011d167:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d16a:	c1 e0 0c             	shl    $0xc,%eax
f011d16d:	89 c2                	mov    %eax,%edx
f011d16f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d175:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011d178:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d17b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d17e:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d181:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d186:	01 c8                	add    %ecx,%eax
f011d188:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011d18e:	74 1d                	je     f011d1ad <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011d190:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d194:	74 17                	je     f011d1ad <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011d196:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d19d:	83 ec 0c             	sub    $0xc,%esp
f011d1a0:	68 30 1b 13 f0       	push   $0xf0131b30
f011d1a5:	e8 e1 3d fe ff       	call   f0100f8b <cprintf>
f011d1aa:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d1ad:	ff 45 d0             	incl   -0x30(%ebp)
f011d1b0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d1b6:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011d1bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d1bf:	39 c2                	cmp    %eax,%edx
f011d1c1:	77 89                	ja     f011d14c <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011d1c3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d1c7:	74 04                	je     f011d1cd <test_kheap_virt_addr+0xb36>
f011d1c9:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011d1cd:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011d1d4:	83 ec 0c             	sub    $0xc,%esp
f011d1d7:	68 54 1b 13 f0       	push   $0xf0131b54
f011d1dc:	e8 aa 3d fe ff       	call   f0100f8b <cprintf>
f011d1e1:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011d1e4:	83 ec 0c             	sub    $0xc,%esp
f011d1e7:	6a 00                	push   $0x0
f011d1e9:	e8 8d c9 fe ff       	call   f0109b7b <sbrk>
f011d1ee:	83 c4 10             	add    $0x10,%esp
f011d1f1:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011d1f6:	77 17                	ja     f011d20f <test_kheap_virt_addr+0xb78>
f011d1f8:	83 ec 04             	sub    $0x4,%esp
f011d1fb:	68 9b 1b 13 f0       	push   $0xf0131b9b
f011d200:	68 91 07 00 00       	push   $0x791
f011d205:	68 33 f0 12 f0       	push   $0xf012f033
f011d20a:	e8 2a 31 fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d20f:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011d216:	e9 d1 00 00 00       	jmp    f011d2ec <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011d21b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011d220:	83 ec 04             	sub    $0x4,%esp
f011d223:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011d229:	52                   	push   %edx
f011d22a:	ff 75 cc             	pushl  -0x34(%ebp)
f011d22d:	50                   	push   %eax
f011d22e:	e8 ad b8 fe ff       	call   f0108ae0 <get_page_table>
f011d233:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d236:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d23c:	85 c0                	test   %eax,%eax
f011d23e:	75 1e                	jne    f011d25e <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011d240:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d247:	83 ec 04             	sub    $0x4,%esp
f011d24a:	68 24 15 13 f0       	push   $0xf0131524
f011d24f:	68 97 07 00 00       	push   $0x797
f011d254:	68 33 f0 12 f0       	push   $0xf012f033
f011d259:	e8 db 30 fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011d25e:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d264:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011d267:	c1 ea 0c             	shr    $0xc,%edx
f011d26a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011d270:	c1 e2 02             	shl    $0x2,%edx
f011d273:	01 d0                	add    %edx,%eax
f011d275:	8b 00                	mov    (%eax),%eax
f011d277:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011d27c:	89 c2                	mov    %eax,%edx
f011d27e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d281:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d286:	01 d0                	add    %edx,%eax
f011d288:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011d28e:	83 ec 0c             	sub    $0xc,%esp
f011d291:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d297:	e8 f6 cd fe ff       	call   f010a092 <kheap_virtual_address>
f011d29c:	83 c4 10             	add    $0x10,%esp
f011d29f:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011d2a5:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011d2ab:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d2ae:	74 39                	je     f011d2e9 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011d2b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d2b4:	74 33                	je     f011d2e9 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011d2b6:	ff 75 cc             	pushl  -0x34(%ebp)
f011d2b9:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011d2bf:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d2c5:	68 b4 1b 13 f0       	push   $0xf0131bb4
f011d2ca:	e8 bc 3c fe ff       	call   f0100f8b <cprintf>
f011d2cf:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011d2d2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d2d9:	83 ec 0c             	sub    $0xc,%esp
f011d2dc:	68 e0 1b 13 f0       	push   $0xf0131be0
f011d2e1:	e8 a5 3c fe ff       	call   f0100f8b <cprintf>
f011d2e6:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d2e9:	ff 45 cc             	incl   -0x34(%ebp)
f011d2ec:	83 ec 0c             	sub    $0xc,%esp
f011d2ef:	6a 00                	push   $0x0
f011d2f1:	e8 85 c8 fe ff       	call   f0109b7b <sbrk>
f011d2f6:	83 c4 10             	add    $0x10,%esp
f011d2f9:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d2fc:	0f 87 19 ff ff ff    	ja     f011d21b <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011d302:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d306:	74 04                	je     f011d30c <test_kheap_virt_addr+0xc75>
f011d308:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011d30c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011d313:	83 ec 0c             	sub    $0xc,%esp
f011d316:	68 04 1c 13 f0       	push   $0xf0131c04
f011d31b:	e8 6b 3c fe ff       	call   f0100f8b <cprintf>
f011d320:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d323:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011d32a:	eb 5a                	jmp    f011d386 <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011d32c:	83 ec 0c             	sub    $0xc,%esp
f011d32f:	ff 75 c8             	pushl  -0x38(%ebp)
f011d332:	e8 5b cd fe ff       	call   f010a092 <kheap_virtual_address>
f011d337:	83 c4 10             	add    $0x10,%esp
f011d33a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011d340:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011d347:	74 36                	je     f011d37f <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011d349:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d34d:	74 30                	je     f011d37f <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011d34f:	83 ec 04             	sub    $0x4,%esp
f011d352:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011d358:	ff 75 c8             	pushl  -0x38(%ebp)
f011d35b:	68 43 1c 13 f0       	push   $0xf0131c43
f011d360:	e8 26 3c fe ff       	call   f0100f8b <cprintf>
f011d365:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011d368:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d36f:	83 ec 0c             	sub    $0xc,%esp
f011d372:	68 60 1c 13 f0       	push   $0xf0131c60
f011d377:	e8 0f 3c fe ff       	call   f0100f8b <cprintf>
f011d37c:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d37f:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011d386:	b8 b0 8a 76 00       	mov    $0x768ab0,%eax
f011d38b:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011d38e:	72 9c                	jb     f011d32c <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011d390:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d394:	74 04                	je     f011d39a <test_kheap_virt_addr+0xd03>
f011d396:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011d39a:	83 ec 08             	sub    $0x8,%esp
f011d39d:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d3a0:	68 84 1c 13 f0       	push   $0xf0131c84
f011d3a5:	e8 e1 3b fe ff       	call   f0100f8b <cprintf>
f011d3aa:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d3ad:	b8 01 00 00 00       	mov    $0x1,%eax
f011d3b2:	89 f4                	mov    %esi,%esp

}
f011d3b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d3b7:	5b                   	pop    %ebx
f011d3b8:	5e                   	pop    %esi
f011d3b9:	5f                   	pop    %edi
f011d3ba:	5d                   	pop    %ebp
f011d3bb:	c3                   	ret    

f011d3bc <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011d3bc:	55                   	push   %ebp
f011d3bd:	89 e5                	mov    %esp,%ebp
f011d3bf:	57                   	push   %edi
f011d3c0:	56                   	push   %esi
f011d3c1:	53                   	push   %ebx
f011d3c2:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011d3c8:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011d3ce:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d3d3:	b8 00 00 00 00       	mov    $0x0,%eax
f011d3d8:	89 d7                	mov    %edx,%edi
f011d3da:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011d3dc:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011d3e3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011d3ea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011d3f1:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f011d3f6:	0f b6 c0             	movzbl %al,%eax
f011d3f9:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011d3fc:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011d403:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d406:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011d409:	39 c2                	cmp    %eax,%edx
f011d40b:	73 02                	jae    f011d40f <test_ksbrk+0x53>
f011d40d:	89 c2                	mov    %eax,%edx
f011d40f:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f011d414:	0f b6 c0             	movzbl %al,%eax
f011d417:	c1 e0 04             	shl    $0x4,%eax
f011d41a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011d41d:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011d424:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011d427:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d42a:	39 c8                	cmp    %ecx,%eax
f011d42c:	73 02                	jae    f011d430 <test_ksbrk+0x74>
f011d42e:	89 c8                	mov    %ecx,%eax
f011d430:	01 d0                	add    %edx,%eax
f011d432:	83 c0 10             	add    $0x10,%eax
f011d435:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011d43a:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011d43d:	83 ec 0c             	sub    $0xc,%esp
f011d440:	68 b8 1c 13 f0       	push   $0xf0131cb8
f011d445:	e8 41 3b fe ff       	call   f0100f8b <cprintf>
f011d44a:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011d44d:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d454:	e8 db 19 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d459:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d45c:	e8 57 76 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d461:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011d464:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d467:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d46a:	29 c2                	sub    %eax,%edx
f011d46c:	89 d0                	mov    %edx,%eax
f011d46e:	83 ec 0c             	sub    $0xc,%esp
f011d471:	50                   	push   %eax
f011d472:	e8 f3 c7 fe ff       	call   f0109c6a <kmalloc>
f011d477:	83 c4 10             	add    $0x10,%esp
f011d47a:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011d480:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d483:	89 c2                	mov    %eax,%edx
f011d485:	c1 ea 1f             	shr    $0x1f,%edx
f011d488:	01 d0                	add    %edx,%eax
f011d48a:	d1 f8                	sar    %eax
f011d48c:	89 c2                	mov    %eax,%edx
f011d48e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011d491:	01 d0                	add    %edx,%eax
f011d493:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011d496:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d49c:	6a 01                	push   $0x1
f011d49e:	ff 75 b8             	pushl  -0x48(%ebp)
f011d4a1:	ff 75 ac             	pushl  -0x54(%ebp)
f011d4a4:	50                   	push   %eax
f011d4a5:	e8 fc 43 ff ff       	call   f01118a6 <check_block>
f011d4aa:	83 c4 10             	add    $0x10,%esp
f011d4ad:	85 c0                	test   %eax,%eax
f011d4af:	75 17                	jne    f011d4c8 <test_ksbrk+0x10c>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011d4b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d4b8:	83 ec 0c             	sub    $0xc,%esp
f011d4bb:	68 09 1d 13 f0       	push   $0xf0131d09
f011d4c0:	e8 c6 3a fe ff       	call   f0100f8b <cprintf>
f011d4c5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d4c8:	e8 67 19 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d4cd:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d4d0:	74 17                	je     f011d4e9 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011d4d2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d4d9:	83 ec 0c             	sub    $0xc,%esp
f011d4dc:	68 20 1d 13 f0       	push   $0xf0131d20
f011d4e1:	e8 a5 3a fe ff       	call   f0100f8b <cprintf>
f011d4e6:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d4e9:	e8 ca 75 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d4ee:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d4f1:	74 17                	je     f011d50a <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d4f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d4fa:	83 ec 0c             	sub    $0xc,%esp
f011d4fd:	68 40 1d 13 f0       	push   $0xf0131d40
f011d502:	e8 84 3a fe ff       	call   f0100f8b <cprintf>
f011d507:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011d50a:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f011d50f:	0f b6 c0             	movzbl %al,%eax
f011d512:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011d515:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011d51c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011d51f:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011d522:	39 c2                	cmp    %eax,%edx
f011d524:	73 02                	jae    f011d528 <test_ksbrk+0x16c>
f011d526:	89 c2                	mov    %eax,%edx
f011d528:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f011d52d:	0f b6 c0             	movzbl %al,%eax
f011d530:	c1 e0 04             	shl    $0x4,%eax
f011d533:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011d536:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011d53d:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011d540:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d543:	39 c8                	cmp    %ecx,%eax
f011d545:	73 02                	jae    f011d549 <test_ksbrk+0x18d>
f011d547:	89 c8                	mov    %ecx,%eax
f011d549:	01 d0                	add    %edx,%eax
f011d54b:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011d550:	29 c2                	sub    %eax,%edx
f011d552:	89 d0                	mov    %edx,%eax
f011d554:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d557:	e8 d8 18 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d55c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d55f:	e8 54 75 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d564:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011d567:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d56a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d56d:	29 c2                	sub    %eax,%edx
f011d56f:	89 d0                	mov    %edx,%eax
f011d571:	83 ec 0c             	sub    $0xc,%esp
f011d574:	50                   	push   %eax
f011d575:	e8 f0 c6 fe ff       	call   f0109c6a <kmalloc>
f011d57a:	83 c4 10             	add    $0x10,%esp
f011d57d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011d583:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d586:	89 c2                	mov    %eax,%edx
f011d588:	c1 ea 1f             	shr    $0x1f,%edx
f011d58b:	01 d0                	add    %edx,%eax
f011d58d:	d1 f8                	sar    %eax
f011d58f:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011d595:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011d598:	01 d0                	add    %edx,%eax
f011d59a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011d59d:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d5a3:	6a 01                	push   $0x1
f011d5a5:	ff 75 b8             	pushl  -0x48(%ebp)
f011d5a8:	ff 75 ac             	pushl  -0x54(%ebp)
f011d5ab:	50                   	push   %eax
f011d5ac:	e8 f5 42 ff ff       	call   f01118a6 <check_block>
f011d5b1:	83 c4 10             	add    $0x10,%esp
f011d5b4:	85 c0                	test   %eax,%eax
f011d5b6:	75 17                	jne    f011d5cf <test_ksbrk+0x213>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011d5b8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d5bf:	83 ec 0c             	sub    $0xc,%esp
f011d5c2:	68 ae 1d 13 f0       	push   $0xf0131dae
f011d5c7:	e8 bf 39 fe ff       	call   f0100f8b <cprintf>
f011d5cc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d5cf:	e8 60 18 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d5d4:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d5d7:	74 17                	je     f011d5f0 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011d5d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d5e0:	83 ec 0c             	sub    $0xc,%esp
f011d5e3:	68 c8 1d 13 f0       	push   $0xf0131dc8
f011d5e8:	e8 9e 39 fe ff       	call   f0100f8b <cprintf>
f011d5ed:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d5f0:	e8 c3 74 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d5f5:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d5f8:	74 17                	je     f011d611 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d5fa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d601:	83 ec 0c             	sub    $0xc,%esp
f011d604:	68 e8 1d 13 f0       	push   $0xf0131de8
f011d609:	e8 7d 39 fe ff       	call   f0100f8b <cprintf>
f011d60e:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011d611:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011d618:	e8 17 18 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d61d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d620:	e8 93 74 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d625:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011d628:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d62b:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d62e:	29 c2                	sub    %eax,%edx
f011d630:	89 d0                	mov    %edx,%eax
f011d632:	83 ec 0c             	sub    $0xc,%esp
f011d635:	50                   	push   %eax
f011d636:	e8 2f c6 fe ff       	call   f0109c6a <kmalloc>
f011d63b:	83 c4 10             	add    $0x10,%esp
f011d63e:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011d644:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d647:	89 c2                	mov    %eax,%edx
f011d649:	c1 ea 1f             	shr    $0x1f,%edx
f011d64c:	01 d0                	add    %edx,%eax
f011d64e:	d1 f8                	sar    %eax
f011d650:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011d655:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011d658:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d65e:	6a 01                	push   $0x1
f011d660:	ff 75 b8             	pushl  -0x48(%ebp)
f011d663:	ff 75 ac             	pushl  -0x54(%ebp)
f011d666:	50                   	push   %eax
f011d667:	e8 3a 42 ff ff       	call   f01118a6 <check_block>
f011d66c:	83 c4 10             	add    $0x10,%esp
f011d66f:	85 c0                	test   %eax,%eax
f011d671:	75 17                	jne    f011d68a <test_ksbrk+0x2ce>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011d673:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d67a:	83 ec 0c             	sub    $0xc,%esp
f011d67d:	68 56 1e 13 f0       	push   $0xf0131e56
f011d682:	e8 04 39 fe ff       	call   f0100f8b <cprintf>
f011d687:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011d68a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d68d:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011d690:	b8 00 10 00 00       	mov    $0x1000,%eax
f011d695:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011d698:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011d69b:	6a 00                	push   $0x0
f011d69d:	ff 75 98             	pushl  -0x68(%ebp)
f011d6a0:	ff 75 ac             	pushl  -0x54(%ebp)
f011d6a3:	ff 75 ac             	pushl  -0x54(%ebp)
f011d6a6:	e8 fb 41 ff ff       	call   f01118a6 <check_block>
f011d6ab:	83 c4 10             	add    $0x10,%esp
f011d6ae:	85 c0                	test   %eax,%eax
f011d6b0:	75 17                	jne    f011d6c9 <test_ksbrk+0x30d>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011d6b2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d6b9:	83 ec 0c             	sub    $0xc,%esp
f011d6bc:	68 6d 1e 13 f0       	push   $0xf0131e6d
f011d6c1:	e8 c5 38 fe ff       	call   f0100f8b <cprintf>
f011d6c6:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011d6c9:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011d6d0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011d6d3:	8b 00                	mov    (%eax),%eax
f011d6d5:	83 f8 01             	cmp    $0x1,%eax
f011d6d8:	74 17                	je     f011d6f1 <test_ksbrk+0x335>
			{ correct = 0; cprintf("A.9: Wrong END block after calling sbrk()\n"); }
f011d6da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d6e1:	83 ec 0c             	sub    $0xc,%esp
f011d6e4:	68 84 1e 13 f0       	push   $0xf0131e84
f011d6e9:	e8 9d 38 fe ff       	call   f0100f8b <cprintf>
f011d6ee:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011d6f1:	83 ec 0c             	sub    $0xc,%esp
f011d6f4:	6a 00                	push   $0x0
f011d6f6:	e8 80 c4 fe ff       	call   f0109b7b <sbrk>
f011d6fb:	83 c4 10             	add    $0x10,%esp
f011d6fe:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011d701:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011d708:	8b 45 90             	mov    -0x70(%ebp),%eax
f011d70b:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011d70e:	74 1d                	je     f011d72d <test_ksbrk+0x371>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011d710:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d717:	83 ec 04             	sub    $0x4,%esp
f011d71a:	ff 75 90             	pushl  -0x70(%ebp)
f011d71d:	ff 75 8c             	pushl  -0x74(%ebp)
f011d720:	68 b0 1e 13 f0       	push   $0xf0131eb0
f011d725:	e8 61 38 fe ff       	call   f0100f8b <cprintf>
f011d72a:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d72d:	e8 02 17 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d732:	89 c2                	mov    %eax,%edx
f011d734:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d737:	29 d0                	sub    %edx,%eax
f011d739:	83 f8 01             	cmp    $0x1,%eax
f011d73c:	74 17                	je     f011d755 <test_ksbrk+0x399>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011d73e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d745:	83 ec 0c             	sub    $0xc,%esp
f011d748:	68 e4 1e 13 f0       	push   $0xf0131ee4
f011d74d:	e8 39 38 fe ff       	call   f0100f8b <cprintf>
f011d752:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d755:	e8 5e 73 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d75a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d75d:	74 17                	je     f011d776 <test_ksbrk+0x3ba>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d75f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d766:	83 ec 0c             	sub    $0xc,%esp
f011d769:	68 04 1f 13 f0       	push   $0xf0131f04
f011d76e:	e8 18 38 fe ff       	call   f0100f8b <cprintf>
f011d773:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011d776:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d77d:	e8 b2 16 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d782:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d785:	e8 2e 73 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d78a:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011d78d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d790:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d793:	29 c2                	sub    %eax,%edx
f011d795:	89 d0                	mov    %edx,%eax
f011d797:	83 ec 0c             	sub    $0xc,%esp
f011d79a:	50                   	push   %eax
f011d79b:	e8 ca c4 fe ff       	call   f0109c6a <kmalloc>
f011d7a0:	83 c4 10             	add    $0x10,%esp
f011d7a3:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011d7a9:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011d7b0:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011d7b6:	6a 01                	push   $0x1
f011d7b8:	ff 75 b8             	pushl  -0x48(%ebp)
f011d7bb:	ff 75 ac             	pushl  -0x54(%ebp)
f011d7be:	50                   	push   %eax
f011d7bf:	e8 e2 40 ff ff       	call   f01118a6 <check_block>
f011d7c4:	83 c4 10             	add    $0x10,%esp
f011d7c7:	85 c0                	test   %eax,%eax
f011d7c9:	75 17                	jne    f011d7e2 <test_ksbrk+0x426>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011d7cb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d7d2:	83 ec 0c             	sub    $0xc,%esp
f011d7d5:	68 73 1f 13 f0       	push   $0xf0131f73
f011d7da:	e8 ac 37 fe ff       	call   f0100f8b <cprintf>
f011d7df:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d7e2:	e8 4d 16 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d7e7:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d7ea:	74 17                	je     f011d803 <test_ksbrk+0x447>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011d7ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d7f3:	83 ec 0c             	sub    $0xc,%esp
f011d7f6:	68 8c 1f 13 f0       	push   $0xf0131f8c
f011d7fb:	e8 8b 37 fe ff       	call   f0100f8b <cprintf>
f011d800:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d803:	e8 b0 72 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d808:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d80b:	74 17                	je     f011d824 <test_ksbrk+0x468>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d80d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d814:	83 ec 0c             	sub    $0xc,%esp
f011d817:	68 ac 1f 13 f0       	push   $0xf0131fac
f011d81c:	e8 6a 37 fe ff       	call   f0100f8b <cprintf>
f011d821:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011d824:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d828:	74 04                	je     f011d82e <test_ksbrk+0x472>
		eval += 25;
f011d82a:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011d82e:	83 ec 0c             	sub    $0xc,%esp
f011d831:	68 1c 20 13 f0       	push   $0xf013201c
f011d836:	e8 50 37 fe ff       	call   f0100f8b <cprintf>
f011d83b:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011d83e:	83 ec 0c             	sub    $0xc,%esp
f011d841:	6a 00                	push   $0x0
f011d843:	e8 33 c3 fe ff       	call   f0109b7b <sbrk>
f011d848:	83 c4 10             	add    $0x10,%esp
f011d84b:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011d84e:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d855:	e8 da 15 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d85a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d85d:	e8 56 72 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d862:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011d865:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d868:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d86b:	29 c2                	sub    %eax,%edx
f011d86d:	89 d0                	mov    %edx,%eax
f011d86f:	83 ec 0c             	sub    $0xc,%esp
f011d872:	50                   	push   %eax
f011d873:	e8 f2 c3 fe ff       	call   f0109c6a <kmalloc>
f011d878:	83 c4 10             	add    $0x10,%esp
f011d87b:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011d881:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d884:	89 c2                	mov    %eax,%edx
f011d886:	c1 ea 1f             	shr    $0x1f,%edx
f011d889:	01 d0                	add    %edx,%eax
f011d88b:	d1 f8                	sar    %eax
f011d88d:	89 c2                	mov    %eax,%edx
f011d88f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011d892:	01 d0                	add    %edx,%eax
f011d894:	83 e8 04             	sub    $0x4,%eax
f011d897:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011d89a:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d8a0:	6a 01                	push   $0x1
f011d8a2:	ff 75 b8             	pushl  -0x48(%ebp)
f011d8a5:	ff 75 ac             	pushl  -0x54(%ebp)
f011d8a8:	50                   	push   %eax
f011d8a9:	e8 f8 3f ff ff       	call   f01118a6 <check_block>
f011d8ae:	83 c4 10             	add    $0x10,%esp
f011d8b1:	85 c0                	test   %eax,%eax
f011d8b3:	75 17                	jne    f011d8cc <test_ksbrk+0x510>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011d8b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d8bc:	83 ec 0c             	sub    $0xc,%esp
f011d8bf:	68 7f 20 13 f0       	push   $0xf013207f
f011d8c4:	e8 c2 36 fe ff       	call   f0100f8b <cprintf>
f011d8c9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d8cc:	e8 63 15 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d8d1:	89 c2                	mov    %eax,%edx
f011d8d3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011d8d6:	29 d0                	sub    %edx,%eax
f011d8d8:	83 f8 01             	cmp    $0x1,%eax
f011d8db:	74 17                	je     f011d8f4 <test_ksbrk+0x538>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011d8dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d8e4:	83 ec 0c             	sub    $0xc,%esp
f011d8e7:	68 98 20 13 f0       	push   $0xf0132098
f011d8ec:	e8 9a 36 fe ff       	call   f0100f8b <cprintf>
f011d8f1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d8f4:	e8 bf 71 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d8f9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d8fc:	74 17                	je     f011d915 <test_ksbrk+0x559>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d8fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d905:	83 ec 0c             	sub    $0xc,%esp
f011d908:	68 b8 20 13 f0       	push   $0xf01320b8
f011d90d:	e8 79 36 fe ff       	call   f0100f8b <cprintf>
f011d912:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011d915:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011d91c:	e8 13 15 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d921:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d924:	e8 8f 71 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d929:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011d92c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d92f:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d932:	29 c2                	sub    %eax,%edx
f011d934:	89 d0                	mov    %edx,%eax
f011d936:	83 ec 0c             	sub    $0xc,%esp
f011d939:	50                   	push   %eax
f011d93a:	e8 2b c3 fe ff       	call   f0109c6a <kmalloc>
f011d93f:	83 c4 10             	add    $0x10,%esp
f011d942:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011d948:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011d94f:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d955:	6a 01                	push   $0x1
f011d957:	ff 75 b8             	pushl  -0x48(%ebp)
f011d95a:	ff 75 ac             	pushl  -0x54(%ebp)
f011d95d:	50                   	push   %eax
f011d95e:	e8 43 3f ff ff       	call   f01118a6 <check_block>
f011d963:	83 c4 10             	add    $0x10,%esp
f011d966:	85 c0                	test   %eax,%eax
f011d968:	75 17                	jne    f011d981 <test_ksbrk+0x5c5>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011d96a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d971:	83 ec 0c             	sub    $0xc,%esp
f011d974:	68 26 21 13 f0       	push   $0xf0132126
f011d979:	e8 0d 36 fe ff       	call   f0100f8b <cprintf>
f011d97e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d981:	e8 ae 14 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d986:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011d989:	74 17                	je     f011d9a2 <test_ksbrk+0x5e6>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011d98b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d992:	83 ec 0c             	sub    $0xc,%esp
f011d995:	68 40 21 13 f0       	push   $0xf0132140
f011d99a:	e8 ec 35 fe ff       	call   f0100f8b <cprintf>
f011d99f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d9a2:	e8 11 71 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d9a7:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011d9aa:	74 17                	je     f011d9c3 <test_ksbrk+0x607>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011d9ac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d9b3:	83 ec 0c             	sub    $0xc,%esp
f011d9b6:	68 60 21 13 f0       	push   $0xf0132160
f011d9bb:	e8 cb 35 fe ff       	call   f0100f8b <cprintf>
f011d9c0:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011d9c3:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011d9ca:	e8 65 14 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011d9cf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011d9d2:	e8 e1 70 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011d9d7:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011d9da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d9dd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011d9e0:	29 c2                	sub    %eax,%edx
f011d9e2:	89 d0                	mov    %edx,%eax
f011d9e4:	83 ec 0c             	sub    $0xc,%esp
f011d9e7:	50                   	push   %eax
f011d9e8:	e8 7d c2 fe ff       	call   f0109c6a <kmalloc>
f011d9ed:	83 c4 10             	add    $0x10,%esp
f011d9f0:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011d9f6:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011d9fd:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011da03:	6a 01                	push   $0x1
f011da05:	ff 75 b8             	pushl  -0x48(%ebp)
f011da08:	ff 75 ac             	pushl  -0x54(%ebp)
f011da0b:	50                   	push   %eax
f011da0c:	e8 95 3e ff ff       	call   f01118a6 <check_block>
f011da11:	83 c4 10             	add    $0x10,%esp
f011da14:	85 c0                	test   %eax,%eax
f011da16:	75 17                	jne    f011da2f <test_ksbrk+0x673>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011da18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011da1f:	83 ec 0c             	sub    $0xc,%esp
f011da22:	68 ce 21 13 f0       	push   $0xf01321ce
f011da27:	e8 5f 35 fe ff       	call   f0100f8b <cprintf>
f011da2c:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011da2f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011da32:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011da35:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011da3c:	6a 00                	push   $0x0
f011da3e:	ff 75 98             	pushl  -0x68(%ebp)
f011da41:	ff 75 ac             	pushl  -0x54(%ebp)
f011da44:	ff 75 ac             	pushl  -0x54(%ebp)
f011da47:	e8 5a 3e ff ff       	call   f01118a6 <check_block>
f011da4c:	83 c4 10             	add    $0x10,%esp
f011da4f:	85 c0                	test   %eax,%eax
f011da51:	75 17                	jne    f011da6a <test_ksbrk+0x6ae>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011da53:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011da5a:	83 ec 0c             	sub    $0xc,%esp
f011da5d:	68 e5 21 13 f0       	push   $0xf01321e5
f011da62:	e8 24 35 fe ff       	call   f0100f8b <cprintf>
f011da67:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011da6a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011da6d:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011da72:	89 45 94             	mov    %eax,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011da75:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011da78:	8b 00                	mov    (%eax),%eax
f011da7a:	83 f8 01             	cmp    $0x1,%eax
f011da7d:	74 17                	je     f011da96 <test_ksbrk+0x6da>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()\n"); }
f011da7f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011da86:	83 ec 0c             	sub    $0xc,%esp
f011da89:	68 fc 21 13 f0       	push   $0xf01321fc
f011da8e:	e8 f8 34 fe ff       	call   f0100f8b <cprintf>
f011da93:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011da96:	83 ec 0c             	sub    $0xc,%esp
f011da99:	6a 00                	push   $0x0
f011da9b:	e8 db c0 fe ff       	call   f0109b7b <sbrk>
f011daa0:	83 c4 10             	add    $0x10,%esp
f011daa3:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011daa6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011daa9:	05 00 20 00 00       	add    $0x2000,%eax
f011daae:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011dab1:	8b 45 90             	mov    -0x70(%ebp),%eax
f011dab4:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011dab7:	74 1d                	je     f011dad6 <test_ksbrk+0x71a>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011dab9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011dac0:	83 ec 04             	sub    $0x4,%esp
f011dac3:	ff 75 90             	pushl  -0x70(%ebp)
f011dac6:	ff 75 8c             	pushl  -0x74(%ebp)
f011dac9:	68 28 22 13 f0       	push   $0xf0132228
f011dace:	e8 b8 34 fe ff       	call   f0100f8b <cprintf>
f011dad3:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011dad6:	e8 59 13 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011dadb:	89 c2                	mov    %eax,%edx
f011dadd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011dae0:	29 d0                	sub    %edx,%eax
f011dae2:	83 f8 01             	cmp    $0x1,%eax
f011dae5:	74 17                	je     f011dafe <test_ksbrk+0x742>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011dae7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011daee:	83 ec 0c             	sub    $0xc,%esp
f011daf1:	68 5c 22 13 f0       	push   $0xf013225c
f011daf6:	e8 90 34 fe ff       	call   f0100f8b <cprintf>
f011dafb:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011dafe:	e8 b5 6f fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011db03:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011db06:	74 17                	je     f011db1f <test_ksbrk+0x763>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011db08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011db0f:	83 ec 0c             	sub    $0xc,%esp
f011db12:	68 7c 22 13 f0       	push   $0xf013227c
f011db17:	e8 6f 34 fe ff       	call   f0100f8b <cprintf>
f011db1c:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011db1f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011db23:	74 04                	je     f011db29 <test_ksbrk+0x76d>
		eval += 25;
f011db25:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011db29:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011db30:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011db36:	bb b8 25 13 f0       	mov    $0xf01325b8,%ebx
f011db3b:	ba 05 00 00 00       	mov    $0x5,%edx
f011db40:	89 c7                	mov    %eax,%edi
f011db42:	89 de                	mov    %ebx,%esi
f011db44:	89 d1                	mov    %edx,%ecx
f011db46:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011db48:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011db4e:	bb cc 25 13 f0       	mov    $0xf01325cc,%ebx
f011db53:	ba 05 00 00 00       	mov    $0x5,%edx
f011db58:	89 c7                	mov    %eax,%edi
f011db5a:	89 de                	mov    %ebx,%esi
f011db5c:	89 d1                	mov    %edx,%ecx
f011db5e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011db60:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011db66:	bb e0 25 13 f0       	mov    $0xf01325e0,%ebx
f011db6b:	ba 05 00 00 00       	mov    $0x5,%edx
f011db70:	89 c7                	mov    %eax,%edi
f011db72:	89 de                	mov    %ebx,%esi
f011db74:	89 d1                	mov    %edx,%ecx
f011db76:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011db78:	83 ec 04             	sub    $0x4,%esp
f011db7b:	68 00 00 00 f8       	push   $0xf8000000
f011db80:	68 00 10 00 00       	push   $0x1000
f011db85:	68 00 00 00 f6       	push   $0xf6000000
f011db8a:	e8 da be fe ff       	call   f0109a69 <initialize_kheap_dynamic_allocator>
f011db8f:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011db92:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011db99:	eb 1b                	jmp    f011dbb6 <test_ksbrk+0x7fa>
	{
		unmap_frame(ptr_page_directory, va);
f011db9b:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011dba0:	83 ec 08             	sub    $0x8,%esp
f011dba3:	ff 75 dc             	pushl  -0x24(%ebp)
f011dba6:	50                   	push   %eax
f011dba7:	e8 2d b3 fe ff       	call   f0108ed9 <unmap_frame>
f011dbac:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011dbaf:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011dbb6:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011dbbd:	76 dc                	jbe    f011db9b <test_ksbrk+0x7df>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011dbbf:	83 ec 0c             	sub    $0xc,%esp
f011dbc2:	68 ec 22 13 f0       	push   $0xf01322ec
f011dbc7:	e8 bf 33 fe ff       	call   f0100f8b <cprintf>
f011dbcc:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011dbcf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011dbd6:	e9 21 01 00 00       	jmp    f011dcfc <test_ksbrk+0x940>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011dbdb:	e8 54 12 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011dbe0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011dbe3:	e8 d0 6e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011dbe8:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011dbeb:	83 ec 0c             	sub    $0xc,%esp
f011dbee:	6a 00                	push   $0x0
f011dbf0:	e8 86 bf fe ff       	call   f0109b7b <sbrk>
f011dbf5:	83 c4 10             	add    $0x10,%esp
f011dbf8:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011dbfb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dbfe:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011dc05:	83 ec 0c             	sub    $0xc,%esp
f011dc08:	50                   	push   %eax
f011dc09:	e8 6d bf fe ff       	call   f0109b7b <sbrk>
f011dc0e:	83 c4 10             	add    $0x10,%esp
f011dc11:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011dc14:	83 ec 0c             	sub    $0xc,%esp
f011dc17:	6a 00                	push   $0x0
f011dc19:	e8 5d bf fe ff       	call   f0109b7b <sbrk>
f011dc1e:	83 c4 10             	add    $0x10,%esp
f011dc21:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011dc24:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011dc2b:	e8 88 6e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011dc30:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011dc33:	74 1a                	je     f011dc4f <test_ksbrk+0x893>
			{
				correct = 0;
f011dc35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011dc3c:	83 ec 08             	sub    $0x8,%esp
f011dc3f:	ff 75 d8             	pushl  -0x28(%ebp)
f011dc42:	68 30 23 13 f0       	push   $0xf0132330
f011dc47:	e8 3f 33 fe ff       	call   f0100f8b <cprintf>
f011dc4c:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011dc4f:	e8 e0 11 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011dc54:	89 c2                	mov    %eax,%edx
f011dc56:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011dc59:	29 d0                	sub    %edx,%eax
f011dc5b:	89 c2                	mov    %eax,%edx
f011dc5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dc60:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011dc67:	39 c2                	cmp    %eax,%edx
f011dc69:	74 1a                	je     f011dc85 <test_ksbrk+0x8c9>
			{
				correct = 0;
f011dc6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011dc72:	83 ec 08             	sub    $0x8,%esp
f011dc75:	ff 75 d8             	pushl  -0x28(%ebp)
f011dc78:	68 a0 23 13 f0       	push   $0xf01323a0
f011dc7d:	e8 09 33 fe ff       	call   f0100f8b <cprintf>
f011dc82:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011dc85:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dc88:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011dc8f:	8b 45 80             	mov    -0x80(%ebp),%eax
f011dc92:	39 c2                	cmp    %eax,%edx
f011dc94:	74 25                	je     f011dcbb <test_ksbrk+0x8ff>
			{
				correct = 0;
f011dc96:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011dc9d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dca0:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011dca7:	ff 75 80             	pushl  -0x80(%ebp)
f011dcaa:	50                   	push   %eax
f011dcab:	ff 75 d8             	pushl  -0x28(%ebp)
f011dcae:	68 c0 23 13 f0       	push   $0xf01323c0
f011dcb3:	e8 d3 32 fe ff       	call   f0100f8b <cprintf>
f011dcb8:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011dcbb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dcbe:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011dcc5:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011dcc8:	74 25                	je     f011dcef <test_ksbrk+0x933>
			{
				correct = 0;
f011dcca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011dcd1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dcd4:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011dcdb:	ff 75 90             	pushl  -0x70(%ebp)
f011dcde:	50                   	push   %eax
f011dcdf:	ff 75 d8             	pushl  -0x28(%ebp)
f011dce2:	68 f8 23 13 f0       	push   $0xf01323f8
f011dce7:	e8 9f 32 fe ff       	call   f0100f8b <cprintf>
f011dcec:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011dcef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dcf3:	74 04                	je     f011dcf9 <test_ksbrk+0x93d>
				eval += 10;
f011dcf5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011dcf9:	ff 45 d8             	incl   -0x28(%ebp)
f011dcfc:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011dcff:	8d 50 ff             	lea    -0x1(%eax),%edx
f011dd02:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011dd05:	39 c2                	cmp    %eax,%edx
f011dd07:	0f 87 ce fe ff ff    	ja     f011dbdb <test_ksbrk+0x81f>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011dd0d:	83 ec 0c             	sub    $0xc,%esp
f011dd10:	68 2c 24 13 f0       	push   $0xf013242c
f011dd15:	e8 71 32 fe ff       	call   f0100f8b <cprintf>
f011dd1a:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011dd1d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011dd20:	48                   	dec    %eax
f011dd21:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011dd24:	e9 18 01 00 00       	jmp    f011de41 <test_ksbrk+0xa85>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011dd29:	e8 06 11 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011dd2e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011dd31:	e8 82 6d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011dd36:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011dd39:	83 ec 0c             	sub    $0xc,%esp
f011dd3c:	6a 00                	push   $0x0
f011dd3e:	e8 38 be fe ff       	call   f0109b7b <sbrk>
f011dd43:	83 c4 10             	add    $0x10,%esp
f011dd46:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011dd49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dd4c:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011dd53:	83 ec 0c             	sub    $0xc,%esp
f011dd56:	50                   	push   %eax
f011dd57:	e8 1f be fe ff       	call   f0109b7b <sbrk>
f011dd5c:	83 c4 10             	add    $0x10,%esp
f011dd5f:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011dd65:	83 ec 0c             	sub    $0xc,%esp
f011dd68:	6a 00                	push   $0x0
f011dd6a:	e8 0c be fe ff       	call   f0109b7b <sbrk>
f011dd6f:	83 c4 10             	add    $0x10,%esp
f011dd72:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011dd75:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011dd7c:	e8 37 6d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011dd81:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011dd84:	74 1a                	je     f011dda0 <test_ksbrk+0x9e4>
			{
				correct = 0;
f011dd86:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011dd8d:	83 ec 08             	sub    $0x8,%esp
f011dd90:	ff 75 d4             	pushl  -0x2c(%ebp)
f011dd93:	68 7c 24 13 f0       	push   $0xf013247c
f011dd98:	e8 ee 31 fe ff       	call   f0100f8b <cprintf>
f011dd9d:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011dda0:	e8 8f 10 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011dda5:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011dda8:	74 1a                	je     f011ddc4 <test_ksbrk+0xa08>
			{
				correct = 0;
f011ddaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011ddb1:	83 ec 08             	sub    $0x8,%esp
f011ddb4:	ff 75 d4             	pushl  -0x2c(%ebp)
f011ddb7:	68 ec 24 13 f0       	push   $0xf01324ec
f011ddbc:	e8 ca 31 fe ff       	call   f0100f8b <cprintf>
f011ddc1:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011ddc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ddc7:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011ddce:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011ddd4:	39 c2                	cmp    %eax,%edx
f011ddd6:	74 28                	je     f011de00 <test_ksbrk+0xa44>
			{
				correct = 0;
f011ddd8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011dddf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dde2:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011dde9:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011ddef:	50                   	push   %eax
f011ddf0:	ff 75 d4             	pushl  -0x2c(%ebp)
f011ddf3:	68 0c 25 13 f0       	push   $0xf013250c
f011ddf8:	e8 8e 31 fe ff       	call   f0100f8b <cprintf>
f011ddfd:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011de00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011de03:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011de0a:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011de0d:	74 25                	je     f011de34 <test_ksbrk+0xa78>
			{
				correct = 0;
f011de0f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011de16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011de19:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011de20:	ff 75 90             	pushl  -0x70(%ebp)
f011de23:	50                   	push   %eax
f011de24:	ff 75 d4             	pushl  -0x2c(%ebp)
f011de27:	68 44 25 13 f0       	push   $0xf0132544
f011de2c:	e8 5a 31 fe ff       	call   f0100f8b <cprintf>
f011de31:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011de34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011de38:	74 04                	je     f011de3e <test_ksbrk+0xa82>
				eval += 10;
f011de3a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011de3e:	ff 45 d4             	incl   -0x2c(%ebp)
f011de41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011de44:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011de47:	0f 82 dc fe ff ff    	jb     f011dd29 <test_ksbrk+0x96d>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011de4d:	83 ec 08             	sub    $0x8,%esp
f011de50:	ff 75 e4             	pushl  -0x1c(%ebp)
f011de53:	68 78 25 13 f0       	push   $0xf0132578
f011de58:	e8 2e 31 fe ff       	call   f0100f8b <cprintf>
f011de5d:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011de60:	83 ec 0c             	sub    $0xc,%esp
f011de63:	68 a2 25 13 f0       	push   $0xf01325a2
f011de68:	e8 1e 31 fe ff       	call   f0100f8b <cprintf>
f011de6d:	83 c4 10             	add    $0x10,%esp
	return 0;
f011de70:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011de75:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011de78:	5b                   	pop    %ebx
f011de79:	5e                   	pop    %esi
f011de7a:	5f                   	pop    %edi
f011de7b:	5d                   	pop    %ebp
f011de7c:	c3                   	ret    

f011de7d <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011de7d:	55                   	push   %ebp
f011de7e:	89 e5                	mov    %esp,%ebp
f011de80:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011de83:	83 ec 04             	sub    $0x4,%esp
f011de86:	68 f4 25 13 f0       	push   $0xf01325f4
f011de8b:	68 c1 08 00 00       	push   $0x8c1
f011de90:	68 33 f0 12 f0       	push   $0xf012f033
f011de95:	e8 9f 24 fe ff       	call   f0100339 <_panic>

f011de9a <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011de9a:	55                   	push   %ebp
f011de9b:	89 e5                	mov    %esp,%ebp
f011de9d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011dea0:	83 ec 04             	sub    $0x4,%esp
f011dea3:	68 f4 25 13 f0       	push   $0xf01325f4
f011dea8:	68 c6 08 00 00       	push   $0x8c6
f011dead:	68 33 f0 12 f0       	push   $0xf012f033
f011deb2:	e8 82 24 fe ff       	call   f0100339 <_panic>

f011deb7 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011deb7:	55                   	push   %ebp
f011deb8:	89 e5                	mov    %esp,%ebp
f011deba:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011debd:	83 ec 04             	sub    $0x4,%esp
f011dec0:	68 f4 25 13 f0       	push   $0xf01325f4
f011dec5:	68 cb 08 00 00       	push   $0x8cb
f011deca:	68 33 f0 12 f0       	push   $0xf012f033
f011decf:	e8 65 24 fe ff       	call   f0100339 <_panic>

f011ded4 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011ded4:	55                   	push   %ebp
f011ded5:	89 e5                	mov    %esp,%ebp
f011ded7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011deda:	83 ec 04             	sub    $0x4,%esp
f011dedd:	68 f4 25 13 f0       	push   $0xf01325f4
f011dee2:	68 d0 08 00 00       	push   $0x8d0
f011dee7:	68 33 f0 12 f0       	push   $0xf012f033
f011deec:	e8 48 24 fe ff       	call   f0100339 <_panic>

f011def1 <test_kfree>:
}

int test_kfree()
{
f011def1:	55                   	push   %ebp
f011def2:	89 e5                	mov    %esp,%ebp
f011def4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011def7:	83 ec 04             	sub    $0x4,%esp
f011defa:	68 f4 25 13 f0       	push   $0xf01325f4
f011deff:	68 d5 08 00 00       	push   $0x8d5
f011df04:	68 33 f0 12 f0       	push   $0xf012f033
f011df09:	e8 2b 24 fe ff       	call   f0100339 <_panic>

f011df0e <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011df0e:	55                   	push   %ebp
f011df0f:	89 e5                	mov    %esp,%ebp
f011df11:	57                   	push   %edi
f011df12:	56                   	push   %esi
f011df13:	53                   	push   %ebx
f011df14:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011df1a:	a0 5c 3e 18 f0       	mov    0xf0183e5c,%al
f011df1f:	84 c0                	test   %al,%al
f011df21:	74 56                	je     f011df79 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011df23:	c6 05 5c 3e 18 f0 00 	movb   $0x0,0xf0183e5c
		initFreeFrames = sys_calculate_free_frames() ;
f011df2a:	e8 05 0f ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011df2f:	a3 c8 87 76 f0       	mov    %eax,0xf07687c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011df34:	e8 7f 6b fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011df39:	a3 c4 87 76 f0       	mov    %eax,0xf07687c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011df3e:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011df44:	bb 59 27 13 f0       	mov    $0xf0132759,%ebx
f011df49:	ba 11 00 00 00       	mov    $0x11,%edx
f011df4e:	89 c7                	mov    %eax,%edi
f011df50:	89 de                	mov    %ebx,%esi
f011df52:	89 d1                	mov    %edx,%ecx
f011df54:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011df56:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011df5c:	b9 53 00 00 00       	mov    $0x53,%ecx
f011df61:	b0 00                	mov    $0x0,%al
f011df63:	89 d7                	mov    %edx,%edi
f011df65:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011df67:	83 ec 0c             	sub    $0xc,%esp
f011df6a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011df70:	50                   	push   %eax
f011df71:	e8 85 3f fe ff       	call   f0101efb <execute_command>
f011df76:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011df79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011df80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011df87:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f011df8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011df8f:	eb 2b                	jmp    f011dfbc <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011df91:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011df94:	83 c0 20             	add    $0x20,%eax
f011df97:	83 ec 08             	sub    $0x8,%esp
f011df9a:	68 04 26 13 f0       	push   $0xf0132604
f011df9f:	50                   	push   %eax
f011dfa0:	e8 a2 40 00 00       	call   f0122047 <strcmp>
f011dfa5:	83 c4 10             	add    $0x10,%esp
f011dfa8:	85 c0                	test   %eax,%eax
f011dfaa:	75 08                	jne    f011dfb4 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011dfac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dfaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011dfb2:	eb 2f                	jmp    f011dfe3 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011dfb4:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f011dfb9:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011dfbc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dfc0:	74 08                	je     f011dfca <test_three_creation_functions+0xbc>
f011dfc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dfc5:	8b 40 08             	mov    0x8(%eax),%eax
f011dfc8:	eb 05                	jmp    f011dfcf <test_three_creation_functions+0xc1>
f011dfca:	b8 00 00 00 00       	mov    $0x0,%eax
f011dfcf:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f011dfd4:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f011dfd9:	85 c0                	test   %eax,%eax
f011dfdb:	75 b4                	jne    f011df91 <test_three_creation_functions+0x83>
f011dfdd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dfe1:	75 ae                	jne    f011df91 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011dfe3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011dfe6:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f011dfec:	85 c0                	test   %eax,%eax
f011dfee:	74 17                	je     f011e007 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011dff0:	83 ec 04             	sub    $0x4,%esp
f011dff3:	68 0c 26 13 f0       	push   $0xf013260c
f011dff8:	68 f6 08 00 00       	push   $0x8f6
f011dffd:	68 33 f0 12 f0       	push   $0xf012f033
f011e002:	e8 32 23 fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011e007:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e00a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f011e010:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011e013:	e8 1c 0e ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e018:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011e01b:	e8 98 6a fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011e020:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011e023:	a1 c4 87 76 f0       	mov    0xf07687c4,%eax
f011e028:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011e02b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011e02e:	74 17                	je     f011e047 <test_three_creation_functions+0x139>
f011e030:	83 ec 04             	sub    $0x4,%esp
f011e033:	68 4c f0 12 f0       	push   $0xf012f04c
f011e038:	68 00 09 00 00       	push   $0x900
f011e03d:	68 33 f0 12 f0       	push   $0xf012f033
f011e042:	e8 f2 22 fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011e047:	a1 c8 87 76 f0       	mov    0xf07687c8,%eax
f011e04c:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011e04f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e052:	83 c2 15             	add    $0x15,%edx
f011e055:	39 d0                	cmp    %edx,%eax
f011e057:	74 17                	je     f011e070 <test_three_creation_functions+0x162>
f011e059:	83 ec 04             	sub    $0x4,%esp
f011e05c:	68 5c 26 13 f0       	push   $0xf013265c
f011e061:	68 02 09 00 00       	push   $0x902
f011e066:	68 33 f0 12 f0       	push   $0xf012f033
f011e06b:	e8 c9 22 fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011e070:	83 ec 0c             	sub    $0xc,%esp
f011e073:	68 00 10 00 00       	push   $0x1000
f011e078:	e8 ed bb fe ff       	call   f0109c6a <kmalloc>
f011e07d:	83 c4 10             	add    $0x10,%esp
f011e080:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011e083:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e086:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011e08b:	74 17                	je     f011e0a4 <test_three_creation_functions+0x196>
f011e08d:	83 ec 04             	sub    $0x4,%esp
f011e090:	68 9c 26 13 f0       	push   $0xf013269c
f011e095:	68 06 09 00 00       	push   $0x906
f011e09a:	68 33 f0 12 f0       	push   $0xf012f033
f011e09f:	e8 95 22 fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011e0a4:	83 ec 0c             	sub    $0xc,%esp
f011e0a7:	68 0c 27 13 f0       	push   $0xf013270c
f011e0ac:	e8 da 2e fe ff       	call   f0100f8b <cprintf>
f011e0b1:	83 c4 10             	add    $0x10,%esp

	return 1;
f011e0b4:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011e0b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e0bc:	5b                   	pop    %ebx
f011e0bd:	5e                   	pop    %esi
f011e0be:	5f                   	pop    %edi
f011e0bf:	5d                   	pop    %ebp
f011e0c0:	c3                   	ret    

f011e0c1 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011e0c1:	55                   	push   %ebp
f011e0c2:	89 e5                	mov    %esp,%ebp
f011e0c4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e0c7:	83 ec 04             	sub    $0x4,%esp
f011e0ca:	68 f4 25 13 f0       	push   $0xf01325f4
f011e0cf:	68 14 09 00 00       	push   $0x914
f011e0d4:	68 33 f0 12 f0       	push   $0xf012f033
f011e0d9:	e8 5b 22 fe ff       	call   f0100339 <_panic>

f011e0de <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011e0de:	55                   	push   %ebp
f011e0df:	89 e5                	mov    %esp,%ebp
f011e0e1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e0e4:	83 ec 04             	sub    $0x4,%esp
f011e0e7:	68 f4 25 13 f0       	push   $0xf01325f4
f011e0ec:	68 1c 09 00 00       	push   $0x91c
f011e0f1:	68 33 f0 12 f0       	push   $0xf012f033
f011e0f6:	e8 3e 22 fe ff       	call   f0100339 <_panic>

f011e0fb <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011e0fb:	55                   	push   %ebp
f011e0fc:	89 e5                	mov    %esp,%ebp
f011e0fe:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e101:	83 ec 04             	sub    $0x4,%esp
f011e104:	68 f4 25 13 f0       	push   $0xf01325f4
f011e109:	68 23 09 00 00       	push   $0x923
f011e10e:	68 33 f0 12 f0       	push   $0xf012f033
f011e113:	e8 21 22 fe ff       	call   f0100339 <_panic>

f011e118 <test_kfreelast>:

}


int test_kfreelast()
{
f011e118:	55                   	push   %ebp
f011e119:	89 e5                	mov    %esp,%ebp
f011e11b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e11e:	83 ec 04             	sub    $0x4,%esp
f011e121:	68 f4 25 13 f0       	push   $0xf01325f4
f011e126:	68 2a 09 00 00       	push   $0x92a
f011e12b:	68 33 f0 12 f0       	push   $0xf012f033
f011e130:	e8 04 22 fe ff       	call   f0100339 <_panic>

f011e135 <test_krealloc>:

}

int test_krealloc() {
f011e135:	55                   	push   %ebp
f011e136:	89 e5                	mov    %esp,%ebp
f011e138:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e13b:	83 ec 04             	sub    $0x4,%esp
f011e13e:	68 f4 25 13 f0       	push   $0xf01325f4
f011e143:	68 2f 09 00 00       	push   $0x92f
f011e148:	68 33 f0 12 f0       	push   $0xf012f033
f011e14d:	e8 e7 21 fe ff       	call   f0100339 <_panic>

f011e152 <test_krealloc_BF>:

}


int test_krealloc_BF() {
f011e152:	55                   	push   %ebp
f011e153:	89 e5                	mov    %esp,%ebp
f011e155:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011e158:	83 ec 04             	sub    $0x4,%esp
f011e15b:	68 f4 25 13 f0       	push   $0xf01325f4
f011e160:	68 35 09 00 00       	push   $0x935
f011e165:	68 33 f0 12 f0       	push   $0xf012f033
f011e16a:	e8 ca 21 fe ff       	call   f0100339 <_panic>

f011e16f <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011e16f:	55                   	push   %ebp
f011e170:	89 e5                	mov    %esp,%ebp
f011e172:	57                   	push   %edi
f011e173:	53                   	push   %ebx
f011e174:	81 ec 60 01 00 00    	sub    $0x160,%esp
		cprintf("==============================================\n");
f011e17a:	83 ec 0c             	sub    $0xc,%esp
f011e17d:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011e182:	e8 04 2e fe ff       	call   f0100f8b <cprintf>
f011e187:	83 c4 10             	add    $0x10,%esp
		cprintf(
f011e18a:	83 ec 0c             	sub    $0xc,%esp
f011e18d:	68 18 d1 12 f0       	push   $0xf012d118
f011e192:	e8 f4 2d fe ff       	call   f0100f8b <cprintf>
f011e197:	83 c4 10             	add    $0x10,%esp
				"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
		cprintf("==============================================\n");
f011e19a:	83 ec 0c             	sub    $0xc,%esp
f011e19d:	68 e8 d0 12 f0       	push   $0xf012d0e8
f011e1a2:	e8 e4 2d fe ff       	call   f0100f8b <cprintf>
f011e1a7:	83 c4 10             	add    $0x10,%esp
		char minByte = 1 << 7;
f011e1aa:	c6 45 cf 80          	movb   $0x80,-0x31(%ebp)
		char maxByte = 0x7F;
f011e1ae:	c6 45 ce 7f          	movb   $0x7f,-0x32(%ebp)
		short minShort = 1 << 15;
f011e1b2:	66 c7 45 cc 00 80    	movw   $0x8000,-0x34(%ebp)
		short maxShort = 0x7FFF;
f011e1b8:	66 c7 45 ca ff 7f    	movw   $0x7fff,-0x36(%ebp)
		int minInt = 1 << 31;
f011e1be:	c7 45 c4 00 00 00 80 	movl   $0x80000000,-0x3c(%ebp)
		int maxInt = 0x7FFFFFFF;
f011e1c5:	c7 45 c0 ff ff ff 7f 	movl   $0x7fffffff,-0x40(%ebp)
		int *intArr;
		struct MyStruct *structArr;
		int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2,
		lastIndexOfInt, lastIndexOfStruct;
		//[1] Test calling krealloc with VA = NULL. It should call malloc
		void* ptr_allocations[20] = { 0 };
f011e1cc:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f011e1d2:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e1d7:	b8 00 00 00 00       	mov    $0x0,%eax
f011e1dc:	89 d7                	mov    %edx,%edi
f011e1de:	f3 ab                	rep stos %eax,%es:(%edi)
		char* ptr;
		void* newAddress = NULL;
f011e1e0:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
		int freeDiskFrames;


		int lastIndices[20] = { 0 };
f011e1e7:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f011e1ed:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e1f2:	b8 00 00 00 00       	mov    $0x0,%eax
f011e1f7:	89 d7                	mov    %edx,%edi
f011e1f9:	f3 ab                	rep stos %eax,%es:(%edi)
		int sums[20] = { 0 };
f011e1fb:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
f011e201:	b9 14 00 00 00       	mov    $0x14,%ecx
f011e206:	b8 00 00 00 00       	mov    $0x0,%eax
f011e20b:	89 d7                	mov    %edx,%edi
f011e20d:	f3 ab                	rep stos %eax,%es:(%edi)
		int freeFrames;
		//[1] Allocate all
		{
			//Allocate 1 MB
			freeFrames = sys_calculate_free_frames();
f011e20f:	e8 20 0c ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e214:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[0] = krealloc(NULL, 1 * Mega - kilo);
f011e217:	83 ec 08             	sub    $0x8,%esp
f011e21a:	68 00 fc 0f 00       	push   $0xffc00
f011e21f:	6a 00                	push   $0x0
f011e221:	e8 ef be fe ff       	call   f010a115 <krealloc>
f011e226:	83 c4 10             	add    $0x10,%esp
f011e229:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			if ((uint32) ptr_allocations[0] < (KERNEL_HEAP_START))
f011e22f:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011e235:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011e23a:	77 17                	ja     f011e253 <test_krealloc_FF1+0xe4>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e23c:	83 ec 04             	sub    $0x4,%esp
f011e23f:	68 c0 27 13 f0       	push   $0xf01327c0
f011e244:	68 5b 09 00 00       	push   $0x95b
f011e249:	68 33 f0 12 f0       	push   $0xf012f033
f011e24e:	e8 e6 20 fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[0] != ACTUAL_START)
f011e253:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011e259:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011e25e:	74 17                	je     f011e277 <test_krealloc_FF1+0x108>
				panic("krealloc: Wrong start address for allocated space");
f011e260:	83 ec 04             	sub    $0x4,%esp
f011e263:	68 fc 27 13 f0       	push   $0xf01327fc
f011e268:	68 5d 09 00 00       	push   $0x95d
f011e26d:	68 33 f0 12 f0       	push   $0xf012f033
f011e272:	e8 c2 20 fe ff       	call   f0100339 <_panic>

			if ((freeFrames - sys_calculate_free_frames()) != 256)
f011e277:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e27a:	e8 b5 0b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e27f:	29 c3                	sub    %eax,%ebx
f011e281:	89 d8                	mov    %ebx,%eax
f011e283:	3d 00 01 00 00       	cmp    $0x100,%eax
f011e288:	74 17                	je     f011e2a1 <test_krealloc_FF1+0x132>
				panic("krealloc: Wrong allocation: ");
f011e28a:	83 ec 04             	sub    $0x4,%esp
f011e28d:	68 2e 28 13 f0       	push   $0xf013282e
f011e292:	68 60 09 00 00       	push   $0x960
f011e297:	68 33 f0 12 f0       	push   $0xf012f033
f011e29c:	e8 98 20 fe ff       	call   f0100339 <_panic>

			lastIndices[0] = (1 * Mega - kilo) / sizeof(char) - 1;
f011e2a1:	c7 85 f8 fe ff ff ff 	movl   $0xffbff,-0x108(%ebp)
f011e2a8:	fb 0f 00 

			//Allocate 1 MB
			freeFrames = sys_calculate_free_frames();
f011e2ab:	e8 84 0b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e2b0:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[1] = krealloc(NULL, 1 * Mega - kilo);
f011e2b3:	83 ec 08             	sub    $0x8,%esp
f011e2b6:	68 00 fc 0f 00       	push   $0xffc00
f011e2bb:	6a 00                	push   $0x0
f011e2bd:	e8 53 be fe ff       	call   f010a115 <krealloc>
f011e2c2:	83 c4 10             	add    $0x10,%esp
f011e2c5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
			if ((uint32) ptr_allocations[1] < (KERNEL_HEAP_START + 1 * Mega))
f011e2cb:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e2d1:	3d ff ff 0f f6       	cmp    $0xf60fffff,%eax
f011e2d6:	77 17                	ja     f011e2ef <test_krealloc_FF1+0x180>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e2d8:	83 ec 04             	sub    $0x4,%esp
f011e2db:	68 c0 27 13 f0       	push   $0xf01327c0
f011e2e0:	68 68 09 00 00       	push   $0x968
f011e2e5:	68 33 f0 12 f0       	push   $0xf012f033
f011e2ea:	e8 4a 20 fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[1] != ACTUAL_START + (1 * Mega))
f011e2ef:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e2f5:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011e2fa:	74 17                	je     f011e313 <test_krealloc_FF1+0x1a4>
				panic("krealloc: Wrong start address for allocated space");
f011e2fc:	83 ec 04             	sub    $0x4,%esp
f011e2ff:	68 fc 27 13 f0       	push   $0xf01327fc
f011e304:	68 6a 09 00 00       	push   $0x96a
f011e309:	68 33 f0 12 f0       	push   $0xf012f033
f011e30e:	e8 26 20 fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 256)
f011e313:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e316:	e8 19 0b ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e31b:	29 c3                	sub    %eax,%ebx
f011e31d:	89 d8                	mov    %ebx,%eax
f011e31f:	3d 00 01 00 00       	cmp    $0x100,%eax
f011e324:	74 17                	je     f011e33d <test_krealloc_FF1+0x1ce>
				panic("krealloc: Wrong allocation: ");
f011e326:	83 ec 04             	sub    $0x4,%esp
f011e329:	68 2e 28 13 f0       	push   $0xf013282e
f011e32e:	68 6c 09 00 00       	push   $0x96c
f011e333:	68 33 f0 12 f0       	push   $0xf012f033
f011e338:	e8 fc 1f fe ff       	call   f0100339 <_panic>

			lastIndices[1] = (1 * Mega - kilo) / sizeof(char) - 1;
f011e33d:	c7 85 fc fe ff ff ff 	movl   $0xffbff,-0x104(%ebp)
f011e344:	fb 0f 00 

			//Allocate 1 MB
			freeFrames = sys_calculate_free_frames();
f011e347:	e8 e8 0a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e34c:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[2] = krealloc(NULL, 1 * Mega - kilo);
f011e34f:	83 ec 08             	sub    $0x8,%esp
f011e352:	68 00 fc 0f 00       	push   $0xffc00
f011e357:	6a 00                	push   $0x0
f011e359:	e8 b7 bd fe ff       	call   f010a115 <krealloc>
f011e35e:	83 c4 10             	add    $0x10,%esp
f011e361:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
			if ((uint32) ptr_allocations[2] < (KERNEL_HEAP_START + 2 * Mega))
f011e367:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011e36d:	3d ff ff 1f f6       	cmp    $0xf61fffff,%eax
f011e372:	77 17                	ja     f011e38b <test_krealloc_FF1+0x21c>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e374:	83 ec 04             	sub    $0x4,%esp
f011e377:	68 c0 27 13 f0       	push   $0xf01327c0
f011e37c:	68 74 09 00 00       	push   $0x974
f011e381:	68 33 f0 12 f0       	push   $0xf012f033
f011e386:	e8 ae 1f fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[2] != ACTUAL_START + (2 * Mega))
f011e38b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011e391:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011e396:	74 17                	je     f011e3af <test_krealloc_FF1+0x240>
				panic("krealloc: Wrong start address for allocated space");
f011e398:	83 ec 04             	sub    $0x4,%esp
f011e39b:	68 fc 27 13 f0       	push   $0xf01327fc
f011e3a0:	68 76 09 00 00       	push   $0x976
f011e3a5:	68 33 f0 12 f0       	push   $0xf012f033
f011e3aa:	e8 8a 1f fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 256)
f011e3af:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e3b2:	e8 7d 0a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e3b7:	29 c3                	sub    %eax,%ebx
f011e3b9:	89 d8                	mov    %ebx,%eax
f011e3bb:	3d 00 01 00 00       	cmp    $0x100,%eax
f011e3c0:	74 17                	je     f011e3d9 <test_krealloc_FF1+0x26a>
				panic("krealloc: Wrong allocation: ");
f011e3c2:	83 ec 04             	sub    $0x4,%esp
f011e3c5:	68 2e 28 13 f0       	push   $0xf013282e
f011e3ca:	68 78 09 00 00       	push   $0x978
f011e3cf:	68 33 f0 12 f0       	push   $0xf012f033
f011e3d4:	e8 60 1f fe ff       	call   f0100339 <_panic>
			lastIndices[2] = (1 * Mega - kilo) / sizeof(int) - 1;
f011e3d9:	c7 85 00 ff ff ff ff 	movl   $0x3feff,-0x100(%ebp)
f011e3e0:	fe 03 00 

			//Allocate 1 MB
			freeFrames = sys_calculate_free_frames();
f011e3e3:	e8 4c 0a ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e3e8:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[3] = krealloc(NULL, 1 * Mega - kilo);
f011e3eb:	83 ec 08             	sub    $0x8,%esp
f011e3ee:	68 00 fc 0f 00       	push   $0xffc00
f011e3f3:	6a 00                	push   $0x0
f011e3f5:	e8 1b bd fe ff       	call   f010a115 <krealloc>
f011e3fa:	83 c4 10             	add    $0x10,%esp
f011e3fd:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
			if ((uint32) ptr_allocations[3] < (KERNEL_HEAP_START + 3 * Mega))
f011e403:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e409:	3d ff ff 2f f6       	cmp    $0xf62fffff,%eax
f011e40e:	77 17                	ja     f011e427 <test_krealloc_FF1+0x2b8>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e410:	83 ec 04             	sub    $0x4,%esp
f011e413:	68 c0 27 13 f0       	push   $0xf01327c0
f011e418:	68 7f 09 00 00       	push   $0x97f
f011e41d:	68 33 f0 12 f0       	push   $0xf012f033
f011e422:	e8 12 1f fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[3] != ACTUAL_START + (3 * Mega))
f011e427:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e42d:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011e432:	74 17                	je     f011e44b <test_krealloc_FF1+0x2dc>
				panic("krealloc: Wrong start address for allocated space");
f011e434:	83 ec 04             	sub    $0x4,%esp
f011e437:	68 fc 27 13 f0       	push   $0xf01327fc
f011e43c:	68 81 09 00 00       	push   $0x981
f011e441:	68 33 f0 12 f0       	push   $0xf012f033
f011e446:	e8 ee 1e fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 256)
f011e44b:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e44e:	e8 e1 09 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e453:	29 c3                	sub    %eax,%ebx
f011e455:	89 d8                	mov    %ebx,%eax
f011e457:	3d 00 01 00 00       	cmp    $0x100,%eax
f011e45c:	74 17                	je     f011e475 <test_krealloc_FF1+0x306>
				panic("krealloc: Wrong allocation: ");
f011e45e:	83 ec 04             	sub    $0x4,%esp
f011e461:	68 2e 28 13 f0       	push   $0xf013282e
f011e466:	68 83 09 00 00       	push   $0x983
f011e46b:	68 33 f0 12 f0       	push   $0xf012f033
f011e470:	e8 c4 1e fe ff       	call   f0100339 <_panic>
			lastIndices[3] = (1 * Mega - kilo) / sizeof(int) - 1;
f011e475:	c7 85 04 ff ff ff ff 	movl   $0x3feff,-0xfc(%ebp)
f011e47c:	fe 03 00 

			//Allocate 2 MB
			freeFrames = sys_calculate_free_frames();
f011e47f:	e8 b0 09 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e484:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[4] = krealloc(NULL, 2 * Mega - kilo);
f011e487:	83 ec 08             	sub    $0x8,%esp
f011e48a:	68 00 fc 1f 00       	push   $0x1ffc00
f011e48f:	6a 00                	push   $0x0
f011e491:	e8 7f bc fe ff       	call   f010a115 <krealloc>
f011e496:	83 c4 10             	add    $0x10,%esp
f011e499:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
			if ((uint32) ptr_allocations[4] < (KERNEL_HEAP_START + 4 * Mega))
f011e49f:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011e4a5:	3d ff ff 3f f6       	cmp    $0xf63fffff,%eax
f011e4aa:	77 17                	ja     f011e4c3 <test_krealloc_FF1+0x354>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e4ac:	83 ec 04             	sub    $0x4,%esp
f011e4af:	68 c0 27 13 f0       	push   $0xf01327c0
f011e4b4:	68 8a 09 00 00       	push   $0x98a
f011e4b9:	68 33 f0 12 f0       	push   $0xf012f033
f011e4be:	e8 76 1e fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[4] != ACTUAL_START + (4 * Mega))
f011e4c3:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011e4c9:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011e4ce:	74 17                	je     f011e4e7 <test_krealloc_FF1+0x378>
				panic("krealloc: Wrong start address for allocated space");
f011e4d0:	83 ec 04             	sub    $0x4,%esp
f011e4d3:	68 fc 27 13 f0       	push   $0xf01327fc
f011e4d8:	68 8c 09 00 00       	push   $0x98c
f011e4dd:	68 33 f0 12 f0       	push   $0xf012f033
f011e4e2:	e8 52 1e fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 512)
f011e4e7:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e4ea:	e8 45 09 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e4ef:	29 c3                	sub    %eax,%ebx
f011e4f1:	89 d8                	mov    %ebx,%eax
f011e4f3:	3d 00 02 00 00       	cmp    $0x200,%eax
f011e4f8:	74 17                	je     f011e511 <test_krealloc_FF1+0x3a2>
				panic("krealloc: Wrong allocation: ");
f011e4fa:	83 ec 04             	sub    $0x4,%esp
f011e4fd:	68 2e 28 13 f0       	push   $0xf013282e
f011e502:	68 8e 09 00 00       	push   $0x98e
f011e507:	68 33 f0 12 f0       	push   $0xf012f033
f011e50c:	e8 28 1e fe ff       	call   f0100339 <_panic>
			lastIndices[4] = (2 * Mega - kilo) / sizeof(short) - 1;
f011e511:	c7 85 08 ff ff ff ff 	movl   $0xffdff,-0xf8(%ebp)
f011e518:	fd 0f 00 

			//Allocate 2 MB
			freeFrames = sys_calculate_free_frames();
f011e51b:	e8 14 09 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e520:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[5] = krealloc(NULL, 2 * Mega - kilo);
f011e523:	83 ec 08             	sub    $0x8,%esp
f011e526:	68 00 fc 1f 00       	push   $0x1ffc00
f011e52b:	6a 00                	push   $0x0
f011e52d:	e8 e3 bb fe ff       	call   f010a115 <krealloc>
f011e532:	83 c4 10             	add    $0x10,%esp
f011e535:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if ((uint32) ptr_allocations[5] < (KERNEL_HEAP_START + 6 * Mega))
f011e53b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011e541:	3d ff ff 5f f6       	cmp    $0xf65fffff,%eax
f011e546:	77 17                	ja     f011e55f <test_krealloc_FF1+0x3f0>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e548:	83 ec 04             	sub    $0x4,%esp
f011e54b:	68 c0 27 13 f0       	push   $0xf01327c0
f011e550:	68 95 09 00 00       	push   $0x995
f011e555:	68 33 f0 12 f0       	push   $0xf012f033
f011e55a:	e8 da 1d fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[5] != ACTUAL_START + (6 * Mega))
f011e55f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011e565:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f011e56a:	74 17                	je     f011e583 <test_krealloc_FF1+0x414>
				panic("krealloc: Wrong start address for allocated space");
f011e56c:	83 ec 04             	sub    $0x4,%esp
f011e56f:	68 fc 27 13 f0       	push   $0xf01327fc
f011e574:	68 97 09 00 00       	push   $0x997
f011e579:	68 33 f0 12 f0       	push   $0xf012f033
f011e57e:	e8 b6 1d fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 512)
f011e583:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e586:	e8 a9 08 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e58b:	29 c3                	sub    %eax,%ebx
f011e58d:	89 d8                	mov    %ebx,%eax
f011e58f:	3d 00 02 00 00       	cmp    $0x200,%eax
f011e594:	74 17                	je     f011e5ad <test_krealloc_FF1+0x43e>
				panic("krealloc: Wrong allocation: ");
f011e596:	83 ec 04             	sub    $0x4,%esp
f011e599:	68 2e 28 13 f0       	push   $0xf013282e
f011e59e:	68 99 09 00 00       	push   $0x999
f011e5a3:	68 33 f0 12 f0       	push   $0xf012f033
f011e5a8:	e8 8c 1d fe ff       	call   f0100339 <_panic>
			lastIndices[5] = (2 * Mega - kilo) / sizeof(short) - 1;
f011e5ad:	c7 85 0c ff ff ff ff 	movl   $0xffdff,-0xf4(%ebp)
f011e5b4:	fd 0f 00 

			//Allocate 3 MB
			freeFrames = sys_calculate_free_frames();
f011e5b7:	e8 78 08 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e5bc:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[6] = krealloc(NULL, 3 * Mega - kilo);
f011e5bf:	83 ec 08             	sub    $0x8,%esp
f011e5c2:	68 00 fc 2f 00       	push   $0x2ffc00
f011e5c7:	6a 00                	push   $0x0
f011e5c9:	e8 47 bb fe ff       	call   f010a115 <krealloc>
f011e5ce:	83 c4 10             	add    $0x10,%esp
f011e5d1:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if ((uint32) ptr_allocations[6] < (KERNEL_HEAP_START + 8 * Mega))
f011e5d7:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011e5dd:	3d ff ff 7f f6       	cmp    $0xf67fffff,%eax
f011e5e2:	77 17                	ja     f011e5fb <test_krealloc_FF1+0x48c>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e5e4:	83 ec 04             	sub    $0x4,%esp
f011e5e7:	68 c0 27 13 f0       	push   $0xf01327c0
f011e5ec:	68 a0 09 00 00       	push   $0x9a0
f011e5f1:	68 33 f0 12 f0       	push   $0xf012f033
f011e5f6:	e8 3e 1d fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[6] != ACTUAL_START + (8 * Mega))
f011e5fb:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011e601:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f011e606:	74 17                	je     f011e61f <test_krealloc_FF1+0x4b0>
				panic("krealloc: Wrong start address for allocated space");
f011e608:	83 ec 04             	sub    $0x4,%esp
f011e60b:	68 fc 27 13 f0       	push   $0xf01327fc
f011e610:	68 a2 09 00 00       	push   $0x9a2
f011e615:	68 33 f0 12 f0       	push   $0xf012f033
f011e61a:	e8 1a 1d fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 768)
f011e61f:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e622:	e8 0d 08 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e627:	29 c3                	sub    %eax,%ebx
f011e629:	89 d8                	mov    %ebx,%eax
f011e62b:	3d 00 03 00 00       	cmp    $0x300,%eax
f011e630:	74 17                	je     f011e649 <test_krealloc_FF1+0x4da>
				panic("Wrong allocation: ");
f011e632:	83 ec 04             	sub    $0x4,%esp
f011e635:	68 4b 28 13 f0       	push   $0xf013284b
f011e63a:	68 a4 09 00 00       	push   $0x9a4
f011e63f:	68 33 f0 12 f0       	push   $0xf012f033
f011e644:	e8 f0 1c fe ff       	call   f0100339 <_panic>
			lastIndices[6] = (3 * Mega - kilo) / sizeof(struct MyStruct) - 1;
f011e649:	c7 85 10 ff ff ff 7f 	movl   $0x5ff7f,-0xf0(%ebp)
f011e650:	ff 05 00 

			//Allocate 3 MB
			freeFrames = sys_calculate_free_frames();
f011e653:	e8 dc 07 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e658:	89 45 b8             	mov    %eax,-0x48(%ebp)
			ptr_allocations[7] = krealloc(NULL, 3 * Mega - kilo);
f011e65b:	83 ec 08             	sub    $0x8,%esp
f011e65e:	68 00 fc 2f 00       	push   $0x2ffc00
f011e663:	6a 00                	push   $0x0
f011e665:	e8 ab ba fe ff       	call   f010a115 <krealloc>
f011e66a:	83 c4 10             	add    $0x10,%esp
f011e66d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			if ((uint32) ptr_allocations[7] < (KERNEL_HEAP_START + 11 * Mega))
f011e673:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011e679:	3d ff ff af f6       	cmp    $0xf6afffff,%eax
f011e67e:	77 17                	ja     f011e697 <test_krealloc_FF1+0x528>
				panic("krealloc: Wrong start address for the allocated space... ");
f011e680:	83 ec 04             	sub    $0x4,%esp
f011e683:	68 c0 27 13 f0       	push   $0xf01327c0
f011e688:	68 ab 09 00 00       	push   $0x9ab
f011e68d:	68 33 f0 12 f0       	push   $0xf012f033
f011e692:	e8 a2 1c fe ff       	call   f0100339 <_panic>
			if ((uint32) ptr_allocations[7] != ACTUAL_START + (11 * Mega))
f011e697:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011e69d:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f011e6a2:	74 17                	je     f011e6bb <test_krealloc_FF1+0x54c>
				panic("krealloc: Wrong start address for allocated space");
f011e6a4:	83 ec 04             	sub    $0x4,%esp
f011e6a7:	68 fc 27 13 f0       	push   $0xf01327fc
f011e6ac:	68 ad 09 00 00       	push   $0x9ad
f011e6b1:	68 33 f0 12 f0       	push   $0xf012f033
f011e6b6:	e8 7e 1c fe ff       	call   f0100339 <_panic>
			if ((freeFrames - sys_calculate_free_frames()) != 768)
f011e6bb:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011e6be:	e8 71 07 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e6c3:	29 c3                	sub    %eax,%ebx
f011e6c5:	89 d8                	mov    %ebx,%eax
f011e6c7:	3d 00 03 00 00       	cmp    $0x300,%eax
f011e6cc:	74 17                	je     f011e6e5 <test_krealloc_FF1+0x576>
				panic("krealloc: Wrong allocation: ");
f011e6ce:	83 ec 04             	sub    $0x4,%esp
f011e6d1:	68 2e 28 13 f0       	push   $0xf013282e
f011e6d6:	68 af 09 00 00       	push   $0x9af
f011e6db:	68 33 f0 12 f0       	push   $0xf012f033
f011e6e0:	e8 54 1c fe ff       	call   f0100339 <_panic>
			lastIndices[7] = (3 * Mega - kilo) / sizeof(struct MyStruct) - 1;
f011e6e5:	c7 85 14 ff ff ff 7f 	movl   $0x5ff7f,-0xec(%ebp)
f011e6ec:	ff 05 00 
		char *byteArr1;
		//[3] Test read write access
		{
			//cprintf("\nTest read write access");
			//Test access for the first 1 MB
			freeFrames = sys_calculate_free_frames();
f011e6ef:	e8 40 07 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011e6f4:	89 45 b8             	mov    %eax,-0x48(%ebp)

			//Write values
			//In 1st 1 MB
			lastIndexOfByte = (1 * Mega - kilo) / sizeof(char) - 1;
f011e6f7:	c7 45 b4 ff fb 0f 00 	movl   $0xffbff,-0x4c(%ebp)
			byteArr = (char *) ptr_allocations[0];
f011e6fe:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011e704:	89 45 b0             	mov    %eax,-0x50(%ebp)
			byteArr[0] = minByte;
f011e707:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011e70a:	8a 55 cf             	mov    -0x31(%ebp),%dl
f011e70d:	88 10                	mov    %dl,(%eax)
			byteArr[lastIndexOfByte] = maxByte;
f011e70f:	8b 55 b4             	mov    -0x4c(%ebp),%edx
f011e712:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011e715:	01 c2                	add    %eax,%edx
f011e717:	8a 45 ce             	mov    -0x32(%ebp),%al
f011e71a:	88 02                	mov    %al,(%edx)

			//In 2nd 1 MB
			ptr = (char*) ptr_allocations[1];
f011e71c:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e722:	89 45 ac             	mov    %eax,-0x54(%ebp)
			for (int i = 0; i <= lastIndices[1]; ++i) {
f011e725:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e72c:	eb 0e                	jmp    f011e73c <test_krealloc_FF1+0x5cd>
				ptr[i] = 2;
f011e72e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e731:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011e734:	01 d0                	add    %edx,%eax
f011e736:	c6 00 02             	movb   $0x2,(%eax)
			byteArr[0] = minByte;
			byteArr[lastIndexOfByte] = maxByte;

			//In 2nd 1 MB
			ptr = (char*) ptr_allocations[1];
			for (int i = 0; i <= lastIndices[1]; ++i) {
f011e739:	ff 45 f4             	incl   -0xc(%ebp)
f011e73c:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011e742:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e745:	7d e7                	jge    f011e72e <test_krealloc_FF1+0x5bf>
				ptr[i] = 2;
			}

			//In 3rd 1 MB
			intArr = (int*) ptr_allocations[2];
f011e747:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011e74d:	89 45 a8             	mov    %eax,-0x58(%ebp)
			intArr[0] = 3;
f011e750:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e753:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
			intArr[lastIndices[2]] = 3;
f011e759:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011e75f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e766:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e769:	01 d0                	add    %edx,%eax
f011e76b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

			//In 4th 1 MB
			intArr = (int*) ptr_allocations[3];
f011e771:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e777:	89 45 a8             	mov    %eax,-0x58(%ebp)
			for (int i = 0; i <= lastIndices[3]; ++i) {
f011e77a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e781:	eb 18                	jmp    f011e79b <test_krealloc_FF1+0x62c>
				intArr[i] = 4;
f011e783:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e786:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e78d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e790:	01 d0                	add    %edx,%eax
f011e792:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
			intArr[0] = 3;
			intArr[lastIndices[2]] = 3;

			//In 4th 1 MB
			intArr = (int*) ptr_allocations[3];
			for (int i = 0; i <= lastIndices[3]; ++i) {
f011e798:	ff 45 f0             	incl   -0x10(%ebp)
f011e79b:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011e7a1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011e7a4:	7d dd                	jge    f011e783 <test_krealloc_FF1+0x614>
				intArr[i] = 4;
			}

			//In 1st 2 MB
			shortArr = (short*) ptr_allocations[4];
f011e7a6:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011e7ac:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			for (int i = 0; i <= lastIndices[4]; ++i) {
f011e7af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e7b6:	eb 14                	jmp    f011e7cc <test_krealloc_FF1+0x65d>
				shortArr[i] = 5;
f011e7b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e7bb:	01 c0                	add    %eax,%eax
f011e7bd:	89 c2                	mov    %eax,%edx
f011e7bf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011e7c2:	01 d0                	add    %edx,%eax
f011e7c4:	66 c7 00 05 00       	movw   $0x5,(%eax)
				intArr[i] = 4;
			}

			//In 1st 2 MB
			shortArr = (short*) ptr_allocations[4];
			for (int i = 0; i <= lastIndices[4]; ++i) {
f011e7c9:	ff 45 ec             	incl   -0x14(%ebp)
f011e7cc:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011e7d2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e7d5:	7d e1                	jge    f011e7b8 <test_krealloc_FF1+0x649>
				shortArr[i] = 5;
			}

			//In the 2nd 2 MB
			shortArr = (short*) ptr_allocations[5];
f011e7d7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011e7dd:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			shortArr[0] = 6;
f011e7e0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011e7e3:	66 c7 00 06 00       	movw   $0x6,(%eax)
			shortArr[lastIndices[5]] = 6;
f011e7e8:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011e7ee:	01 c0                	add    %eax,%eax
f011e7f0:	89 c2                	mov    %eax,%edx
f011e7f2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011e7f5:	01 d0                	add    %edx,%eax
f011e7f7:	66 c7 00 06 00       	movw   $0x6,(%eax)

			//In the 1st 3 MB
			structArr = (struct MyStruct *) ptr_allocations[6];
f011e7fc:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011e802:	89 45 a0             	mov    %eax,-0x60(%ebp)
			for (int i = 0; i <= lastIndices[6]; i++) {
f011e805:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011e80c:	eb 40                	jmp    f011e84e <test_krealloc_FF1+0x6df>
				structArr[i].a = 7;
f011e80e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e811:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e818:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e81b:	01 d0                	add    %edx,%eax
f011e81d:	c6 00 07             	movb   $0x7,(%eax)
				structArr[i].b = 7;
f011e820:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e823:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e82a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e82d:	01 d0                	add    %edx,%eax
f011e82f:	66 c7 40 02 07 00    	movw   $0x7,0x2(%eax)
				structArr[i].c = 7;
f011e835:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e838:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e83f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e842:	01 d0                	add    %edx,%eax
f011e844:	c7 40 04 07 00 00 00 	movl   $0x7,0x4(%eax)
			shortArr[0] = 6;
			shortArr[lastIndices[5]] = 6;

			//In the 1st 3 MB
			structArr = (struct MyStruct *) ptr_allocations[6];
			for (int i = 0; i <= lastIndices[6]; i++) {
f011e84b:	ff 45 e8             	incl   -0x18(%ebp)
f011e84e:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011e854:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e857:	7d b5                	jge    f011e80e <test_krealloc_FF1+0x69f>
				structArr[i].b = 7;
				structArr[i].c = 7;
			}

			//In the last 3 MB
			structArr = (struct MyStruct*) ptr_allocations[7];
f011e859:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011e85f:	89 45 a0             	mov    %eax,-0x60(%ebp)
			structArr[0].a = 8;
f011e862:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e865:	c6 00 08             	movb   $0x8,(%eax)
			structArr[0].b = 8;
f011e868:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e86b:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
			structArr[0].c = 8;
f011e871:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e874:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
			structArr[lastIndices[7]].a = 8;
f011e87b:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011e881:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e888:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e88b:	01 d0                	add    %edx,%eax
f011e88d:	c6 00 08             	movb   $0x8,(%eax)
			structArr[lastIndices[7]].b = 8;
f011e890:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011e896:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e89d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e8a0:	01 d0                	add    %edx,%eax
f011e8a2:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
			structArr[lastIndices[7]].c = 8;
f011e8a8:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011e8ae:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011e8b5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011e8b8:	01 d0                	add    %edx,%eax
f011e8ba:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)

			//Read values: check that the values are successfully written
			if (byteArr[0] != minByte || byteArr[lastIndices[0]] != maxByte)
f011e8c1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011e8c4:	8a 00                	mov    (%eax),%al
f011e8c6:	3a 45 cf             	cmp    -0x31(%ebp),%al
f011e8c9:	75 14                	jne    f011e8df <test_krealloc_FF1+0x770>
f011e8cb:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011e8d1:	89 c2                	mov    %eax,%edx
f011e8d3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011e8d6:	01 d0                	add    %edx,%eax
f011e8d8:	8a 00                	mov    (%eax),%al
f011e8da:	3a 45 ce             	cmp    -0x32(%ebp),%al
f011e8dd:	74 17                	je     f011e8f6 <test_krealloc_FF1+0x787>
				panic(
f011e8df:	83 ec 04             	sub    $0x4,%esp
f011e8e2:	68 60 28 13 f0       	push   $0xf0132860
f011e8e7:	68 f2 09 00 00       	push   $0x9f2
f011e8ec:	68 33 f0 12 f0       	push   $0xf012f033
f011e8f1:	e8 43 1a fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			ptr = (char*) ptr_allocations[1];
f011e8f6:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011e8fc:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (ptr[0] != 2 || ptr[lastIndices[1]] != 2)
f011e8ff:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011e902:	8a 00                	mov    (%eax),%al
f011e904:	3c 02                	cmp    $0x2,%al
f011e906:	75 13                	jne    f011e91b <test_krealloc_FF1+0x7ac>
f011e908:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011e90e:	89 c2                	mov    %eax,%edx
f011e910:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011e913:	01 d0                	add    %edx,%eax
f011e915:	8a 00                	mov    (%eax),%al
f011e917:	3c 02                	cmp    $0x2,%al
f011e919:	74 1d                	je     f011e938 <test_krealloc_FF1+0x7c9>
				panic(
f011e91b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011e91e:	8a 00                	mov    (%eax),%al
f011e920:	0f be c0             	movsbl %al,%eax
f011e923:	50                   	push   %eax
f011e924:	68 a0 28 13 f0       	push   $0xf01328a0
f011e929:	68 f8 09 00 00       	push   $0x9f8
f011e92e:	68 33 f0 12 f0       	push   $0xf012f033
f011e933:	e8 01 1a fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!, char = %c",
						ptr[0]);

			intArr = (int*) ptr_allocations[2];
f011e938:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011e93e:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if (intArr[0] != 3 || intArr[lastIndices[2]] != 3)
f011e941:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e944:	8b 00                	mov    (%eax),%eax
f011e946:	83 f8 03             	cmp    $0x3,%eax
f011e949:	75 19                	jne    f011e964 <test_krealloc_FF1+0x7f5>
f011e94b:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011e951:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e958:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e95b:	01 d0                	add    %edx,%eax
f011e95d:	8b 00                	mov    (%eax),%eax
f011e95f:	83 f8 03             	cmp    $0x3,%eax
f011e962:	74 17                	je     f011e97b <test_krealloc_FF1+0x80c>
				panic("Wrong allocation stored values are wrongly changed!");
f011e964:	83 ec 04             	sub    $0x4,%esp
f011e967:	68 ec 28 13 f0       	push   $0xf01328ec
f011e96c:	68 fc 09 00 00       	push   $0x9fc
f011e971:	68 33 f0 12 f0       	push   $0xf012f033
f011e976:	e8 be 19 fe ff       	call   f0100339 <_panic>

			intArr = (int*) ptr_allocations[3];
f011e97b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011e981:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if (intArr[0] != 4 || intArr[lastIndices[3]] != 4)
f011e984:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e987:	8b 00                	mov    (%eax),%eax
f011e989:	83 f8 04             	cmp    $0x4,%eax
f011e98c:	75 19                	jne    f011e9a7 <test_krealloc_FF1+0x838>
f011e98e:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011e994:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e99b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011e99e:	01 d0                	add    %edx,%eax
f011e9a0:	8b 00                	mov    (%eax),%eax
f011e9a2:	83 f8 04             	cmp    $0x4,%eax
f011e9a5:	74 17                	je     f011e9be <test_krealloc_FF1+0x84f>
				panic(
f011e9a7:	83 ec 04             	sub    $0x4,%esp
f011e9aa:	68 60 28 13 f0       	push   $0xf0132860
f011e9af:	68 01 0a 00 00       	push   $0xa01
f011e9b4:	68 33 f0 12 f0       	push   $0xf012f033
f011e9b9:	e8 7b 19 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			shortArr = (short*) ptr_allocations[4];
f011e9be:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011e9c4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if (shortArr[0] != 5 || shortArr[lastIndices[4]] != 5)
f011e9c7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011e9ca:	66 8b 00             	mov    (%eax),%ax
f011e9cd:	66 83 f8 05          	cmp    $0x5,%ax
f011e9d1:	75 18                	jne    f011e9eb <test_krealloc_FF1+0x87c>
f011e9d3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011e9d9:	01 c0                	add    %eax,%eax
f011e9db:	89 c2                	mov    %eax,%edx
f011e9dd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011e9e0:	01 d0                	add    %edx,%eax
f011e9e2:	66 8b 00             	mov    (%eax),%ax
f011e9e5:	66 83 f8 05          	cmp    $0x5,%ax
f011e9e9:	74 17                	je     f011ea02 <test_krealloc_FF1+0x893>
				panic(
f011e9eb:	83 ec 04             	sub    $0x4,%esp
f011e9ee:	68 60 28 13 f0       	push   $0xf0132860
f011e9f3:	68 06 0a 00 00       	push   $0xa06
f011e9f8:	68 33 f0 12 f0       	push   $0xf012f033
f011e9fd:	e8 37 19 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			shortArr = (short*) ptr_allocations[5];
f011ea02:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011ea08:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if (shortArr[0] != 6 || shortArr[lastIndices[5]] != 6)
f011ea0b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ea0e:	66 8b 00             	mov    (%eax),%ax
f011ea11:	66 83 f8 06          	cmp    $0x6,%ax
f011ea15:	75 18                	jne    f011ea2f <test_krealloc_FF1+0x8c0>
f011ea17:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011ea1d:	01 c0                	add    %eax,%eax
f011ea1f:	89 c2                	mov    %eax,%edx
f011ea21:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ea24:	01 d0                	add    %edx,%eax
f011ea26:	66 8b 00             	mov    (%eax),%ax
f011ea29:	66 83 f8 06          	cmp    $0x6,%ax
f011ea2d:	74 17                	je     f011ea46 <test_krealloc_FF1+0x8d7>
				panic(
f011ea2f:	83 ec 04             	sub    $0x4,%esp
f011ea32:	68 60 28 13 f0       	push   $0xf0132860
f011ea37:	68 0b 0a 00 00       	push   $0xa0b
f011ea3c:	68 33 f0 12 f0       	push   $0xf012f033
f011ea41:	e8 f3 18 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			structArr = (struct MyStruct*) ptr_allocations[6];
f011ea46:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ea4c:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (structArr[0].a != 7 || structArr[lastIndices[6]].a != 7)
f011ea4f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea52:	8a 00                	mov    (%eax),%al
f011ea54:	3c 07                	cmp    $0x7,%al
f011ea56:	75 18                	jne    f011ea70 <test_krealloc_FF1+0x901>
f011ea58:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011ea5e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011ea65:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea68:	01 d0                	add    %edx,%eax
f011ea6a:	8a 00                	mov    (%eax),%al
f011ea6c:	3c 07                	cmp    $0x7,%al
f011ea6e:	74 17                	je     f011ea87 <test_krealloc_FF1+0x918>
				panic(
f011ea70:	83 ec 04             	sub    $0x4,%esp
f011ea73:	68 60 28 13 f0       	push   $0xf0132860
f011ea78:	68 10 0a 00 00       	push   $0xa10
f011ea7d:	68 33 f0 12 f0       	push   $0xf012f033
f011ea82:	e8 b2 18 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");
			if (structArr[0].b != 7 || structArr[lastIndices[6]].b != 7)
f011ea87:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ea8a:	66 8b 40 02          	mov    0x2(%eax),%ax
f011ea8e:	66 83 f8 07          	cmp    $0x7,%ax
f011ea92:	75 1c                	jne    f011eab0 <test_krealloc_FF1+0x941>
f011ea94:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011ea9a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011eaa1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eaa4:	01 d0                	add    %edx,%eax
f011eaa6:	66 8b 40 02          	mov    0x2(%eax),%ax
f011eaaa:	66 83 f8 07          	cmp    $0x7,%ax
f011eaae:	74 17                	je     f011eac7 <test_krealloc_FF1+0x958>
				panic(
f011eab0:	83 ec 04             	sub    $0x4,%esp
f011eab3:	68 60 28 13 f0       	push   $0xf0132860
f011eab8:	68 13 0a 00 00       	push   $0xa13
f011eabd:	68 33 f0 12 f0       	push   $0xf012f033
f011eac2:	e8 72 18 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");
			if (structArr[0].c != 7 || structArr[lastIndices[6]].c != 7)
f011eac7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eaca:	8b 40 04             	mov    0x4(%eax),%eax
f011eacd:	83 f8 07             	cmp    $0x7,%eax
f011ead0:	75 1a                	jne    f011eaec <test_krealloc_FF1+0x97d>
f011ead2:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011ead8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011eadf:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eae2:	01 d0                	add    %edx,%eax
f011eae4:	8b 40 04             	mov    0x4(%eax),%eax
f011eae7:	83 f8 07             	cmp    $0x7,%eax
f011eaea:	74 17                	je     f011eb03 <test_krealloc_FF1+0x994>
				panic(
f011eaec:	83 ec 04             	sub    $0x4,%esp
f011eaef:	68 60 28 13 f0       	push   $0xf0132860
f011eaf4:	68 16 0a 00 00       	push   $0xa16
f011eaf9:	68 33 f0 12 f0       	push   $0xf012f033
f011eafe:	e8 36 18 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			structArr = (struct MyStruct*) ptr_allocations[7];
f011eb03:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011eb09:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if (structArr[0].a != 8 || structArr[lastIndices[7]].a != 8)
f011eb0c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb0f:	8a 00                	mov    (%eax),%al
f011eb11:	3c 08                	cmp    $0x8,%al
f011eb13:	75 18                	jne    f011eb2d <test_krealloc_FF1+0x9be>
f011eb15:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011eb1b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011eb22:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb25:	01 d0                	add    %edx,%eax
f011eb27:	8a 00                	mov    (%eax),%al
f011eb29:	3c 08                	cmp    $0x8,%al
f011eb2b:	74 17                	je     f011eb44 <test_krealloc_FF1+0x9d5>
				panic(
f011eb2d:	83 ec 04             	sub    $0x4,%esp
f011eb30:	68 60 28 13 f0       	push   $0xf0132860
f011eb35:	68 1b 0a 00 00       	push   $0xa1b
f011eb3a:	68 33 f0 12 f0       	push   $0xf012f033
f011eb3f:	e8 f5 17 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");
			if (structArr[0].b != 8 || structArr[lastIndices[7]].b != 8)
f011eb44:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb47:	66 8b 40 02          	mov    0x2(%eax),%ax
f011eb4b:	66 83 f8 08          	cmp    $0x8,%ax
f011eb4f:	75 1c                	jne    f011eb6d <test_krealloc_FF1+0x9fe>
f011eb51:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011eb57:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011eb5e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb61:	01 d0                	add    %edx,%eax
f011eb63:	66 8b 40 02          	mov    0x2(%eax),%ax
f011eb67:	66 83 f8 08          	cmp    $0x8,%ax
f011eb6b:	74 17                	je     f011eb84 <test_krealloc_FF1+0xa15>
				panic(
f011eb6d:	83 ec 04             	sub    $0x4,%esp
f011eb70:	68 60 28 13 f0       	push   $0xf0132860
f011eb75:	68 1e 0a 00 00       	push   $0xa1e
f011eb7a:	68 33 f0 12 f0       	push   $0xf012f033
f011eb7f:	e8 b5 17 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");
			if (structArr[0].c != 8 || structArr[lastIndices[7]].c != 8)
f011eb84:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb87:	8b 40 04             	mov    0x4(%eax),%eax
f011eb8a:	83 f8 08             	cmp    $0x8,%eax
f011eb8d:	75 1a                	jne    f011eba9 <test_krealloc_FF1+0xa3a>
f011eb8f:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011eb95:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011eb9c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011eb9f:	01 d0                	add    %edx,%eax
f011eba1:	8b 40 04             	mov    0x4(%eax),%eax
f011eba4:	83 f8 08             	cmp    $0x8,%eax
f011eba7:	74 17                	je     f011ebc0 <test_krealloc_FF1+0xa51>
				panic(
f011eba9:	83 ec 04             	sub    $0x4,%esp
f011ebac:	68 60 28 13 f0       	push   $0xf0132860
f011ebb1:	68 21 0a 00 00       	push   $0xa21
f011ebb6:	68 33 f0 12 f0       	push   $0xf012f033
f011ebbb:	e8 79 17 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation stored values are wrongly changed!");

			if ((freeFrames - sys_calculate_free_frames()) != 0)
f011ebc0:	e8 6f 02 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ebc5:	89 c2                	mov    %eax,%edx
f011ebc7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ebca:	39 c2                	cmp    %eax,%edx
f011ebcc:	74 17                	je     f011ebe5 <test_krealloc_FF1+0xa76>
				panic(
f011ebce:	83 ec 04             	sub    $0x4,%esp
f011ebd1:	68 20 29 13 f0       	push   $0xf0132920
f011ebd6:	68 25 0a 00 00       	push   $0xa25
f011ebdb:	68 33 f0 12 f0       	push   $0xf012f033
f011ebe0:	e8 54 17 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation pages are not loaded successfully into memory");

		}
		cprintf("\nkrealloc: current evaluation = 10%");
f011ebe5:	83 ec 0c             	sub    $0xc,%esp
f011ebe8:	68 6c 29 13 f0       	push   $0xf013296c
f011ebed:	e8 99 23 fe ff       	call   f0100f8b <cprintf>
f011ebf2:	83 c4 10             	add    $0x10,%esp

		//[3] Test krealloc by passing size = 0
		{
			//kfree 1st 1 MB
			freeFrames = sys_calculate_free_frames();
f011ebf5:	e8 3a 02 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ebfa:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011ebfd:	e8 b6 5e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ec02:	89 45 9c             	mov    %eax,-0x64(%ebp)
			krealloc(ptr_allocations[0], 0);
f011ec05:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011ec0b:	83 ec 08             	sub    $0x8,%esp
f011ec0e:	6a 00                	push   $0x0
f011ec10:	50                   	push   %eax
f011ec11:	e8 ff b4 fe ff       	call   f010a115 <krealloc>
f011ec16:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011ec19:	e8 9a 5e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ec1e:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ec21:	74 17                	je     f011ec3a <test_krealloc_FF1+0xacb>
				panic(
f011ec23:	83 ec 04             	sub    $0x4,%esp
f011ec26:	68 90 29 13 f0       	push   $0xf0132990
f011ec2b:	68 32 0a 00 00       	push   $0xa32
f011ec30:	68 33 f0 12 f0       	push   $0xf012f033
f011ec35:	e8 ff 16 fe ff       	call   f0100339 <_panic>
						"krealloc: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 256)
f011ec3a:	e8 f5 01 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ec3f:	89 c2                	mov    %eax,%edx
f011ec41:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ec44:	29 c2                	sub    %eax,%edx
f011ec46:	89 d0                	mov    %edx,%eax
f011ec48:	3d 00 01 00 00       	cmp    $0x100,%eax
f011ec4d:	74 17                	je     f011ec66 <test_krealloc_FF1+0xaf7>
				panic("krealloc: pages in memory are not freed correctly");
f011ec4f:	83 ec 04             	sub    $0x4,%esp
f011ec52:	68 04 2a 13 f0       	push   $0xf0132a04
f011ec57:	68 34 0a 00 00       	push   $0xa34
f011ec5c:	68 33 f0 12 f0       	push   $0xf012f033
f011ec61:	e8 d3 16 fe ff       	call   f0100339 <_panic>

			//kfree 3rd 1 MB
			freeFrames = sys_calculate_free_frames();
f011ec66:	e8 c9 01 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ec6b:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011ec6e:	e8 45 5e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ec73:	89 45 9c             	mov    %eax,-0x64(%ebp)

			krealloc(ptr_allocations[2], 0);
f011ec76:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011ec7c:	83 ec 08             	sub    $0x8,%esp
f011ec7f:	6a 00                	push   $0x0
f011ec81:	50                   	push   %eax
f011ec82:	e8 8e b4 fe ff       	call   f010a115 <krealloc>
f011ec87:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011ec8a:	e8 29 5e fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ec8f:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ec92:	74 17                	je     f011ecab <test_krealloc_FF1+0xb3c>
				panic(
f011ec94:	83 ec 04             	sub    $0x4,%esp
f011ec97:	68 90 29 13 f0       	push   $0xf0132990
f011ec9c:	68 3d 0a 00 00       	push   $0xa3d
f011eca1:	68 33 f0 12 f0       	push   $0xf012f033
f011eca6:	e8 8e 16 fe ff       	call   f0100339 <_panic>
						"krealloc: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 256)
f011ecab:	e8 84 01 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ecb0:	89 c2                	mov    %eax,%edx
f011ecb2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ecb5:	29 c2                	sub    %eax,%edx
f011ecb7:	89 d0                	mov    %edx,%eax
f011ecb9:	3d 00 01 00 00       	cmp    $0x100,%eax
f011ecbe:	74 17                	je     f011ecd7 <test_krealloc_FF1+0xb68>
				panic("krealloc: pages in memory are not freed correctly");
f011ecc0:	83 ec 04             	sub    $0x4,%esp
f011ecc3:	68 04 2a 13 f0       	push   $0xf0132a04
f011ecc8:	68 3f 0a 00 00       	push   $0xa3f
f011eccd:	68 33 f0 12 f0       	push   $0xf012f033
f011ecd2:	e8 62 16 fe ff       	call   f0100339 <_panic>

			//kfree 2nd 2 MB
			freeFrames = sys_calculate_free_frames();
f011ecd7:	e8 58 01 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ecdc:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011ecdf:	e8 d4 5d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ece4:	89 45 9c             	mov    %eax,-0x64(%ebp)
			krealloc(ptr_allocations[5], 0);
f011ece7:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f011eced:	83 ec 08             	sub    $0x8,%esp
f011ecf0:	6a 00                	push   $0x0
f011ecf2:	50                   	push   %eax
f011ecf3:	e8 1d b4 fe ff       	call   f010a115 <krealloc>
f011ecf8:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011ecfb:	e8 b8 5d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ed00:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ed03:	74 17                	je     f011ed1c <test_krealloc_FF1+0xbad>
				panic(
f011ed05:	83 ec 04             	sub    $0x4,%esp
f011ed08:	68 4c f0 12 f0       	push   $0xf012f04c
f011ed0d:	68 47 0a 00 00       	push   $0xa47
f011ed12:	68 33 f0 12 f0       	push   $0xf012f033
f011ed17:	e8 1d 16 fe ff       	call   f0100339 <_panic>
						"Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 2 * Mega / PAGE_SIZE)
f011ed1c:	e8 13 01 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ed21:	89 c2                	mov    %eax,%edx
f011ed23:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ed26:	29 c2                	sub    %eax,%edx
f011ed28:	89 d0                	mov    %edx,%eax
f011ed2a:	3d 00 02 00 00       	cmp    $0x200,%eax
f011ed2f:	74 17                	je     f011ed48 <test_krealloc_FF1+0xbd9>
				panic("krealloc: pages in memory are not freed correctly");
f011ed31:	83 ec 04             	sub    $0x4,%esp
f011ed34:	68 04 2a 13 f0       	push   $0xf0132a04
f011ed39:	68 49 0a 00 00       	push   $0xa49
f011ed3e:	68 33 f0 12 f0       	push   $0xf012f033
f011ed43:	e8 f1 15 fe ff       	call   f0100339 <_panic>

			//kfree last 3 MB
			freeFrames = sys_calculate_free_frames();
f011ed48:	e8 e7 00 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ed4d:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011ed50:	e8 63 5d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ed55:	89 45 9c             	mov    %eax,-0x64(%ebp)
			krealloc(ptr_allocations[7], 0);
f011ed58:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f011ed5e:	83 ec 08             	sub    $0x8,%esp
f011ed61:	6a 00                	push   $0x0
f011ed63:	50                   	push   %eax
f011ed64:	e8 ac b3 fe ff       	call   f010a115 <krealloc>
f011ed69:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011ed6c:	e8 47 5d fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011ed71:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011ed74:	74 17                	je     f011ed8d <test_krealloc_FF1+0xc1e>
				panic(
f011ed76:	83 ec 04             	sub    $0x4,%esp
f011ed79:	68 90 29 13 f0       	push   $0xf0132990
f011ed7e:	68 51 0a 00 00       	push   $0xa51
f011ed83:	68 33 f0 12 f0       	push   $0xf012f033
f011ed88:	e8 ac 15 fe ff       	call   f0100339 <_panic>
						"krealloc: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 3 * Mega / PAGE_SIZE)
f011ed8d:	e8 a2 00 ff ff       	call   f010ee34 <sys_calculate_free_frames>
f011ed92:	89 c2                	mov    %eax,%edx
f011ed94:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011ed97:	29 c2                	sub    %eax,%edx
f011ed99:	89 d0                	mov    %edx,%eax
f011ed9b:	3d 00 03 00 00       	cmp    $0x300,%eax
f011eda0:	74 17                	je     f011edb9 <test_krealloc_FF1+0xc4a>
				panic(
f011eda2:	83 ec 04             	sub    $0x4,%esp
f011eda5:	68 38 2a 13 f0       	push   $0xf0132a38
f011edaa:	68 54 0a 00 00       	push   $0xa54
f011edaf:	68 33 f0 12 f0       	push   $0xf012f033
f011edb4:	e8 80 15 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong kfree: pages in memory are not freed correctly");
			//check tables	[15%]
			{
				long long va;
				for (va = KERNEL_HEAP_START; va < (long long) KERNEL_HEAP_MAX; va +=
f011edb9:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011edc0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011edc7:	eb 48                	jmp    f011ee11 <test_krealloc_FF1+0xca2>
						PTSIZE)
				{
					uint32 *ptr_table;
					get_page_table(ptr_page_directory,  (uint32) va,
f011edc9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011edcc:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011edd1:	83 ec 04             	sub    $0x4,%esp
f011edd4:	8d 8d a4 fe ff ff    	lea    -0x15c(%ebp),%ecx
f011edda:	51                   	push   %ecx
f011eddb:	52                   	push   %edx
f011eddc:	50                   	push   %eax
f011eddd:	e8 fe 9c fe ff       	call   f0108ae0 <get_page_table>
f011ede2:	83 c4 10             	add    $0x10,%esp
							&ptr_table);
					if (ptr_table == NULL) {
f011ede5:	8b 85 a4 fe ff ff    	mov    -0x15c(%ebp),%eax
f011edeb:	85 c0                	test   %eax,%eax
f011eded:	75 17                	jne    f011ee06 <test_krealloc_FF1+0xc97>
						panic(
f011edef:	83 ec 04             	sub    $0x4,%esp
f011edf2:	68 78 2a 13 f0       	push   $0xf0132a78
f011edf7:	68 60 0a 00 00       	push   $0xa60
f011edfc:	68 33 f0 12 f0       	push   $0xf012f033
f011ee01:	e8 33 15 fe ff       	call   f0100339 <_panic>
				panic(
						"krealloc: Wrong kfree: pages in memory are not freed correctly");
			//check tables	[15%]
			{
				long long va;
				for (va = KERNEL_HEAP_START; va < (long long) KERNEL_HEAP_MAX; va +=
f011ee06:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011ee0d:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011ee11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ee15:	78 b2                	js     f011edc9 <test_krealloc_FF1+0xc5a>
f011ee17:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ee1b:	7f 09                	jg     f011ee26 <test_krealloc_FF1+0xcb7>
f011ee1d:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011ee24:	76 a3                	jbe    f011edc9 <test_krealloc_FF1+0xc5a>
								"Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree");
					}
				}
			}
		}
		cprintf("\b\b\b20%");
f011ee26:	83 ec 0c             	sub    $0xc,%esp
f011ee29:	68 dd 2a 13 f0       	push   $0xf0132add
f011ee2e:	e8 58 21 fe ff       	call   f0100f8b <cprintf>
f011ee33:	83 c4 10             	add    $0x10,%esp
		//Check memory access after kfree by checking sum
		{
			//2nd 1 MB
			//cprintf("2nd 1 MB\n");
			ptr = (char*) ptr_allocations[1];
f011ee36:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011ee3c:	89 45 ac             	mov    %eax,-0x54(%ebp)
			int i;
			for (i = 0; i <= lastIndices[1]; ++i) {
f011ee3f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ee46:	eb 1e                	jmp    f011ee66 <test_krealloc_FF1+0xcf7>
				sums[0] += ptr[i];
f011ee48:	8b 95 a8 fe ff ff    	mov    -0x158(%ebp),%edx
f011ee4e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011ee51:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011ee54:	01 c8                	add    %ecx,%eax
f011ee56:	8a 00                	mov    (%eax),%al
f011ee58:	0f be c0             	movsbl %al,%eax
f011ee5b:	01 d0                	add    %edx,%eax
f011ee5d:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)
		{
			//2nd 1 MB
			//cprintf("2nd 1 MB\n");
			ptr = (char*) ptr_allocations[1];
			int i;
			for (i = 0; i <= lastIndices[1]; ++i) {
f011ee63:	ff 45 dc             	incl   -0x24(%ebp)
f011ee66:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011ee6c:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011ee6f:	7d d7                	jge    f011ee48 <test_krealloc_FF1+0xcd9>
				sums[0] += ptr[i];

			}
			//cprintf("sum for 2nd 1 MB = %d LIM1 = %d\n", sums[0], (lastIndices[1] - 1));
			if (sums[0] != (lastIndices[1] + 1) * 2)
f011ee71:	8b 85 a8 fe ff ff    	mov    -0x158(%ebp),%eax
f011ee77:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f011ee7d:	42                   	inc    %edx
f011ee7e:	01 d2                	add    %edx,%edx
f011ee80:	39 d0                	cmp    %edx,%eax
f011ee82:	74 17                	je     f011ee9b <test_krealloc_FF1+0xd2c>
				panic("krealloc: invalid read after freeing some allocations");
f011ee84:	83 ec 04             	sub    $0x4,%esp
f011ee87:	68 e4 2a 13 f0       	push   $0xf0132ae4
f011ee8c:	68 72 0a 00 00       	push   $0xa72
f011ee91:	68 33 f0 12 f0       	push   $0xf012f033
f011ee96:	e8 9e 14 fe ff       	call   f0100339 <_panic>

			//4th 1 MB
			//cprintf("4th 1 MB\n");
			intArr = (int*) ptr_allocations[3];
f011ee9b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011eea1:	89 45 a8             	mov    %eax,-0x58(%ebp)

			for (i = 0; i <= lastIndices[3]; ++i) {
f011eea4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011eeab:	eb 22                	jmp    f011eecf <test_krealloc_FF1+0xd60>
				sums[1] += intArr[i];
f011eead:	8b 95 ac fe ff ff    	mov    -0x154(%ebp),%edx
f011eeb3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eeb6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011eebd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011eec0:	01 c8                	add    %ecx,%eax
f011eec2:	8b 00                	mov    (%eax),%eax
f011eec4:	01 d0                	add    %edx,%eax
f011eec6:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)

			//4th 1 MB
			//cprintf("4th 1 MB\n");
			intArr = (int*) ptr_allocations[3];

			for (i = 0; i <= lastIndices[3]; ++i) {
f011eecc:	ff 45 dc             	incl   -0x24(%ebp)
f011eecf:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011eed5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011eed8:	7d d3                	jge    f011eead <test_krealloc_FF1+0xd3e>
				sums[1] += intArr[i];
			}
			if (sums[1] != (lastIndices[3] + 1) * 4)
f011eeda:	8b 85 ac fe ff ff    	mov    -0x154(%ebp),%eax
f011eee0:	8b 95 04 ff ff ff    	mov    -0xfc(%ebp),%edx
f011eee6:	42                   	inc    %edx
f011eee7:	c1 e2 02             	shl    $0x2,%edx
f011eeea:	39 d0                	cmp    %edx,%eax
f011eeec:	74 17                	je     f011ef05 <test_krealloc_FF1+0xd96>
				panic("krealloc: invalid read after freeing some allocations");
f011eeee:	83 ec 04             	sub    $0x4,%esp
f011eef1:	68 e4 2a 13 f0       	push   $0xf0132ae4
f011eef6:	68 7c 0a 00 00       	push   $0xa7c
f011eefb:	68 33 f0 12 f0       	push   $0xf012f033
f011ef00:	e8 34 14 fe ff       	call   f0100339 <_panic>

			//1st 2 MB
			//cprintf("1st 2 MB\n");
			shortArr = (short*) ptr_allocations[4];
f011ef05:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011ef0b:	89 45 a4             	mov    %eax,-0x5c(%ebp)

			for (i = 0; i <= lastIndices[4]; ++i) {
f011ef0e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ef15:	eb 21                	jmp    f011ef38 <test_krealloc_FF1+0xdc9>
				sums[2] += shortArr[i];
f011ef17:	8b 95 b0 fe ff ff    	mov    -0x150(%ebp),%edx
f011ef1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef20:	01 c0                	add    %eax,%eax
f011ef22:	89 c1                	mov    %eax,%ecx
f011ef24:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011ef27:	01 c8                	add    %ecx,%eax
f011ef29:	66 8b 00             	mov    (%eax),%ax
f011ef2c:	98                   	cwtl   
f011ef2d:	01 d0                	add    %edx,%eax
f011ef2f:	89 85 b0 fe ff ff    	mov    %eax,-0x150(%ebp)

			//1st 2 MB
			//cprintf("1st 2 MB\n");
			shortArr = (short*) ptr_allocations[4];

			for (i = 0; i <= lastIndices[4]; ++i) {
f011ef35:	ff 45 dc             	incl   -0x24(%ebp)
f011ef38:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011ef3e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011ef41:	7d d4                	jge    f011ef17 <test_krealloc_FF1+0xda8>
				sums[2] += shortArr[i];
			}
			if (sums[2] != (lastIndices[4] + 1) * 5)
f011ef43:	8b 95 b0 fe ff ff    	mov    -0x150(%ebp),%edx
f011ef49:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011ef4f:	8d 48 01             	lea    0x1(%eax),%ecx
f011ef52:	89 c8                	mov    %ecx,%eax
f011ef54:	c1 e0 02             	shl    $0x2,%eax
f011ef57:	01 c8                	add    %ecx,%eax
f011ef59:	39 c2                	cmp    %eax,%edx
f011ef5b:	74 17                	je     f011ef74 <test_krealloc_FF1+0xe05>
				panic("krealloc: invalid read after freeing some allocations");
f011ef5d:	83 ec 04             	sub    $0x4,%esp
f011ef60:	68 e4 2a 13 f0       	push   $0xf0132ae4
f011ef65:	68 86 0a 00 00       	push   $0xa86
f011ef6a:	68 33 f0 12 f0       	push   $0xf012f033
f011ef6f:	e8 c5 13 fe ff       	call   f0100339 <_panic>

			//1st 3 MB
			//cprintf("1st 3 MB\n");
			structArr = (struct MyStruct*) ptr_allocations[6];
f011ef74:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011ef7a:	89 45 a0             	mov    %eax,-0x60(%ebp)

			for (i = 0; i <= lastIndices[6]; ++i) {
f011ef7d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ef84:	eb 67                	jmp    f011efed <test_krealloc_FF1+0xe7e>
				sums[3] += structArr[i].a;
f011ef86:	8b 95 b4 fe ff ff    	mov    -0x14c(%ebp),%edx
f011ef8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef8f:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011ef96:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ef99:	01 c8                	add    %ecx,%eax
f011ef9b:	8a 00                	mov    (%eax),%al
f011ef9d:	0f be c0             	movsbl %al,%eax
f011efa0:	01 d0                	add    %edx,%eax
f011efa2:	89 85 b4 fe ff ff    	mov    %eax,-0x14c(%ebp)
				sums[4] += structArr[i].b;
f011efa8:	8b 95 b8 fe ff ff    	mov    -0x148(%ebp),%edx
f011efae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efb1:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011efb8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011efbb:	01 c8                	add    %ecx,%eax
f011efbd:	66 8b 40 02          	mov    0x2(%eax),%ax
f011efc1:	98                   	cwtl   
f011efc2:	01 d0                	add    %edx,%eax
f011efc4:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
				sums[5] += structArr[i].c;
f011efca:	8b 95 bc fe ff ff    	mov    -0x144(%ebp),%edx
f011efd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efd3:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011efda:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011efdd:	01 c8                	add    %ecx,%eax
f011efdf:	8b 40 04             	mov    0x4(%eax),%eax
f011efe2:	01 d0                	add    %edx,%eax
f011efe4:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)

			//1st 3 MB
			//cprintf("1st 3 MB\n");
			structArr = (struct MyStruct*) ptr_allocations[6];

			for (i = 0; i <= lastIndices[6]; ++i) {
f011efea:	ff 45 dc             	incl   -0x24(%ebp)
f011efed:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011eff3:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011eff6:	7d 8e                	jge    f011ef86 <test_krealloc_FF1+0xe17>
				sums[3] += structArr[i].a;
				sums[4] += structArr[i].b;
				sums[5] += structArr[i].c;
			}
			if (sums[3] != (lastIndices[6] + 1) * 7
f011eff8:	8b 8d b4 fe ff ff    	mov    -0x14c(%ebp),%ecx
f011effe:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f004:	8d 50 01             	lea    0x1(%eax),%edx
f011f007:	89 d0                	mov    %edx,%eax
f011f009:	01 c0                	add    %eax,%eax
f011f00b:	01 d0                	add    %edx,%eax
f011f00d:	01 c0                	add    %eax,%eax
f011f00f:	01 d0                	add    %edx,%eax
f011f011:	39 c1                	cmp    %eax,%ecx
f011f013:	75 3a                	jne    f011f04f <test_krealloc_FF1+0xee0>
					|| sums[4] != (lastIndices[6] + 1) * 7
f011f015:	8b 8d b8 fe ff ff    	mov    -0x148(%ebp),%ecx
f011f01b:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f021:	8d 50 01             	lea    0x1(%eax),%edx
f011f024:	89 d0                	mov    %edx,%eax
f011f026:	01 c0                	add    %eax,%eax
f011f028:	01 d0                	add    %edx,%eax
f011f02a:	01 c0                	add    %eax,%eax
f011f02c:	01 d0                	add    %edx,%eax
f011f02e:	39 c1                	cmp    %eax,%ecx
f011f030:	75 1d                	jne    f011f04f <test_krealloc_FF1+0xee0>
					|| sums[5] != (lastIndices[6] + 1) * 7)
f011f032:	8b 8d bc fe ff ff    	mov    -0x144(%ebp),%ecx
f011f038:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f03e:	8d 50 01             	lea    0x1(%eax),%edx
f011f041:	89 d0                	mov    %edx,%eax
f011f043:	01 c0                	add    %eax,%eax
f011f045:	01 d0                	add    %edx,%eax
f011f047:	01 c0                	add    %eax,%eax
f011f049:	01 d0                	add    %edx,%eax
f011f04b:	39 c1                	cmp    %eax,%ecx
f011f04d:	74 17                	je     f011f066 <test_krealloc_FF1+0xef7>
				panic("krealloc: invalid read after freeing some allocations");
f011f04f:	83 ec 04             	sub    $0x4,%esp
f011f052:	68 e4 2a 13 f0       	push   $0xf0132ae4
f011f057:	68 94 0a 00 00       	push   $0xa94
f011f05c:	68 33 f0 12 f0       	push   $0xf012f033
f011f061:	e8 d3 12 fe ff       	call   f0100339 <_panic>
		}

		//[4] Test krealloc reallocation with valid and invalid sizes
		{
			int freeDiskFrames;
			void* newAddress = NULL;
f011f066:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
			//Try to reallocate 2nd 1 MB with a size smaller than its current size (it should return the same VA and do nothing)
			freeFrames = sys_calculate_free_frames();
f011f06d:	e8 c2 fd fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f072:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[1], 15 * kilo);
f011f075:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f07b:	83 ec 08             	sub    $0x8,%esp
f011f07e:	68 00 3c 00 00       	push   $0x3c00
f011f083:	50                   	push   %eax
f011f084:	e8 8c b0 fe ff       	call   f010a115 <krealloc>
f011f089:	83 c4 10             	add    $0x10,%esp
f011f08c:	89 45 98             	mov    %eax,-0x68(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f08f:	8b 45 98             	mov    -0x68(%ebp),%eax
f011f092:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f097:	77 17                	ja     f011f0b0 <test_krealloc_FF1+0xf41>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f099:	83 ec 04             	sub    $0x4,%esp
f011f09c:	68 c0 27 13 f0       	push   $0xf01327c0
f011f0a1:	68 a0 0a 00 00       	push   $0xaa0
f011f0a6:	68 33 f0 12 f0       	push   $0xf012f033
f011f0ab:	e8 89 12 fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[1])
f011f0b0:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f0b6:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011f0b9:	74 17                	je     f011f0d2 <test_krealloc_FF1+0xf63>
				panic(
f011f0bb:	83 ec 04             	sub    $0x4,%esp
f011f0be:	68 1c 2b 13 f0       	push   $0xf0132b1c
f011f0c3:	68 a3 0a 00 00       	push   $0xaa3
f011f0c8:	68 33 f0 12 f0       	push   $0xf012f033
f011f0cd:	e8 67 12 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation: krealloc reallocated an address with the same size (it should return same VA)");
			if (freeFrames != sys_calculate_free_frames())
f011f0d2:	e8 5d fd fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f0d7:	89 c2                	mov    %eax,%edx
f011f0d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f0dc:	39 c2                	cmp    %eax,%edx
f011f0de:	74 17                	je     f011f0f7 <test_krealloc_FF1+0xf88>
				panic(
f011f0e0:	83 ec 04             	sub    $0x4,%esp
f011f0e3:	68 88 2b 13 f0       	push   $0xf0132b88
f011f0e8:	68 a6 0a 00 00       	push   $0xaa6
f011f0ed:	68 33 f0 12 f0       	push   $0xf012f033
f011f0f2:	e8 42 12 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong number of frames after krealloc with the same size");

			//Try to reallocate 1st 2 MB with a size smaller than its current size (it should return the same VA and do nothing)
			freeFrames = sys_calculate_free_frames();
f011f0f7:	e8 38 fd fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f0fc:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[4], 1 * Mega - kilo);
f011f0ff:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f105:	83 ec 08             	sub    $0x8,%esp
f011f108:	68 00 fc 0f 00       	push   $0xffc00
f011f10d:	50                   	push   %eax
f011f10e:	e8 02 b0 fe ff       	call   f010a115 <krealloc>
f011f113:	83 c4 10             	add    $0x10,%esp
f011f116:	89 45 98             	mov    %eax,-0x68(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f119:	8b 45 98             	mov    -0x68(%ebp),%eax
f011f11c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f121:	77 17                	ja     f011f13a <test_krealloc_FF1+0xfcb>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f123:	83 ec 04             	sub    $0x4,%esp
f011f126:	68 c0 27 13 f0       	push   $0xf01327c0
f011f12b:	68 ac 0a 00 00       	push   $0xaac
f011f130:	68 33 f0 12 f0       	push   $0xf012f033
f011f135:	e8 ff 11 fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[4])
f011f13a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f140:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011f143:	74 17                	je     f011f15c <test_krealloc_FF1+0xfed>
				panic(
f011f145:	83 ec 04             	sub    $0x4,%esp
f011f148:	68 1c 2b 13 f0       	push   $0xf0132b1c
f011f14d:	68 af 0a 00 00       	push   $0xaaf
f011f152:	68 33 f0 12 f0       	push   $0xf012f033
f011f157:	e8 dd 11 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation: krealloc reallocated an address with the same size (it should return same VA)");
			if (freeFrames != sys_calculate_free_frames())
f011f15c:	e8 d3 fc fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f161:	89 c2                	mov    %eax,%edx
f011f163:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f166:	39 c2                	cmp    %eax,%edx
f011f168:	74 17                	je     f011f181 <test_krealloc_FF1+0x1012>
				panic(
f011f16a:	83 ec 04             	sub    $0x4,%esp
f011f16d:	68 88 2b 13 f0       	push   $0xf0132b88
f011f172:	68 b2 0a 00 00       	push   $0xab2
f011f177:	68 33 f0 12 f0       	push   $0xf012f033
f011f17c:	e8 b8 11 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong number of frames after krealloc with the same size");

			//Try to reallocate 2nd 1 MB with the same size it should return the same VA
			freeFrames = sys_calculate_free_frames();
f011f181:	e8 ae fc fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f186:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[1], 1 * Mega - kilo);
f011f189:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f18f:	83 ec 08             	sub    $0x8,%esp
f011f192:	68 00 fc 0f 00       	push   $0xffc00
f011f197:	50                   	push   %eax
f011f198:	e8 78 af fe ff       	call   f010a115 <krealloc>
f011f19d:	83 c4 10             	add    $0x10,%esp
f011f1a0:	89 45 98             	mov    %eax,-0x68(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f1a3:	8b 45 98             	mov    -0x68(%ebp),%eax
f011f1a6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f1ab:	77 17                	ja     f011f1c4 <test_krealloc_FF1+0x1055>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f1ad:	83 ec 04             	sub    $0x4,%esp
f011f1b0:	68 c0 27 13 f0       	push   $0xf01327c0
f011f1b5:	68 b8 0a 00 00       	push   $0xab8
f011f1ba:	68 33 f0 12 f0       	push   $0xf012f033
f011f1bf:	e8 75 11 fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[1])
f011f1c4:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f1ca:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011f1cd:	74 17                	je     f011f1e6 <test_krealloc_FF1+0x1077>
				panic(
f011f1cf:	83 ec 04             	sub    $0x4,%esp
f011f1d2:	68 1c 2b 13 f0       	push   $0xf0132b1c
f011f1d7:	68 bb 0a 00 00       	push   $0xabb
f011f1dc:	68 33 f0 12 f0       	push   $0xf012f033
f011f1e1:	e8 53 11 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong allocation: krealloc reallocated an address with the same size (it should return same VA)");
			if (freeFrames != sys_calculate_free_frames())
f011f1e6:	e8 49 fc fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f1eb:	89 c2                	mov    %eax,%edx
f011f1ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f1f0:	39 c2                	cmp    %eax,%edx
f011f1f2:	74 17                	je     f011f20b <test_krealloc_FF1+0x109c>
				panic(
f011f1f4:	83 ec 04             	sub    $0x4,%esp
f011f1f7:	68 88 2b 13 f0       	push   $0xf0132b88
f011f1fc:	68 be 0a 00 00       	push   $0xabe
f011f201:	68 33 f0 12 f0       	push   $0xf012f033
f011f206:	e8 2e 11 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong number of frames after krealloc with the same size");



			//Try to reallocate 4th 1 MB with the same size it should return the same VA
			freeFrames = sys_calculate_free_frames();
f011f20b:	e8 24 fc fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f210:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[3], 1 * Mega - kilo);
f011f213:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011f219:	83 ec 08             	sub    $0x8,%esp
f011f21c:	68 00 fc 0f 00       	push   $0xffc00
f011f221:	50                   	push   %eax
f011f222:	e8 ee ae fe ff       	call   f010a115 <krealloc>
f011f227:	83 c4 10             	add    $0x10,%esp
f011f22a:	89 45 98             	mov    %eax,-0x68(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f22d:	8b 45 98             	mov    -0x68(%ebp),%eax
f011f230:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f235:	77 17                	ja     f011f24e <test_krealloc_FF1+0x10df>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f237:	83 ec 04             	sub    $0x4,%esp
f011f23a:	68 c0 27 13 f0       	push   $0xf01327c0
f011f23f:	68 c6 0a 00 00       	push   $0xac6
f011f244:	68 33 f0 12 f0       	push   $0xf012f033
f011f249:	e8 eb 10 fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[3])
f011f24e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f011f254:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011f257:	74 17                	je     f011f270 <test_krealloc_FF1+0x1101>
				panic(
f011f259:	83 ec 04             	sub    $0x4,%esp
f011f25c:	68 cc 2b 13 f0       	push   $0xf0132bcc
f011f261:	68 c9 0a 00 00       	push   $0xac9
f011f266:	68 33 f0 12 f0       	push   $0xf012f033
f011f26b:	e8 c9 10 fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated an address with the same size (it should return same VA)");
			if (freeFrames != sys_calculate_free_frames())
f011f270:	e8 bf fb fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f275:	89 c2                	mov    %eax,%edx
f011f277:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f27a:	39 c2                	cmp    %eax,%edx
f011f27c:	74 17                	je     f011f295 <test_krealloc_FF1+0x1126>
				panic(
f011f27e:	83 ec 04             	sub    $0x4,%esp
f011f281:	68 88 2b 13 f0       	push   $0xf0132b88
f011f286:	68 cc 0a 00 00       	push   $0xacc
f011f28b:	68 33 f0 12 f0       	push   $0xf012f033
f011f290:	e8 a4 10 fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong number of frames after krealloc with the same size");
		}
		cprintf("\b\b\b30%");
f011f295:	83 ec 0c             	sub    $0xc,%esp
f011f298:	68 2c 2c 13 f0       	push   $0xf0132c2c
f011f29d:	e8 e9 1c fe ff       	call   f0100f8b <cprintf>
f011f2a2:	83 c4 10             	add    $0x10,%esp
		{
			//Reallocate 2nd 1 MB to 1 MB + 7 KB
			freeFrames = sys_calculate_free_frames();
f011f2a5:	e8 8a fb fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f2aa:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[1],
f011f2ad:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f2b3:	83 ec 08             	sub    $0x8,%esp
f011f2b6:	68 00 18 10 00       	push   $0x101800
f011f2bb:	50                   	push   %eax
f011f2bc:	e8 54 ae fe ff       	call   f010a115 <krealloc>
f011f2c1:	83 c4 10             	add    $0x10,%esp
f011f2c4:	89 45 bc             	mov    %eax,-0x44(%ebp)
					(1 * Mega - kilo) + (7 * kilo));
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f2c7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f2ca:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f2cf:	77 17                	ja     f011f2e8 <test_krealloc_FF1+0x1179>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f2d1:	83 ec 04             	sub    $0x4,%esp
f011f2d4:	68 c0 27 13 f0       	push   $0xf01327c0
f011f2d9:	68 d5 0a 00 00       	push   $0xad5
f011f2de:	68 33 f0 12 f0       	push   $0xf012f033
f011f2e3:	e8 51 10 fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[1])
f011f2e8:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f2ee:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011f2f1:	74 17                	je     f011f30a <test_krealloc_FF1+0x119b>
				panic(
f011f2f3:	83 ec 04             	sub    $0x4,%esp
f011f2f6:	68 34 2c 13 f0       	push   $0xf0132c34
f011f2fb:	68 d8 0a 00 00       	push   $0xad8
f011f300:	68 33 f0 12 f0       	push   $0xf012f033
f011f305:	e8 2f 10 fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated a new address while there is a sufficient space after it (it should return same VA)");
			if (freeFrames - sys_calculate_free_frames() != 2)
f011f30a:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011f30d:	e8 22 fb fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f312:	29 c3                	sub    %eax,%ebx
f011f314:	89 d8                	mov    %ebx,%eax
f011f316:	83 f8 02             	cmp    $0x2,%eax
f011f319:	74 17                	je     f011f332 <test_krealloc_FF1+0x11c3>
				panic("krealloc: pages in memory are not loaded correctly");
f011f31b:	83 ec 04             	sub    $0x4,%esp
f011f31e:	68 b0 2c 13 f0       	push   $0xf0132cb0
f011f323:	68 da 0a 00 00       	push   $0xada
f011f328:	68 33 f0 12 f0       	push   $0xf012f033
f011f32d:	e8 07 10 fe ff       	call   f0100339 <_panic>

			//Reallocate 1st 2 MB to 2 MB + 2 MB
			freeFrames = sys_calculate_free_frames();
f011f332:	e8 fd fa fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f337:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[4], (4 * Mega - kilo));
f011f33a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f340:	83 ec 08             	sub    $0x8,%esp
f011f343:	68 00 fc 3f 00       	push   $0x3ffc00
f011f348:	50                   	push   %eax
f011f349:	e8 c7 ad fe ff       	call   f010a115 <krealloc>
f011f34e:	83 c4 10             	add    $0x10,%esp
f011f351:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f354:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f357:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f35c:	77 17                	ja     f011f375 <test_krealloc_FF1+0x1206>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f35e:	83 ec 04             	sub    $0x4,%esp
f011f361:	68 c0 27 13 f0       	push   $0xf01327c0
f011f366:	68 e0 0a 00 00       	push   $0xae0
f011f36b:	68 33 f0 12 f0       	push   $0xf012f033
f011f370:	e8 c4 0f fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[4])
f011f375:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f37b:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011f37e:	74 17                	je     f011f397 <test_krealloc_FF1+0x1228>
				panic(
f011f380:	83 ec 04             	sub    $0x4,%esp
f011f383:	68 34 2c 13 f0       	push   $0xf0132c34
f011f388:	68 e3 0a 00 00       	push   $0xae3
f011f38d:	68 33 f0 12 f0       	push   $0xf012f033
f011f392:	e8 a2 0f fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated a new address while there is a sufficient space after it (it should return same VA)");
			//2 MB only for the new size
			if (freeFrames - sys_calculate_free_frames() != 512)
f011f397:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011f39a:	e8 95 fa fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f39f:	29 c3                	sub    %eax,%ebx
f011f3a1:	89 d8                	mov    %ebx,%eax
f011f3a3:	3d 00 02 00 00       	cmp    $0x200,%eax
f011f3a8:	74 17                	je     f011f3c1 <test_krealloc_FF1+0x1252>
				panic("krealloc: pages in memory are not loaded correctly");
f011f3aa:	83 ec 04             	sub    $0x4,%esp
f011f3ad:	68 b0 2c 13 f0       	push   $0xf0132cb0
f011f3b2:	68 e6 0a 00 00       	push   $0xae6
f011f3b7:	68 33 f0 12 f0       	push   $0xf012f033
f011f3bc:	e8 78 0f fe ff       	call   f0100339 <_panic>


		}
		cprintf("\b\b\b60%");
f011f3c1:	83 ec 0c             	sub    $0xc,%esp
f011f3c4:	68 e3 2c 13 f0       	push   $0xf0132ce3
f011f3c9:	e8 bd 1b fe ff       	call   f0100f8b <cprintf>
f011f3ce:	83 c4 10             	add    $0x10,%esp
		//Test krealloc: Cut & paste
		{
			//Reallocate 1st 2 MB (already reallocated to 4 MB) to 10 MB. It should return new VA
			freeFrames = sys_calculate_free_frames();
f011f3d1:	e8 5e fa fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f3d6:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[4], (10 * Mega - kilo));
f011f3d9:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f3df:	83 ec 08             	sub    $0x8,%esp
f011f3e2:	68 00 fc 9f 00       	push   $0x9ffc00
f011f3e7:	50                   	push   %eax
f011f3e8:	e8 28 ad fe ff       	call   f010a115 <krealloc>
f011f3ed:	83 c4 10             	add    $0x10,%esp
f011f3f0:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f3f3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f3f6:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f3fb:	77 17                	ja     f011f414 <test_krealloc_FF1+0x12a5>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f3fd:	83 ec 04             	sub    $0x4,%esp
f011f400:	68 c0 27 13 f0       	push   $0xf01327c0
f011f405:	68 f1 0a 00 00       	push   $0xaf1
f011f40a:	68 33 f0 12 f0       	push   $0xf012f033
f011f40f:	e8 25 0f fe ff       	call   f0100339 <_panic>
			if ((uint32) newAddress != ACTUAL_START + (14 * Mega))
f011f414:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f417:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f011f41c:	74 18                	je     f011f436 <test_krealloc_FF1+0x12c7>
				panic(
f011f41e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f421:	50                   	push   %eax
f011f422:	68 ec 2c 13 f0       	push   $0xf0132cec
f011f427:	68 f5 0a 00 00       	push   $0xaf5
f011f42c:	68 33 f0 12 f0       	push   $0xf012f033
f011f431:	e8 03 0f fe ff       	call   f0100339 <_panic>
						"krealloc: Wrong start address for reallocated space, NSA = %x\nbbb",
						(uint32 )newAddress);
			if (newAddress == ptr_allocations[4])
f011f436:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f43c:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011f43f:	75 17                	jne    f011f458 <test_krealloc_FF1+0x12e9>
				panic(
f011f441:	83 ec 04             	sub    $0x4,%esp
f011f444:	68 30 2d 13 f0       	push   $0xf0132d30
f011f449:	68 f8 0a 00 00       	push   $0xaf8
f011f44e:	68 33 f0 12 f0       	push   $0xf012f033
f011f453:	e8 e1 0e fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated at the same address while there is NO sufficient space after it (it should return new VA)");
			//6 MB only for the new size
			if (freeFrames - sys_calculate_free_frames() != 1536)
f011f458:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011f45b:	e8 d4 f9 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f460:	29 c3                	sub    %eax,%ebx
f011f462:	89 d8                	mov    %ebx,%eax
f011f464:	3d 00 06 00 00       	cmp    $0x600,%eax
f011f469:	74 17                	je     f011f482 <test_krealloc_FF1+0x1313>
				panic("krealloc: pages in memory are not loaded correctly");
f011f46b:	83 ec 04             	sub    $0x4,%esp
f011f46e:	68 b0 2c 13 f0       	push   $0xf0132cb0
f011f473:	68 fb 0a 00 00       	push   $0xafb
f011f478:	68 33 f0 12 f0       	push   $0xf012f033
f011f47d:	e8 b7 0e fe ff       	call   f0100339 <_panic>

			ptr_allocations[4] = newAddress;
f011f482:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f485:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
			//lastIndices[4] = (10 * Mega - kilo) / sizeof(short) - 1;

			//Reallocate 1st 3 MB to 6 MB
			freeFrames = sys_calculate_free_frames();
f011f48b:	e8 a4 f9 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f490:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[6], (6 * Mega - kilo));
f011f493:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f499:	83 ec 08             	sub    $0x8,%esp
f011f49c:	68 00 fc 5f 00       	push   $0x5ffc00
f011f4a1:	50                   	push   %eax
f011f4a2:	e8 6e ac fe ff       	call   f010a115 <krealloc>
f011f4a7:	83 c4 10             	add    $0x10,%esp
f011f4aa:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f4ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f4b0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f4b5:	77 17                	ja     f011f4ce <test_krealloc_FF1+0x135f>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f4b7:	83 ec 04             	sub    $0x4,%esp
f011f4ba:	68 c0 27 13 f0       	push   $0xf01327c0
f011f4bf:	68 04 0b 00 00       	push   $0xb04
f011f4c4:	68 33 f0 12 f0       	push   $0xf012f033
f011f4c9:	e8 6b 0e fe ff       	call   f0100339 <_panic>
			if (newAddress != ptr_allocations[6])
f011f4ce:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f4d4:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011f4d7:	74 17                	je     f011f4f0 <test_krealloc_FF1+0x1381>
				panic(
f011f4d9:	83 ec 04             	sub    $0x4,%esp
f011f4dc:	68 34 2c 13 f0       	push   $0xf0132c34
f011f4e1:	68 07 0b 00 00       	push   $0xb07
f011f4e6:	68 33 f0 12 f0       	push   $0xf012f033
f011f4eb:	e8 49 0e fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated a new address while there is a sufficient space after it (it should return same VA)");
			//3 MB only for the new size
			if (freeFrames - sys_calculate_free_frames() != 768)
f011f4f0:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011f4f3:	e8 3c f9 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f4f8:	29 c3                	sub    %eax,%ebx
f011f4fa:	89 d8                	mov    %ebx,%eax
f011f4fc:	3d 00 03 00 00       	cmp    $0x300,%eax
f011f501:	74 17                	je     f011f51a <test_krealloc_FF1+0x13ab>
				panic("krealloc: pages in memory are not loaded correctly");
f011f503:	83 ec 04             	sub    $0x4,%esp
f011f506:	68 b0 2c 13 f0       	push   $0xf0132cb0
f011f50b:	68 0a 0b 00 00       	push   $0xb0a
f011f510:	68 33 f0 12 f0       	push   $0xf012f033
f011f515:	e8 1f 0e fe ff       	call   f0100339 <_panic>

			//Reallocate 1st 3 MB (already reallocated to 6 MB) to 20 MB. It should return new VA

			freeFrames = sys_calculate_free_frames();
f011f51a:	e8 15 f9 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f51f:	89 45 b8             	mov    %eax,-0x48(%ebp)
			newAddress = krealloc(ptr_allocations[6], (20 * Mega - kilo));
f011f522:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f528:	83 ec 08             	sub    $0x8,%esp
f011f52b:	68 00 fc 3f 01       	push   $0x13ffc00
f011f530:	50                   	push   %eax
f011f531:	e8 df ab fe ff       	call   f010a115 <krealloc>
f011f536:	83 c4 10             	add    $0x10,%esp
f011f539:	89 45 bc             	mov    %eax,-0x44(%ebp)
			if ((uint32) newAddress < (KERNEL_HEAP_START))
f011f53c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f53f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011f544:	77 17                	ja     f011f55d <test_krealloc_FF1+0x13ee>
				panic("krealloc: Wrong start address for the allocated space... ");
f011f546:	83 ec 04             	sub    $0x4,%esp
f011f549:	68 c0 27 13 f0       	push   $0xf01327c0
f011f54e:	68 11 0b 00 00       	push   $0xb11
f011f553:	68 33 f0 12 f0       	push   $0xf012f033
f011f558:	e8 dc 0d fe ff       	call   f0100339 <_panic>
			if (newAddress == ptr_allocations[6])
f011f55d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f563:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f011f566:	75 17                	jne    f011f57f <test_krealloc_FF1+0x1410>
				panic(
f011f568:	83 ec 04             	sub    $0x4,%esp
f011f56b:	68 30 2d 13 f0       	push   $0xf0132d30
f011f570:	68 14 0b 00 00       	push   $0xb14
f011f575:	68 33 f0 12 f0       	push   $0xf012f033
f011f57a:	e8 ba 0d fe ff       	call   f0100339 <_panic>
						"Wrong allocation: krealloc reallocated at the same address while there is NO sufficient space after it (it should return new VA)");
			if ((uint32) newAddress != ACTUAL_START + (24 * Mega))
f011f57f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f582:	3d 00 10 80 f9       	cmp    $0xf9801000,%eax
f011f587:	74 17                	je     f011f5a0 <test_krealloc_FF1+0x1431>
				panic("krealloc: Wrong start address for reallocated space");
f011f589:	83 ec 04             	sub    $0x4,%esp
f011f58c:	68 b4 2d 13 f0       	push   $0xf0132db4
f011f591:	68 16 0b 00 00       	push   $0xb16
f011f596:	68 33 f0 12 f0       	push   $0xf012f033
f011f59b:	e8 99 0d fe ff       	call   f0100339 <_panic>
			//3 MB only for the new size
			if (freeFrames - sys_calculate_free_frames() != 3584)
f011f5a0:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f011f5a3:	e8 8c f8 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f5a8:	29 c3                	sub    %eax,%ebx
f011f5aa:	89 d8                	mov    %ebx,%eax
f011f5ac:	3d 00 0e 00 00       	cmp    $0xe00,%eax
f011f5b1:	74 17                	je     f011f5ca <test_krealloc_FF1+0x145b>
				panic("krealloc: pages in memory are not loaded correctly");
f011f5b3:	83 ec 04             	sub    $0x4,%esp
f011f5b6:	68 b0 2c 13 f0       	push   $0xf0132cb0
f011f5bb:	68 19 0b 00 00       	push   $0xb19
f011f5c0:	68 33 f0 12 f0       	push   $0xf012f033
f011f5c5:	e8 6f 0d fe ff       	call   f0100339 <_panic>

			ptr_allocations[6] = newAddress;
f011f5ca:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011f5cd:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			//Test read write access for the new allocated size of 2nd 1 MB
			ptr = (char*) ptr_allocations[1];
f011f5d3:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011f5d9:	89 45 ac             	mov    %eax,-0x54(%ebp)
			int i;
			sums[0] = 0;
f011f5dc:	c7 85 a8 fe ff ff 00 	movl   $0x0,-0x158(%ebp)
f011f5e3:	00 00 00 
			for (i = 0; i <= lastIndices[1]; ++i) {
f011f5e6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011f5ed:	eb 1e                	jmp    f011f60d <test_krealloc_FF1+0x149e>
				sums[0] += ptr[i];
f011f5ef:	8b 95 a8 fe ff ff    	mov    -0x158(%ebp),%edx
f011f5f5:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011f5f8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011f5fb:	01 c8                	add    %ecx,%eax
f011f5fd:	8a 00                	mov    (%eax),%al
f011f5ff:	0f be c0             	movsbl %al,%eax
f011f602:	01 d0                	add    %edx,%eax
f011f604:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)

			//Test read write access for the new allocated size of 2nd 1 MB
			ptr = (char*) ptr_allocations[1];
			int i;
			sums[0] = 0;
			for (i = 0; i <= lastIndices[1]; ++i) {
f011f60a:	ff 45 d8             	incl   -0x28(%ebp)
f011f60d:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011f613:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f616:	7d d7                	jge    f011f5ef <test_krealloc_FF1+0x1480>
				sums[0] += ptr[i];

			}
			//cprintf("sum for 2nd 1 MB = %d LIM1 = %d\n", sums[0], (lastIndices[1] - 1));
			if (sums[0] != (lastIndices[1] + 1) * 2)
f011f618:	8b 85 a8 fe ff ff    	mov    -0x158(%ebp),%eax
f011f61e:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
f011f624:	42                   	inc    %edx
f011f625:	01 d2                	add    %edx,%edx
f011f627:	39 d0                	cmp    %edx,%eax
f011f629:	74 17                	je     f011f642 <test_krealloc_FF1+0x14d3>
				panic("krealloc: invalid read after re-allocations");
f011f62b:	83 ec 04             	sub    $0x4,%esp
f011f62e:	68 e8 2d 13 f0       	push   $0xf0132de8
f011f633:	68 27 0b 00 00       	push   $0xb27
f011f638:	68 33 f0 12 f0       	push   $0xf012f033
f011f63d:	e8 f7 0c fe ff       	call   f0100339 <_panic>

			//Test read write access for the new allocated size of 1st 3 MB
			structArr = (struct MyStruct*) ptr_allocations[6];
f011f642:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f648:	89 45 a0             	mov    %eax,-0x60(%ebp)

			sums[0] = 0;
f011f64b:	c7 85 a8 fe ff ff 00 	movl   $0x0,-0x158(%ebp)
f011f652:	00 00 00 
			sums[1] = 0;
f011f655:	c7 85 ac fe ff ff 00 	movl   $0x0,-0x154(%ebp)
f011f65c:	00 00 00 
			sums[2] = 0;
f011f65f:	c7 85 b0 fe ff ff 00 	movl   $0x0,-0x150(%ebp)
f011f666:	00 00 00 
			for (i = 0; i <= lastIndices[6]; ++i) {
f011f669:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011f670:	eb 67                	jmp    f011f6d9 <test_krealloc_FF1+0x156a>
				sums[0] += structArr[i].a;
f011f672:	8b 95 a8 fe ff ff    	mov    -0x158(%ebp),%edx
f011f678:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f67b:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011f682:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011f685:	01 c8                	add    %ecx,%eax
f011f687:	8a 00                	mov    (%eax),%al
f011f689:	0f be c0             	movsbl %al,%eax
f011f68c:	01 d0                	add    %edx,%eax
f011f68e:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)
				sums[1] += structArr[i].b;
f011f694:	8b 95 ac fe ff ff    	mov    -0x154(%ebp),%edx
f011f69a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f69d:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011f6a4:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011f6a7:	01 c8                	add    %ecx,%eax
f011f6a9:	66 8b 40 02          	mov    0x2(%eax),%ax
f011f6ad:	98                   	cwtl   
f011f6ae:	01 d0                	add    %edx,%eax
f011f6b0:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
				sums[2] += structArr[i].c;
f011f6b6:	8b 95 b0 fe ff ff    	mov    -0x150(%ebp),%edx
f011f6bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f6bf:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f011f6c6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011f6c9:	01 c8                	add    %ecx,%eax
f011f6cb:	8b 40 04             	mov    0x4(%eax),%eax
f011f6ce:	01 d0                	add    %edx,%eax
f011f6d0:	89 85 b0 fe ff ff    	mov    %eax,-0x150(%ebp)
			structArr = (struct MyStruct*) ptr_allocations[6];

			sums[0] = 0;
			sums[1] = 0;
			sums[2] = 0;
			for (i = 0; i <= lastIndices[6]; ++i) {
f011f6d6:	ff 45 d8             	incl   -0x28(%ebp)
f011f6d9:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f6df:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f6e2:	7d 8e                	jge    f011f672 <test_krealloc_FF1+0x1503>
				sums[1] += structArr[i].b;
				sums[2] += structArr[i].c;

			}
			//cprintf("sum for 2nd 1 MB = %d LIM1 = %d\n", sums[0], (lastIndices[1] - 1));
			if (sums[0] != (lastIndices[6] + 1) * 7
f011f6e4:	8b 8d a8 fe ff ff    	mov    -0x158(%ebp),%ecx
f011f6ea:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f6f0:	8d 50 01             	lea    0x1(%eax),%edx
f011f6f3:	89 d0                	mov    %edx,%eax
f011f6f5:	01 c0                	add    %eax,%eax
f011f6f7:	01 d0                	add    %edx,%eax
f011f6f9:	01 c0                	add    %eax,%eax
f011f6fb:	01 d0                	add    %edx,%eax
f011f6fd:	39 c1                	cmp    %eax,%ecx
f011f6ff:	75 3a                	jne    f011f73b <test_krealloc_FF1+0x15cc>
					|| sums[1] != (lastIndices[6] + 1) * 7
f011f701:	8b 8d ac fe ff ff    	mov    -0x154(%ebp),%ecx
f011f707:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f70d:	8d 50 01             	lea    0x1(%eax),%edx
f011f710:	89 d0                	mov    %edx,%eax
f011f712:	01 c0                	add    %eax,%eax
f011f714:	01 d0                	add    %edx,%eax
f011f716:	01 c0                	add    %eax,%eax
f011f718:	01 d0                	add    %edx,%eax
f011f71a:	39 c1                	cmp    %eax,%ecx
f011f71c:	75 1d                	jne    f011f73b <test_krealloc_FF1+0x15cc>
					|| sums[2] != (lastIndices[6] + 1) * 7)
f011f71e:	8b 8d b0 fe ff ff    	mov    -0x150(%ebp),%ecx
f011f724:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011f72a:	8d 50 01             	lea    0x1(%eax),%edx
f011f72d:	89 d0                	mov    %edx,%eax
f011f72f:	01 c0                	add    %eax,%eax
f011f731:	01 d0                	add    %edx,%eax
f011f733:	01 c0                	add    %eax,%eax
f011f735:	01 d0                	add    %edx,%eax
f011f737:	39 c1                	cmp    %eax,%ecx
f011f739:	74 17                	je     f011f752 <test_krealloc_FF1+0x15e3>
				panic("krealloc: invalid read after re-allocations");
f011f73b:	83 ec 04             	sub    $0x4,%esp
f011f73e:	68 e8 2d 13 f0       	push   $0xf0132de8
f011f743:	68 39 0b 00 00       	push   $0xb39
f011f748:	68 33 f0 12 f0       	push   $0xf012f033
f011f74d:	e8 e7 0b fe ff       	call   f0100339 <_panic>

			//Test read write access for the new allocated size of 1st 2 MB
			shortArr = (short*) ptr_allocations[4];
f011f752:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f758:	89 45 a4             	mov    %eax,-0x5c(%ebp)

			sums[0] = 0;
f011f75b:	c7 85 a8 fe ff ff 00 	movl   $0x0,-0x158(%ebp)
f011f762:	00 00 00 
			for (i = 0; i <= lastIndices[4]; ++i) {
f011f765:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011f76c:	eb 21                	jmp    f011f78f <test_krealloc_FF1+0x1620>
				sums[0] += shortArr[i];
f011f76e:	8b 95 a8 fe ff ff    	mov    -0x158(%ebp),%edx
f011f774:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f777:	01 c0                	add    %eax,%eax
f011f779:	89 c1                	mov    %eax,%ecx
f011f77b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011f77e:	01 c8                	add    %ecx,%eax
f011f780:	66 8b 00             	mov    (%eax),%ax
f011f783:	98                   	cwtl   
f011f784:	01 d0                	add    %edx,%eax
f011f786:	89 85 a8 fe ff ff    	mov    %eax,-0x158(%ebp)

			//Test read write access for the new allocated size of 1st 2 MB
			shortArr = (short*) ptr_allocations[4];

			sums[0] = 0;
			for (i = 0; i <= lastIndices[4]; ++i) {
f011f78c:	ff 45 d8             	incl   -0x28(%ebp)
f011f78f:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f795:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011f798:	7d d4                	jge    f011f76e <test_krealloc_FF1+0x15ff>
				sums[0] += shortArr[i];
			}
			if (sums[0] != (lastIndices[4] + 1) * 5)
f011f79a:	8b 95 a8 fe ff ff    	mov    -0x158(%ebp),%edx
f011f7a0:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011f7a6:	8d 48 01             	lea    0x1(%eax),%ecx
f011f7a9:	89 c8                	mov    %ecx,%eax
f011f7ab:	c1 e0 02             	shl    $0x2,%eax
f011f7ae:	01 c8                	add    %ecx,%eax
f011f7b0:	39 c2                	cmp    %eax,%edx
f011f7b2:	74 17                	je     f011f7cb <test_krealloc_FF1+0x165c>
				panic("krealloc: invalid read after re-allocations");
f011f7b4:	83 ec 04             	sub    $0x4,%esp
f011f7b7:	68 e8 2d 13 f0       	push   $0xf0132de8
f011f7bc:	68 43 0b 00 00       	push   $0xb43
f011f7c1:	68 33 f0 12 f0       	push   $0xf012f033
f011f7c6:	e8 6e 0b fe ff       	call   f0100339 <_panic>

			//Test krealloc with size = 0 after krealloc 1st 3 MB to 20 MB
			freeFrames = sys_calculate_free_frames();
f011f7cb:	e8 64 f6 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f7d0:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011f7d3:	e8 e0 52 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011f7d8:	89 45 9c             	mov    %eax,-0x64(%ebp)
			krealloc(ptr_allocations[6], 0);
f011f7db:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011f7e1:	83 ec 08             	sub    $0x8,%esp
f011f7e4:	6a 00                	push   $0x0
f011f7e6:	50                   	push   %eax
f011f7e7:	e8 29 a9 fe ff       	call   f010a115 <krealloc>
f011f7ec:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011f7ef:	e8 c4 52 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011f7f4:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011f7f7:	74 17                	je     f011f810 <test_krealloc_FF1+0x16a1>
				panic(
f011f7f9:	83 ec 04             	sub    $0x4,%esp
f011f7fc:	68 4c f0 12 f0       	push   $0xf012f04c
f011f801:	68 4b 0b 00 00       	push   $0xb4b
f011f806:	68 33 f0 12 f0       	push   $0xf012f033
f011f80b:	e8 29 0b fe ff       	call   f0100339 <_panic>
						"Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 20 * Mega / PAGE_SIZE)
f011f810:	e8 1f f6 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f815:	89 c2                	mov    %eax,%edx
f011f817:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f81a:	29 c2                	sub    %eax,%edx
f011f81c:	89 d0                	mov    %edx,%eax
f011f81e:	3d 00 14 00 00       	cmp    $0x1400,%eax
f011f823:	74 17                	je     f011f83c <test_krealloc_FF1+0x16cd>
				panic("krealloc: pages in memory are not freed correctly");
f011f825:	83 ec 04             	sub    $0x4,%esp
f011f828:	68 04 2a 13 f0       	push   $0xf0132a04
f011f82d:	68 4d 0b 00 00       	push   $0xb4d
f011f832:	68 33 f0 12 f0       	push   $0xf012f033
f011f837:	e8 fd 0a fe ff       	call   f0100339 <_panic>

			//Test kfree after krealloc 1st 2 MB to 10 MB
			freeFrames = sys_calculate_free_frames();
f011f83c:	e8 f3 f5 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f841:	89 45 b8             	mov    %eax,-0x48(%ebp)
			freeDiskFrames = pf_calculate_free_frames();
f011f844:	e8 6f 52 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011f849:	89 45 9c             	mov    %eax,-0x64(%ebp)
			kfree(ptr_allocations[4]);
f011f84c:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f011f852:	83 ec 0c             	sub    $0xc,%esp
f011f855:	50                   	push   %eax
f011f856:	e8 79 a6 fe ff       	call   f0109ed4 <kfree>
f011f85b:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0)
f011f85e:	e8 55 52 fe ff       	call   f0104ab8 <pf_calculate_free_frames>
f011f863:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011f866:	74 17                	je     f011f87f <test_krealloc_FF1+0x1710>
				panic(
f011f868:	83 ec 04             	sub    $0x4,%esp
f011f86b:	68 4c f0 12 f0       	push   $0xf012f04c
f011f870:	68 55 0b 00 00       	push   $0xb55
f011f875:	68 33 f0 12 f0       	push   $0xf012f033
f011f87a:	e8 ba 0a fe ff       	call   f0100339 <_panic>
						"Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
			if ((sys_calculate_free_frames() - freeFrames) != 10 * Mega / PAGE_SIZE)
f011f87f:	e8 b0 f5 fe ff       	call   f010ee34 <sys_calculate_free_frames>
f011f884:	89 c2                	mov    %eax,%edx
f011f886:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011f889:	29 c2                	sub    %eax,%edx
f011f88b:	89 d0                	mov    %edx,%eax
f011f88d:	3d 00 0a 00 00       	cmp    $0xa00,%eax
f011f892:	74 17                	je     f011f8ab <test_krealloc_FF1+0x173c>
				panic("krealloc: pages in memory are not freed correctly");
f011f894:	83 ec 04             	sub    $0x4,%esp
f011f897:	68 04 2a 13 f0       	push   $0xf0132a04
f011f89c:	68 57 0b 00 00       	push   $0xb57
f011f8a1:	68 33 f0 12 f0       	push   $0xf012f033
f011f8a6:	e8 8e 0a fe ff       	call   f0100339 <_panic>

			//check tables	[15%]
			{
				long long va;
				for (va = KERNEL_HEAP_START; va < (long long) KERNEL_HEAP_MAX; va +=
f011f8ab:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011f8b2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011f8b9:	eb 48                	jmp    f011f903 <test_krealloc_FF1+0x1794>
						PTSIZE)
				{
					uint32 *ptr_table;
					get_page_table(ptr_page_directory,  (uint32) va,
f011f8bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011f8be:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f011f8c3:	83 ec 04             	sub    $0x4,%esp
f011f8c6:	8d 8d a0 fe ff ff    	lea    -0x160(%ebp),%ecx
f011f8cc:	51                   	push   %ecx
f011f8cd:	52                   	push   %edx
f011f8ce:	50                   	push   %eax
f011f8cf:	e8 0c 92 fe ff       	call   f0108ae0 <get_page_table>
f011f8d4:	83 c4 10             	add    $0x10,%esp
							&ptr_table);
					if (ptr_table == NULL) {
f011f8d7:	8b 85 a0 fe ff ff    	mov    -0x160(%ebp),%eax
f011f8dd:	85 c0                	test   %eax,%eax
f011f8df:	75 17                	jne    f011f8f8 <test_krealloc_FF1+0x1789>
						panic(
f011f8e1:	83 ec 04             	sub    $0x4,%esp
f011f8e4:	68 78 2a 13 f0       	push   $0xf0132a78
f011f8e9:	68 64 0b 00 00       	push   $0xb64
f011f8ee:	68 33 f0 12 f0       	push   $0xf012f033
f011f8f3:	e8 41 0a fe ff       	call   f0100339 <_panic>
				panic("krealloc: pages in memory are not freed correctly");

			//check tables	[15%]
			{
				long long va;
				for (va = KERNEL_HEAP_START; va < (long long) KERNEL_HEAP_MAX; va +=
f011f8f8:	81 45 d0 00 00 40 00 	addl   $0x400000,-0x30(%ebp)
f011f8ff:	83 55 d4 00          	adcl   $0x0,-0x2c(%ebp)
f011f903:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011f907:	78 b2                	js     f011f8bb <test_krealloc_FF1+0x174c>
f011f909:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011f90d:	7f 09                	jg     f011f918 <test_krealloc_FF1+0x17a9>
f011f90f:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011f916:	76 a3                	jbe    f011f8bb <test_krealloc_FF1+0x174c>
				}
			}

		}

		cprintf("\b\b\b100%\n");
f011f918:	83 ec 0c             	sub    $0xc,%esp
f011f91b:	68 14 2e 13 f0       	push   $0xf0132e14
f011f920:	e8 66 16 fe ff       	call   f0100f8b <cprintf>
f011f925:	83 c4 10             	add    $0x10,%esp

		cprintf("\nCongratulations!! test krealloc completed successfully.\n");
f011f928:	83 ec 0c             	sub    $0xc,%esp
f011f92b:	68 20 2e 13 f0       	push   $0xf0132e20
f011f930:	e8 56 16 fe ff       	call   f0100f8b <cprintf>
f011f935:	83 c4 10             	add    $0x10,%esp
		return 0;
f011f938:	b8 00 00 00 00       	mov    $0x0,%eax
	}
f011f93d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f940:	5b                   	pop    %ebx
f011f941:	5f                   	pop    %edi
f011f942:	5d                   	pop    %ebp
f011f943:	c3                   	ret    

f011f944 <test_krealloc_FF2>:


int test_krealloc_FF2()
{
f011f944:	55                   	push   %ebp
f011f945:	89 e5                	mov    %esp,%ebp
f011f947:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011f94a:	83 ec 04             	sub    $0x4,%esp
f011f94d:	68 f4 25 13 f0       	push   $0xf01325f4
f011f952:	68 74 0b 00 00       	push   $0xb74
f011f957:	68 33 f0 12 f0       	push   $0xf012f033
f011f95c:	e8 d8 09 fe ff       	call   f0100339 <_panic>

f011f961 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011f961:	55                   	push   %ebp
f011f962:	89 e5                	mov    %esp,%ebp
f011f964:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011f967:	83 ec 04             	sub    $0x4,%esp
f011f96a:	68 f4 25 13 f0       	push   $0xf01325f4
f011f96f:	68 7a 0b 00 00       	push   $0xb7a
f011f974:	68 33 f0 12 f0       	push   $0xf012f033
f011f979:	e8 bb 09 fe ff       	call   f0100339 <_panic>

f011f97e <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011f97e:	55                   	push   %ebp
f011f97f:	89 e5                	mov    %esp,%ebp
f011f981:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011f984:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f98b:	e9 84 00 00 00       	jmp    f011fa14 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011f990:	83 ec 08             	sub    $0x8,%esp
f011f993:	ff 75 f4             	pushl  -0xc(%ebp)
f011f996:	68 5c 2e 13 f0       	push   $0xf0132e5c
f011f99b:	e8 eb 15 fe ff       	call   f0100f8b <cprintf>
f011f9a0:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011f9a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011f9aa:	eb 4c                	jmp    f011f9f8 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011f9ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f9af:	89 d0                	mov    %edx,%eax
f011f9b1:	c1 e0 02             	shl    $0x2,%eax
f011f9b4:	01 d0                	add    %edx,%eax
f011f9b6:	c1 e0 03             	shl    $0x3,%eax
f011f9b9:	89 c2                	mov    %eax,%edx
f011f9bb:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9be:	01 c2                	add    %eax,%edx
f011f9c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f9c3:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011f9c6:	85 c0                	test   %eax,%eax
f011f9c8:	74 36                	je     f011fa00 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011f9ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f9cd:	89 d0                	mov    %edx,%eax
f011f9cf:	c1 e0 02             	shl    $0x2,%eax
f011f9d2:	01 d0                	add    %edx,%eax
f011f9d4:	c1 e0 03             	shl    $0x3,%eax
f011f9d7:	89 c2                	mov    %eax,%edx
f011f9d9:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9dc:	01 c2                	add    %eax,%edx
f011f9de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f9e1:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011f9e4:	83 ec 08             	sub    $0x8,%esp
f011f9e7:	50                   	push   %eax
f011f9e8:	68 64 2e 13 f0       	push   $0xf0132e64
f011f9ed:	e8 99 15 fe ff       	call   f0100f8b <cprintf>
f011f9f2:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011f9f5:	ff 45 f0             	incl   -0x10(%ebp)
f011f9f8:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011f9fc:	7e ae                	jle    f011f9ac <print_order+0x2e>
f011f9fe:	eb 01                	jmp    f011fa01 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011fa00:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011fa01:	83 ec 0c             	sub    $0xc,%esp
f011fa04:	68 69 2e 13 f0       	push   $0xf0132e69
f011fa09:	e8 7d 15 fe ff       	call   f0100f8b <cprintf>
f011fa0e:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011fa11:	ff 45 f4             	incl   -0xc(%ebp)
f011fa14:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011fa18:	0f 8e 72 ff ff ff    	jle    f011f990 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011fa1e:	90                   	nop
f011fa1f:	c9                   	leave  
f011fa20:	c3                   	ret    

f011fa21 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011fa21:	55                   	push   %ebp
f011fa22:	89 e5                	mov    %esp,%ebp
f011fa24:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011fa27:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011fa2e:	83 ec 0c             	sub    $0xc,%esp
f011fa31:	68 00 58 74 f0       	push   $0xf0745800
f011fa36:	e8 af 0d ff ff       	call   f01107ea <acquire_spinlock>
f011fa3b:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011fa3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011fa45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011fa4c:	8b 55 0c             	mov    0xc(%ebp),%edx
f011fa4f:	8b 45 10             	mov    0x10(%ebp),%eax
f011fa52:	01 d0                	add    %edx,%eax
f011fa54:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011fa57:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f011fa5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011fa5f:	a1 84 58 74 f0       	mov    0xf0745884,%eax
f011fa64:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011fa67:	ff 75 e8             	pushl  -0x18(%ebp)
f011fa6a:	ff 75 0c             	pushl  0xc(%ebp)
f011fa6d:	ff 75 08             	pushl  0x8(%ebp)
f011fa70:	68 6c 2e 13 f0       	push   $0xf0132e6c
f011fa75:	e8 11 15 fe ff       	call   f0100f8b <cprintf>
f011fa7a:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011fa7d:	eb 34                	jmp    f011fab3 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011fa7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fa82:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011fa85:	7d 05                	jge    f011fa8c <find_in_range+0x6b>
			{
				i++;
f011fa87:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011fa8a:	eb 1e                	jmp    f011faaa <find_in_range+0x89>
			}
			if (i >= end)
f011fa8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fa8f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011fa92:	7d 29                	jge    f011fabd <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011fa94:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fa97:	8b 40 10             	mov    0x10(%eax),%eax
f011fa9a:	3b 45 08             	cmp    0x8(%ebp),%eax
f011fa9d:	75 08                	jne    f011faa7 <find_in_range+0x86>
			{
				ret = i;
f011fa9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011faa2:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011faa5:	eb 17                	jmp    f011fabe <find_in_range+0x9d>
			}
			i++;
f011faa7:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011faaa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011faad:	8b 40 0c             	mov    0xc(%eax),%eax
f011fab0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fab6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011fab9:	7c c4                	jl     f011fa7f <find_in_range+0x5e>
f011fabb:	eb 01                	jmp    f011fabe <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011fabd:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011fabe:	83 ec 0c             	sub    $0xc,%esp
f011fac1:	68 00 58 74 f0       	push   $0xf0745800
f011fac6:	e8 a6 0d ff ff       	call   f0110871 <release_spinlock>
f011facb:	83 c4 10             	add    $0x10,%esp
	return ret;
f011face:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011fad1:	c9                   	leave  
f011fad2:	c3                   	ret    

f011fad3 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011fad3:	55                   	push   %ebp
f011fad4:	89 e5                	mov    %esp,%ebp
f011fad6:	57                   	push   %edi
f011fad7:	56                   	push   %esi
f011fad8:	53                   	push   %ebx
f011fad9:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011fadc:	a0 5d 3e 18 f0       	mov    0xf0183e5d,%al
f011fae1:	84 c0                	test   %al,%al
f011fae3:	0f 84 9b 01 00 00    	je     f011fc84 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011fae9:	c6 05 5d 3e 18 f0 00 	movb   $0x0,0xf0183e5d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011faf0:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011faf3:	bb e4 2f 13 f0       	mov    $0xf0132fe4,%ebx
f011faf8:	ba 05 00 00 00       	mov    $0x5,%edx
f011fafd:	89 c7                	mov    %eax,%edi
f011faff:	89 de                	mov    %ebx,%esi
f011fb01:	89 d1                	mov    %edx,%ecx
f011fb03:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011fb05:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011fb0c:	e9 44 01 00 00       	jmp    f011fc55 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011fb11:	6a 00                	push   $0x0
f011fb13:	6a 00                	push   $0x0
f011fb15:	68 f4 01 00 00       	push   $0x1f4
f011fb1a:	68 9d 2e 13 f0       	push   $0xf0132e9d
f011fb1f:	e8 a2 b9 fe ff       	call   f010b4c6 <env_create>
f011fb24:	83 c4 10             	add    $0x10,%esp
f011fb27:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011fb2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fb2d:	b9 05 00 00 00       	mov    $0x5,%ecx
f011fb32:	99                   	cltd   
f011fb33:	f7 f9                	idiv   %ecx
f011fb35:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011fb38:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fb3b:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011fb3f:	83 ec 08             	sub    $0x8,%esp
f011fb42:	50                   	push   %eax
f011fb43:	ff 75 d4             	pushl  -0x2c(%ebp)
f011fb46:	e8 cb 6d fe ff       	call   f0106916 <env_set_nice>
f011fb4b:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011fb4e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011fb52:	75 14                	jne    f011fb68 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011fb54:	83 ec 04             	sub    $0x4,%esp
f011fb57:	68 a5 2e 13 f0       	push   $0xf0132ea5
f011fb5c:	6a 53                	push   $0x53
f011fb5e:	68 be 2e 13 f0       	push   $0xf0132ebe
f011fb63:	e8 d1 07 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011fb68:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fb6b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011fb71:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011fb76:	74 14                	je     f011fb8c <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011fb78:	83 ec 04             	sub    $0x4,%esp
f011fb7b:	68 dc 2e 13 f0       	push   $0xf0132edc
f011fb80:	6a 55                	push   $0x55
f011fb82:	68 be 2e 13 f0       	push   $0xf0132ebe
f011fb87:	e8 ad 07 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011fb8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fb8f:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011fb93:	83 c0 0a             	add    $0xa,%eax
f011fb96:	83 f8 14             	cmp    $0x14,%eax
f011fb99:	0f 87 a5 00 00 00    	ja     f011fc44 <test_bsd_nice_0+0x171>
f011fb9f:	8b 04 85 f8 2f 13 f0 	mov    -0xfecd008(,%eax,4),%eax
f011fba6:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011fba8:	a1 9c 55 74 f0       	mov    0xf074559c,%eax
f011fbad:	8d 50 01             	lea    0x1(%eax),%edx
f011fbb0:	89 15 9c 55 74 f0    	mov    %edx,0xf074559c
f011fbb6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fbb9:	8b 52 10             	mov    0x10(%edx),%edx
f011fbbc:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f011fbc3:	eb 7f                	jmp    f011fc44 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011fbc5:	a1 a0 55 74 f0       	mov    0xf07455a0,%eax
f011fbca:	8d 50 01             	lea    0x1(%eax),%edx
f011fbcd:	89 15 a0 55 74 f0    	mov    %edx,0xf07455a0
f011fbd3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fbd6:	8b 52 10             	mov    0x10(%edx),%edx
f011fbd9:	83 c0 0a             	add    $0xa,%eax
f011fbdc:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f011fbe3:	eb 5f                	jmp    f011fc44 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011fbe5:	a1 a4 55 74 f0       	mov    0xf07455a4,%eax
f011fbea:	8d 50 01             	lea    0x1(%eax),%edx
f011fbed:	89 15 a4 55 74 f0    	mov    %edx,0xf07455a4
f011fbf3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fbf6:	8b 52 10             	mov    0x10(%edx),%edx
f011fbf9:	83 c0 14             	add    $0x14,%eax
f011fbfc:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f011fc03:	eb 3f                	jmp    f011fc44 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011fc05:	a1 a8 55 74 f0       	mov    0xf07455a8,%eax
f011fc0a:	8d 50 01             	lea    0x1(%eax),%edx
f011fc0d:	89 15 a8 55 74 f0    	mov    %edx,0xf07455a8
f011fc13:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fc16:	8b 52 10             	mov    0x10(%edx),%edx
f011fc19:	83 c0 1e             	add    $0x1e,%eax
f011fc1c:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f011fc23:	eb 1f                	jmp    f011fc44 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011fc25:	a1 ac 55 74 f0       	mov    0xf07455ac,%eax
f011fc2a:	8d 50 01             	lea    0x1(%eax),%edx
f011fc2d:	89 15 ac 55 74 f0    	mov    %edx,0xf07455ac
f011fc33:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011fc36:	8b 52 10             	mov    0x10(%edx),%edx
f011fc39:	83 c0 28             	add    $0x28,%eax
f011fc3c:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f011fc43:	90                   	nop
			}
			sched_new_env(env);
f011fc44:	83 ec 0c             	sub    $0xc,%esp
f011fc47:	ff 75 d4             	pushl  -0x2c(%ebp)
f011fc4a:	e8 5d 5d fe ff       	call   f01059ac <sched_new_env>
f011fc4f:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011fc52:	ff 45 e4             	incl   -0x1c(%ebp)
f011fc55:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011fc59:	0f 8e b2 fe ff ff    	jle    f011fb11 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011fc5f:	83 ec 0c             	sub    $0xc,%esp
f011fc62:	68 0c 2f 13 f0       	push   $0xf0132f0c
f011fc67:	e8 1f 13 fe ff       	call   f0100f8b <cprintf>
f011fc6c:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011fc6f:	83 ec 0c             	sub    $0xc,%esp
f011fc72:	68 5b 2f 13 f0       	push   $0xf0132f5b
f011fc77:	e8 7f 22 fe ff       	call   f0101efb <execute_command>
f011fc7c:	83 c4 10             	add    $0x10,%esp
f011fc7f:	e9 c0 00 00 00       	jmp    f011fd44 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011fc84:	83 ec 0c             	sub    $0xc,%esp
f011fc87:	68 62 2f 13 f0       	push   $0xf0132f62
f011fc8c:	e8 fa 12 fe ff       	call   f0100f8b <cprintf>
f011fc91:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011fc94:	e8 4b 64 fe ff       	call   f01060e4 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011fc99:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011fca0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011fca7:	e9 87 00 00 00       	jmp    f011fd33 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011fcac:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011fcb3:	eb 52                	jmp    f011fd07 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011fcb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fcb8:	8b 14 85 9c 55 74 f0 	mov    -0xf8baa64(,%eax,4),%edx
f011fcbf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011fcc2:	89 c8                	mov    %ecx,%eax
f011fcc4:	c1 e0 02             	shl    $0x2,%eax
f011fcc7:	01 c8                	add    %ecx,%eax
f011fcc9:	01 c0                	add    %eax,%eax
f011fccb:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011fcce:	01 c8                	add    %ecx,%eax
f011fcd0:	8b 04 85 e0 87 76 f0 	mov    -0xf897820(,%eax,4),%eax
f011fcd7:	83 ec 04             	sub    $0x4,%esp
f011fcda:	52                   	push   %edx
f011fcdb:	ff 75 e0             	pushl  -0x20(%ebp)
f011fcde:	50                   	push   %eax
f011fcdf:	e8 3d fd ff ff       	call   f011fa21 <find_in_range>
f011fce4:	83 c4 10             	add    $0x10,%esp
f011fce7:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011fcea:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011fcee:	75 14                	jne    f011fd04 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011fcf0:	83 ec 04             	sub    $0x4,%esp
f011fcf3:	68 74 2f 13 f0       	push   $0xf0132f74
f011fcf8:	6a 7b                	push   $0x7b
f011fcfa:	68 be 2e 13 f0       	push   $0xf0132ebe
f011fcff:	e8 35 06 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011fd04:	ff 45 d8             	incl   -0x28(%ebp)
f011fd07:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011fd0a:	89 d0                	mov    %edx,%eax
f011fd0c:	c1 e0 02             	shl    $0x2,%eax
f011fd0f:	01 d0                	add    %edx,%eax
f011fd11:	01 c0                	add    %eax,%eax
f011fd13:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011fd16:	01 d0                	add    %edx,%eax
f011fd18:	8b 04 85 e0 87 76 f0 	mov    -0xf897820(,%eax,4),%eax
f011fd1f:	85 c0                	test   %eax,%eax
f011fd21:	75 92                	jne    f011fcb5 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011fd23:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011fd26:	8b 04 85 9c 55 74 f0 	mov    -0xf8baa64(,%eax,4),%eax
f011fd2d:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011fd30:	ff 45 dc             	incl   -0x24(%ebp)
f011fd33:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011fd37:	0f 8e 6f ff ff ff    	jle    f011fcac <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011fd3d:	c6 05 5d 3e 18 f0 00 	movb   $0x0,0xf0183e5d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011fd44:	83 ec 0c             	sub    $0xc,%esp
f011fd47:	68 a8 2f 13 f0       	push   $0xf0132fa8
f011fd4c:	e8 3a 12 fe ff       	call   f0100f8b <cprintf>
f011fd51:	83 c4 10             	add    $0x10,%esp
}
f011fd54:	90                   	nop
f011fd55:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011fd58:	5b                   	pop    %ebx
f011fd59:	5e                   	pop    %esi
f011fd5a:	5f                   	pop    %edi
f011fd5b:	5d                   	pop    %ebp
f011fd5c:	c3                   	ret    

f011fd5d <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011fd5d:	55                   	push   %ebp
f011fd5e:	89 e5                	mov    %esp,%ebp
f011fd60:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011fd63:	a0 5d 3e 18 f0       	mov    0xf0183e5d,%al
f011fd68:	84 c0                	test   %al,%al
f011fd6a:	0f 84 50 01 00 00    	je     f011fec0 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011fd70:	c6 05 5d 3e 18 f0 00 	movb   $0x0,0xf0183e5d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011fd77:	6a 00                	push   $0x0
f011fd79:	6a 00                	push   $0x0
f011fd7b:	68 f4 01 00 00       	push   $0x1f4
f011fd80:	68 9d 2e 13 f0       	push   $0xf0132e9d
f011fd85:	e8 3c b7 fe ff       	call   f010b4c6 <env_create>
f011fd8a:	83 c4 10             	add    $0x10,%esp
f011fd8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011fd90:	6a 00                	push   $0x0
f011fd92:	6a 00                	push   $0x0
f011fd94:	68 f4 01 00 00       	push   $0x1f4
f011fd99:	68 4c 30 13 f0       	push   $0xf013304c
f011fd9e:	e8 23 b7 fe ff       	call   f010b4c6 <env_create>
f011fda3:	83 c4 10             	add    $0x10,%esp
f011fda6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011fda9:	6a 00                	push   $0x0
f011fdab:	6a 00                	push   $0x0
f011fdad:	68 f4 01 00 00       	push   $0x1f4
f011fdb2:	68 59 30 13 f0       	push   $0xf0133059
f011fdb7:	e8 0a b7 fe ff       	call   f010b4c6 <env_create>
f011fdbc:	83 c4 10             	add    $0x10,%esp
f011fdbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011fdc2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011fdc6:	74 0c                	je     f011fdd4 <test_bsd_nice_1+0x77>
f011fdc8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011fdcc:	74 06                	je     f011fdd4 <test_bsd_nice_1+0x77>
f011fdce:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011fdd2:	75 17                	jne    f011fdeb <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011fdd4:	83 ec 04             	sub    $0x4,%esp
f011fdd7:	68 a5 2e 13 f0       	push   $0xf0132ea5
f011fddc:	68 8e 00 00 00       	push   $0x8e
f011fde1:	68 be 2e 13 f0       	push   $0xf0132ebe
f011fde6:	e8 4e 05 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011fdeb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fdee:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011fdf4:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011fdf9:	75 20                	jne    f011fe1b <test_bsd_nice_1+0xbe>
f011fdfb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fdfe:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011fe04:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011fe09:	75 10                	jne    f011fe1b <test_bsd_nice_1+0xbe>
f011fe0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fe0e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011fe14:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011fe19:	74 35                	je     f011fe50 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011fe1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fe1e:	8b 88 90 00 00 00    	mov    0x90(%eax),%ecx
f011fe24:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fe27:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
f011fe2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fe30:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f011fe36:	83 ec 08             	sub    $0x8,%esp
f011fe39:	51                   	push   %ecx
f011fe3a:	52                   	push   %edx
f011fe3b:	50                   	push   %eax
f011fe3c:	68 68 30 13 f0       	push   $0xf0133068
f011fe41:	68 90 00 00 00       	push   $0x90
f011fe46:	68 be 2e 13 f0       	push   $0xf0132ebe
f011fe4b:	e8 e9 04 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011fe50:	83 ec 0c             	sub    $0xc,%esp
f011fe53:	ff 75 ec             	pushl  -0x14(%ebp)
f011fe56:	e8 51 5b fe ff       	call   f01059ac <sched_new_env>
f011fe5b:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011fe5e:	83 ec 0c             	sub    $0xc,%esp
f011fe61:	ff 75 e8             	pushl  -0x18(%ebp)
f011fe64:	e8 43 5b fe ff       	call   f01059ac <sched_new_env>
f011fe69:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011fe6c:	83 ec 0c             	sub    $0xc,%esp
f011fe6f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fe72:	e8 35 5b fe ff       	call   f01059ac <sched_new_env>
f011fe77:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011fe7a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fe7d:	8b 40 10             	mov    0x10(%eax),%eax
f011fe80:	a3 e0 87 76 f0       	mov    %eax,0xf07687e0
		prog_orders[1][0] = fibEnv->env_id;
f011fe85:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011fe88:	8b 40 10             	mov    0x10(%eax),%eax
f011fe8b:	a3 08 88 76 f0       	mov    %eax,0xf0768808
		prog_orders[2][0] = fibposnEnv->env_id;
f011fe90:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fe93:	8b 40 10             	mov    0x10(%eax),%eax
f011fe96:	a3 30 88 76 f0       	mov    %eax,0xf0768830
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011fe9b:	83 ec 0c             	sub    $0xc,%esp
f011fe9e:	68 0c 2f 13 f0       	push   $0xf0132f0c
f011fea3:	e8 e3 10 fe ff       	call   f0100f8b <cprintf>
f011fea8:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011feab:	83 ec 0c             	sub    $0xc,%esp
f011feae:	68 5b 2f 13 f0       	push   $0xf0132f5b
f011feb3:	e8 43 20 fe ff       	call   f0101efb <execute_command>
f011feb8:	83 c4 10             	add    $0x10,%esp
f011febb:	e9 9e 00 00 00       	jmp    f011ff5e <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011fec0:	83 ec 0c             	sub    $0xc,%esp
f011fec3:	68 62 2f 13 f0       	push   $0xf0132f62
f011fec8:	e8 be 10 fe ff       	call   f0100f8b <cprintf>
f011fecd:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011fed0:	e8 0f 62 fe ff       	call   f01060e4 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011fed5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011fedc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011fee3:	83 ec 0c             	sub    $0xc,%esp
f011fee6:	68 00 58 74 f0       	push   $0xf0745800
f011feeb:	e8 fa 08 ff ff       	call   f01107ea <acquire_spinlock>
f011fef0:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011fef3:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f011fef8:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011fefb:	a1 84 58 74 f0       	mov    0xf0745884,%eax
f011ff00:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011ff03:	eb 41                	jmp    f011ff46 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011ff05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ff08:	89 d0                	mov    %edx,%eax
f011ff0a:	c1 e0 02             	shl    $0x2,%eax
f011ff0d:	01 d0                	add    %edx,%eax
f011ff0f:	c1 e0 03             	shl    $0x3,%eax
f011ff12:	05 e0 87 76 f0       	add    $0xf07687e0,%eax
f011ff17:	8b 10                	mov    (%eax),%edx
f011ff19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ff1c:	8b 40 10             	mov    0x10(%eax),%eax
f011ff1f:	39 c2                	cmp    %eax,%edx
f011ff21:	74 17                	je     f011ff3a <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011ff23:	83 ec 04             	sub    $0x4,%esp
f011ff26:	68 74 2f 13 f0       	push   $0xf0132f74
f011ff2b:	68 ab 00 00 00       	push   $0xab
f011ff30:	68 be 2e 13 f0       	push   $0xf0132ebe
f011ff35:	e8 ff 03 fe ff       	call   f0100339 <_panic>
				i++;
f011ff3a:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011ff3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ff40:	8b 40 0c             	mov    0xc(%eax),%eax
f011ff43:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ff46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ff49:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011ff4c:	7c b7                	jl     f011ff05 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011ff4e:	83 ec 0c             	sub    $0xc,%esp
f011ff51:	68 00 58 74 f0       	push   $0xf0745800
f011ff56:	e8 16 09 ff ff       	call   f0110871 <release_spinlock>
f011ff5b:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011ff5e:	83 ec 0c             	sub    $0xc,%esp
f011ff61:	68 d4 30 13 f0       	push   $0xf01330d4
f011ff66:	e8 20 10 fe ff       	call   f0100f8b <cprintf>
f011ff6b:	83 c4 10             	add    $0x10,%esp
}
f011ff6e:	90                   	nop
f011ff6f:	c9                   	leave  
f011ff70:	c3                   	ret    

f011ff71 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011ff71:	55                   	push   %ebp
f011ff72:	89 e5                	mov    %esp,%ebp
f011ff74:	57                   	push   %edi
f011ff75:	56                   	push   %esi
f011ff76:	53                   	push   %ebx
f011ff77:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011ff7a:	a0 5d 3e 18 f0       	mov    0xf0183e5d,%al
f011ff7f:	84 c0                	test   %al,%al
f011ff81:	0f 84 ae 01 00 00    	je     f0120135 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011ff87:	83 ec 0c             	sub    $0xc,%esp
f011ff8a:	6a 01                	push   $0x1
f011ff8c:	e8 fe 10 00 00       	call   f012108f <chksch>
f011ff91:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011ff94:	c6 05 5d 3e 18 f0 00 	movb   $0x0,0xf0183e5d
		int nice_values[] = {15, 5, 0, -5, -15};
f011ff9b:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011ff9e:	bb 58 31 13 f0       	mov    $0xf0133158,%ebx
f011ffa3:	ba 05 00 00 00       	mov    $0x5,%edx
f011ffa8:	89 c7                	mov    %eax,%edi
f011ffaa:	89 de                	mov    %ebx,%esi
f011ffac:	89 d1                	mov    %edx,%ecx
f011ffae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011ffb0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011ffb7:	e9 4a 01 00 00       	jmp    f0120106 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011ffbc:	6a 00                	push   $0x0
f011ffbe:	6a 00                	push   $0x0
f011ffc0:	68 10 27 00 00       	push   $0x2710
f011ffc5:	68 10 31 13 f0       	push   $0xf0133110
f011ffca:	e8 f7 b4 fe ff       	call   f010b4c6 <env_create>
f011ffcf:	83 c4 10             	add    $0x10,%esp
f011ffd2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011ffd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ffd8:	b9 05 00 00 00       	mov    $0x5,%ecx
f011ffdd:	99                   	cltd   
f011ffde:	f7 f9                	idiv   %ecx
f011ffe0:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011ffe3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ffe6:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011ffea:	83 ec 08             	sub    $0x8,%esp
f011ffed:	50                   	push   %eax
f011ffee:	ff 75 d4             	pushl  -0x2c(%ebp)
f011fff1:	e8 20 69 fe ff       	call   f0106916 <env_set_nice>
f011fff6:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011fff9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011fffd:	75 17                	jne    f0120016 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011ffff:	83 ec 04             	sub    $0x4,%esp
f0120002:	68 a5 2e 13 f0       	push   $0xf0132ea5
f0120007:	68 c1 00 00 00       	push   $0xc1
f012000c:	68 be 2e 13 f0       	push   $0xf0132ebe
f0120011:	e8 23 03 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f0120016:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120019:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f012001f:	3d 10 27 00 00       	cmp    $0x2710,%eax
f0120024:	74 17                	je     f012003d <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f0120026:	83 ec 04             	sub    $0x4,%esp
f0120029:	68 dc 2e 13 f0       	push   $0xf0132edc
f012002e:	68 c3 00 00 00       	push   $0xc3
f0120033:	68 be 2e 13 f0       	push   $0xf0132ebe
f0120038:	e8 fc 02 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f012003d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120040:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f0120044:	83 c0 0f             	add    $0xf,%eax
f0120047:	83 f8 1e             	cmp    $0x1e,%eax
f012004a:	0f 87 a5 00 00 00    	ja     f01200f5 <test_bsd_nice_2+0x184>
f0120050:	8b 04 85 6c 31 13 f0 	mov    -0xfecce94(,%eax,4),%eax
f0120057:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f0120059:	a1 9c 55 74 f0       	mov    0xf074559c,%eax
f012005e:	8d 50 01             	lea    0x1(%eax),%edx
f0120061:	89 15 9c 55 74 f0    	mov    %edx,0xf074559c
f0120067:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f012006a:	8b 52 10             	mov    0x10(%edx),%edx
f012006d:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f0120074:	eb 7f                	jmp    f01200f5 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f0120076:	a1 a0 55 74 f0       	mov    0xf07455a0,%eax
f012007b:	8d 50 01             	lea    0x1(%eax),%edx
f012007e:	89 15 a0 55 74 f0    	mov    %edx,0xf07455a0
f0120084:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0120087:	8b 52 10             	mov    0x10(%edx),%edx
f012008a:	83 c0 0a             	add    $0xa,%eax
f012008d:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f0120094:	eb 5f                	jmp    f01200f5 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f0120096:	a1 a4 55 74 f0       	mov    0xf07455a4,%eax
f012009b:	8d 50 01             	lea    0x1(%eax),%edx
f012009e:	89 15 a4 55 74 f0    	mov    %edx,0xf07455a4
f01200a4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01200a7:	8b 52 10             	mov    0x10(%edx),%edx
f01200aa:	83 c0 14             	add    $0x14,%eax
f01200ad:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f01200b4:	eb 3f                	jmp    f01200f5 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f01200b6:	a1 a8 55 74 f0       	mov    0xf07455a8,%eax
f01200bb:	8d 50 01             	lea    0x1(%eax),%edx
f01200be:	89 15 a8 55 74 f0    	mov    %edx,0xf07455a8
f01200c4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01200c7:	8b 52 10             	mov    0x10(%edx),%edx
f01200ca:	83 c0 1e             	add    $0x1e,%eax
f01200cd:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f01200d4:	eb 1f                	jmp    f01200f5 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f01200d6:	a1 ac 55 74 f0       	mov    0xf07455ac,%eax
f01200db:	8d 50 01             	lea    0x1(%eax),%edx
f01200de:	89 15 ac 55 74 f0    	mov    %edx,0xf07455ac
f01200e4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01200e7:	8b 52 10             	mov    0x10(%edx),%edx
f01200ea:	83 c0 28             	add    $0x28,%eax
f01200ed:	89 14 85 e0 87 76 f0 	mov    %edx,-0xf897820(,%eax,4)
				break;
f01200f4:	90                   	nop
			}
			sched_new_env(env);
f01200f5:	83 ec 0c             	sub    $0xc,%esp
f01200f8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01200fb:	e8 ac 58 fe ff       	call   f01059ac <sched_new_env>
f0120100:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f0120103:	ff 45 e4             	incl   -0x1c(%ebp)
f0120106:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f012010a:	0f 8e ac fe ff ff    	jle    f011ffbc <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f0120110:	83 ec 0c             	sub    $0xc,%esp
f0120113:	68 0c 2f 13 f0       	push   $0xf0132f0c
f0120118:	e8 6e 0e fe ff       	call   f0100f8b <cprintf>
f012011d:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0120120:	83 ec 0c             	sub    $0xc,%esp
f0120123:	68 5b 2f 13 f0       	push   $0xf0132f5b
f0120128:	e8 ce 1d fe ff       	call   f0101efb <execute_command>
f012012d:	83 c4 10             	add    $0x10,%esp
f0120130:	e9 d0 00 00 00       	jmp    f0120205 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f0120135:	83 ec 0c             	sub    $0xc,%esp
f0120138:	6a 00                	push   $0x0
f012013a:	e8 50 0f 00 00       	call   f012108f <chksch>
f012013f:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f0120142:	83 ec 0c             	sub    $0xc,%esp
f0120145:	68 62 2f 13 f0       	push   $0xf0132f62
f012014a:	e8 3c 0e fe ff       	call   f0100f8b <cprintf>
f012014f:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0120152:	e8 8d 5f fe ff       	call   f01060e4 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0120157:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f012015e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0120165:	e9 8a 00 00 00       	jmp    f01201f4 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f012016a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0120171:	eb 55                	jmp    f01201c8 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f0120173:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120176:	8b 14 85 9c 55 74 f0 	mov    -0xf8baa64(,%eax,4),%edx
f012017d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0120180:	89 c8                	mov    %ecx,%eax
f0120182:	c1 e0 02             	shl    $0x2,%eax
f0120185:	01 c8                	add    %ecx,%eax
f0120187:	01 c0                	add    %eax,%eax
f0120189:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f012018c:	01 c8                	add    %ecx,%eax
f012018e:	8b 04 85 e0 87 76 f0 	mov    -0xf897820(,%eax,4),%eax
f0120195:	83 ec 04             	sub    $0x4,%esp
f0120198:	52                   	push   %edx
f0120199:	ff 75 e0             	pushl  -0x20(%ebp)
f012019c:	50                   	push   %eax
f012019d:	e8 7f f8 ff ff       	call   f011fa21 <find_in_range>
f01201a2:	83 c4 10             	add    $0x10,%esp
f01201a5:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f01201a8:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f01201ac:	75 17                	jne    f01201c5 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f01201ae:	83 ec 04             	sub    $0x4,%esp
f01201b1:	68 74 2f 13 f0       	push   $0xf0132f74
f01201b6:	68 ea 00 00 00       	push   $0xea
f01201bb:	68 be 2e 13 f0       	push   $0xf0132ebe
f01201c0:	e8 74 01 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f01201c5:	ff 45 d8             	incl   -0x28(%ebp)
f01201c8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01201cb:	89 d0                	mov    %edx,%eax
f01201cd:	c1 e0 02             	shl    $0x2,%eax
f01201d0:	01 d0                	add    %edx,%eax
f01201d2:	01 c0                	add    %eax,%eax
f01201d4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01201d7:	01 d0                	add    %edx,%eax
f01201d9:	8b 04 85 e0 87 76 f0 	mov    -0xf897820(,%eax,4),%eax
f01201e0:	85 c0                	test   %eax,%eax
f01201e2:	75 8f                	jne    f0120173 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f01201e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01201e7:	8b 04 85 9c 55 74 f0 	mov    -0xf8baa64(,%eax,4),%eax
f01201ee:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f01201f1:	ff 45 dc             	incl   -0x24(%ebp)
f01201f4:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f01201f8:	0f 8e 6c ff ff ff    	jle    f012016a <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f01201fe:	c6 05 5d 3e 18 f0 00 	movb   $0x0,0xf0183e5d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f0120205:	83 ec 0c             	sub    $0xc,%esp
f0120208:	68 1c 31 13 f0       	push   $0xf013311c
f012020d:	e8 79 0d fe ff       	call   f0100f8b <cprintf>
f0120212:	83 c4 10             	add    $0x10,%esp
}
f0120215:	90                   	nop
f0120216:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0120219:	5b                   	pop    %ebx
f012021a:	5e                   	pop    %esi
f012021b:	5f                   	pop    %edi
f012021c:	5d                   	pop    %ebp
f012021d:	c3                   	ret    

f012021e <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f012021e:	55                   	push   %ebp
f012021f:	89 e5                	mov    %esp,%ebp
f0120221:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f0120224:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120227:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f012022a:	8b 45 08             	mov    0x8(%ebp),%eax
f012022d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120230:	89 10                	mov    %edx,(%eax)
}
f0120232:	8b 45 08             	mov    0x8(%ebp),%eax
f0120235:	c9                   	leave  
f0120236:	c2 04 00             	ret    $0x4

f0120239 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f0120239:	55                   	push   %ebp
f012023a:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f012023c:	8b 45 08             	mov    0x8(%ebp),%eax
f012023f:	85 c0                	test   %eax,%eax
f0120241:	78 16                	js     f0120259 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f0120243:	8b 45 08             	mov    0x8(%ebp),%eax
f0120246:	05 00 20 00 00       	add    $0x2000,%eax
f012024b:	85 c0                	test   %eax,%eax
f012024d:	79 05                	jns    f0120254 <fix_round+0x1b>
f012024f:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0120254:	c1 f8 0e             	sar    $0xe,%eax
f0120257:	eb 14                	jmp    f012026d <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f0120259:	8b 45 08             	mov    0x8(%ebp),%eax
f012025c:	2d 00 20 00 00       	sub    $0x2000,%eax
f0120261:	85 c0                	test   %eax,%eax
f0120263:	79 05                	jns    f012026a <fix_round+0x31>
f0120265:	05 ff 3f 00 00       	add    $0x3fff,%eax
f012026a:	c1 f8 0e             	sar    $0xe,%eax
}
f012026d:	5d                   	pop    %ebp
f012026e:	c3                   	ret    

f012026f <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f012026f:	55                   	push   %ebp
f0120270:	89 e5                	mov    %esp,%ebp
f0120272:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f0120275:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120279:	79 16                	jns    f0120291 <fix_scale+0x22>
f012027b:	68 e8 31 13 f0       	push   $0xf01331e8
f0120280:	68 ef 31 13 f0       	push   $0xf01331ef
f0120285:	6a 5a                	push   $0x5a
f0120287:	68 04 32 13 f0       	push   $0xf0133204
f012028c:	e8 a8 00 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f0120291:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120294:	0f af 45 10          	imul   0x10(%ebp),%eax
f0120298:	89 c2                	mov    %eax,%edx
f012029a:	8b 45 08             	mov    0x8(%ebp),%eax
f012029d:	83 ec 08             	sub    $0x8,%esp
f01202a0:	52                   	push   %edx
f01202a1:	50                   	push   %eax
f01202a2:	e8 77 ff ff ff       	call   f012021e <__mk_fix>
f01202a7:	83 c4 0c             	add    $0xc,%esp
}
f01202aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01202ad:	c9                   	leave  
f01202ae:	c2 04 00             	ret    $0x4

f01202b1 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f01202b1:	55                   	push   %ebp
f01202b2:	89 e5                	mov    %esp,%ebp
f01202b4:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f01202b7:	83 ec 08             	sub    $0x8,%esp
f01202ba:	68 18 32 13 f0       	push   $0xf0133218
f01202bf:	68 e0 5f 74 f0       	push   $0xf0745fe0
f01202c4:	e8 f0 04 ff ff       	call   f01107b9 <init_spinlock>
f01202c9:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f01202cc:	83 ec 0c             	sub    $0xc,%esp
f01202cf:	68 e0 5f 74 f0       	push   $0xf0745fe0
f01202d4:	e8 11 05 ff ff       	call   f01107ea <acquire_spinlock>
f01202d9:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f01202dc:	c7 05 e8 56 74 f0 00 	movl   $0x0,0xf07456e8
f01202e3:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f01202e6:	83 ec 0c             	sub    $0xc,%esp
f01202e9:	68 e0 5f 74 f0       	push   $0xf0745fe0
f01202ee:	e8 7e 05 ff ff       	call   f0110871 <release_spinlock>
f01202f3:	83 c4 10             	add    $0x10,%esp
}
f01202f6:	90                   	nop
f01202f7:	c9                   	leave  
f01202f8:	c3                   	ret    

f01202f9 <inctst>:
void inctst()
{
f01202f9:	55                   	push   %ebp
f01202fa:	89 e5                	mov    %esp,%ebp
f01202fc:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f01202ff:	83 ec 0c             	sub    $0xc,%esp
f0120302:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120307:	e8 de 04 ff ff       	call   f01107ea <acquire_spinlock>
f012030c:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f012030f:	a1 e8 56 74 f0       	mov    0xf07456e8,%eax
f0120314:	40                   	inc    %eax
f0120315:	a3 e8 56 74 f0       	mov    %eax,0xf07456e8
	}
	release_spinlock(&tstcntlock);
f012031a:	83 ec 0c             	sub    $0xc,%esp
f012031d:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120322:	e8 4a 05 ff ff       	call   f0110871 <release_spinlock>
f0120327:	83 c4 10             	add    $0x10,%esp
}
f012032a:	90                   	nop
f012032b:	c9                   	leave  
f012032c:	c3                   	ret    

f012032d <gettst>:
uint32 gettst()
{
f012032d:	55                   	push   %ebp
f012032e:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f0120330:	a1 e8 56 74 f0       	mov    0xf07456e8,%eax
}
f0120335:	5d                   	pop    %ebp
f0120336:	c3                   	ret    

f0120337 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f0120337:	55                   	push   %ebp
f0120338:	89 e5                	mov    %esp,%ebp
f012033a:	83 ec 28             	sub    $0x28,%esp
f012033d:	8b 45 14             	mov    0x14(%ebp),%eax
f0120340:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f0120343:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f012034a:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f012034e:	83 f8 65             	cmp    $0x65,%eax
f0120351:	74 5d                	je     f01203b0 <tst+0x79>
f0120353:	83 f8 65             	cmp    $0x65,%eax
f0120356:	7f 0a                	jg     f0120362 <tst+0x2b>
f0120358:	83 f8 62             	cmp    $0x62,%eax
f012035b:	74 73                	je     f01203d0 <tst+0x99>
f012035d:	e9 91 00 00 00       	jmp    f01203f3 <tst+0xbc>
f0120362:	83 f8 67             	cmp    $0x67,%eax
f0120365:	74 29                	je     f0120390 <tst+0x59>
f0120367:	83 f8 6c             	cmp    $0x6c,%eax
f012036a:	0f 85 83 00 00 00    	jne    f01203f3 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f0120370:	8b 45 08             	mov    0x8(%ebp),%eax
f0120373:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120376:	73 09                	jae    f0120381 <tst+0x4a>
			chk = 1;
f0120378:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f012037f:	eb 68                	jmp    f01203e9 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0120381:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0120385:	74 62                	je     f01203e9 <tst+0xb2>
			chk = 1;
f0120387:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f012038e:	eb 59                	jmp    f01203e9 <tst+0xb2>
	case 'g':
		if (n > v1)
f0120390:	8b 45 08             	mov    0x8(%ebp),%eax
f0120393:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120396:	76 09                	jbe    f01203a1 <tst+0x6a>
			chk = 1;
f0120398:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f012039f:	eb 4b                	jmp    f01203ec <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f01203a1:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01203a5:	74 45                	je     f01203ec <tst+0xb5>
			chk = 1;
f01203a7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01203ae:	eb 3c                	jmp    f01203ec <tst+0xb5>
	case 'e':
		if (n == v1)
f01203b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01203b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01203b6:	75 09                	jne    f01203c1 <tst+0x8a>
			chk = 1;
f01203b8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f01203bf:	eb 2e                	jmp    f01203ef <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f01203c1:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f01203c5:	74 28                	je     f01203ef <tst+0xb8>
			chk = 1;
f01203c7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01203ce:	eb 1f                	jmp    f01203ef <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f01203d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01203d3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01203d6:	72 1a                	jb     f01203f2 <tst+0xbb>
f01203d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01203db:	3b 45 10             	cmp    0x10(%ebp),%eax
f01203de:	77 12                	ja     f01203f2 <tst+0xbb>
			chk = 1;
f01203e0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f01203e7:	eb 09                	jmp    f01203f2 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01203e9:	90                   	nop
f01203ea:	eb 07                	jmp    f01203f3 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01203ec:	90                   	nop
f01203ed:	eb 04                	jmp    f01203f3 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f01203ef:	90                   	nop
f01203f0:	eb 01                	jmp    f01203f3 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f01203f2:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f01203f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01203f7:	75 14                	jne    f012040d <tst+0xd6>
f01203f9:	83 ec 04             	sub    $0x4,%esp
f01203fc:	68 24 32 13 f0       	push   $0xf0133224
f0120401:	6a 48                	push   $0x48
f0120403:	68 37 32 13 f0       	push   $0xf0133237
f0120408:	e8 2c ff fd ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f012040d:	83 ec 0c             	sub    $0xc,%esp
f0120410:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120415:	e8 d0 03 ff ff       	call   f01107ea <acquire_spinlock>
f012041a:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f012041d:	a1 e8 56 74 f0       	mov    0xf07456e8,%eax
f0120422:	40                   	inc    %eax
f0120423:	a3 e8 56 74 f0       	mov    %eax,0xf07456e8
	}
	release_spinlock(&tstcntlock);
f0120428:	83 ec 0c             	sub    $0xc,%esp
f012042b:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120430:	e8 3c 04 ff ff       	call   f0110871 <release_spinlock>
f0120435:	83 c4 10             	add    $0x10,%esp

	return;
f0120438:	90                   	nop
}
f0120439:	c9                   	leave  
f012043a:	c3                   	ret    

f012043b <chktst>:

void chktst(uint32 n)
{
f012043b:	55                   	push   %ebp
f012043c:	89 e5                	mov    %esp,%ebp
f012043e:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f0120441:	83 ec 0c             	sub    $0xc,%esp
f0120444:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120449:	e8 9c 03 ff ff       	call   f01107ea <acquire_spinlock>
f012044e:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0120451:	a1 e8 56 74 f0       	mov    0xf07456e8,%eax
f0120456:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f0120459:	83 ec 0c             	sub    $0xc,%esp
f012045c:	68 e0 5f 74 f0       	push   $0xf0745fe0
f0120461:	e8 0b 04 ff ff       	call   f0110871 <release_spinlock>
f0120466:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0120469:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012046c:	3b 45 08             	cmp    0x8(%ebp),%eax
f012046f:	75 12                	jne    f0120483 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0120471:	83 ec 0c             	sub    $0xc,%esp
f0120474:	68 50 32 13 f0       	push   $0xf0133250
f0120479:	e8 0d 0b fe ff       	call   f0100f8b <cprintf>
f012047e:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0120481:	eb 14                	jmp    f0120497 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0120483:	83 ec 04             	sub    $0x4,%esp
f0120486:	68 7c 32 13 f0       	push   $0xf013327c
f012048b:	6a 5e                	push   $0x5e
f012048d:	68 37 32 13 f0       	push   $0xf0133237
f0120492:	e8 a2 fe fd ff       	call   f0100339 <_panic>
}
f0120497:	c9                   	leave  
f0120498:	c3                   	ret    

f0120499 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0120499:	55                   	push   %ebp
f012049a:	89 e5                	mov    %esp,%ebp
f012049c:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f012049f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01204a3:	77 07                	ja     f01204ac <nearest_pow2_ceil+0x13>
f01204a5:	b8 01 00 00 00       	mov    $0x1,%eax
f01204aa:	eb 20                	jmp    f01204cc <nearest_pow2_ceil+0x33>
	int power = 2;
f01204ac:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f01204b3:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f01204b6:	eb 08                	jmp    f01204c0 <nearest_pow2_ceil+0x27>
		power <<= 1;
f01204b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01204bb:	01 c0                	add    %eax,%eax
f01204bd:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f01204c0:	d1 6d 08             	shrl   0x8(%ebp)
f01204c3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01204c7:	75 ef                	jne    f01204b8 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f01204c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01204cc:	c9                   	leave  
f01204cd:	c3                   	ret    

f01204ce <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f01204ce:	55                   	push   %ebp
f01204cf:	89 e5                	mov    %esp,%ebp
f01204d1:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f01204d4:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01204d8:	77 07                	ja     f01204e1 <log2_ceil+0x13>
f01204da:	b8 01 00 00 00       	mov    $0x1,%eax
f01204df:	eb 1b                	jmp    f01204fc <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f01204e1:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f01204e8:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f01204eb:	eb 03                	jmp    f01204f0 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f01204ed:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f01204f0:	d1 6d 08             	shrl   0x8(%ebp)
f01204f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01204f7:	75 f4                	jne    f01204ed <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f01204f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01204fc:	c9                   	leave  
f01204fd:	c3                   	ret    

f01204fe <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f01204fe:	55                   	push   %ebp
f01204ff:	89 e5                	mov    %esp,%ebp
f0120501:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0120504:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f012050b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0120512:	eb 12                	jmp    f0120526 <fixedPt2Str+0x28>
		mulFactor *= 10;
f0120514:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120517:	89 d0                	mov    %edx,%eax
f0120519:	c1 e0 02             	shl    $0x2,%eax
f012051c:	01 d0                	add    %edx,%eax
f012051e:	01 c0                	add    %eax,%eax
f0120520:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0120523:	ff 45 f0             	incl   -0x10(%ebp)
f0120526:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120529:	3b 45 0c             	cmp    0xc(%ebp),%eax
f012052c:	7c e6                	jl     f0120514 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f012052e:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0120531:	83 ec 04             	sub    $0x4,%esp
f0120534:	ff 75 f4             	pushl  -0xc(%ebp)
f0120537:	ff 75 08             	pushl  0x8(%ebp)
f012053a:	50                   	push   %eax
f012053b:	e8 2f fd ff ff       	call   f012026f <fix_scale>
f0120540:	83 c4 0c             	add    $0xc,%esp
f0120543:	83 ec 0c             	sub    $0xc,%esp
f0120546:	ff 75 dc             	pushl  -0x24(%ebp)
f0120549:	e8 eb fc ff ff       	call   f0120239 <fix_round>
f012054e:	83 c4 10             	add    $0x10,%esp
f0120551:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0120554:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120557:	99                   	cltd   
f0120558:	f7 7d f4             	idivl  -0xc(%ebp)
f012055b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f012055e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0120561:	99                   	cltd   
f0120562:	f7 7d f4             	idivl  -0xc(%ebp)
f0120565:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0120568:	83 ec 08             	sub    $0x8,%esp
f012056b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f012056e:	50                   	push   %eax
f012056f:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120572:	e8 6a 1e 00 00       	call   f01223e1 <ltostr>
f0120577:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f012057a:	83 ec 08             	sub    $0x8,%esp
f012057d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120580:	50                   	push   %eax
f0120581:	ff 75 e0             	pushl  -0x20(%ebp)
f0120584:	e8 58 1e 00 00       	call   f01223e1 <ltostr>
f0120589:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f012058c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f012058f:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120594:	f7 e9                	imul   %ecx
f0120596:	c1 fa 02             	sar    $0x2,%edx
f0120599:	89 c8                	mov    %ecx,%eax
f012059b:	c1 f8 1f             	sar    $0x1f,%eax
f012059e:	29 c2                	sub    %eax,%edx
f01205a0:	89 d0                	mov    %edx,%eax
f01205a2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f01205a5:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f01205ac:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f01205b3:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f01205b9:	eb 31                	jmp    f01205ec <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f01205bb:	83 ec 04             	sub    $0x4,%esp
f01205be:	8d 45 aa             	lea    -0x56(%ebp),%eax
f01205c1:	50                   	push   %eax
f01205c2:	8d 45 aa             	lea    -0x56(%ebp),%eax
f01205c5:	50                   	push   %eax
f01205c6:	68 98 32 13 f0       	push   $0xf0133298
f01205cb:	e8 ea 1e 00 00       	call   f01224ba <strcconcat>
f01205d0:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f01205d3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01205d6:	b8 67 66 66 66       	mov    $0x66666667,%eax
f01205db:	f7 e9                	imul   %ecx
f01205dd:	c1 fa 02             	sar    $0x2,%edx
f01205e0:	89 c8                	mov    %ecx,%eax
f01205e2:	c1 f8 1f             	sar    $0x1f,%eax
f01205e5:	29 c2                	sub    %eax,%edx
f01205e7:	89 d0                	mov    %edx,%eax
f01205e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f01205ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01205ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01205f2:	7c c7                	jl     f01205bb <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f01205f4:	83 ec 04             	sub    $0x4,%esp
f01205f7:	8d 45 96             	lea    -0x6a(%ebp),%eax
f01205fa:	50                   	push   %eax
f01205fb:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f01205fe:	50                   	push   %eax
f01205ff:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0120602:	50                   	push   %eax
f0120603:	e8 b2 1e 00 00       	call   f01224ba <strcconcat>
f0120608:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f012060b:	83 ec 04             	sub    $0x4,%esp
f012060e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120611:	50                   	push   %eax
f0120612:	68 9a 32 13 f0       	push   $0xf013329a
f0120617:	8d 45 c8             	lea    -0x38(%ebp),%eax
f012061a:	50                   	push   %eax
f012061b:	e8 9a 1e 00 00       	call   f01224ba <strcconcat>
f0120620:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0120623:	83 ec 04             	sub    $0x4,%esp
f0120626:	ff 75 10             	pushl  0x10(%ebp)
f0120629:	8d 45 96             	lea    -0x6a(%ebp),%eax
f012062c:	50                   	push   %eax
f012062d:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0120630:	50                   	push   %eax
f0120631:	e8 84 1e 00 00       	call   f01224ba <strcconcat>
f0120636:	83 c4 10             	add    $0x10,%esp

}
f0120639:	90                   	nop
f012063a:	c9                   	leave  
f012063b:	c3                   	ret    

f012063c <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f012063c:	55                   	push   %ebp
f012063d:	89 e5                	mov    %esp,%ebp
f012063f:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0120645:	83 ec 0c             	sub    $0xc,%esp
f0120648:	68 9c 32 13 f0       	push   $0xf013329c
f012064d:	e8 e9 18 00 00       	call   f0121f3b <strlen>
f0120652:	83 c4 10             	add    $0x10,%esp
f0120655:	83 ec 04             	sub    $0x4,%esp
f0120658:	50                   	push   %eax
f0120659:	68 9c 32 13 f0       	push   $0xf013329c
f012065e:	ff 75 08             	pushl  0x8(%ebp)
f0120661:	e8 19 1a 00 00       	call   f012207f <strncmp>
f0120666:	83 c4 10             	add    $0x10,%esp
f0120669:	85 c0                	test   %eax,%eax
f012066b:	0f 85 8a 00 00 00    	jne    f01206fb <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0120671:	8d 45 bc             	lea    -0x44(%ebp),%eax
f0120674:	50                   	push   %eax
f0120675:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f012067b:	50                   	push   %eax
f012067c:	68 aa 32 13 f0       	push   $0xf01332aa
f0120681:	ff 75 08             	pushl  0x8(%ebp)
f0120684:	e8 c7 1e 00 00       	call   f0122550 <strsplit>
f0120689:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f012068c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0120692:	83 ec 04             	sub    $0x4,%esp
f0120695:	6a 0a                	push   $0xa
f0120697:	6a 00                	push   $0x0
f0120699:	50                   	push   %eax
f012069a:	e8 fc 1b 00 00       	call   f012229b <strtol>
f012069f:	83 c4 10             	add    $0x10,%esp
f01206a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f01206a5:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f01206ac:	83 ec 04             	sub    $0x4,%esp
f01206af:	6a 00                	push   $0x0
f01206b1:	8d 45 b8             	lea    -0x48(%ebp),%eax
f01206b4:	50                   	push   %eax
f01206b5:	ff 75 e0             	pushl  -0x20(%ebp)
f01206b8:	e8 d7 b8 fe ff       	call   f010bf94 <envid2env>
f01206bd:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f01206c0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01206c3:	8b 40 10             	mov    0x10(%eax),%eax
f01206c6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01206c9:	74 19                	je     f01206e4 <sys_utilities+0xa8>
f01206cb:	68 ac 32 13 f0       	push   $0xf01332ac
f01206d0:	68 ef 31 13 f0       	push   $0xf01331ef
f01206d5:	68 a4 00 00 00       	push   $0xa4
f01206da:	68 37 32 13 f0       	push   $0xf0133237
f01206df:	e8 55 fc fd ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f01206e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01206e7:	83 ec 08             	sub    $0x8,%esp
f01206ea:	ff 75 0c             	pushl  0xc(%ebp)
f01206ed:	50                   	push   %eax
f01206ee:	e8 23 62 fe ff       	call   f0106916 <env_set_nice>
f01206f3:	83 c4 10             	add    $0x10,%esp
f01206f6:	e9 12 04 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f01206fb:	83 ec 0c             	sub    $0xc,%esp
f01206fe:	68 c1 32 13 f0       	push   $0xf01332c1
f0120703:	e8 33 18 00 00       	call   f0121f3b <strlen>
f0120708:	83 c4 10             	add    $0x10,%esp
f012070b:	83 ec 04             	sub    $0x4,%esp
f012070e:	50                   	push   %eax
f012070f:	68 c1 32 13 f0       	push   $0xf01332c1
f0120714:	ff 75 08             	pushl  0x8(%ebp)
f0120717:	e8 63 19 00 00       	call   f012207f <strncmp>
f012071c:	83 c4 10             	add    $0x10,%esp
f012071f:	85 c0                	test   %eax,%eax
f0120721:	0f 85 a6 01 00 00    	jne    f01208cd <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f0120727:	8b 45 0c             	mov    0xc(%ebp),%eax
f012072a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f012072d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0120730:	50                   	push   %eax
f0120731:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0120737:	50                   	push   %eax
f0120738:	68 aa 32 13 f0       	push   $0xf01332aa
f012073d:	ff 75 08             	pushl  0x8(%ebp)
f0120740:	e8 0b 1e 00 00       	call   f0122550 <strsplit>
f0120745:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0120748:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f012074e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f0120751:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0120758:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f012075f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0120766:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120769:	8b 00                	mov    (%eax),%eax
f012076b:	85 c0                	test   %eax,%eax
f012076d:	79 1c                	jns    f012078b <sys_utilities+0x14f>
		{
			chkAscending = 0;
f012076f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0120776:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120779:	8b 00                	mov    (%eax),%eax
f012077b:	f7 d8                	neg    %eax
f012077d:	89 c2                	mov    %eax,%edx
f012077f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120782:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0120784:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f012078b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f0120792:	83 ec 0c             	sub    $0xc,%esp
f0120795:	68 00 58 74 f0       	push   $0xf0745800
f012079a:	e8 4b 00 ff ff       	call   f01107ea <acquire_spinlock>
f012079f:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01207a2:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f01207a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01207aa:	a1 84 58 74 f0       	mov    0xf0745884,%eax
f01207af:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f01207b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01207b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01207b8:	eb 6c                	jmp    f0120826 <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f01207ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207bd:	83 c0 20             	add    $0x20,%eax
f01207c0:	83 ec 08             	sub    $0x8,%esp
f01207c3:	ff 75 d8             	pushl  -0x28(%ebp)
f01207c6:	50                   	push   %eax
f01207c7:	e8 7b 18 00 00       	call   f0122047 <strcmp>
f01207cc:	83 c4 10             	add    $0x10,%esp
f01207cf:	85 c0                	test   %eax,%eax
f01207d1:	75 46                	jne    f0120819 <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f01207d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207d6:	8b 00                	mov    (%eax),%eax
f01207d8:	8d 50 ff             	lea    -0x1(%eax),%edx
f01207db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01207de:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f01207e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01207e4:	74 14                	je     f01207fa <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f01207e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207e9:	8b 40 10             	mov    0x10(%eax),%eax
f01207ec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01207ef:	7d 1d                	jge    f012080e <sys_utilities+0x1d2>
					{
						success = 0;
f01207f1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f01207f8:	eb 32                	jmp    f012082c <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f01207fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01207fd:	8b 40 10             	mov    0x10(%eax),%eax
f0120800:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0120803:	7e 09                	jle    f012080e <sys_utilities+0x1d2>
					{
						success = 0;
f0120805:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f012080c:	eb 1e                	jmp    f012082c <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f012080e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120811:	8b 40 10             	mov    0x10(%eax),%eax
f0120814:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120817:	eb 01                	jmp    f012081a <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0120819:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f012081a:	ff 4d e4             	decl   -0x1c(%ebp)
f012081d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120820:	8b 40 0c             	mov    0xc(%eax),%eax
f0120823:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120826:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012082a:	7f 8e                	jg     f01207ba <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f012082c:	83 ec 0c             	sub    $0xc,%esp
f012082f:	68 00 58 74 f0       	push   $0xf0745800
f0120834:	e8 38 00 ff ff       	call   f0110871 <release_spinlock>
f0120839:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f012083c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012083f:	8b 00                	mov    (%eax),%eax
f0120841:	85 c0                	test   %eax,%eax
f0120843:	75 06                	jne    f012084b <sys_utilities+0x20f>
f0120845:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0120849:	75 41                	jne    f012088c <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f012084b:	83 ec 0c             	sub    $0xc,%esp
f012084e:	68 d4 32 13 f0       	push   $0xf01332d4
f0120853:	e8 33 07 fe ff       	call   f0100f8b <cprintf>
f0120858:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f012085b:	83 ec 08             	sub    $0x8,%esp
f012085e:	ff 75 d8             	pushl  -0x28(%ebp)
f0120861:	68 04 33 13 f0       	push   $0xf0133304
f0120866:	e8 20 07 fe ff       	call   f0100f8b <cprintf>
f012086b:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f012086e:	83 ec 0c             	sub    $0xc,%esp
f0120871:	68 d4 32 13 f0       	push   $0xf01332d4
f0120876:	e8 10 07 fe ff       	call   f0100f8b <cprintf>
f012087b:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f012087e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120881:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120887:	e9 81 02 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f012088c:	83 ec 0c             	sub    $0xc,%esp
f012088f:	68 24 33 13 f0       	push   $0xf0133324
f0120894:	e8 f2 06 fe ff       	call   f0100f8b <cprintf>
f0120899:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f012089c:	83 ec 08             	sub    $0x8,%esp
f012089f:	ff 75 d8             	pushl  -0x28(%ebp)
f01208a2:	68 5c 33 13 f0       	push   $0xf013335c
f01208a7:	e8 df 06 fe ff       	call   f0100f8b <cprintf>
f01208ac:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f01208af:	83 ec 0c             	sub    $0xc,%esp
f01208b2:	68 24 33 13 f0       	push   $0xf0133324
f01208b7:	e8 cf 06 fe ff       	call   f0100f8b <cprintf>
f01208bc:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f01208bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01208c2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f01208c8:	e9 40 02 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f01208cd:	83 ec 08             	sub    $0x8,%esp
f01208d0:	68 7f 33 13 f0       	push   $0xf013337f
f01208d5:	ff 75 08             	pushl  0x8(%ebp)
f01208d8:	e8 6a 17 00 00       	call   f0122047 <strcmp>
f01208dd:	83 c4 10             	add    $0x10,%esp
f01208e0:	85 c0                	test   %eax,%eax
f01208e2:	75 77                	jne    f012095b <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f01208e4:	a1 60 3e 18 f0       	mov    0xf0183e60,%eax
f01208e9:	85 c0                	test   %eax,%eax
f01208eb:	74 34                	je     f0120921 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f01208ed:	c7 05 60 3e 18 f0 00 	movl   $0x0,0xf0183e60
f01208f4:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f01208f7:	83 ec 08             	sub    $0x8,%esp
f01208fa:	68 89 33 13 f0       	push   $0xf0133389
f01208ff:	68 c0 88 76 f0       	push   $0xf07688c0
f0120904:	e8 a2 02 ff ff       	call   f0110bab <init_channel>
f0120909:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f012090c:	83 ec 08             	sub    $0x8,%esp
f012090f:	68 96 33 13 f0       	push   $0xf0133396
f0120914:	68 40 8a 76 f0       	push   $0xf0768a40
f0120919:	e8 9b fe fe ff       	call   f01107b9 <init_spinlock>
f012091e:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f0120921:	83 ec 0c             	sub    $0xc,%esp
f0120924:	68 40 8a 76 f0       	push   $0xf0768a40
f0120929:	e8 bc fe fe ff       	call   f01107ea <acquire_spinlock>
f012092e:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f0120931:	83 ec 08             	sub    $0x8,%esp
f0120934:	68 40 8a 76 f0       	push   $0xf0768a40
f0120939:	68 c0 88 76 f0       	push   $0xf07688c0
f012093e:	e8 95 02 ff ff       	call   f0110bd8 <sleep>
f0120943:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f0120946:	83 ec 0c             	sub    $0xc,%esp
f0120949:	68 40 8a 76 f0       	push   $0xf0768a40
f012094e:	e8 1e ff fe ff       	call   f0110871 <release_spinlock>
f0120953:	83 c4 10             	add    $0x10,%esp
f0120956:	e9 b2 01 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f012095b:	83 ec 08             	sub    $0x8,%esp
f012095e:	68 a8 33 13 f0       	push   $0xf01333a8
f0120963:	ff 75 08             	pushl  0x8(%ebp)
f0120966:	e8 dc 16 00 00       	call   f0122047 <strcmp>
f012096b:	83 c4 10             	add    $0x10,%esp
f012096e:	85 c0                	test   %eax,%eax
f0120970:	75 15                	jne    f0120987 <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f0120972:	83 ec 0c             	sub    $0xc,%esp
f0120975:	68 c0 88 76 f0       	push   $0xf07688c0
f012097a:	e8 c7 02 ff ff       	call   f0110c46 <wakeup_one>
f012097f:	83 c4 10             	add    $0x10,%esp
f0120982:	e9 86 01 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0120987:	83 ec 08             	sub    $0x8,%esp
f012098a:	68 b6 33 13 f0       	push   $0xf01333b6
f012098f:	ff 75 08             	pushl  0x8(%ebp)
f0120992:	e8 b0 16 00 00       	call   f0122047 <strcmp>
f0120997:	83 c4 10             	add    $0x10,%esp
f012099a:	85 c0                	test   %eax,%eax
f012099c:	75 15                	jne    f01209b3 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f012099e:	83 ec 0c             	sub    $0xc,%esp
f01209a1:	68 c0 88 76 f0       	push   $0xf07688c0
f01209a6:	e8 10 03 ff ff       	call   f0110cbb <wakeup_all>
f01209ab:	83 c4 10             	add    $0x10,%esp
f01209ae:	e9 5a 01 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f01209b3:	83 ec 08             	sub    $0x8,%esp
f01209b6:	68 c4 33 13 f0       	push   $0xf01333c4
f01209bb:	ff 75 08             	pushl  0x8(%ebp)
f01209be:	e8 84 16 00 00       	call   f0122047 <strcmp>
f01209c3:	83 c4 10             	add    $0x10,%esp
f01209c6:	85 c0                	test   %eax,%eax
f01209c8:	75 17                	jne    f01209e1 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f01209ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209cd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f01209d0:	a1 cc 88 76 f0       	mov    0xf07688cc,%eax
f01209d5:	89 c2                	mov    %eax,%edx
f01209d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01209da:	89 10                	mov    %edx,(%eax)
f01209dc:	e9 2c 01 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f01209e1:	83 ec 08             	sub    $0x8,%esp
f01209e4:	68 d9 33 13 f0       	push   $0xf01333d9
f01209e9:	ff 75 08             	pushl  0x8(%ebp)
f01209ec:	e8 56 16 00 00       	call   f0122047 <strcmp>
f01209f1:	83 c4 10             	add    $0x10,%esp
f01209f4:	85 c0                	test   %eax,%eax
f01209f6:	75 1a                	jne    f0120a12 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f01209f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209fb:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f01209fe:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120a03:	8b 40 0c             	mov    0xc(%eax),%eax
f0120a06:	89 c2                	mov    %eax,%edx
f0120a08:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120a0b:	89 10                	mov    %edx,(%eax)
f0120a0d:	e9 fb 00 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f0120a12:	83 ec 08             	sub    $0x8,%esp
f0120a15:	68 ef 33 13 f0       	push   $0xf01333ef
f0120a1a:	ff 75 08             	pushl  0x8(%ebp)
f0120a1d:	e8 25 16 00 00       	call   f0122047 <strcmp>
f0120a22:	83 c4 10             	add    $0x10,%esp
f0120a25:	85 c0                	test   %eax,%eax
f0120a27:	75 3d                	jne    f0120a66 <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f0120a29:	a1 64 3e 18 f0       	mov    0xf0183e64,%eax
f0120a2e:	85 c0                	test   %eax,%eax
f0120a30:	74 1f                	je     f0120a51 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f0120a32:	c7 05 64 3e 18 f0 00 	movl   $0x0,0xf0183e64
f0120a39:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f0120a3c:	83 ec 08             	sub    $0x8,%esp
f0120a3f:	68 04 34 13 f0       	push   $0xf0133404
f0120a44:	68 20 89 76 f0       	push   $0xf0768920
f0120a49:	e8 f6 ff fe ff       	call   f0110a44 <init_sleeplock>
f0120a4e:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f0120a51:	83 ec 0c             	sub    $0xc,%esp
f0120a54:	68 20 89 76 f0       	push   $0xf0768920
f0120a59:	e8 aa 00 ff ff       	call   f0110b08 <acquire_sleeplock>
f0120a5e:	83 c4 10             	add    $0x10,%esp
f0120a61:	e9 a7 00 00 00       	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f0120a66:	83 ec 08             	sub    $0x8,%esp
f0120a69:	68 14 34 13 f0       	push   $0xf0133414
f0120a6e:	ff 75 08             	pushl  0x8(%ebp)
f0120a71:	e8 d1 15 00 00       	call   f0122047 <strcmp>
f0120a76:	83 c4 10             	add    $0x10,%esp
f0120a79:	85 c0                	test   %eax,%eax
f0120a7b:	75 12                	jne    f0120a8f <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f0120a7d:	83 ec 0c             	sub    $0xc,%esp
f0120a80:	68 20 89 76 f0       	push   $0xf0768920
f0120a85:	e8 d9 00 ff ff       	call   f0110b63 <release_sleeplock>
f0120a8a:	83 c4 10             	add    $0x10,%esp
f0120a8d:	eb 7e                	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f0120a8f:	83 ec 08             	sub    $0x8,%esp
f0120a92:	68 29 34 13 f0       	push   $0xf0133429
f0120a97:	ff 75 08             	pushl  0x8(%ebp)
f0120a9a:	e8 a8 15 00 00       	call   f0122047 <strcmp>
f0120a9f:	83 c4 10             	add    $0x10,%esp
f0120aa2:	85 c0                	test   %eax,%eax
f0120aa4:	75 14                	jne    f0120aba <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f0120aa6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aa9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f0120aac:	a1 a0 89 76 f0       	mov    0xf07689a0,%eax
f0120ab1:	89 c2                	mov    %eax,%edx
f0120ab3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120ab6:	89 10                	mov    %edx,(%eax)
f0120ab8:	eb 53                	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f0120aba:	83 ec 08             	sub    $0x8,%esp
f0120abd:	68 3e 34 13 f0       	push   $0xf013343e
f0120ac2:	ff 75 08             	pushl  0x8(%ebp)
f0120ac5:	e8 7d 15 00 00       	call   f0122047 <strcmp>
f0120aca:	83 c4 10             	add    $0x10,%esp
f0120acd:	85 c0                	test   %eax,%eax
f0120acf:	75 13                	jne    f0120ae4 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f0120ad1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ad4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f0120ad7:	8b 15 20 89 76 f0    	mov    0xf0768920,%edx
f0120add:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120ae0:	89 10                	mov    %edx,(%eax)
f0120ae2:	eb 29                	jmp    f0120b0d <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f0120ae4:	83 ec 08             	sub    $0x8,%esp
f0120ae7:	68 4f 34 13 f0       	push   $0xf013344f
f0120aec:	ff 75 08             	pushl  0x8(%ebp)
f0120aef:	e8 53 15 00 00       	call   f0122047 <strcmp>
f0120af4:	83 c4 10             	add    $0x10,%esp
f0120af7:	85 c0                	test   %eax,%eax
f0120af9:	75 12                	jne    f0120b0d <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f0120afb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120afe:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f0120b01:	a1 24 8a 76 f0       	mov    0xf0768a24,%eax
f0120b06:	89 c2                	mov    %eax,%edx
f0120b08:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120b0b:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f0120b0d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120b11:	79 5b                	jns    f0120b6e <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f0120b13:	83 ec 08             	sub    $0x8,%esp
f0120b16:	68 60 34 13 f0       	push   $0xf0133460
f0120b1b:	ff 75 08             	pushl  0x8(%ebp)
f0120b1e:	e8 24 15 00 00       	call   f0122047 <strcmp>
f0120b23:	83 c4 10             	add    $0x10,%esp
f0120b26:	85 c0                	test   %eax,%eax
f0120b28:	75 44                	jne    f0120b6e <sys_utilities+0x532>
		{
			switch (value)
f0120b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b2d:	83 f8 fc             	cmp    $0xfffffffc,%eax
f0120b30:	74 07                	je     f0120b39 <sys_utilities+0x4fd>
f0120b32:	83 f8 fe             	cmp    $0xfffffffe,%eax
f0120b35:	74 19                	je     f0120b50 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f0120b37:	eb 35                	jmp    f0120b6e <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f0120b39:	83 ec 0c             	sub    $0xc,%esp
f0120b3c:	68 70 34 13 f0       	push   $0xf0133470
f0120b41:	e8 45 04 fe ff       	call   f0100f8b <cprintf>
f0120b46:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f0120b49:	e8 de f0 fe ff       	call   f010fc2c <setPageReplacmentAlgorithmFIFO>
				break;
f0120b4e:	eb 1e                	jmp    f0120b6e <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f0120b50:	83 ec 0c             	sub    $0xc,%esp
f0120b53:	68 e0 34 13 f0       	push   $0xf01334e0
f0120b58:	e8 2e 04 fe ff       	call   f0100f8b <cprintf>
f0120b5d:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f0120b60:	83 ec 0c             	sub    $0xc,%esp
f0120b63:	6a 02                	push   $0x2
f0120b65:	e8 7f f0 fe ff       	call   f010fbe9 <setPageReplacmentAlgorithmLRU>
f0120b6a:	83 c4 10             	add    $0x10,%esp
				break;
f0120b6d:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f0120b6e:	90                   	nop
f0120b6f:	c9                   	leave  
f0120b70:	c3                   	ret    

f0120b71 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f0120b71:	55                   	push   %ebp
f0120b72:	89 e5                	mov    %esp,%ebp
f0120b74:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f0120b77:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b7a:	8b 00                	mov    (%eax),%eax
f0120b7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f0120b7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b82:	8b 00                	mov    (%eax),%eax
f0120b84:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f0120b87:	eb 52                	jmp    f0120bdb <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0120b89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b8c:	8b 00                	mov    (%eax),%eax
f0120b8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f0120b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120b94:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120b97:	75 12                	jne    f0120bab <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f0120b99:	83 ec 0c             	sub    $0xc,%esp
f0120b9c:	68 54 35 13 f0       	push   $0xf0133554
f0120ba1:	e8 e5 03 fe ff       	call   f0100f8b <cprintf>
f0120ba6:	83 c4 10             	add    $0x10,%esp
			break;
f0120ba9:	eb 3f                	jmp    f0120bea <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f0120bab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120baf:	74 38                	je     f0120be9 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f0120bb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bb4:	8b 00                	mov    (%eax),%eax
f0120bb6:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0120bb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120bbc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120bbf:	75 12                	jne    f0120bd3 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f0120bc1:	83 ec 0c             	sub    $0xc,%esp
f0120bc4:	68 70 35 13 f0       	push   $0xf0133570
f0120bc9:	e8 bd 03 fe ff       	call   f0100f8b <cprintf>
f0120bce:	83 c4 10             	add    $0x10,%esp
			break;
f0120bd1:	eb 17                	jmp    f0120bea <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f0120bd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120bd6:	8b 00                	mov    (%eax),%eax
f0120bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0120bdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120bdf:	74 09                	je     f0120bea <detect_loop_in_FrameInfo_list+0x79>
f0120be1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120be5:	75 a2                	jne    f0120b89 <detect_loop_in_FrameInfo_list+0x18>
f0120be7:	eb 01                	jmp    f0120bea <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0120be9:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0120bea:	83 ec 0c             	sub    $0xc,%esp
f0120bed:	68 87 35 13 f0       	push   $0xf0133587
f0120bf2:	e8 94 03 fe ff       	call   f0100f8b <cprintf>
f0120bf7:	83 c4 10             	add    $0x10,%esp
}
f0120bfa:	90                   	nop
f0120bfb:	c9                   	leave  
f0120bfc:	c3                   	ret    

f0120bfd <scarce_memory>:

void scarce_memory()
{
f0120bfd:	55                   	push   %ebp
f0120bfe:	89 e5                	mov    %esp,%ebp
f0120c00:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f0120c03:	a1 d0 59 74 f0       	mov    0xf07459d0,%eax
f0120c08:	ba 64 00 00 00       	mov    $0x64,%edx
f0120c0d:	29 c2                	sub    %eax,%edx
f0120c0f:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0120c14:	0f af c2             	imul   %edx,%eax
f0120c17:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0120c1c:	f7 e2                	mul    %edx
f0120c1e:	89 d0                	mov    %edx,%eax
f0120c20:	c1 e8 05             	shr    $0x5,%eax
f0120c23:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f0120c26:	a1 d0 59 74 f0       	mov    0xf07459d0,%eax
f0120c2b:	ba 64 00 00 00       	mov    $0x64,%edx
f0120c30:	29 c2                	sub    %eax,%edx
f0120c32:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f0120c37:	89 d1                	mov    %edx,%ecx
f0120c39:	0f af c8             	imul   %eax,%ecx
f0120c3c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0120c41:	f7 e1                	mul    %ecx
f0120c43:	c1 ea 05             	shr    $0x5,%edx
f0120c46:	89 d0                	mov    %edx,%eax
f0120c48:	c1 e0 02             	shl    $0x2,%eax
f0120c4b:	01 d0                	add    %edx,%eax
f0120c4d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120c54:	01 d0                	add    %edx,%eax
f0120c56:	c1 e0 02             	shl    $0x2,%eax
f0120c59:	29 c1                	sub    %eax,%ecx
f0120c5b:	89 ca                	mov    %ecx,%edx
f0120c5d:	85 d2                	test   %edx,%edx
f0120c5f:	74 03                	je     f0120c64 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f0120c61:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f0120c64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f0120c6b:	83 ec 0c             	sub    $0xc,%esp
f0120c6e:	68 c0 58 74 f0       	push   $0xf07458c0
f0120c73:	e8 72 fb fe ff       	call   f01107ea <acquire_spinlock>
f0120c78:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f0120c7b:	a1 ac 58 74 f0       	mov    0xf07458ac,%eax
f0120c80:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f0120c83:	8b 15 98 5a 74 f0    	mov    0xf0745a98,%edx
f0120c89:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120c8c:	29 c2                	sub    %eax,%edx
f0120c8e:	89 d0                	mov    %edx,%eax
f0120c90:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f0120c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c96:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0120c99:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0120c9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0120ca3:	eb 12                	jmp    f0120cb7 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f0120ca5:	83 ec 0c             	sub    $0xc,%esp
f0120ca8:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0120cab:	50                   	push   %eax
f0120cac:	e8 f2 7b fe ff       	call   f01088a3 <allocate_frame>
f0120cb1:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f0120cb4:	ff 45 f0             	incl   -0x10(%ebp)
f0120cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cba:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0120cbd:	76 e6                	jbe    f0120ca5 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f0120cbf:	83 ec 0c             	sub    $0xc,%esp
f0120cc2:	68 c0 58 74 f0       	push   $0xf07458c0
f0120cc7:	e8 a5 fb fe ff       	call   f0110871 <release_spinlock>
f0120ccc:	83 c4 10             	add    $0x10,%esp

}
f0120ccf:	90                   	nop
f0120cd0:	c9                   	leave  
f0120cd1:	c3                   	ret    

f0120cd2 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f0120cd2:	55                   	push   %ebp
f0120cd3:	89 e5                	mov    %esp,%ebp
f0120cd5:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0120cd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0120cdf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f0120ce6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0120ced:	e8 52 b2 fe ff       	call   f010bf44 <get_cpu_proc>
f0120cf2:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f0120cf5:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0120cf9:	75 19                	jne    f0120d14 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0120cfb:	68 a1 35 13 f0       	push   $0xf01335a1
f0120d00:	68 ef 31 13 f0       	push   $0xf01331ef
f0120d05:	68 79 01 00 00       	push   $0x179
f0120d0a:	68 37 32 13 f0       	push   $0xf0133237
f0120d0f:	e8 25 f6 fd ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f0120d14:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0120d18:	0f 85 d6 01 00 00    	jne    f0120ef4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0120d1e:	83 ec 0c             	sub    $0xc,%esp
f0120d21:	68 00 58 74 f0       	push   $0xf0745800
f0120d26:	e8 bf fa fe ff       	call   f01107ea <acquire_spinlock>
f0120d2b:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f0120d2e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0120d35:	e9 d2 00 00 00       	jmp    f0120e0c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f0120d3a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0120d41:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120d46:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120d49:	c1 e2 04             	shl    $0x4,%edx
f0120d4c:	01 d0                	add    %edx,%eax
f0120d4e:	8b 00                	mov    (%eax),%eax
f0120d50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0120d53:	eb 7c                	jmp    f0120dd1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f0120d55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0120d58:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0120d5e:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0120d61:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120d64:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120d6a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120d6d:	0f af c2             	imul   %edx,%eax
f0120d70:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0120d75:	f7 e2                	mul    %edx
f0120d77:	89 d0                	mov    %edx,%eax
f0120d79:	c1 e8 05             	shr    $0x5,%eax
f0120d7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0120d7f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120d82:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120d88:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0120d8b:	89 d1                	mov    %edx,%ecx
f0120d8d:	0f af c8             	imul   %eax,%ecx
f0120d90:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0120d95:	f7 e1                	mul    %ecx
f0120d97:	c1 ea 05             	shr    $0x5,%edx
f0120d9a:	89 d0                	mov    %edx,%eax
f0120d9c:	c1 e0 02             	shl    $0x2,%eax
f0120d9f:	01 d0                	add    %edx,%eax
f0120da1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120da8:	01 d0                	add    %edx,%eax
f0120daa:	c1 e0 02             	shl    $0x2,%eax
f0120dad:	29 c1                	sub    %eax,%ecx
f0120daf:	89 ca                	mov    %ecx,%edx
f0120db1:	85 d2                	test   %edx,%edx
f0120db3:	74 03                	je     f0120db8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f0120db5:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0120db8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120dbb:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0120dbe:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120dc3:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120dc6:	c1 e2 04             	shl    $0x4,%edx
f0120dc9:	01 d0                	add    %edx,%eax
f0120dcb:	8b 40 08             	mov    0x8(%eax),%eax
f0120dce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0120dd1:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120dd6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120dd9:	c1 e2 04             	shl    $0x4,%edx
f0120ddc:	01 d0                	add    %edx,%eax
f0120dde:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120de2:	74 08                	je     f0120dec <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f0120de4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120de7:	8b 52 08             	mov    0x8(%edx),%edx
f0120dea:	eb 05                	jmp    f0120df1 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f0120dec:	ba 00 00 00 00       	mov    $0x0,%edx
f0120df1:	89 50 08             	mov    %edx,0x8(%eax)
f0120df4:	8b 40 08             	mov    0x8(%eax),%eax
f0120df7:	85 c0                	test   %eax,%eax
f0120df9:	0f 85 56 ff ff ff    	jne    f0120d55 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f0120dff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120e03:	0f 85 4c ff ff ff    	jne    f0120d55 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f0120e09:	ff 45 e8             	incl   -0x18(%ebp)
f0120e0c:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0120e11:	0f b6 c0             	movzbl %al,%eax
f0120e14:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0120e17:	0f 8f 1d ff ff ff    	jg     f0120d3a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f0120e1d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f0120e24:	a1 80 58 74 f0       	mov    0xf0745880,%eax
f0120e29:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120e2c:	eb 1a                	jmp    f0120e48 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f0120e2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e31:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0120e37:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f0120e3a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e3d:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f0120e40:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0120e45:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120e48:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120e4c:	74 08                	je     f0120e56 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f0120e4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e51:	8b 40 08             	mov    0x8(%eax),%eax
f0120e54:	eb 05                	jmp    f0120e5b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f0120e56:	b8 00 00 00 00       	mov    $0x0,%eax
f0120e5b:	a3 88 58 74 f0       	mov    %eax,0xf0745888
f0120e60:	a1 88 58 74 f0       	mov    0xf0745888,%eax
f0120e65:	85 c0                	test   %eax,%eax
f0120e67:	75 c5                	jne    f0120e2e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f0120e69:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120e6d:	75 bf                	jne    f0120e2e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f0120e6f:	83 ec 0c             	sub    $0xc,%esp
f0120e72:	68 00 58 74 f0       	push   $0xf0745800
f0120e77:	e8 f5 f9 fe ff       	call   f0110871 <release_spinlock>
f0120e7c:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0120e7f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0120e83:	0f 84 d4 00 00 00    	je     f0120f5d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0120e89:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120e8c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0120e92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0120e95:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120e98:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120e9e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120ea1:	0f af c2             	imul   %edx,%eax
f0120ea4:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0120ea9:	f7 e2                	mul    %edx
f0120eab:	89 d0                	mov    %edx,%eax
f0120ead:	c1 e8 05             	shr    $0x5,%eax
f0120eb0:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0120eb3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120eb6:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120ebc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120ebf:	89 d1                	mov    %edx,%ecx
f0120ec1:	0f af c8             	imul   %eax,%ecx
f0120ec4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0120ec9:	f7 e1                	mul    %ecx
f0120ecb:	c1 ea 05             	shr    $0x5,%edx
f0120ece:	89 d0                	mov    %edx,%eax
f0120ed0:	c1 e0 02             	shl    $0x2,%eax
f0120ed3:	01 d0                	add    %edx,%eax
f0120ed5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120edc:	01 d0                	add    %edx,%eax
f0120ede:	c1 e0 02             	shl    $0x2,%eax
f0120ee1:	29 c1                	sub    %eax,%ecx
f0120ee3:	89 ca                	mov    %ecx,%edx
f0120ee5:	85 d2                	test   %edx,%edx
f0120ee7:	74 03                	je     f0120eec <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f0120ee9:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0120eec:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120eef:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0120ef2:	eb 69                	jmp    f0120f5d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0120ef4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120ef7:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
f0120efd:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0120f00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120f03:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120f09:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120f0c:	0f af c2             	imul   %edx,%eax
f0120f0f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0120f14:	f7 e2                	mul    %edx
f0120f16:	89 d0                	mov    %edx,%eax
f0120f18:	c1 e8 05             	shr    $0x5,%eax
f0120f1b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0120f1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120f21:	8b 90 90 05 00 00    	mov    0x590(%eax),%edx
f0120f27:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120f2a:	89 d1                	mov    %edx,%ecx
f0120f2c:	0f af c8             	imul   %eax,%ecx
f0120f2f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0120f34:	f7 e1                	mul    %ecx
f0120f36:	c1 ea 05             	shr    $0x5,%edx
f0120f39:	89 d0                	mov    %edx,%eax
f0120f3b:	c1 e0 02             	shl    $0x2,%eax
f0120f3e:	01 d0                	add    %edx,%eax
f0120f40:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120f47:	01 d0                	add    %edx,%eax
f0120f49:	c1 e0 02             	shl    $0x2,%eax
f0120f4c:	29 c1                	sub    %eax,%ecx
f0120f4e:	89 ca                	mov    %ecx,%edx
f0120f50:	85 d2                	test   %edx,%edx
f0120f52:	74 03                	je     f0120f57 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f0120f54:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0120f57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0120f5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f0120f5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120f60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120f63:	01 c2                	add    %eax,%edx
f0120f65:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120f68:	01 d0                	add    %edx,%eax
}
f0120f6a:	c9                   	leave  
f0120f6b:	c3                   	ret    

f0120f6c <schenv>:


void schenv()
{
f0120f6c:	55                   	push   %ebp
f0120f6d:	89 e5                	mov    %esp,%ebp
f0120f6f:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0120f72:	c6 05 c4 5f 74 f0 00 	movb   $0x0,0xf0745fc4
	__ne = NULL;
f0120f79:	c7 05 ec 5c 74 f0 00 	movl   $0x0,0xf0745cec
f0120f80:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f0120f83:	83 ec 0c             	sub    $0xc,%esp
f0120f86:	68 00 58 74 f0       	push   $0xf0745800
f0120f8b:	e8 5a f8 fe ff       	call   f01107ea <acquire_spinlock>
f0120f90:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0120f93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0120f9a:	eb 3f                	jmp    f0120fdb <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0120f9c:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120fa1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fa4:	c1 e2 04             	shl    $0x4,%edx
f0120fa7:	01 d0                	add    %edx,%eax
f0120fa9:	83 ec 0c             	sub    $0xc,%esp
f0120fac:	50                   	push   %eax
f0120fad:	e8 f3 41 fe ff       	call   f01051a5 <queue_size>
f0120fb2:	83 c4 10             	add    $0x10,%esp
f0120fb5:	85 c0                	test   %eax,%eax
f0120fb7:	74 1f                	je     f0120fd8 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0120fb9:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f0120fbe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120fc1:	c1 e2 04             	shl    $0x4,%edx
f0120fc4:	01 d0                	add    %edx,%eax
f0120fc6:	8b 40 04             	mov    0x4(%eax),%eax
f0120fc9:	a3 ec 5c 74 f0       	mov    %eax,0xf0745cec
				__nl = i;
f0120fce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120fd1:	a2 c4 5f 74 f0       	mov    %al,0xf0745fc4
				break;
f0120fd6:	eb 10                	jmp    f0120fe8 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0120fd8:	ff 45 f4             	incl   -0xc(%ebp)
f0120fdb:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f0120fe0:	0f b6 c0             	movzbl %al,%eax
f0120fe3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120fe6:	7f b4                	jg     f0120f9c <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f0120fe8:	83 ec 0c             	sub    $0xc,%esp
f0120feb:	68 00 58 74 f0       	push   $0xf0745800
f0120ff0:	e8 7c f8 fe ff       	call   f0110871 <release_spinlock>
f0120ff5:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0120ff8:	e8 47 af fe ff       	call   f010bf44 <get_cpu_proc>
f0120ffd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f0121000:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121004:	0f 84 82 00 00 00    	je     f012108c <schenv+0x120>
	{
		if (__ne != NULL)
f012100a:	a1 ec 5c 74 f0       	mov    0xf0745cec,%eax
f012100f:	85 c0                	test   %eax,%eax
f0121011:	74 49                	je     f012105c <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f0121013:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f0121018:	0f b6 c0             	movzbl %al,%eax
f012101b:	8d 50 01             	lea    0x1(%eax),%edx
f012101e:	a0 c4 5f 74 f0       	mov    0xf0745fc4,%al
f0121023:	0f b6 c0             	movzbl %al,%eax
f0121026:	39 c2                	cmp    %eax,%edx
f0121028:	7d 62                	jge    f012108c <schenv+0x120>
			{
				__ne = cur_env;
f012102a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012102d:	a3 ec 5c 74 f0       	mov    %eax,0xf0745cec
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0121032:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f0121037:	0f b6 c0             	movzbl %al,%eax
f012103a:	8a 15 40 5f 74 f0    	mov    0xf0745f40,%dl
f0121040:	0f b6 d2             	movzbl %dl,%edx
f0121043:	4a                   	dec    %edx
f0121044:	39 d0                	cmp    %edx,%eax
f0121046:	7d 08                	jge    f0121050 <schenv+0xe4>
f0121048:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f012104d:	40                   	inc    %eax
f012104e:	eb 05                	jmp    f0121055 <schenv+0xe9>
f0121050:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f0121055:	a2 c4 5f 74 f0       	mov    %al,0xf0745fc4
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f012105a:	eb 30                	jmp    f012108c <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f012105c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012105f:	a3 ec 5c 74 f0       	mov    %eax,0xf0745cec
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0121064:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f0121069:	0f b6 c0             	movzbl %al,%eax
f012106c:	8a 15 40 5f 74 f0    	mov    0xf0745f40,%dl
f0121072:	0f b6 d2             	movzbl %dl,%edx
f0121075:	4a                   	dec    %edx
f0121076:	39 d0                	cmp    %edx,%eax
f0121078:	7d 08                	jge    f0121082 <schenv+0x116>
f012107a:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f012107f:	40                   	inc    %eax
f0121080:	eb 05                	jmp    f0121087 <schenv+0x11b>
f0121082:	a0 e1 57 74 f0       	mov    0xf07457e1,%al
f0121087:	a2 c4 5f 74 f0       	mov    %al,0xf0745fc4
		}
	}
}
f012108c:	90                   	nop
f012108d:	c9                   	leave  
f012108e:	c3                   	ret    

f012108f <chksch>:

void chksch(uint8 onoff)
{
f012108f:	55                   	push   %ebp
f0121090:	89 e5                	mov    %esp,%ebp
f0121092:	83 ec 18             	sub    $0x18,%esp
f0121095:	8b 45 08             	mov    0x8(%ebp),%eax
f0121098:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f012109b:	e8 1e 5a fe ff       	call   f0106abe <isSchedMethodBSD>
f01210a0:	85 c0                	test   %eax,%eax
f01210a2:	74 48                	je     f01210ec <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f01210a4:	e8 a7 58 fe ff       	call   f0106950 <get_load_average>
f01210a9:	a3 5c 5f 74 f0       	mov    %eax,0xf0745f5c
f01210ae:	a1 5c 5f 74 f0       	mov    0xf0745f5c,%eax
f01210b3:	a3 9c 5a 74 f0       	mov    %eax,0xf0745a9c
		acquire_spinlock(&ProcessQueues.qlock);
f01210b8:	83 ec 0c             	sub    $0xc,%esp
f01210bb:	68 00 58 74 f0       	push   $0xf0745800
f01210c0:	e8 25 f7 fe ff       	call   f01107ea <acquire_spinlock>
f01210c5:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f01210c8:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f01210cd:	a3 40 59 74 f0       	mov    %eax,0xf0745940
		}
		release_spinlock(&ProcessQueues.qlock);
f01210d2:	83 ec 0c             	sub    $0xc,%esp
f01210d5:	68 00 58 74 f0       	push   $0xf0745800
f01210da:	e8 92 f7 fe ff       	call   f0110871 <release_spinlock>
f01210df:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f01210e2:	c7 05 fc 5c 74 f0 01 	movl   $0x1,0xf0745cfc
f01210e9:	00 00 00 
	}
	__chkstatus = onoff;
f01210ec:	8a 45 f4             	mov    -0xc(%ebp),%al
f01210ef:	a2 e8 5c 74 f0       	mov    %al,0xf0745ce8
}
f01210f4:	90                   	nop
f01210f5:	c9                   	leave  
f01210f6:	c3                   	ret    

f01210f7 <chk1>:
void chk1()
{
f01210f7:	55                   	push   %ebp
f01210f8:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f01210fa:	90                   	nop
f01210fb:	5d                   	pop    %ebp
f01210fc:	c3                   	ret    

f01210fd <chk2>:
void chk2(struct Env* __se)
{
f01210fd:	55                   	push   %ebp
f01210fe:	89 e5                	mov    %esp,%ebp
f0121100:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f0121103:	a0 e8 5c 74 f0       	mov    0xf0745ce8,%al
f0121108:	84 c0                	test   %al,%al
f012110a:	0f 84 59 03 00 00    	je     f0121469 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0121110:	e8 a9 59 fe ff       	call   f0106abe <isSchedMethodBSD>
f0121115:	85 c0                	test   %eax,%eax
f0121117:	0f 84 4d 03 00 00    	je     f012146a <chk2+0x36d>
	{
		__nla = get_load_average();
f012111d:	e8 2e 58 fe ff       	call   f0106950 <get_load_average>
f0121122:	a3 d4 59 74 f0       	mov    %eax,0xf07459d4
		acquire_spinlock(&ProcessQueues.qlock);
f0121127:	83 ec 0c             	sub    $0xc,%esp
f012112a:	68 00 58 74 f0       	push   $0xf0745800
f012112f:	e8 b6 f6 fe ff       	call   f01107ea <acquire_spinlock>
f0121134:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0121137:	a1 8c 58 74 f0       	mov    0xf074588c,%eax
f012113c:	a3 f0 5c 74 f0       	mov    %eax,0xf0745cf0
		}
		release_spinlock(&ProcessQueues.qlock);
f0121141:	83 ec 0c             	sub    $0xc,%esp
f0121144:	68 00 58 74 f0       	push   $0xf0745800
f0121149:	e8 23 f7 fe ff       	call   f0110871 <release_spinlock>
f012114e:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f0121151:	a1 fc 5c 74 f0       	mov    0xf0745cfc,%eax
f0121156:	85 c0                	test   %eax,%eax
f0121158:	74 72                	je     f01211cc <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f012115a:	83 ec 0c             	sub    $0xc,%esp
f012115d:	68 00 58 74 f0       	push   $0xf0745800
f0121162:	e8 83 f6 fe ff       	call   f01107ea <acquire_spinlock>
f0121167:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f012116a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012116e:	0f 95 c0             	setne  %al
f0121171:	0f b6 c0             	movzbl %al,%eax
f0121174:	a3 b4 5e 74 f0       	mov    %eax,0xf0745eb4
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121179:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f012117e:	0f b6 c0             	movzbl %al,%eax
f0121181:	48                   	dec    %eax
f0121182:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121185:	eb 20                	jmp    f01211a7 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0121187:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f012118c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012118f:	c1 e2 04             	shl    $0x4,%edx
f0121192:	01 d0                	add    %edx,%eax
f0121194:	8b 40 0c             	mov    0xc(%eax),%eax
f0121197:	8b 15 b4 5e 74 f0    	mov    0xf0745eb4,%edx
f012119d:	01 d0                	add    %edx,%eax
f012119f:	a3 b4 5e 74 f0       	mov    %eax,0xf0745eb4
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f01211a4:	ff 4d f4             	decl   -0xc(%ebp)
f01211a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01211ab:	79 da                	jns    f0121187 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f01211ad:	c7 05 fc 5c 74 f0 00 	movl   $0x0,0xf0745cfc
f01211b4:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f01211b7:	83 ec 0c             	sub    $0xc,%esp
f01211ba:	68 00 58 74 f0       	push   $0xf0745800
f01211bf:	e8 ad f6 fe ff       	call   f0110871 <release_spinlock>
f01211c4:	83 c4 10             	add    $0x10,%esp
f01211c7:	e9 91 02 00 00       	jmp    f012145d <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f01211cc:	8b 15 40 59 74 f0    	mov    0xf0745940,%edx
f01211d2:	a1 f0 5c 74 f0       	mov    0xf0745cf0,%eax
f01211d7:	39 c2                	cmp    %eax,%edx
f01211d9:	74 63                	je     f012123e <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f01211db:	83 ec 0c             	sub    $0xc,%esp
f01211de:	68 00 58 74 f0       	push   $0xf0745800
f01211e3:	e8 02 f6 fe ff       	call   f01107ea <acquire_spinlock>
f01211e8:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f01211eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01211ef:	0f 95 c0             	setne  %al
f01211f2:	0f b6 c0             	movzbl %al,%eax
f01211f5:	a3 b4 5e 74 f0       	mov    %eax,0xf0745eb4
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f01211fa:	a0 40 5f 74 f0       	mov    0xf0745f40,%al
f01211ff:	0f b6 c0             	movzbl %al,%eax
f0121202:	48                   	dec    %eax
f0121203:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121206:	eb 20                	jmp    f0121228 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0121208:	a1 90 58 74 f0       	mov    0xf0745890,%eax
f012120d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0121210:	c1 e2 04             	shl    $0x4,%edx
f0121213:	01 d0                	add    %edx,%eax
f0121215:	8b 40 0c             	mov    0xc(%eax),%eax
f0121218:	8b 15 b4 5e 74 f0    	mov    0xf0745eb4,%edx
f012121e:	01 d0                	add    %edx,%eax
f0121220:	a3 b4 5e 74 f0       	mov    %eax,0xf0745eb4
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0121225:	ff 4d f0             	decl   -0x10(%ebp)
f0121228:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012122c:	79 da                	jns    f0121208 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f012122e:	83 ec 0c             	sub    $0xc,%esp
f0121231:	68 00 58 74 f0       	push   $0xf0745800
f0121236:	e8 36 f6 fe ff       	call   f0110871 <release_spinlock>
f012123b:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f012123e:	e8 a6 56 fe ff       	call   f01068e9 <timer_ticks>
f0121243:	6a 00                	push   $0x0
f0121245:	68 e8 03 00 00       	push   $0x3e8
f012124a:	52                   	push   %edx
f012124b:	50                   	push   %eax
f012124c:	e8 e7 29 00 00       	call   f0123c38 <__moddi3>
f0121251:	83 c4 10             	add    $0x10,%esp
f0121254:	09 d0                	or     %edx,%eax
f0121256:	85 c0                	test   %eax,%eax
f0121258:	75 32                	jne    f012128c <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f012125a:	8b 15 9c 5a 74 f0    	mov    0xf0745a9c,%edx
f0121260:	a1 d4 59 74 f0       	mov    0xf07459d4,%eax
f0121265:	39 c2                	cmp    %eax,%edx
f0121267:	75 19                	jne    f0121282 <chk2+0x185>
f0121269:	68 b1 35 13 f0       	push   $0xf01335b1
f012126e:	68 ef 31 13 f0       	push   $0xf01331ef
f0121273:	68 35 02 00 00       	push   $0x235
f0121278:	68 37 32 13 f0       	push   $0xf0133237
f012127d:	e8 47 f1 fd ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f0121282:	a1 d4 59 74 f0       	mov    0xf07459d4,%eax
f0121287:	a3 9c 5a 74 f0       	mov    %eax,0xf0745a9c
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f012128c:	e8 58 56 fe ff       	call   f01068e9 <timer_ticks>
f0121291:	6a 00                	push   $0x0
f0121293:	6a 64                	push   $0x64
f0121295:	52                   	push   %edx
f0121296:	50                   	push   %eax
f0121297:	e8 9c 29 00 00       	call   f0123c38 <__moddi3>
f012129c:	83 c4 10             	add    $0x10,%esp
f012129f:	09 d0                	or     %edx,%eax
f01212a1:	85 c0                	test   %eax,%eax
f01212a3:	0f 85 b4 01 00 00    	jne    f012145d <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f01212a9:	8b 0d 5c 5f 74 f0    	mov    0xf0745f5c,%ecx
f01212af:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01212b4:	f7 e9                	imul   %ecx
f01212b6:	c1 fa 05             	sar    $0x5,%edx
f01212b9:	89 c8                	mov    %ecx,%eax
f01212bb:	c1 f8 1f             	sar    $0x1f,%eax
f01212be:	29 c2                	sub    %eax,%edx
f01212c0:	89 d0                	mov    %edx,%eax
f01212c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f01212c5:	8b 0d 5c 5f 74 f0    	mov    0xf0745f5c,%ecx
f01212cb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01212d0:	f7 e9                	imul   %ecx
f01212d2:	c1 fa 05             	sar    $0x5,%edx
f01212d5:	89 c8                	mov    %ecx,%eax
f01212d7:	c1 f8 1f             	sar    $0x1f,%eax
f01212da:	29 c2                	sub    %eax,%edx
f01212dc:	89 d0                	mov    %edx,%eax
f01212de:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01212e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01212e4:	89 d0                	mov    %edx,%eax
f01212e6:	c1 e0 02             	shl    $0x2,%eax
f01212e9:	01 d0                	add    %edx,%eax
f01212eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01212f2:	01 d0                	add    %edx,%eax
f01212f4:	c1 e0 02             	shl    $0x2,%eax
f01212f7:	29 c1                	sub    %eax,%ecx
f01212f9:	89 c8                	mov    %ecx,%eax
f01212fb:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f01212fe:	8b 0d d4 59 74 f0    	mov    0xf07459d4,%ecx
f0121304:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121309:	f7 e9                	imul   %ecx
f012130b:	c1 fa 05             	sar    $0x5,%edx
f012130e:	89 c8                	mov    %ecx,%eax
f0121310:	c1 f8 1f             	sar    $0x1f,%eax
f0121313:	29 c2                	sub    %eax,%edx
f0121315:	89 d0                	mov    %edx,%eax
f0121317:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f012131a:	8b 0d d4 59 74 f0    	mov    0xf07459d4,%ecx
f0121320:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0121325:	f7 e9                	imul   %ecx
f0121327:	c1 fa 05             	sar    $0x5,%edx
f012132a:	89 c8                	mov    %ecx,%eax
f012132c:	c1 f8 1f             	sar    $0x1f,%eax
f012132f:	29 c2                	sub    %eax,%edx
f0121331:	89 d0                	mov    %edx,%eax
f0121333:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0121336:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121339:	89 d0                	mov    %edx,%eax
f012133b:	c1 e0 02             	shl    $0x2,%eax
f012133e:	01 d0                	add    %edx,%eax
f0121340:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121347:	01 d0                	add    %edx,%eax
f0121349:	c1 e0 02             	shl    $0x2,%eax
f012134c:	29 c1                	sub    %eax,%ecx
f012134e:	89 c8                	mov    %ecx,%eax
f0121350:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f0121353:	8b 15 f0 5c 74 f0    	mov    0xf0745cf0,%edx
f0121359:	a1 40 59 74 f0       	mov    0xf0745940,%eax
f012135e:	39 c2                	cmp    %eax,%edx
f0121360:	0f 85 ed 00 00 00    	jne    f0121453 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0121366:	a1 b4 5e 74 f0       	mov    0xf0745eb4,%eax
f012136b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f012136e:	7e 5b                	jle    f01213cb <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0121370:	a1 b4 5e 74 f0       	mov    0xf0745eb4,%eax
f0121375:	83 ec 08             	sub    $0x8,%esp
f0121378:	ff 75 e0             	pushl  -0x20(%ebp)
f012137b:	ff 75 e4             	pushl  -0x1c(%ebp)
f012137e:	ff 75 e8             	pushl  -0x18(%ebp)
f0121381:	ff 75 ec             	pushl  -0x14(%ebp)
f0121384:	50                   	push   %eax
f0121385:	68 c4 35 13 f0       	push   $0xf01335c4
f012138a:	e8 fc fb fd ff       	call   f0100f8b <cprintf>
f012138f:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f0121392:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121395:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121398:	0f 8f b5 00 00 00    	jg     f0121453 <chk2+0x356>
f012139e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01213a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01213a4:	75 0c                	jne    f01213b2 <chk2+0x2b5>
f01213a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01213a9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01213ac:	0f 8d a1 00 00 00    	jge    f0121453 <chk2+0x356>
f01213b2:	68 0c 36 13 f0       	push   $0xf013360c
f01213b7:	68 ef 31 13 f0       	push   $0xf01331ef
f01213bc:	68 4a 02 00 00       	push   $0x24a
f01213c1:	68 37 32 13 f0       	push   $0xf0133237
f01213c6:	e8 fe ef fd ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f01213cb:	a1 b4 5e 74 f0       	mov    0xf0745eb4,%eax
f01213d0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01213d3:	7d 53                	jge    f0121428 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f01213d5:	a1 b4 5e 74 f0       	mov    0xf0745eb4,%eax
f01213da:	83 ec 08             	sub    $0x8,%esp
f01213dd:	ff 75 e0             	pushl  -0x20(%ebp)
f01213e0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01213e3:	ff 75 e8             	pushl  -0x18(%ebp)
f01213e6:	ff 75 ec             	pushl  -0x14(%ebp)
f01213e9:	50                   	push   %eax
f01213ea:	68 4c 36 13 f0       	push   $0xf013364c
f01213ef:	e8 97 fb fd ff       	call   f0100f8b <cprintf>
f01213f4:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f01213f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01213fa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01213fd:	7c 54                	jl     f0121453 <chk2+0x356>
f01213ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121402:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121405:	75 08                	jne    f012140f <chk2+0x312>
f0121407:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012140a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012140d:	7e 44                	jle    f0121453 <chk2+0x356>
f012140f:	68 94 36 13 f0       	push   $0xf0133694
f0121414:	68 ef 31 13 f0       	push   $0xf01331ef
f0121419:	68 50 02 00 00       	push   $0x250
f012141e:	68 37 32 13 f0       	push   $0xf0133237
f0121423:	e8 a1 ef fd ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f0121428:	a1 b4 5e 74 f0       	mov    0xf0745eb4,%eax
f012142d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121430:	75 21                	jne    f0121453 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f0121432:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0121435:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0121438:	74 19                	je     f0121453 <chk2+0x356>
f012143a:	68 d4 36 13 f0       	push   $0xf01336d4
f012143f:	68 ef 31 13 f0       	push   $0xf01331ef
f0121444:	68 54 02 00 00       	push   $0x254
f0121449:	68 37 32 13 f0       	push   $0xf0133237
f012144e:	e8 76 ef fd ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f0121453:	a1 d4 59 74 f0       	mov    0xf07459d4,%eax
f0121458:	a3 5c 5f 74 f0       	mov    %eax,0xf0745f5c
			}
		}
		__pnexit = __nnexit;
f012145d:	a1 f0 5c 74 f0       	mov    0xf0745cf0,%eax
f0121462:	a3 40 59 74 f0       	mov    %eax,0xf0745940
f0121467:	eb 01                	jmp    f012146a <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f0121469:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f012146a:	c9                   	leave  
f012146b:	c3                   	ret    

f012146c <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f012146c:	55                   	push   %ebp
f012146d:	89 e5                	mov    %esp,%ebp
f012146f:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0121472:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0121479:	eb 40                	jmp    f01214bb <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f012147b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012147e:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0121484:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0121489:	83 ec 08             	sub    $0x8,%esp
f012148c:	52                   	push   %edx
f012148d:	50                   	push   %eax
f012148e:	e8 af 01 00 00       	call   f0121642 <check_va2pa>
f0121493:	83 c4 10             	add    $0x10,%esp
f0121496:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0121499:	74 19                	je     f01214b4 <check_boot_pgdir+0x48>
f012149b:	68 e8 36 13 f0       	push   $0xf01336e8
f01214a0:	68 ef 31 13 f0       	push   $0xf01331ef
f01214a5:	68 9b 02 00 00       	push   $0x29b
f01214aa:	68 37 32 13 f0       	push   $0xf0133237
f01214af:	e8 85 ee fd ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f01214b4:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01214bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01214be:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f01214c4:	a1 b8 5e 74 f0       	mov    0xf0745eb8,%eax
f01214c9:	39 c2                	cmp    %eax,%edx
f01214cb:	72 ae                	jb     f012147b <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f01214cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01214d4:	e9 81 00 00 00       	jmp    f012155a <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f01214d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01214dc:	25 ff 7f 00 00       	and    $0x7fff,%eax
f01214e1:	85 c0                	test   %eax,%eax
f01214e3:	74 6d                	je     f0121552 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f01214e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01214e8:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f01214ee:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01214f3:	83 ec 08             	sub    $0x8,%esp
f01214f6:	52                   	push   %edx
f01214f7:	50                   	push   %eax
f01214f8:	e8 45 01 00 00       	call   f0121642 <check_va2pa>
f01214fd:	83 c4 10             	add    $0x10,%esp
f0121500:	c7 45 f0 00 b0 17 f0 	movl   $0xf017b000,-0x10(%ebp)
f0121507:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f012150e:	77 17                	ja     f0121527 <check_boot_pgdir+0xbb>
f0121510:	ff 75 f0             	pushl  -0x10(%ebp)
f0121513:	68 20 37 13 f0       	push   $0xf0133720
f0121518:	68 a9 02 00 00       	push   $0x2a9
f012151d:	68 37 32 13 f0       	push   $0xf0133237
f0121522:	e8 12 ee fd ff       	call   f0100339 <_panic>
f0121527:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012152a:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0121530:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121533:	01 ca                	add    %ecx,%edx
f0121535:	39 d0                	cmp    %edx,%eax
f0121537:	74 1a                	je     f0121553 <check_boot_pgdir+0xe7>
f0121539:	68 54 37 13 f0       	push   $0xf0133754
f012153e:	68 ef 31 13 f0       	push   $0xf01331ef
f0121543:	68 a9 02 00 00       	push   $0x2a9
f0121548:	68 37 32 13 f0       	push   $0xf0133237
f012154d:	e8 e7 ed fd ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f0121552:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0121553:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f012155a:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0121561:	0f 86 72 ff ff ff    	jbe    f01214d9 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0121567:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f012156e:	e9 af 00 00 00       	jmp    f0121622 <check_boot_pgdir+0x1b6>
		switch (i) {
f0121573:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121576:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f012157b:	74 11                	je     f012158e <check_boot_pgdir+0x122>
f012157d:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f0121582:	72 36                	jb     f01215ba <check_boot_pgdir+0x14e>
f0121584:	2d bd 03 00 00       	sub    $0x3bd,%eax
f0121589:	83 f8 02             	cmp    $0x2,%eax
f012158c:	77 2c                	ja     f01215ba <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f012158e:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f0121593:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121596:	c1 e2 02             	shl    $0x2,%edx
f0121599:	01 d0                	add    %edx,%eax
f012159b:	8b 00                	mov    (%eax),%eax
f012159d:	85 c0                	test   %eax,%eax
f012159f:	75 7a                	jne    f012161b <check_boot_pgdir+0x1af>
f01215a1:	68 da 37 13 f0       	push   $0xf01337da
f01215a6:	68 ef 31 13 f0       	push   $0xf01331ef
f01215ab:	68 b4 02 00 00       	push   $0x2b4
f01215b0:	68 37 32 13 f0       	push   $0xf0133237
f01215b5:	e8 7f ed fd ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f01215ba:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f01215c1:	76 2c                	jbe    f01215ef <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f01215c3:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01215c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01215cb:	c1 e2 02             	shl    $0x2,%edx
f01215ce:	01 d0                	add    %edx,%eax
f01215d0:	8b 00                	mov    (%eax),%eax
f01215d2:	85 c0                	test   %eax,%eax
f01215d4:	75 48                	jne    f012161e <check_boot_pgdir+0x1b2>
f01215d6:	68 da 37 13 f0       	push   $0xf01337da
f01215db:	68 ef 31 13 f0       	push   $0xf01331ef
f01215e0:	68 b8 02 00 00       	push   $0x2b8
f01215e5:	68 37 32 13 f0       	push   $0xf0133237
f01215ea:	e8 4a ed fd ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f01215ef:	a1 bc 5e 74 f0       	mov    0xf0745ebc,%eax
f01215f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01215f7:	c1 e2 02             	shl    $0x2,%edx
f01215fa:	01 d0                	add    %edx,%eax
f01215fc:	8b 00                	mov    (%eax),%eax
f01215fe:	85 c0                	test   %eax,%eax
f0121600:	74 1c                	je     f012161e <check_boot_pgdir+0x1b2>
f0121602:	68 f0 37 13 f0       	push   $0xf01337f0
f0121607:	68 ef 31 13 f0       	push   $0xf01331ef
f012160c:	68 ba 02 00 00       	push   $0x2ba
f0121611:	68 37 32 13 f0       	push   $0xf0133237
f0121616:	e8 1e ed fd ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f012161b:	90                   	nop
f012161c:	eb 01                	jmp    f012161f <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f012161e:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f012161f:	ff 45 f4             	incl   -0xc(%ebp)
f0121622:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0121629:	0f 86 44 ff ff ff    	jbe    f0121573 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f012162f:	83 ec 0c             	sub    $0xc,%esp
f0121632:	68 0c 38 13 f0       	push   $0xf013380c
f0121637:	e8 4f f9 fd ff       	call   f0100f8b <cprintf>
f012163c:	83 c4 10             	add    $0x10,%esp
}
f012163f:	90                   	nop
f0121640:	c9                   	leave  
f0121641:	c3                   	ret    

f0121642 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f0121642:	55                   	push   %ebp
f0121643:	89 e5                	mov    %esp,%ebp
f0121645:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f0121648:	8b 45 0c             	mov    0xc(%ebp),%eax
f012164b:	c1 e8 16             	shr    $0x16,%eax
f012164e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0121655:	8b 45 08             	mov    0x8(%ebp),%eax
f0121658:	01 d0                	add    %edx,%eax
f012165a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f012165d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121660:	8b 00                	mov    (%eax),%eax
f0121662:	83 e0 01             	and    $0x1,%eax
f0121665:	85 c0                	test   %eax,%eax
f0121667:	75 0a                	jne    f0121673 <check_va2pa+0x31>
		return ~0;
f0121669:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f012166e:	e9 87 00 00 00       	jmp    f01216fa <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f0121673:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121676:	8b 00                	mov    (%eax),%eax
f0121678:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f012167d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121680:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121683:	c1 e8 0c             	shr    $0xc,%eax
f0121686:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121689:	a1 98 5a 74 f0       	mov    0xf0745a98,%eax
f012168e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0121691:	72 17                	jb     f01216aa <check_va2pa+0x68>
f0121693:	ff 75 f0             	pushl  -0x10(%ebp)
f0121696:	68 30 38 13 f0       	push   $0xf0133830
f012169b:	68 d0 02 00 00       	push   $0x2d0
f01216a0:	68 37 32 13 f0       	push   $0xf0133237
f01216a5:	e8 8f ec fd ff       	call   f0100339 <_panic>
f01216aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01216ad:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01216b2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f01216b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216b8:	c1 e8 0c             	shr    $0xc,%eax
f01216bb:	25 ff 03 00 00       	and    $0x3ff,%eax
f01216c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01216c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01216ca:	01 d0                	add    %edx,%eax
f01216cc:	8b 00                	mov    (%eax),%eax
f01216ce:	83 e0 01             	and    $0x1,%eax
f01216d1:	85 c0                	test   %eax,%eax
f01216d3:	75 07                	jne    f01216dc <check_va2pa+0x9a>
		return ~0;
f01216d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01216da:	eb 1e                	jmp    f01216fa <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f01216dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01216df:	c1 e8 0c             	shr    $0xc,%eax
f01216e2:	25 ff 03 00 00       	and    $0x3ff,%eax
f01216e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01216ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01216f1:	01 d0                	add    %edx,%eax
f01216f3:	8b 00                	mov    (%eax),%eax
f01216f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f01216fa:	c9                   	leave  
f01216fb:	c3                   	ret    

f01216fc <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f01216fc:	55                   	push   %ebp
f01216fd:	89 e5                	mov    %esp,%ebp
f01216ff:	53                   	push   %ebx
f0121700:	83 ec 14             	sub    $0x14,%esp
f0121703:	8b 45 10             	mov    0x10(%ebp),%eax
f0121706:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121709:	8b 45 14             	mov    0x14(%ebp),%eax
f012170c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f012170f:	8b 45 18             	mov    0x18(%ebp),%eax
f0121712:	ba 00 00 00 00       	mov    $0x0,%edx
f0121717:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f012171a:	77 55                	ja     f0121771 <printnum+0x75>
f012171c:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f012171f:	72 05                	jb     f0121726 <printnum+0x2a>
f0121721:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0121724:	77 4b                	ja     f0121771 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f0121726:	8b 45 1c             	mov    0x1c(%ebp),%eax
f0121729:	8d 58 ff             	lea    -0x1(%eax),%ebx
f012172c:	8b 45 18             	mov    0x18(%ebp),%eax
f012172f:	ba 00 00 00 00       	mov    $0x0,%edx
f0121734:	52                   	push   %edx
f0121735:	50                   	push   %eax
f0121736:	ff 75 f4             	pushl  -0xc(%ebp)
f0121739:	ff 75 f0             	pushl  -0x10(%ebp)
f012173c:	e8 8f 26 00 00       	call   f0123dd0 <__udivdi3>
f0121741:	83 c4 10             	add    $0x10,%esp
f0121744:	83 ec 04             	sub    $0x4,%esp
f0121747:	ff 75 20             	pushl  0x20(%ebp)
f012174a:	53                   	push   %ebx
f012174b:	ff 75 18             	pushl  0x18(%ebp)
f012174e:	52                   	push   %edx
f012174f:	50                   	push   %eax
f0121750:	ff 75 0c             	pushl  0xc(%ebp)
f0121753:	ff 75 08             	pushl  0x8(%ebp)
f0121756:	e8 a1 ff ff ff       	call   f01216fc <printnum>
f012175b:	83 c4 20             	add    $0x20,%esp
f012175e:	eb 1a                	jmp    f012177a <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f0121760:	83 ec 08             	sub    $0x8,%esp
f0121763:	ff 75 0c             	pushl  0xc(%ebp)
f0121766:	ff 75 20             	pushl  0x20(%ebp)
f0121769:	8b 45 08             	mov    0x8(%ebp),%eax
f012176c:	ff d0                	call   *%eax
f012176e:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f0121771:	ff 4d 1c             	decl   0x1c(%ebp)
f0121774:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f0121778:	7f e6                	jg     f0121760 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f012177a:	8b 4d 18             	mov    0x18(%ebp),%ecx
f012177d:	bb 00 00 00 00       	mov    $0x0,%ebx
f0121782:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121785:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121788:	53                   	push   %ebx
f0121789:	51                   	push   %ecx
f012178a:	52                   	push   %edx
f012178b:	50                   	push   %eax
f012178c:	e8 4f 27 00 00       	call   f0123ee0 <__umoddi3>
f0121791:	83 c4 10             	add    $0x10,%esp
f0121794:	05 74 3a 13 f0       	add    $0xf0133a74,%eax
f0121799:	8a 00                	mov    (%eax),%al
f012179b:	0f be c0             	movsbl %al,%eax
f012179e:	83 ec 08             	sub    $0x8,%esp
f01217a1:	ff 75 0c             	pushl  0xc(%ebp)
f01217a4:	50                   	push   %eax
f01217a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01217a8:	ff d0                	call   *%eax
f01217aa:	83 c4 10             	add    $0x10,%esp
}
f01217ad:	90                   	nop
f01217ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01217b1:	c9                   	leave  
f01217b2:	c3                   	ret    

f01217b3 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f01217b3:	55                   	push   %ebp
f01217b4:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f01217b6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f01217ba:	7e 1c                	jle    f01217d8 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f01217bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01217bf:	8b 00                	mov    (%eax),%eax
f01217c1:	8d 50 08             	lea    0x8(%eax),%edx
f01217c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01217c7:	89 10                	mov    %edx,(%eax)
f01217c9:	8b 45 08             	mov    0x8(%ebp),%eax
f01217cc:	8b 00                	mov    (%eax),%eax
f01217ce:	83 e8 08             	sub    $0x8,%eax
f01217d1:	8b 50 04             	mov    0x4(%eax),%edx
f01217d4:	8b 00                	mov    (%eax),%eax
f01217d6:	eb 40                	jmp    f0121818 <getuint+0x65>
	else if (lflag)
f01217d8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01217dc:	74 1e                	je     f01217fc <getuint+0x49>
		return va_arg(*ap, unsigned long);
f01217de:	8b 45 08             	mov    0x8(%ebp),%eax
f01217e1:	8b 00                	mov    (%eax),%eax
f01217e3:	8d 50 04             	lea    0x4(%eax),%edx
f01217e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01217e9:	89 10                	mov    %edx,(%eax)
f01217eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01217ee:	8b 00                	mov    (%eax),%eax
f01217f0:	83 e8 04             	sub    $0x4,%eax
f01217f3:	8b 00                	mov    (%eax),%eax
f01217f5:	ba 00 00 00 00       	mov    $0x0,%edx
f01217fa:	eb 1c                	jmp    f0121818 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f01217fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01217ff:	8b 00                	mov    (%eax),%eax
f0121801:	8d 50 04             	lea    0x4(%eax),%edx
f0121804:	8b 45 08             	mov    0x8(%ebp),%eax
f0121807:	89 10                	mov    %edx,(%eax)
f0121809:	8b 45 08             	mov    0x8(%ebp),%eax
f012180c:	8b 00                	mov    (%eax),%eax
f012180e:	83 e8 04             	sub    $0x4,%eax
f0121811:	8b 00                	mov    (%eax),%eax
f0121813:	ba 00 00 00 00       	mov    $0x0,%edx
}
f0121818:	5d                   	pop    %ebp
f0121819:	c3                   	ret    

f012181a <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f012181a:	55                   	push   %ebp
f012181b:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f012181d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f0121821:	7e 1c                	jle    f012183f <getint+0x25>
		return va_arg(*ap, long long);
f0121823:	8b 45 08             	mov    0x8(%ebp),%eax
f0121826:	8b 00                	mov    (%eax),%eax
f0121828:	8d 50 08             	lea    0x8(%eax),%edx
f012182b:	8b 45 08             	mov    0x8(%ebp),%eax
f012182e:	89 10                	mov    %edx,(%eax)
f0121830:	8b 45 08             	mov    0x8(%ebp),%eax
f0121833:	8b 00                	mov    (%eax),%eax
f0121835:	83 e8 08             	sub    $0x8,%eax
f0121838:	8b 50 04             	mov    0x4(%eax),%edx
f012183b:	8b 00                	mov    (%eax),%eax
f012183d:	eb 38                	jmp    f0121877 <getint+0x5d>
	else if (lflag)
f012183f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121843:	74 1a                	je     f012185f <getint+0x45>
		return va_arg(*ap, long);
f0121845:	8b 45 08             	mov    0x8(%ebp),%eax
f0121848:	8b 00                	mov    (%eax),%eax
f012184a:	8d 50 04             	lea    0x4(%eax),%edx
f012184d:	8b 45 08             	mov    0x8(%ebp),%eax
f0121850:	89 10                	mov    %edx,(%eax)
f0121852:	8b 45 08             	mov    0x8(%ebp),%eax
f0121855:	8b 00                	mov    (%eax),%eax
f0121857:	83 e8 04             	sub    $0x4,%eax
f012185a:	8b 00                	mov    (%eax),%eax
f012185c:	99                   	cltd   
f012185d:	eb 18                	jmp    f0121877 <getint+0x5d>
	else
		return va_arg(*ap, int);
f012185f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121862:	8b 00                	mov    (%eax),%eax
f0121864:	8d 50 04             	lea    0x4(%eax),%edx
f0121867:	8b 45 08             	mov    0x8(%ebp),%eax
f012186a:	89 10                	mov    %edx,(%eax)
f012186c:	8b 45 08             	mov    0x8(%ebp),%eax
f012186f:	8b 00                	mov    (%eax),%eax
f0121871:	83 e8 04             	sub    $0x4,%eax
f0121874:	8b 00                	mov    (%eax),%eax
f0121876:	99                   	cltd   
}
f0121877:	5d                   	pop    %ebp
f0121878:	c3                   	ret    

f0121879 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f0121879:	55                   	push   %ebp
f012187a:	89 e5                	mov    %esp,%ebp
f012187c:	56                   	push   %esi
f012187d:	53                   	push   %ebx
f012187e:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f0121881:	eb 17                	jmp    f012189a <vprintfmt+0x21>
			if (ch == '\0')
f0121883:	85 db                	test   %ebx,%ebx
f0121885:	0f 84 c1 03 00 00    	je     f0121c4c <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f012188b:	83 ec 08             	sub    $0x8,%esp
f012188e:	ff 75 0c             	pushl  0xc(%ebp)
f0121891:	53                   	push   %ebx
f0121892:	8b 45 08             	mov    0x8(%ebp),%eax
f0121895:	ff d0                	call   *%eax
f0121897:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f012189a:	8b 45 10             	mov    0x10(%ebp),%eax
f012189d:	8d 50 01             	lea    0x1(%eax),%edx
f01218a0:	89 55 10             	mov    %edx,0x10(%ebp)
f01218a3:	8a 00                	mov    (%eax),%al
f01218a5:	0f b6 d8             	movzbl %al,%ebx
f01218a8:	83 fb 25             	cmp    $0x25,%ebx
f01218ab:	75 d6                	jne    f0121883 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f01218ad:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f01218b1:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f01218b8:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f01218bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f01218c6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f01218cd:	8b 45 10             	mov    0x10(%ebp),%eax
f01218d0:	8d 50 01             	lea    0x1(%eax),%edx
f01218d3:	89 55 10             	mov    %edx,0x10(%ebp)
f01218d6:	8a 00                	mov    (%eax),%al
f01218d8:	0f b6 d8             	movzbl %al,%ebx
f01218db:	8d 43 dd             	lea    -0x23(%ebx),%eax
f01218de:	83 f8 5b             	cmp    $0x5b,%eax
f01218e1:	0f 87 3d 03 00 00    	ja     f0121c24 <vprintfmt+0x3ab>
f01218e7:	8b 04 85 98 3a 13 f0 	mov    -0xfecc568(,%eax,4),%eax
f01218ee:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f01218f0:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f01218f4:	eb d7                	jmp    f01218cd <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f01218f6:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f01218fa:	eb d1                	jmp    f01218cd <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f01218fc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f0121903:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0121906:	89 d0                	mov    %edx,%eax
f0121908:	c1 e0 02             	shl    $0x2,%eax
f012190b:	01 d0                	add    %edx,%eax
f012190d:	01 c0                	add    %eax,%eax
f012190f:	01 d8                	add    %ebx,%eax
f0121911:	83 e8 30             	sub    $0x30,%eax
f0121914:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f0121917:	8b 45 10             	mov    0x10(%ebp),%eax
f012191a:	8a 00                	mov    (%eax),%al
f012191c:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f012191f:	83 fb 2f             	cmp    $0x2f,%ebx
f0121922:	7e 3e                	jle    f0121962 <vprintfmt+0xe9>
f0121924:	83 fb 39             	cmp    $0x39,%ebx
f0121927:	7f 39                	jg     f0121962 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f0121929:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f012192c:	eb d5                	jmp    f0121903 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f012192e:	8b 45 14             	mov    0x14(%ebp),%eax
f0121931:	83 c0 04             	add    $0x4,%eax
f0121934:	89 45 14             	mov    %eax,0x14(%ebp)
f0121937:	8b 45 14             	mov    0x14(%ebp),%eax
f012193a:	83 e8 04             	sub    $0x4,%eax
f012193d:	8b 00                	mov    (%eax),%eax
f012193f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f0121942:	eb 1f                	jmp    f0121963 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f0121944:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121948:	79 83                	jns    f01218cd <vprintfmt+0x54>
				width = 0;
f012194a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f0121951:	e9 77 ff ff ff       	jmp    f01218cd <vprintfmt+0x54>

		case '#':
			altflag = 1;
f0121956:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f012195d:	e9 6b ff ff ff       	jmp    f01218cd <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f0121962:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f0121963:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121967:	0f 89 60 ff ff ff    	jns    f01218cd <vprintfmt+0x54>
				width = precision, precision = -1;
f012196d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121970:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0121973:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f012197a:	e9 4e ff ff ff       	jmp    f01218cd <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f012197f:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f0121982:	e9 46 ff ff ff       	jmp    f01218cd <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f0121987:	8b 45 14             	mov    0x14(%ebp),%eax
f012198a:	83 c0 04             	add    $0x4,%eax
f012198d:	89 45 14             	mov    %eax,0x14(%ebp)
f0121990:	8b 45 14             	mov    0x14(%ebp),%eax
f0121993:	83 e8 04             	sub    $0x4,%eax
f0121996:	8b 00                	mov    (%eax),%eax
f0121998:	83 ec 08             	sub    $0x8,%esp
f012199b:	ff 75 0c             	pushl  0xc(%ebp)
f012199e:	50                   	push   %eax
f012199f:	8b 45 08             	mov    0x8(%ebp),%eax
f01219a2:	ff d0                	call   *%eax
f01219a4:	83 c4 10             	add    $0x10,%esp
			break;
f01219a7:	e9 9b 02 00 00       	jmp    f0121c47 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f01219ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01219af:	83 c0 04             	add    $0x4,%eax
f01219b2:	89 45 14             	mov    %eax,0x14(%ebp)
f01219b5:	8b 45 14             	mov    0x14(%ebp),%eax
f01219b8:	83 e8 04             	sub    $0x4,%eax
f01219bb:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f01219bd:	85 db                	test   %ebx,%ebx
f01219bf:	79 02                	jns    f01219c3 <vprintfmt+0x14a>
				err = -err;
f01219c1:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f01219c3:	83 fb 64             	cmp    $0x64,%ebx
f01219c6:	7f 0b                	jg     f01219d3 <vprintfmt+0x15a>
f01219c8:	8b 34 9d e0 38 13 f0 	mov    -0xfecc720(,%ebx,4),%esi
f01219cf:	85 f6                	test   %esi,%esi
f01219d1:	75 19                	jne    f01219ec <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f01219d3:	53                   	push   %ebx
f01219d4:	68 85 3a 13 f0       	push   $0xf0133a85
f01219d9:	ff 75 0c             	pushl  0xc(%ebp)
f01219dc:	ff 75 08             	pushl  0x8(%ebp)
f01219df:	e8 70 02 00 00       	call   f0121c54 <printfmt>
f01219e4:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f01219e7:	e9 5b 02 00 00       	jmp    f0121c47 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f01219ec:	56                   	push   %esi
f01219ed:	68 8e 3a 13 f0       	push   $0xf0133a8e
f01219f2:	ff 75 0c             	pushl  0xc(%ebp)
f01219f5:	ff 75 08             	pushl  0x8(%ebp)
f01219f8:	e8 57 02 00 00       	call   f0121c54 <printfmt>
f01219fd:	83 c4 10             	add    $0x10,%esp
			break;
f0121a00:	e9 42 02 00 00       	jmp    f0121c47 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f0121a05:	8b 45 14             	mov    0x14(%ebp),%eax
f0121a08:	83 c0 04             	add    $0x4,%eax
f0121a0b:	89 45 14             	mov    %eax,0x14(%ebp)
f0121a0e:	8b 45 14             	mov    0x14(%ebp),%eax
f0121a11:	83 e8 04             	sub    $0x4,%eax
f0121a14:	8b 30                	mov    (%eax),%esi
f0121a16:	85 f6                	test   %esi,%esi
f0121a18:	75 05                	jne    f0121a1f <vprintfmt+0x1a6>
				p = "(null)";
f0121a1a:	be 91 3a 13 f0       	mov    $0xf0133a91,%esi
			if (width > 0 && padc != '-')
f0121a1f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121a23:	7e 6d                	jle    f0121a92 <vprintfmt+0x219>
f0121a25:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f0121a29:	74 67                	je     f0121a92 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f0121a2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0121a2e:	83 ec 08             	sub    $0x8,%esp
f0121a31:	50                   	push   %eax
f0121a32:	56                   	push   %esi
f0121a33:	e8 26 05 00 00       	call   f0121f5e <strnlen>
f0121a38:	83 c4 10             	add    $0x10,%esp
f0121a3b:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f0121a3e:	eb 16                	jmp    f0121a56 <vprintfmt+0x1dd>
					putch(padc, putdat);
f0121a40:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f0121a44:	83 ec 08             	sub    $0x8,%esp
f0121a47:	ff 75 0c             	pushl  0xc(%ebp)
f0121a4a:	50                   	push   %eax
f0121a4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a4e:	ff d0                	call   *%eax
f0121a50:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f0121a53:	ff 4d e4             	decl   -0x1c(%ebp)
f0121a56:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121a5a:	7f e4                	jg     f0121a40 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0121a5c:	eb 34                	jmp    f0121a92 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f0121a5e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0121a62:	74 1c                	je     f0121a80 <vprintfmt+0x207>
f0121a64:	83 fb 1f             	cmp    $0x1f,%ebx
f0121a67:	7e 05                	jle    f0121a6e <vprintfmt+0x1f5>
f0121a69:	83 fb 7e             	cmp    $0x7e,%ebx
f0121a6c:	7e 12                	jle    f0121a80 <vprintfmt+0x207>
					putch('?', putdat);
f0121a6e:	83 ec 08             	sub    $0x8,%esp
f0121a71:	ff 75 0c             	pushl  0xc(%ebp)
f0121a74:	6a 3f                	push   $0x3f
f0121a76:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a79:	ff d0                	call   *%eax
f0121a7b:	83 c4 10             	add    $0x10,%esp
f0121a7e:	eb 0f                	jmp    f0121a8f <vprintfmt+0x216>
				else
					putch(ch, putdat);
f0121a80:	83 ec 08             	sub    $0x8,%esp
f0121a83:	ff 75 0c             	pushl  0xc(%ebp)
f0121a86:	53                   	push   %ebx
f0121a87:	8b 45 08             	mov    0x8(%ebp),%eax
f0121a8a:	ff d0                	call   *%eax
f0121a8c:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0121a8f:	ff 4d e4             	decl   -0x1c(%ebp)
f0121a92:	89 f0                	mov    %esi,%eax
f0121a94:	8d 70 01             	lea    0x1(%eax),%esi
f0121a97:	8a 00                	mov    (%eax),%al
f0121a99:	0f be d8             	movsbl %al,%ebx
f0121a9c:	85 db                	test   %ebx,%ebx
f0121a9e:	74 24                	je     f0121ac4 <vprintfmt+0x24b>
f0121aa0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121aa4:	78 b8                	js     f0121a5e <vprintfmt+0x1e5>
f0121aa6:	ff 4d e0             	decl   -0x20(%ebp)
f0121aa9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0121aad:	79 af                	jns    f0121a5e <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f0121aaf:	eb 13                	jmp    f0121ac4 <vprintfmt+0x24b>
				putch(' ', putdat);
f0121ab1:	83 ec 08             	sub    $0x8,%esp
f0121ab4:	ff 75 0c             	pushl  0xc(%ebp)
f0121ab7:	6a 20                	push   $0x20
f0121ab9:	8b 45 08             	mov    0x8(%ebp),%eax
f0121abc:	ff d0                	call   *%eax
f0121abe:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f0121ac1:	ff 4d e4             	decl   -0x1c(%ebp)
f0121ac4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0121ac8:	7f e7                	jg     f0121ab1 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f0121aca:	e9 78 01 00 00       	jmp    f0121c47 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f0121acf:	83 ec 08             	sub    $0x8,%esp
f0121ad2:	ff 75 e8             	pushl  -0x18(%ebp)
f0121ad5:	8d 45 14             	lea    0x14(%ebp),%eax
f0121ad8:	50                   	push   %eax
f0121ad9:	e8 3c fd ff ff       	call   f012181a <getint>
f0121ade:	83 c4 10             	add    $0x10,%esp
f0121ae1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121ae4:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f0121ae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121aea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121aed:	85 d2                	test   %edx,%edx
f0121aef:	79 23                	jns    f0121b14 <vprintfmt+0x29b>
				putch('-', putdat);
f0121af1:	83 ec 08             	sub    $0x8,%esp
f0121af4:	ff 75 0c             	pushl  0xc(%ebp)
f0121af7:	6a 2d                	push   $0x2d
f0121af9:	8b 45 08             	mov    0x8(%ebp),%eax
f0121afc:	ff d0                	call   *%eax
f0121afe:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f0121b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121b04:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121b07:	f7 d8                	neg    %eax
f0121b09:	83 d2 00             	adc    $0x0,%edx
f0121b0c:	f7 da                	neg    %edx
f0121b0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121b11:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f0121b14:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0121b1b:	e9 bc 00 00 00       	jmp    f0121bdc <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f0121b20:	83 ec 08             	sub    $0x8,%esp
f0121b23:	ff 75 e8             	pushl  -0x18(%ebp)
f0121b26:	8d 45 14             	lea    0x14(%ebp),%eax
f0121b29:	50                   	push   %eax
f0121b2a:	e8 84 fc ff ff       	call   f01217b3 <getuint>
f0121b2f:	83 c4 10             	add    $0x10,%esp
f0121b32:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121b35:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f0121b38:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0121b3f:	e9 98 00 00 00       	jmp    f0121bdc <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f0121b44:	83 ec 08             	sub    $0x8,%esp
f0121b47:	ff 75 0c             	pushl  0xc(%ebp)
f0121b4a:	6a 58                	push   $0x58
f0121b4c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b4f:	ff d0                	call   *%eax
f0121b51:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0121b54:	83 ec 08             	sub    $0x8,%esp
f0121b57:	ff 75 0c             	pushl  0xc(%ebp)
f0121b5a:	6a 58                	push   $0x58
f0121b5c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b5f:	ff d0                	call   *%eax
f0121b61:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f0121b64:	83 ec 08             	sub    $0x8,%esp
f0121b67:	ff 75 0c             	pushl  0xc(%ebp)
f0121b6a:	6a 58                	push   $0x58
f0121b6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b6f:	ff d0                	call   *%eax
f0121b71:	83 c4 10             	add    $0x10,%esp
			break;
f0121b74:	e9 ce 00 00 00       	jmp    f0121c47 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f0121b79:	83 ec 08             	sub    $0x8,%esp
f0121b7c:	ff 75 0c             	pushl  0xc(%ebp)
f0121b7f:	6a 30                	push   $0x30
f0121b81:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b84:	ff d0                	call   *%eax
f0121b86:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f0121b89:	83 ec 08             	sub    $0x8,%esp
f0121b8c:	ff 75 0c             	pushl  0xc(%ebp)
f0121b8f:	6a 78                	push   $0x78
f0121b91:	8b 45 08             	mov    0x8(%ebp),%eax
f0121b94:	ff d0                	call   *%eax
f0121b96:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f0121b99:	8b 45 14             	mov    0x14(%ebp),%eax
f0121b9c:	83 c0 04             	add    $0x4,%eax
f0121b9f:	89 45 14             	mov    %eax,0x14(%ebp)
f0121ba2:	8b 45 14             	mov    0x14(%ebp),%eax
f0121ba5:	83 e8 04             	sub    $0x4,%eax
f0121ba8:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f0121baa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121bad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f0121bb4:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f0121bbb:	eb 1f                	jmp    f0121bdc <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f0121bbd:	83 ec 08             	sub    $0x8,%esp
f0121bc0:	ff 75 e8             	pushl  -0x18(%ebp)
f0121bc3:	8d 45 14             	lea    0x14(%ebp),%eax
f0121bc6:	50                   	push   %eax
f0121bc7:	e8 e7 fb ff ff       	call   f01217b3 <getuint>
f0121bcc:	83 c4 10             	add    $0x10,%esp
f0121bcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121bd2:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f0121bd5:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f0121bdc:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0121be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121be3:	83 ec 04             	sub    $0x4,%esp
f0121be6:	52                   	push   %edx
f0121be7:	ff 75 e4             	pushl  -0x1c(%ebp)
f0121bea:	50                   	push   %eax
f0121beb:	ff 75 f4             	pushl  -0xc(%ebp)
f0121bee:	ff 75 f0             	pushl  -0x10(%ebp)
f0121bf1:	ff 75 0c             	pushl  0xc(%ebp)
f0121bf4:	ff 75 08             	pushl  0x8(%ebp)
f0121bf7:	e8 00 fb ff ff       	call   f01216fc <printnum>
f0121bfc:	83 c4 20             	add    $0x20,%esp
			break;
f0121bff:	eb 46                	jmp    f0121c47 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f0121c01:	83 ec 08             	sub    $0x8,%esp
f0121c04:	ff 75 0c             	pushl  0xc(%ebp)
f0121c07:	53                   	push   %ebx
f0121c08:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c0b:	ff d0                	call   *%eax
f0121c0d:	83 c4 10             	add    $0x10,%esp
			break;
f0121c10:	eb 35                	jmp    f0121c47 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f0121c12:	c6 05 e0 57 74 f0 00 	movb   $0x0,0xf07457e0
			break;
f0121c19:	eb 2c                	jmp    f0121c47 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f0121c1b:	c6 05 e0 57 74 f0 01 	movb   $0x1,0xf07457e0
			break;
f0121c22:	eb 23                	jmp    f0121c47 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f0121c24:	83 ec 08             	sub    $0x8,%esp
f0121c27:	ff 75 0c             	pushl  0xc(%ebp)
f0121c2a:	6a 25                	push   $0x25
f0121c2c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121c2f:	ff d0                	call   *%eax
f0121c31:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f0121c34:	ff 4d 10             	decl   0x10(%ebp)
f0121c37:	eb 03                	jmp    f0121c3c <vprintfmt+0x3c3>
f0121c39:	ff 4d 10             	decl   0x10(%ebp)
f0121c3c:	8b 45 10             	mov    0x10(%ebp),%eax
f0121c3f:	48                   	dec    %eax
f0121c40:	8a 00                	mov    (%eax),%al
f0121c42:	3c 25                	cmp    $0x25,%al
f0121c44:	75 f3                	jne    f0121c39 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f0121c46:	90                   	nop
		}
	}
f0121c47:	e9 35 fc ff ff       	jmp    f0121881 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f0121c4c:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f0121c4d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0121c50:	5b                   	pop    %ebx
f0121c51:	5e                   	pop    %esi
f0121c52:	5d                   	pop    %ebp
f0121c53:	c3                   	ret    

f0121c54 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f0121c54:	55                   	push   %ebp
f0121c55:	89 e5                	mov    %esp,%ebp
f0121c57:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f0121c5a:	8d 45 10             	lea    0x10(%ebp),%eax
f0121c5d:	83 c0 04             	add    $0x4,%eax
f0121c60:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f0121c63:	8b 45 10             	mov    0x10(%ebp),%eax
f0121c66:	ff 75 f4             	pushl  -0xc(%ebp)
f0121c69:	50                   	push   %eax
f0121c6a:	ff 75 0c             	pushl  0xc(%ebp)
f0121c6d:	ff 75 08             	pushl  0x8(%ebp)
f0121c70:	e8 04 fc ff ff       	call   f0121879 <vprintfmt>
f0121c75:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0121c78:	90                   	nop
f0121c79:	c9                   	leave  
f0121c7a:	c3                   	ret    

f0121c7b <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f0121c7b:	55                   	push   %ebp
f0121c7c:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f0121c7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c81:	8b 40 08             	mov    0x8(%eax),%eax
f0121c84:	8d 50 01             	lea    0x1(%eax),%edx
f0121c87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c8a:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f0121c8d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c90:	8b 10                	mov    (%eax),%edx
f0121c92:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c95:	8b 40 04             	mov    0x4(%eax),%eax
f0121c98:	39 c2                	cmp    %eax,%edx
f0121c9a:	73 12                	jae    f0121cae <sprintputch+0x33>
		*b->buf++ = ch;
f0121c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121c9f:	8b 00                	mov    (%eax),%eax
f0121ca1:	8d 48 01             	lea    0x1(%eax),%ecx
f0121ca4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121ca7:	89 0a                	mov    %ecx,(%edx)
f0121ca9:	8b 55 08             	mov    0x8(%ebp),%edx
f0121cac:	88 10                	mov    %dl,(%eax)
}
f0121cae:	90                   	nop
f0121caf:	5d                   	pop    %ebp
f0121cb0:	c3                   	ret    

f0121cb1 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f0121cb1:	55                   	push   %ebp
f0121cb2:	89 e5                	mov    %esp,%ebp
f0121cb4:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f0121cb7:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cba:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0121cbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121cc0:	8d 50 ff             	lea    -0x1(%eax),%edx
f0121cc3:	8b 45 08             	mov    0x8(%ebp),%eax
f0121cc6:	01 d0                	add    %edx,%eax
f0121cc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0121ccb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f0121cd2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121cd6:	74 06                	je     f0121cde <vsnprintf+0x2d>
f0121cd8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121cdc:	7f 07                	jg     f0121ce5 <vsnprintf+0x34>
		return -E_INVAL;
f0121cde:	b8 03 00 00 00       	mov    $0x3,%eax
f0121ce3:	eb 20                	jmp    f0121d05 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f0121ce5:	ff 75 14             	pushl  0x14(%ebp)
f0121ce8:	ff 75 10             	pushl  0x10(%ebp)
f0121ceb:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0121cee:	50                   	push   %eax
f0121cef:	68 7b 1c 12 f0       	push   $0xf0121c7b
f0121cf4:	e8 80 fb ff ff       	call   f0121879 <vprintfmt>
f0121cf9:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f0121cfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0121cff:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f0121d02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0121d05:	c9                   	leave  
f0121d06:	c3                   	ret    

f0121d07 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f0121d07:	55                   	push   %ebp
f0121d08:	89 e5                	mov    %esp,%ebp
f0121d0a:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f0121d0d:	8d 45 10             	lea    0x10(%ebp),%eax
f0121d10:	83 c0 04             	add    $0x4,%eax
f0121d13:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f0121d16:	8b 45 10             	mov    0x10(%ebp),%eax
f0121d19:	ff 75 f4             	pushl  -0xc(%ebp)
f0121d1c:	50                   	push   %eax
f0121d1d:	ff 75 0c             	pushl  0xc(%ebp)
f0121d20:	ff 75 08             	pushl  0x8(%ebp)
f0121d23:	e8 89 ff ff ff       	call   f0121cb1 <vsnprintf>
f0121d28:	83 c4 10             	add    $0x10,%esp
f0121d2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f0121d2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0121d31:	c9                   	leave  
f0121d32:	c3                   	ret    

f0121d33 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f0121d33:	55                   	push   %ebp
f0121d34:	89 e5                	mov    %esp,%ebp
f0121d36:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f0121d39:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121d3d:	74 13                	je     f0121d52 <readline+0x1f>
		cprintf("%s", prompt);
f0121d3f:	83 ec 08             	sub    $0x8,%esp
f0121d42:	ff 75 08             	pushl  0x8(%ebp)
f0121d45:	68 08 3c 13 f0       	push   $0xf0133c08
f0121d4a:	e8 3c f2 fd ff       	call   f0100f8b <cprintf>
f0121d4f:	83 c4 10             	add    $0x10,%esp

	i = 0;
f0121d52:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f0121d59:	83 ec 0c             	sub    $0xc,%esp
f0121d5c:	6a 00                	push   $0x0
f0121d5e:	e8 35 f1 fd ff       	call   f0100e98 <iscons>
f0121d63:	83 c4 10             	add    $0x10,%esp
f0121d66:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f0121d69:	e8 11 f1 fd ff       	call   f0100e7f <getchar>
f0121d6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f0121d71:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0121d75:	79 22                	jns    f0121d99 <readline+0x66>
			if (c != -E_EOF)
f0121d77:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0121d7b:	0f 84 ad 00 00 00    	je     f0121e2e <readline+0xfb>
				cprintf("read error: %e\n", c);
f0121d81:	83 ec 08             	sub    $0x8,%esp
f0121d84:	ff 75 ec             	pushl  -0x14(%ebp)
f0121d87:	68 0b 3c 13 f0       	push   $0xf0133c0b
f0121d8c:	e8 fa f1 fd ff       	call   f0100f8b <cprintf>
f0121d91:	83 c4 10             	add    $0x10,%esp
			break;
f0121d94:	e9 95 00 00 00       	jmp    f0121e2e <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f0121d99:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0121d9d:	7e 34                	jle    f0121dd3 <readline+0xa0>
f0121d9f:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0121da6:	7f 2b                	jg     f0121dd3 <readline+0xa0>
			if (echoing)
f0121da8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121dac:	74 0e                	je     f0121dbc <readline+0x89>
				cputchar(c);
f0121dae:	83 ec 0c             	sub    $0xc,%esp
f0121db1:	ff 75 ec             	pushl  -0x14(%ebp)
f0121db4:	e8 af f0 fd ff       	call   f0100e68 <cputchar>
f0121db9:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0121dbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121dbf:	8d 50 01             	lea    0x1(%eax),%edx
f0121dc2:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0121dc5:	89 c2                	mov    %eax,%edx
f0121dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121dca:	01 d0                	add    %edx,%eax
f0121dcc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121dcf:	88 10                	mov    %dl,(%eax)
f0121dd1:	eb 56                	jmp    f0121e29 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f0121dd3:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0121dd7:	75 1f                	jne    f0121df8 <readline+0xc5>
f0121dd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121ddd:	7e 19                	jle    f0121df8 <readline+0xc5>
			if (echoing)
f0121ddf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121de3:	74 0e                	je     f0121df3 <readline+0xc0>
				cputchar(c);
f0121de5:	83 ec 0c             	sub    $0xc,%esp
f0121de8:	ff 75 ec             	pushl  -0x14(%ebp)
f0121deb:	e8 78 f0 fd ff       	call   f0100e68 <cputchar>
f0121df0:	83 c4 10             	add    $0x10,%esp

			i--;
f0121df3:	ff 4d f4             	decl   -0xc(%ebp)
f0121df6:	eb 31                	jmp    f0121e29 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f0121df8:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0121dfc:	74 0a                	je     f0121e08 <readline+0xd5>
f0121dfe:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f0121e02:	0f 85 61 ff ff ff    	jne    f0121d69 <readline+0x36>
			if (echoing)
f0121e08:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121e0c:	74 0e                	je     f0121e1c <readline+0xe9>
				cputchar(c);
f0121e0e:	83 ec 0c             	sub    $0xc,%esp
f0121e11:	ff 75 ec             	pushl  -0x14(%ebp)
f0121e14:	e8 4f f0 fd ff       	call   f0100e68 <cputchar>
f0121e19:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f0121e1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121e1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121e22:	01 d0                	add    %edx,%eax
f0121e24:	c6 00 00             	movb   $0x0,(%eax)
			break;
f0121e27:	eb 06                	jmp    f0121e2f <readline+0xfc>
		}
	}
f0121e29:	e9 3b ff ff ff       	jmp    f0121d69 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f0121e2e:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f0121e2f:	90                   	nop
f0121e30:	c9                   	leave  
f0121e31:	c3                   	ret    

f0121e32 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f0121e32:	55                   	push   %ebp
f0121e33:	89 e5                	mov    %esp,%ebp
f0121e35:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f0121e38:	e8 66 ce fe ff       	call   f010eca3 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f0121e3d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0121e41:	74 13                	je     f0121e56 <atomic_readline+0x24>
			cprintf("%s", prompt);
f0121e43:	83 ec 08             	sub    $0x8,%esp
f0121e46:	ff 75 08             	pushl  0x8(%ebp)
f0121e49:	68 08 3c 13 f0       	push   $0xf0133c08
f0121e4e:	e8 38 f1 fd ff       	call   f0100f8b <cprintf>
f0121e53:	83 c4 10             	add    $0x10,%esp

		i = 0;
f0121e56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f0121e5d:	83 ec 0c             	sub    $0xc,%esp
f0121e60:	6a 00                	push   $0x0
f0121e62:	e8 31 f0 fd ff       	call   f0100e98 <iscons>
f0121e67:	83 c4 10             	add    $0x10,%esp
f0121e6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f0121e6d:	e8 0d f0 fd ff       	call   f0100e7f <getchar>
f0121e72:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f0121e75:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0121e79:	79 22                	jns    f0121e9d <atomic_readline+0x6b>
				if (c != -E_EOF)
f0121e7b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0121e7f:	0f 84 ad 00 00 00    	je     f0121f32 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f0121e85:	83 ec 08             	sub    $0x8,%esp
f0121e88:	ff 75 ec             	pushl  -0x14(%ebp)
f0121e8b:	68 0b 3c 13 f0       	push   $0xf0133c0b
f0121e90:	e8 f6 f0 fd ff       	call   f0100f8b <cprintf>
f0121e95:	83 c4 10             	add    $0x10,%esp
				break;
f0121e98:	e9 95 00 00 00       	jmp    f0121f32 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f0121e9d:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0121ea1:	7e 34                	jle    f0121ed7 <atomic_readline+0xa5>
f0121ea3:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f0121eaa:	7f 2b                	jg     f0121ed7 <atomic_readline+0xa5>
				if (echoing)
f0121eac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121eb0:	74 0e                	je     f0121ec0 <atomic_readline+0x8e>
					cputchar(c);
f0121eb2:	83 ec 0c             	sub    $0xc,%esp
f0121eb5:	ff 75 ec             	pushl  -0x14(%ebp)
f0121eb8:	e8 ab ef fd ff       	call   f0100e68 <cputchar>
f0121ebd:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f0121ec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0121ec3:	8d 50 01             	lea    0x1(%eax),%edx
f0121ec6:	89 55 f4             	mov    %edx,-0xc(%ebp)
f0121ec9:	89 c2                	mov    %eax,%edx
f0121ecb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121ece:	01 d0                	add    %edx,%eax
f0121ed0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0121ed3:	88 10                	mov    %dl,(%eax)
f0121ed5:	eb 56                	jmp    f0121f2d <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f0121ed7:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f0121edb:	75 1f                	jne    f0121efc <atomic_readline+0xca>
f0121edd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121ee1:	7e 19                	jle    f0121efc <atomic_readline+0xca>
				if (echoing)
f0121ee3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121ee7:	74 0e                	je     f0121ef7 <atomic_readline+0xc5>
					cputchar(c);
f0121ee9:	83 ec 0c             	sub    $0xc,%esp
f0121eec:	ff 75 ec             	pushl  -0x14(%ebp)
f0121eef:	e8 74 ef fd ff       	call   f0100e68 <cputchar>
f0121ef4:	83 c4 10             	add    $0x10,%esp
				i--;
f0121ef7:	ff 4d f4             	decl   -0xc(%ebp)
f0121efa:	eb 31                	jmp    f0121f2d <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f0121efc:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0121f00:	74 0a                	je     f0121f0c <atomic_readline+0xda>
f0121f02:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f0121f06:	0f 85 61 ff ff ff    	jne    f0121e6d <atomic_readline+0x3b>
				if (echoing)
f0121f0c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0121f10:	74 0e                	je     f0121f20 <atomic_readline+0xee>
					cputchar(c);
f0121f12:	83 ec 0c             	sub    $0xc,%esp
f0121f15:	ff 75 ec             	pushl  -0x14(%ebp)
f0121f18:	e8 4b ef fd ff       	call   f0100e68 <cputchar>
f0121f1d:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f0121f20:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121f23:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121f26:	01 d0                	add    %edx,%eax
f0121f28:	c6 00 00             	movb   $0x0,(%eax)
				break;
f0121f2b:	eb 06                	jmp    f0121f33 <atomic_readline+0x101>
			}
		}
f0121f2d:	e9 3b ff ff ff       	jmp    f0121e6d <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f0121f32:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f0121f33:	e8 79 cd fe ff       	call   f010ecb1 <sys_unlock_cons>
}
f0121f38:	90                   	nop
f0121f39:	c9                   	leave  
f0121f3a:	c3                   	ret    

f0121f3b <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f0121f3b:	55                   	push   %ebp
f0121f3c:	89 e5                	mov    %esp,%ebp
f0121f3e:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0121f41:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121f48:	eb 06                	jmp    f0121f50 <strlen+0x15>
		n++;
f0121f4a:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f0121f4d:	ff 45 08             	incl   0x8(%ebp)
f0121f50:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f53:	8a 00                	mov    (%eax),%al
f0121f55:	84 c0                	test   %al,%al
f0121f57:	75 f1                	jne    f0121f4a <strlen+0xf>
		n++;
	return n;
f0121f59:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0121f5c:	c9                   	leave  
f0121f5d:	c3                   	ret    

f0121f5e <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f0121f5e:	55                   	push   %ebp
f0121f5f:	89 e5                	mov    %esp,%ebp
f0121f61:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0121f64:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121f6b:	eb 09                	jmp    f0121f76 <strnlen+0x18>
		n++;
f0121f6d:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0121f70:	ff 45 08             	incl   0x8(%ebp)
f0121f73:	ff 4d 0c             	decl   0xc(%ebp)
f0121f76:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121f7a:	74 09                	je     f0121f85 <strnlen+0x27>
f0121f7c:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f7f:	8a 00                	mov    (%eax),%al
f0121f81:	84 c0                	test   %al,%al
f0121f83:	75 e8                	jne    f0121f6d <strnlen+0xf>
		n++;
	return n;
f0121f85:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0121f88:	c9                   	leave  
f0121f89:	c3                   	ret    

f0121f8a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f0121f8a:	55                   	push   %ebp
f0121f8b:	89 e5                	mov    %esp,%ebp
f0121f8d:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f0121f90:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f93:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f0121f96:	90                   	nop
f0121f97:	8b 45 08             	mov    0x8(%ebp),%eax
f0121f9a:	8d 50 01             	lea    0x1(%eax),%edx
f0121f9d:	89 55 08             	mov    %edx,0x8(%ebp)
f0121fa0:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121fa3:	8d 4a 01             	lea    0x1(%edx),%ecx
f0121fa6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0121fa9:	8a 12                	mov    (%edx),%dl
f0121fab:	88 10                	mov    %dl,(%eax)
f0121fad:	8a 00                	mov    (%eax),%al
f0121faf:	84 c0                	test   %al,%al
f0121fb1:	75 e4                	jne    f0121f97 <strcpy+0xd>
		/* do nothing */;
	return ret;
f0121fb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0121fb6:	c9                   	leave  
f0121fb7:	c3                   	ret    

f0121fb8 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f0121fb8:	55                   	push   %ebp
f0121fb9:	89 e5                	mov    %esp,%ebp
f0121fbb:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f0121fbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0121fc1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f0121fc4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0121fcb:	eb 1f                	jmp    f0121fec <strncpy+0x34>
		*dst++ = *src;
f0121fcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0121fd0:	8d 50 01             	lea    0x1(%eax),%edx
f0121fd3:	89 55 08             	mov    %edx,0x8(%ebp)
f0121fd6:	8b 55 0c             	mov    0xc(%ebp),%edx
f0121fd9:	8a 12                	mov    (%edx),%dl
f0121fdb:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f0121fdd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121fe0:	8a 00                	mov    (%eax),%al
f0121fe2:	84 c0                	test   %al,%al
f0121fe4:	74 03                	je     f0121fe9 <strncpy+0x31>
			src++;
f0121fe6:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f0121fe9:	ff 45 fc             	incl   -0x4(%ebp)
f0121fec:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0121fef:	3b 45 10             	cmp    0x10(%ebp),%eax
f0121ff2:	72 d9                	jb     f0121fcd <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f0121ff4:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0121ff7:	c9                   	leave  
f0121ff8:	c3                   	ret    

f0121ff9 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f0121ff9:	55                   	push   %ebp
f0121ffa:	89 e5                	mov    %esp,%ebp
f0121ffc:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f0121fff:	8b 45 08             	mov    0x8(%ebp),%eax
f0122002:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f0122005:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122009:	74 30                	je     f012203b <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f012200b:	eb 16                	jmp    f0122023 <strlcpy+0x2a>
			*dst++ = *src++;
f012200d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122010:	8d 50 01             	lea    0x1(%eax),%edx
f0122013:	89 55 08             	mov    %edx,0x8(%ebp)
f0122016:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122019:	8d 4a 01             	lea    0x1(%edx),%ecx
f012201c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f012201f:	8a 12                	mov    (%edx),%dl
f0122021:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f0122023:	ff 4d 10             	decl   0x10(%ebp)
f0122026:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012202a:	74 09                	je     f0122035 <strlcpy+0x3c>
f012202c:	8b 45 0c             	mov    0xc(%ebp),%eax
f012202f:	8a 00                	mov    (%eax),%al
f0122031:	84 c0                	test   %al,%al
f0122033:	75 d8                	jne    f012200d <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f0122035:	8b 45 08             	mov    0x8(%ebp),%eax
f0122038:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f012203b:	8b 55 08             	mov    0x8(%ebp),%edx
f012203e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122041:	29 c2                	sub    %eax,%edx
f0122043:	89 d0                	mov    %edx,%eax
}
f0122045:	c9                   	leave  
f0122046:	c3                   	ret    

f0122047 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f0122047:	55                   	push   %ebp
f0122048:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f012204a:	eb 06                	jmp    f0122052 <strcmp+0xb>
		p++, q++;
f012204c:	ff 45 08             	incl   0x8(%ebp)
f012204f:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0122052:	8b 45 08             	mov    0x8(%ebp),%eax
f0122055:	8a 00                	mov    (%eax),%al
f0122057:	84 c0                	test   %al,%al
f0122059:	74 0e                	je     f0122069 <strcmp+0x22>
f012205b:	8b 45 08             	mov    0x8(%ebp),%eax
f012205e:	8a 10                	mov    (%eax),%dl
f0122060:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122063:	8a 00                	mov    (%eax),%al
f0122065:	38 c2                	cmp    %al,%dl
f0122067:	74 e3                	je     f012204c <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f0122069:	8b 45 08             	mov    0x8(%ebp),%eax
f012206c:	8a 00                	mov    (%eax),%al
f012206e:	0f b6 d0             	movzbl %al,%edx
f0122071:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122074:	8a 00                	mov    (%eax),%al
f0122076:	0f b6 c0             	movzbl %al,%eax
f0122079:	29 c2                	sub    %eax,%edx
f012207b:	89 d0                	mov    %edx,%eax
}
f012207d:	5d                   	pop    %ebp
f012207e:	c3                   	ret    

f012207f <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f012207f:	55                   	push   %ebp
f0122080:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f0122082:	eb 09                	jmp    f012208d <strncmp+0xe>
		n--, p++, q++;
f0122084:	ff 4d 10             	decl   0x10(%ebp)
f0122087:	ff 45 08             	incl   0x8(%ebp)
f012208a:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f012208d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122091:	74 17                	je     f01220aa <strncmp+0x2b>
f0122093:	8b 45 08             	mov    0x8(%ebp),%eax
f0122096:	8a 00                	mov    (%eax),%al
f0122098:	84 c0                	test   %al,%al
f012209a:	74 0e                	je     f01220aa <strncmp+0x2b>
f012209c:	8b 45 08             	mov    0x8(%ebp),%eax
f012209f:	8a 10                	mov    (%eax),%dl
f01220a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01220a4:	8a 00                	mov    (%eax),%al
f01220a6:	38 c2                	cmp    %al,%dl
f01220a8:	74 da                	je     f0122084 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f01220aa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01220ae:	75 07                	jne    f01220b7 <strncmp+0x38>
		return 0;
f01220b0:	b8 00 00 00 00       	mov    $0x0,%eax
f01220b5:	eb 14                	jmp    f01220cb <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f01220b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01220ba:	8a 00                	mov    (%eax),%al
f01220bc:	0f b6 d0             	movzbl %al,%edx
f01220bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01220c2:	8a 00                	mov    (%eax),%al
f01220c4:	0f b6 c0             	movzbl %al,%eax
f01220c7:	29 c2                	sub    %eax,%edx
f01220c9:	89 d0                	mov    %edx,%eax
}
f01220cb:	5d                   	pop    %ebp
f01220cc:	c3                   	ret    

f01220cd <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f01220cd:	55                   	push   %ebp
f01220ce:	89 e5                	mov    %esp,%ebp
f01220d0:	83 ec 04             	sub    $0x4,%esp
f01220d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01220d6:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01220d9:	eb 12                	jmp    f01220ed <strchr+0x20>
		if (*s == c)
f01220db:	8b 45 08             	mov    0x8(%ebp),%eax
f01220de:	8a 00                	mov    (%eax),%al
f01220e0:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01220e3:	75 05                	jne    f01220ea <strchr+0x1d>
			return (char *) s;
f01220e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01220e8:	eb 11                	jmp    f01220fb <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f01220ea:	ff 45 08             	incl   0x8(%ebp)
f01220ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01220f0:	8a 00                	mov    (%eax),%al
f01220f2:	84 c0                	test   %al,%al
f01220f4:	75 e5                	jne    f01220db <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f01220f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01220fb:	c9                   	leave  
f01220fc:	c3                   	ret    

f01220fd <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f01220fd:	55                   	push   %ebp
f01220fe:	89 e5                	mov    %esp,%ebp
f0122100:	83 ec 04             	sub    $0x4,%esp
f0122103:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122106:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0122109:	eb 0d                	jmp    f0122118 <strfind+0x1b>
		if (*s == c)
f012210b:	8b 45 08             	mov    0x8(%ebp),%eax
f012210e:	8a 00                	mov    (%eax),%al
f0122110:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0122113:	74 0e                	je     f0122123 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f0122115:	ff 45 08             	incl   0x8(%ebp)
f0122118:	8b 45 08             	mov    0x8(%ebp),%eax
f012211b:	8a 00                	mov    (%eax),%al
f012211d:	84 c0                	test   %al,%al
f012211f:	75 ea                	jne    f012210b <strfind+0xe>
f0122121:	eb 01                	jmp    f0122124 <strfind+0x27>
		if (*s == c)
			break;
f0122123:	90                   	nop
	return (char *) s;
f0122124:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122127:	c9                   	leave  
f0122128:	c3                   	ret    

f0122129 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f0122129:	55                   	push   %ebp
f012212a:	89 e5                	mov    %esp,%ebp
f012212c:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f012212f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122132:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f0122135:	8b 45 10             	mov    0x10(%ebp),%eax
f0122138:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f012213b:	eb 0e                	jmp    f012214b <memset+0x22>
		*p++ = c;
f012213d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122140:	8d 50 01             	lea    0x1(%eax),%edx
f0122143:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0122146:	8b 55 0c             	mov    0xc(%ebp),%edx
f0122149:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f012214b:	ff 4d f8             	decl   -0x8(%ebp)
f012214e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0122152:	79 e9                	jns    f012213d <memset+0x14>
		*p++ = c;

	return v;
f0122154:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122157:	c9                   	leave  
f0122158:	c3                   	ret    

f0122159 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f0122159:	55                   	push   %ebp
f012215a:	89 e5                	mov    %esp,%ebp
f012215c:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012215f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122162:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0122165:	8b 45 08             	mov    0x8(%ebp),%eax
f0122168:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f012216b:	eb 16                	jmp    f0122183 <memcpy+0x2a>
		*d++ = *s++;
f012216d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122170:	8d 50 01             	lea    0x1(%eax),%edx
f0122173:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0122176:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122179:	8d 4a 01             	lea    0x1(%edx),%ecx
f012217c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f012217f:	8a 12                	mov    (%edx),%dl
f0122181:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f0122183:	8b 45 10             	mov    0x10(%ebp),%eax
f0122186:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122189:	89 55 10             	mov    %edx,0x10(%ebp)
f012218c:	85 c0                	test   %eax,%eax
f012218e:	75 dd                	jne    f012216d <memcpy+0x14>
		*d++ = *s++;

	return dst;
f0122190:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122193:	c9                   	leave  
f0122194:	c3                   	ret    

f0122195 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f0122195:	55                   	push   %ebp
f0122196:	89 e5                	mov    %esp,%ebp
f0122198:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f012219b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012219e:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f01221a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01221a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f01221a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01221aa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01221ad:	73 50                	jae    f01221ff <memmove+0x6a>
f01221af:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01221b2:	8b 45 10             	mov    0x10(%ebp),%eax
f01221b5:	01 d0                	add    %edx,%eax
f01221b7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01221ba:	76 43                	jbe    f01221ff <memmove+0x6a>
		s += n;
f01221bc:	8b 45 10             	mov    0x10(%ebp),%eax
f01221bf:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f01221c2:	8b 45 10             	mov    0x10(%ebp),%eax
f01221c5:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f01221c8:	eb 10                	jmp    f01221da <memmove+0x45>
			*--d = *--s;
f01221ca:	ff 4d f8             	decl   -0x8(%ebp)
f01221cd:	ff 4d fc             	decl   -0x4(%ebp)
f01221d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01221d3:	8a 10                	mov    (%eax),%dl
f01221d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01221d8:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f01221da:	8b 45 10             	mov    0x10(%ebp),%eax
f01221dd:	8d 50 ff             	lea    -0x1(%eax),%edx
f01221e0:	89 55 10             	mov    %edx,0x10(%ebp)
f01221e3:	85 c0                	test   %eax,%eax
f01221e5:	75 e3                	jne    f01221ca <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f01221e7:	eb 23                	jmp    f012220c <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f01221e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01221ec:	8d 50 01             	lea    0x1(%eax),%edx
f01221ef:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01221f2:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01221f5:	8d 4a 01             	lea    0x1(%edx),%ecx
f01221f8:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01221fb:	8a 12                	mov    (%edx),%dl
f01221fd:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f01221ff:	8b 45 10             	mov    0x10(%ebp),%eax
f0122202:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122205:	89 55 10             	mov    %edx,0x10(%ebp)
f0122208:	85 c0                	test   %eax,%eax
f012220a:	75 dd                	jne    f01221e9 <memmove+0x54>
			*d++ = *s++;

	return dst;
f012220c:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012220f:	c9                   	leave  
f0122210:	c3                   	ret    

f0122211 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f0122211:	55                   	push   %ebp
f0122212:	89 e5                	mov    %esp,%ebp
f0122214:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f0122217:	8b 45 08             	mov    0x8(%ebp),%eax
f012221a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f012221d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122220:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f0122223:	eb 2a                	jmp    f012224f <memcmp+0x3e>
		if (*s1 != *s2)
f0122225:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122228:	8a 10                	mov    (%eax),%dl
f012222a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012222d:	8a 00                	mov    (%eax),%al
f012222f:	38 c2                	cmp    %al,%dl
f0122231:	74 16                	je     f0122249 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f0122233:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122236:	8a 00                	mov    (%eax),%al
f0122238:	0f b6 d0             	movzbl %al,%edx
f012223b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012223e:	8a 00                	mov    (%eax),%al
f0122240:	0f b6 c0             	movzbl %al,%eax
f0122243:	29 c2                	sub    %eax,%edx
f0122245:	89 d0                	mov    %edx,%eax
f0122247:	eb 18                	jmp    f0122261 <memcmp+0x50>
		s1++, s2++;
f0122249:	ff 45 fc             	incl   -0x4(%ebp)
f012224c:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f012224f:	8b 45 10             	mov    0x10(%ebp),%eax
f0122252:	8d 50 ff             	lea    -0x1(%eax),%edx
f0122255:	89 55 10             	mov    %edx,0x10(%ebp)
f0122258:	85 c0                	test   %eax,%eax
f012225a:	75 c9                	jne    f0122225 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f012225c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122261:	c9                   	leave  
f0122262:	c3                   	ret    

f0122263 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f0122263:	55                   	push   %ebp
f0122264:	89 e5                	mov    %esp,%ebp
f0122266:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f0122269:	8b 55 08             	mov    0x8(%ebp),%edx
f012226c:	8b 45 10             	mov    0x10(%ebp),%eax
f012226f:	01 d0                	add    %edx,%eax
f0122271:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f0122274:	eb 15                	jmp    f012228b <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f0122276:	8b 45 08             	mov    0x8(%ebp),%eax
f0122279:	8a 00                	mov    (%eax),%al
f012227b:	0f b6 d0             	movzbl %al,%edx
f012227e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122281:	0f b6 c0             	movzbl %al,%eax
f0122284:	39 c2                	cmp    %eax,%edx
f0122286:	74 0d                	je     f0122295 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0122288:	ff 45 08             	incl   0x8(%ebp)
f012228b:	8b 45 08             	mov    0x8(%ebp),%eax
f012228e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0122291:	72 e3                	jb     f0122276 <memfind+0x13>
f0122293:	eb 01                	jmp    f0122296 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f0122295:	90                   	nop
	return (void *) s;
f0122296:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0122299:	c9                   	leave  
f012229a:	c3                   	ret    

f012229b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f012229b:	55                   	push   %ebp
f012229c:	89 e5                	mov    %esp,%ebp
f012229e:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f01222a1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f01222a8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01222af:	eb 03                	jmp    f01222b4 <strtol+0x19>
		s++;
f01222b1:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01222b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01222b7:	8a 00                	mov    (%eax),%al
f01222b9:	3c 20                	cmp    $0x20,%al
f01222bb:	74 f4                	je     f01222b1 <strtol+0x16>
f01222bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01222c0:	8a 00                	mov    (%eax),%al
f01222c2:	3c 09                	cmp    $0x9,%al
f01222c4:	74 eb                	je     f01222b1 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f01222c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01222c9:	8a 00                	mov    (%eax),%al
f01222cb:	3c 2b                	cmp    $0x2b,%al
f01222cd:	75 05                	jne    f01222d4 <strtol+0x39>
		s++;
f01222cf:	ff 45 08             	incl   0x8(%ebp)
f01222d2:	eb 13                	jmp    f01222e7 <strtol+0x4c>
	else if (*s == '-')
f01222d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01222d7:	8a 00                	mov    (%eax),%al
f01222d9:	3c 2d                	cmp    $0x2d,%al
f01222db:	75 0a                	jne    f01222e7 <strtol+0x4c>
		s++, neg = 1;
f01222dd:	ff 45 08             	incl   0x8(%ebp)
f01222e0:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f01222e7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01222eb:	74 06                	je     f01222f3 <strtol+0x58>
f01222ed:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f01222f1:	75 20                	jne    f0122313 <strtol+0x78>
f01222f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01222f6:	8a 00                	mov    (%eax),%al
f01222f8:	3c 30                	cmp    $0x30,%al
f01222fa:	75 17                	jne    f0122313 <strtol+0x78>
f01222fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01222ff:	40                   	inc    %eax
f0122300:	8a 00                	mov    (%eax),%al
f0122302:	3c 78                	cmp    $0x78,%al
f0122304:	75 0d                	jne    f0122313 <strtol+0x78>
		s += 2, base = 16;
f0122306:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f012230a:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0122311:	eb 28                	jmp    f012233b <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f0122313:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122317:	75 15                	jne    f012232e <strtol+0x93>
f0122319:	8b 45 08             	mov    0x8(%ebp),%eax
f012231c:	8a 00                	mov    (%eax),%al
f012231e:	3c 30                	cmp    $0x30,%al
f0122320:	75 0c                	jne    f012232e <strtol+0x93>
		s++, base = 8;
f0122322:	ff 45 08             	incl   0x8(%ebp)
f0122325:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f012232c:	eb 0d                	jmp    f012233b <strtol+0xa0>
	else if (base == 0)
f012232e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122332:	75 07                	jne    f012233b <strtol+0xa0>
		base = 10;
f0122334:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f012233b:	8b 45 08             	mov    0x8(%ebp),%eax
f012233e:	8a 00                	mov    (%eax),%al
f0122340:	3c 2f                	cmp    $0x2f,%al
f0122342:	7e 19                	jle    f012235d <strtol+0xc2>
f0122344:	8b 45 08             	mov    0x8(%ebp),%eax
f0122347:	8a 00                	mov    (%eax),%al
f0122349:	3c 39                	cmp    $0x39,%al
f012234b:	7f 10                	jg     f012235d <strtol+0xc2>
			dig = *s - '0';
f012234d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122350:	8a 00                	mov    (%eax),%al
f0122352:	0f be c0             	movsbl %al,%eax
f0122355:	83 e8 30             	sub    $0x30,%eax
f0122358:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012235b:	eb 42                	jmp    f012239f <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f012235d:	8b 45 08             	mov    0x8(%ebp),%eax
f0122360:	8a 00                	mov    (%eax),%al
f0122362:	3c 60                	cmp    $0x60,%al
f0122364:	7e 19                	jle    f012237f <strtol+0xe4>
f0122366:	8b 45 08             	mov    0x8(%ebp),%eax
f0122369:	8a 00                	mov    (%eax),%al
f012236b:	3c 7a                	cmp    $0x7a,%al
f012236d:	7f 10                	jg     f012237f <strtol+0xe4>
			dig = *s - 'a' + 10;
f012236f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122372:	8a 00                	mov    (%eax),%al
f0122374:	0f be c0             	movsbl %al,%eax
f0122377:	83 e8 57             	sub    $0x57,%eax
f012237a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f012237d:	eb 20                	jmp    f012239f <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f012237f:	8b 45 08             	mov    0x8(%ebp),%eax
f0122382:	8a 00                	mov    (%eax),%al
f0122384:	3c 40                	cmp    $0x40,%al
f0122386:	7e 39                	jle    f01223c1 <strtol+0x126>
f0122388:	8b 45 08             	mov    0x8(%ebp),%eax
f012238b:	8a 00                	mov    (%eax),%al
f012238d:	3c 5a                	cmp    $0x5a,%al
f012238f:	7f 30                	jg     f01223c1 <strtol+0x126>
			dig = *s - 'A' + 10;
f0122391:	8b 45 08             	mov    0x8(%ebp),%eax
f0122394:	8a 00                	mov    (%eax),%al
f0122396:	0f be c0             	movsbl %al,%eax
f0122399:	83 e8 37             	sub    $0x37,%eax
f012239c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f012239f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01223a2:	3b 45 10             	cmp    0x10(%ebp),%eax
f01223a5:	7d 19                	jge    f01223c0 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f01223a7:	ff 45 08             	incl   0x8(%ebp)
f01223aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01223ad:	0f af 45 10          	imul   0x10(%ebp),%eax
f01223b1:	89 c2                	mov    %eax,%edx
f01223b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01223b6:	01 d0                	add    %edx,%eax
f01223b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f01223bb:	e9 7b ff ff ff       	jmp    f012233b <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01223c0:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01223c1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01223c5:	74 08                	je     f01223cf <strtol+0x134>
		*endptr = (char *) s;
f01223c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01223ca:	8b 55 08             	mov    0x8(%ebp),%edx
f01223cd:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01223cf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01223d3:	74 07                	je     f01223dc <strtol+0x141>
f01223d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01223d8:	f7 d8                	neg    %eax
f01223da:	eb 03                	jmp    f01223df <strtol+0x144>
f01223dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01223df:	c9                   	leave  
f01223e0:	c3                   	ret    

f01223e1 <ltostr>:

void
ltostr(long value, char *str)
{
f01223e1:	55                   	push   %ebp
f01223e2:	89 e5                	mov    %esp,%ebp
f01223e4:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01223e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f01223ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f01223f5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01223f9:	79 13                	jns    f012240e <ltostr+0x2d>
	{
		neg = 1;
f01223fb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0122402:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122405:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0122408:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f012240b:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f012240e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122411:	b9 0a 00 00 00       	mov    $0xa,%ecx
f0122416:	99                   	cltd   
f0122417:	f7 f9                	idiv   %ecx
f0122419:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f012241c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012241f:	8d 50 01             	lea    0x1(%eax),%edx
f0122422:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0122425:	89 c2                	mov    %eax,%edx
f0122427:	8b 45 0c             	mov    0xc(%ebp),%eax
f012242a:	01 d0                	add    %edx,%eax
f012242c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012242f:	83 c2 30             	add    $0x30,%edx
f0122432:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0122434:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0122437:	b8 67 66 66 66       	mov    $0x66666667,%eax
f012243c:	f7 e9                	imul   %ecx
f012243e:	c1 fa 02             	sar    $0x2,%edx
f0122441:	89 c8                	mov    %ecx,%eax
f0122443:	c1 f8 1f             	sar    $0x1f,%eax
f0122446:	29 c2                	sub    %eax,%edx
f0122448:	89 d0                	mov    %edx,%eax
f012244a:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f012244d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122451:	75 bb                	jne    f012240e <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0122453:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f012245a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012245d:	48                   	dec    %eax
f012245e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0122461:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0122465:	74 3d                	je     f01224a4 <ltostr+0xc3>
		start = 1 ;
f0122467:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f012246e:	eb 34                	jmp    f01224a4 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0122470:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122473:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122476:	01 d0                	add    %edx,%eax
f0122478:	8a 00                	mov    (%eax),%al
f012247a:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f012247d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122480:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122483:	01 c2                	add    %eax,%edx
f0122485:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0122488:	8b 45 0c             	mov    0xc(%ebp),%eax
f012248b:	01 c8                	add    %ecx,%eax
f012248d:	8a 00                	mov    (%eax),%al
f012248f:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0122491:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122494:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122497:	01 c2                	add    %eax,%edx
f0122499:	8a 45 eb             	mov    -0x15(%ebp),%al
f012249c:	88 02                	mov    %al,(%edx)
		start++ ;
f012249e:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f01224a1:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f01224a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01224a7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01224aa:	7c c4                	jl     f0122470 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f01224ac:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01224af:	8b 45 0c             	mov    0xc(%ebp),%eax
f01224b2:	01 d0                	add    %edx,%eax
f01224b4:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f01224b7:	90                   	nop
f01224b8:	c9                   	leave  
f01224b9:	c3                   	ret    

f01224ba <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f01224ba:	55                   	push   %ebp
f01224bb:	89 e5                	mov    %esp,%ebp
f01224bd:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f01224c0:	ff 75 08             	pushl  0x8(%ebp)
f01224c3:	e8 73 fa ff ff       	call   f0121f3b <strlen>
f01224c8:	83 c4 04             	add    $0x4,%esp
f01224cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f01224ce:	ff 75 0c             	pushl  0xc(%ebp)
f01224d1:	e8 65 fa ff ff       	call   f0121f3b <strlen>
f01224d6:	83 c4 04             	add    $0x4,%esp
f01224d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f01224dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f01224e3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01224ea:	eb 17                	jmp    f0122503 <strcconcat+0x49>
		final[s] = str1[s] ;
f01224ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01224ef:	8b 45 10             	mov    0x10(%ebp),%eax
f01224f2:	01 c2                	add    %eax,%edx
f01224f4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f01224f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01224fa:	01 c8                	add    %ecx,%eax
f01224fc:	8a 00                	mov    (%eax),%al
f01224fe:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0122500:	ff 45 fc             	incl   -0x4(%ebp)
f0122503:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122506:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0122509:	7c e1                	jl     f01224ec <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f012250b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0122512:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0122519:	eb 1f                	jmp    f012253a <strcconcat+0x80>
		final[s++] = str2[i] ;
f012251b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012251e:	8d 50 01             	lea    0x1(%eax),%edx
f0122521:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0122524:	89 c2                	mov    %eax,%edx
f0122526:	8b 45 10             	mov    0x10(%ebp),%eax
f0122529:	01 c2                	add    %eax,%edx
f012252b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f012252e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122531:	01 c8                	add    %ecx,%eax
f0122533:	8a 00                	mov    (%eax),%al
f0122535:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0122537:	ff 45 f8             	incl   -0x8(%ebp)
f012253a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f012253d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0122540:	7c d9                	jl     f012251b <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0122542:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0122545:	8b 45 10             	mov    0x10(%ebp),%eax
f0122548:	01 d0                	add    %edx,%eax
f012254a:	c6 00 00             	movb   $0x0,(%eax)
}
f012254d:	90                   	nop
f012254e:	c9                   	leave  
f012254f:	c3                   	ret    

f0122550 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0122550:	55                   	push   %ebp
f0122551:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0122553:	8b 45 14             	mov    0x14(%ebp),%eax
f0122556:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f012255c:	8b 45 14             	mov    0x14(%ebp),%eax
f012255f:	8b 00                	mov    (%eax),%eax
f0122561:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122568:	8b 45 10             	mov    0x10(%ebp),%eax
f012256b:	01 d0                	add    %edx,%eax
f012256d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122573:	eb 0c                	jmp    f0122581 <strsplit+0x31>
			*string++ = 0;
f0122575:	8b 45 08             	mov    0x8(%ebp),%eax
f0122578:	8d 50 01             	lea    0x1(%eax),%edx
f012257b:	89 55 08             	mov    %edx,0x8(%ebp)
f012257e:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0122581:	8b 45 08             	mov    0x8(%ebp),%eax
f0122584:	8a 00                	mov    (%eax),%al
f0122586:	84 c0                	test   %al,%al
f0122588:	74 18                	je     f01225a2 <strsplit+0x52>
f012258a:	8b 45 08             	mov    0x8(%ebp),%eax
f012258d:	8a 00                	mov    (%eax),%al
f012258f:	0f be c0             	movsbl %al,%eax
f0122592:	50                   	push   %eax
f0122593:	ff 75 0c             	pushl  0xc(%ebp)
f0122596:	e8 32 fb ff ff       	call   f01220cd <strchr>
f012259b:	83 c4 08             	add    $0x8,%esp
f012259e:	85 c0                	test   %eax,%eax
f01225a0:	75 d3                	jne    f0122575 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f01225a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01225a5:	8a 00                	mov    (%eax),%al
f01225a7:	84 c0                	test   %al,%al
f01225a9:	74 5a                	je     f0122605 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f01225ab:	8b 45 14             	mov    0x14(%ebp),%eax
f01225ae:	8b 00                	mov    (%eax),%eax
f01225b0:	83 f8 0f             	cmp    $0xf,%eax
f01225b3:	75 07                	jne    f01225bc <strsplit+0x6c>
		{
			return 0;
f01225b5:	b8 00 00 00 00       	mov    $0x0,%eax
f01225ba:	eb 66                	jmp    f0122622 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f01225bc:	8b 45 14             	mov    0x14(%ebp),%eax
f01225bf:	8b 00                	mov    (%eax),%eax
f01225c1:	8d 48 01             	lea    0x1(%eax),%ecx
f01225c4:	8b 55 14             	mov    0x14(%ebp),%edx
f01225c7:	89 0a                	mov    %ecx,(%edx)
f01225c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01225d0:	8b 45 10             	mov    0x10(%ebp),%eax
f01225d3:	01 c2                	add    %eax,%edx
f01225d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01225d8:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f01225da:	eb 03                	jmp    f01225df <strsplit+0x8f>
			string++;
f01225dc:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f01225df:	8b 45 08             	mov    0x8(%ebp),%eax
f01225e2:	8a 00                	mov    (%eax),%al
f01225e4:	84 c0                	test   %al,%al
f01225e6:	74 8b                	je     f0122573 <strsplit+0x23>
f01225e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01225eb:	8a 00                	mov    (%eax),%al
f01225ed:	0f be c0             	movsbl %al,%eax
f01225f0:	50                   	push   %eax
f01225f1:	ff 75 0c             	pushl  0xc(%ebp)
f01225f4:	e8 d4 fa ff ff       	call   f01220cd <strchr>
f01225f9:	83 c4 08             	add    $0x8,%esp
f01225fc:	85 c0                	test   %eax,%eax
f01225fe:	74 dc                	je     f01225dc <strsplit+0x8c>
			string++;
	}
f0122600:	e9 6e ff ff ff       	jmp    f0122573 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0122605:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0122606:	8b 45 14             	mov    0x14(%ebp),%eax
f0122609:	8b 00                	mov    (%eax),%eax
f012260b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0122612:	8b 45 10             	mov    0x10(%ebp),%eax
f0122615:	01 d0                	add    %edx,%eax
f0122617:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f012261d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0122622:	c9                   	leave  
f0122623:	c3                   	ret    

f0122624 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0122624:	55                   	push   %ebp
f0122625:	89 e5                	mov    %esp,%ebp
f0122627:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f012262a:	83 ec 04             	sub    $0x4,%esp
f012262d:	68 1c 3c 13 f0       	push   $0xf0133c1c
f0122632:	68 3f 01 00 00       	push   $0x13f
f0122637:	68 3e 3c 13 f0       	push   $0xf0133c3e
f012263c:	e8 f8 dc fd ff       	call   f0100339 <_panic>

f0122641 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0122641:	55                   	push   %ebp
f0122642:	89 e5                	mov    %esp,%ebp
f0122644:	83 ec 18             	sub    $0x18,%esp
f0122647:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f012264e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122651:	89 c2                	mov    %eax,%edx
f0122653:	ec                   	in     (%dx),%al
f0122654:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0122657:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f012265a:	0f b6 c0             	movzbl %al,%eax
f012265d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122660:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122663:	25 c0 00 00 00       	and    $0xc0,%eax
f0122668:	83 f8 40             	cmp    $0x40,%eax
f012266b:	75 10                	jne    f012267d <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f012266d:	83 ec 0c             	sub    $0xc,%esp
f0122670:	68 00 57 74 f0       	push   $0xf0745700
f0122675:	e8 cc e5 fe ff       	call   f0110c46 <wakeup_one>
f012267a:	83 c4 10             	add    $0x10,%esp
	}

}
f012267d:	90                   	nop
f012267e:	c9                   	leave  
f012267f:	c3                   	ret    

f0122680 <ide_init>:

void ide_init()
{
f0122680:	55                   	push   %ebp
f0122681:	89 e5                	mov    %esp,%ebp
f0122683:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0122686:	83 ec 08             	sub    $0x8,%esp
f0122689:	68 41 26 12 f0       	push   $0xf0122641
f012268e:	6a 0e                	push   $0xe
f0122690:	e8 11 c1 fe ff       	call   f010e7a6 <irq_install_handler>
f0122695:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0122698:	83 ec 08             	sub    $0x8,%esp
f012269b:	68 4c 3c 13 f0       	push   $0xf0133c4c
f01226a0:	68 00 57 74 f0       	push   $0xf0745700
f01226a5:	e8 01 e5 fe ff       	call   f0110bab <init_channel>
f01226aa:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f01226ad:	83 ec 08             	sub    $0x8,%esp
f01226b0:	68 59 3c 13 f0       	push   $0xf0133c59
f01226b5:	68 20 5d 74 f0       	push   $0xf0745d20
f01226ba:	e8 fa e0 fe ff       	call   f01107b9 <init_spinlock>
f01226bf:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f01226c2:	90                   	nop
f01226c3:	c9                   	leave  
f01226c4:	c3                   	ret    

f01226c5 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f01226c5:	55                   	push   %ebp
f01226c6:	89 e5                	mov    %esp,%ebp
f01226c8:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f01226cb:	90                   	nop
f01226cc:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01226d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01226d6:	89 c2                	mov    %eax,%edx
f01226d8:	ec                   	in     (%dx),%al
f01226d9:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f01226dc:	8a 45 ef             	mov    -0x11(%ebp),%al
f01226df:	0f b6 c0             	movzbl %al,%eax
f01226e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01226e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01226e8:	25 c0 00 00 00       	and    $0xc0,%eax
f01226ed:	83 f8 40             	cmp    $0x40,%eax
f01226f0:	75 da                	jne    f01226cc <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f01226f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01226f6:	74 24                	je     f012271c <ide_wait_ready+0x57>
f01226f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01226fb:	83 e0 21             	and    $0x21,%eax
f01226fe:	85 c0                	test   %eax,%eax
f0122700:	74 1a                	je     f012271c <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0122702:	83 ec 0c             	sub    $0xc,%esp
f0122705:	ff 75 f4             	pushl  -0xc(%ebp)
f0122708:	ff 75 f4             	pushl  -0xc(%ebp)
f012270b:	68 6c 3c 13 f0       	push   $0xf0133c6c
f0122710:	6a 5d                	push   $0x5d
f0122712:	68 8f 3c 13 f0       	push   $0xf0133c8f
f0122717:	e8 1d dc fd ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f012271c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0122721:	c9                   	leave  
f0122722:	c3                   	ret    

f0122723 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0122723:	55                   	push   %ebp
f0122724:	89 e5                	mov    %esp,%ebp
f0122726:	57                   	push   %edi
f0122727:	53                   	push   %ebx
f0122728:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f012272b:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122732:	76 16                	jbe    f012274a <ide_read+0x27>
f0122734:	68 9a 3c 13 f0       	push   $0xf0133c9a
f0122739:	68 a7 3c 13 f0       	push   $0xf0133ca7
f012273e:	6a 68                	push   $0x68
f0122740:	68 8f 3c 13 f0       	push   $0xf0133c8f
f0122745:	e8 ef db fd ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f012274a:	83 ec 0c             	sub    $0xc,%esp
f012274d:	6a 00                	push   $0x0
f012274f:	e8 71 ff ff ff       	call   f01226c5 <ide_wait_ready>
f0122754:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0122757:	8b 45 10             	mov    0x10(%ebp),%eax
f012275a:	0f b6 c0             	movzbl %al,%eax
f012275d:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0122764:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0122767:	8a 45 d2             	mov    -0x2e(%ebp),%al
f012276a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012276d:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f012276e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122771:	0f b6 c0             	movzbl %al,%eax
f0122774:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f012277b:	88 45 d3             	mov    %al,-0x2d(%ebp)
f012277e:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0122781:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122784:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0122785:	8b 45 08             	mov    0x8(%ebp),%eax
f0122788:	c1 e8 08             	shr    $0x8,%eax
f012278b:	0f b6 c0             	movzbl %al,%eax
f012278e:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0122795:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0122798:	8a 45 d4             	mov    -0x2c(%ebp),%al
f012279b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012279e:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f012279f:	8b 45 08             	mov    0x8(%ebp),%eax
f01227a2:	c1 e8 10             	shr    $0x10,%eax
f01227a5:	0f b6 c0             	movzbl %al,%eax
f01227a8:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01227af:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01227b2:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01227b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01227b8:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01227b9:	a1 b0 55 74 f0       	mov    0xf07455b0,%eax
f01227be:	83 e0 01             	and    $0x1,%eax
f01227c1:	c1 e0 04             	shl    $0x4,%eax
f01227c4:	88 c2                	mov    %al,%dl
f01227c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01227c9:	c1 e8 18             	shr    $0x18,%eax
f01227cc:	83 e0 0f             	and    $0xf,%eax
f01227cf:	09 d0                	or     %edx,%eax
f01227d1:	83 c8 e0             	or     $0xffffffe0,%eax
f01227d4:	0f b6 c0             	movzbl %al,%eax
f01227d7:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f01227de:	88 45 d6             	mov    %al,-0x2a(%ebp)
f01227e1:	8a 45 d6             	mov    -0x2a(%ebp),%al
f01227e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01227e7:	ee                   	out    %al,(%dx)
f01227e8:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f01227ef:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f01227f3:	8a 45 d7             	mov    -0x29(%ebp),%al
f01227f6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01227f9:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f01227fa:	eb 55                	jmp    f0122851 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f01227fc:	83 ec 0c             	sub    $0xc,%esp
f01227ff:	6a 01                	push   $0x1
f0122801:	e8 bf fe ff ff       	call   f01226c5 <ide_wait_ready>
f0122806:	83 c4 10             	add    $0x10,%esp
f0122809:	89 45 dc             	mov    %eax,-0x24(%ebp)
f012280c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122810:	79 05                	jns    f0122817 <ide_read+0xf4>
			return r;
f0122812:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122815:	eb 45                	jmp    f012285c <ide_read+0x139>
f0122817:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f012281e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122821:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0122824:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f012282b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012282e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0122831:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0122834:	89 cb                	mov    %ecx,%ebx
f0122836:	89 df                	mov    %ebx,%edi
f0122838:	89 c1                	mov    %eax,%ecx
f012283a:	fc                   	cld    
f012283b:	f2 6d                	repnz insl (%dx),%es:(%edi)
f012283d:	89 c8                	mov    %ecx,%eax
f012283f:	89 fb                	mov    %edi,%ebx
f0122841:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0122844:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0122847:	ff 4d 10             	decl   0x10(%ebp)
f012284a:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0122851:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122855:	75 a5                	jne    f01227fc <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0122857:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012285c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f012285f:	5b                   	pop    %ebx
f0122860:	5f                   	pop    %edi
f0122861:	5d                   	pop    %ebp
f0122862:	c3                   	ret    

f0122863 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0122863:	55                   	push   %ebp
f0122864:	89 e5                	mov    %esp,%ebp
f0122866:	56                   	push   %esi
f0122867:	53                   	push   %ebx
f0122868:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f012286b:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0122872:	76 19                	jbe    f012288d <ide_write+0x2a>
f0122874:	68 9a 3c 13 f0       	push   $0xf0133c9a
f0122879:	68 a7 3c 13 f0       	push   $0xf0133ca7
f012287e:	68 82 00 00 00       	push   $0x82
f0122883:	68 8f 3c 13 f0       	push   $0xf0133c8f
f0122888:	e8 ac da fd ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f012288d:	83 ec 0c             	sub    $0xc,%esp
f0122890:	6a 00                	push   $0x0
f0122892:	e8 2e fe ff ff       	call   f01226c5 <ide_wait_ready>
f0122897:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f012289a:	8b 45 10             	mov    0x10(%ebp),%eax
f012289d:	0f b6 c0             	movzbl %al,%eax
f01228a0:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f01228a7:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01228aa:	8a 45 d2             	mov    -0x2e(%ebp),%al
f01228ad:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01228b0:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f01228b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01228b4:	0f b6 c0             	movzbl %al,%eax
f01228b7:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f01228be:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01228c1:	8a 45 d3             	mov    -0x2d(%ebp),%al
f01228c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01228c7:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f01228c8:	8b 45 08             	mov    0x8(%ebp),%eax
f01228cb:	c1 e8 08             	shr    $0x8,%eax
f01228ce:	0f b6 c0             	movzbl %al,%eax
f01228d1:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f01228d8:	88 45 d4             	mov    %al,-0x2c(%ebp)
f01228db:	8a 45 d4             	mov    -0x2c(%ebp),%al
f01228de:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01228e1:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f01228e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01228e5:	c1 e8 10             	shr    $0x10,%eax
f01228e8:	0f b6 c0             	movzbl %al,%eax
f01228eb:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f01228f2:	88 45 d5             	mov    %al,-0x2b(%ebp)
f01228f5:	8a 45 d5             	mov    -0x2b(%ebp),%al
f01228f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01228fb:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f01228fc:	a1 b0 55 74 f0       	mov    0xf07455b0,%eax
f0122901:	83 e0 01             	and    $0x1,%eax
f0122904:	c1 e0 04             	shl    $0x4,%eax
f0122907:	88 c2                	mov    %al,%dl
f0122909:	8b 45 08             	mov    0x8(%ebp),%eax
f012290c:	c1 e8 18             	shr    $0x18,%eax
f012290f:	83 e0 0f             	and    $0xf,%eax
f0122912:	09 d0                	or     %edx,%eax
f0122914:	83 c8 e0             	or     $0xffffffe0,%eax
f0122917:	0f b6 c0             	movzbl %al,%eax
f012291a:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0122921:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0122924:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0122927:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012292a:	ee                   	out    %al,(%dx)
f012292b:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0122932:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0122936:	8a 45 d7             	mov    -0x29(%ebp),%al
f0122939:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012293c:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f012293d:	eb 55                	jmp    f0122994 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f012293f:	83 ec 0c             	sub    $0xc,%esp
f0122942:	6a 01                	push   $0x1
f0122944:	e8 7c fd ff ff       	call   f01226c5 <ide_wait_ready>
f0122949:	83 c4 10             	add    $0x10,%esp
f012294c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f012294f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0122953:	79 05                	jns    f012295a <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0122955:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122958:	eb 45                	jmp    f012299f <ide_write+0x13c>
f012295a:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0122961:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122964:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0122967:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f012296e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122971:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0122974:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0122977:	89 cb                	mov    %ecx,%ebx
f0122979:	89 de                	mov    %ebx,%esi
f012297b:	89 c1                	mov    %eax,%ecx
f012297d:	fc                   	cld    
f012297e:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0122980:	89 c8                	mov    %ecx,%eax
f0122982:	89 f3                	mov    %esi,%ebx
f0122984:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0122987:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f012298a:	ff 4d 10             	decl   0x10(%ebp)
f012298d:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0122994:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0122998:	75 a5                	jne    f012293f <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f012299a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f012299f:	8d 65 f8             	lea    -0x8(%ebp),%esp
f01229a2:	5b                   	pop    %ebx
f01229a3:	5e                   	pop    %esi
f01229a4:	5d                   	pop    %ebp
f01229a5:	c3                   	ret    

f01229a6 <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f01229a6:	55                   	push   %ebp
f01229a7:	89 e5                	mov    %esp,%ebp
f01229a9:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01229ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01229af:	83 e8 04             	sub    $0x4,%eax
f01229b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f01229b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01229b8:	8b 00                	mov    (%eax),%eax
f01229ba:	83 e0 fe             	and    $0xfffffffe,%eax
}
f01229bd:	c9                   	leave  
f01229be:	c3                   	ret    

f01229bf <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f01229bf:	55                   	push   %ebp
f01229c0:	89 e5                	mov    %esp,%ebp
f01229c2:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f01229c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01229c8:	83 e8 04             	sub    $0x4,%eax
f01229cb:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f01229ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01229d1:	8b 00                	mov    (%eax),%eax
f01229d3:	83 e0 01             	and    $0x1,%eax
f01229d6:	85 c0                	test   %eax,%eax
f01229d8:	0f 94 c0             	sete   %al
}
f01229db:	c9                   	leave  
f01229dc:	c3                   	ret    

f01229dd <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f01229dd:	55                   	push   %ebp
f01229de:	89 e5                	mov    %esp,%ebp
f01229e0:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f01229e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f01229ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01229ed:	83 f8 02             	cmp    $0x2,%eax
f01229f0:	74 2b                	je     f0122a1d <alloc_block+0x40>
f01229f2:	83 f8 02             	cmp    $0x2,%eax
f01229f5:	7f 07                	jg     f01229fe <alloc_block+0x21>
f01229f7:	83 f8 01             	cmp    $0x1,%eax
f01229fa:	74 0e                	je     f0122a0a <alloc_block+0x2d>
f01229fc:	eb 58                	jmp    f0122a56 <alloc_block+0x79>
f01229fe:	83 f8 03             	cmp    $0x3,%eax
f0122a01:	74 2d                	je     f0122a30 <alloc_block+0x53>
f0122a03:	83 f8 04             	cmp    $0x4,%eax
f0122a06:	74 3b                	je     f0122a43 <alloc_block+0x66>
f0122a08:	eb 4c                	jmp    f0122a56 <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0122a0a:	83 ec 0c             	sub    $0xc,%esp
f0122a0d:	ff 75 08             	pushl  0x8(%ebp)
f0122a10:	e8 f7 03 00 00       	call   f0122e0c <alloc_block_FF>
f0122a15:	83 c4 10             	add    $0x10,%esp
f0122a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122a1b:	eb 4a                	jmp    f0122a67 <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0122a1d:	83 ec 0c             	sub    $0xc,%esp
f0122a20:	ff 75 08             	pushl  0x8(%ebp)
f0122a23:	e8 f0 11 00 00       	call   f0123c18 <alloc_block_NF>
f0122a28:	83 c4 10             	add    $0x10,%esp
f0122a2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122a2e:	eb 37                	jmp    f0122a67 <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0122a30:	83 ec 0c             	sub    $0xc,%esp
f0122a33:	ff 75 08             	pushl  0x8(%ebp)
f0122a36:	e8 08 08 00 00       	call   f0123243 <alloc_block_BF>
f0122a3b:	83 c4 10             	add    $0x10,%esp
f0122a3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122a41:	eb 24                	jmp    f0122a67 <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0122a43:	83 ec 0c             	sub    $0xc,%esp
f0122a46:	ff 75 08             	pushl  0x8(%ebp)
f0122a49:	e8 ad 11 00 00       	call   f0123bfb <alloc_block_WF>
f0122a4e:	83 c4 10             	add    $0x10,%esp
f0122a51:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0122a54:	eb 11                	jmp    f0122a67 <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f0122a56:	83 ec 0c             	sub    $0xc,%esp
f0122a59:	68 bc 3c 13 f0       	push   $0xf0133cbc
f0122a5e:	e8 28 e5 fd ff       	call   f0100f8b <cprintf>
f0122a63:	83 c4 10             	add    $0x10,%esp
		break;
f0122a66:	90                   	nop
	}
	return va;
f0122a67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0122a6a:	c9                   	leave  
f0122a6b:	c3                   	ret    

f0122a6c <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0122a6c:	55                   	push   %ebp
f0122a6d:	89 e5                	mov    %esp,%ebp
f0122a6f:	53                   	push   %ebx
f0122a70:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0122a73:	83 ec 0c             	sub    $0xc,%esp
f0122a76:	68 dc 3c 13 f0       	push   $0xf0133cdc
f0122a7b:	e8 0b e5 fd ff       	call   f0100f8b <cprintf>
f0122a80:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0122a83:	83 ec 0c             	sub    $0xc,%esp
f0122a86:	68 07 3d 13 f0       	push   $0xf0133d07
f0122a8b:	e8 fb e4 fd ff       	call   f0100f8b <cprintf>
f0122a90:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f0122a93:	8b 45 08             	mov    0x8(%ebp),%eax
f0122a96:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122a99:	eb 37                	jmp    f0122ad2 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0122a9b:	83 ec 0c             	sub    $0xc,%esp
f0122a9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0122aa1:	e8 19 ff ff ff       	call   f01229bf <is_free_block>
f0122aa6:	83 c4 10             	add    $0x10,%esp
f0122aa9:	0f be d8             	movsbl %al,%ebx
f0122aac:	83 ec 0c             	sub    $0xc,%esp
f0122aaf:	ff 75 f4             	pushl  -0xc(%ebp)
f0122ab2:	e8 ef fe ff ff       	call   f01229a6 <get_block_size>
f0122ab7:	83 c4 10             	add    $0x10,%esp
f0122aba:	83 ec 04             	sub    $0x4,%esp
f0122abd:	53                   	push   %ebx
f0122abe:	50                   	push   %eax
f0122abf:	68 1f 3d 13 f0       	push   $0xf0133d1f
f0122ac4:	e8 c2 e4 fd ff       	call   f0100f8b <cprintf>
f0122ac9:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f0122acc:	8b 45 10             	mov    0x10(%ebp),%eax
f0122acf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122ad2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122ad6:	74 07                	je     f0122adf <print_blocks_list+0x73>
f0122ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122adb:	8b 00                	mov    (%eax),%eax
f0122add:	eb 05                	jmp    f0122ae4 <print_blocks_list+0x78>
f0122adf:	b8 00 00 00 00       	mov    $0x0,%eax
f0122ae4:	89 45 10             	mov    %eax,0x10(%ebp)
f0122ae7:	8b 45 10             	mov    0x10(%ebp),%eax
f0122aea:	85 c0                	test   %eax,%eax
f0122aec:	75 ad                	jne    f0122a9b <print_blocks_list+0x2f>
f0122aee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122af2:	75 a7                	jne    f0122a9b <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f0122af4:	83 ec 0c             	sub    $0xc,%esp
f0122af7:	68 dc 3c 13 f0       	push   $0xf0133cdc
f0122afc:	e8 8a e4 fd ff       	call   f0100f8b <cprintf>
f0122b01:	83 c4 10             	add    $0x10,%esp

}
f0122b04:	90                   	nop
f0122b05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0122b08:	c9                   	leave  
f0122b09:	c3                   	ret    

f0122b0a <initialize_dynamic_allocator>:

//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0122b0a:	55                   	push   %ebp
f0122b0b:	89 e5                	mov    %esp,%ebp
f0122b0d:	83 ec 18             	sub    $0x18,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0122b10:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b13:	83 e0 01             	and    $0x1,%eax
f0122b16:	85 c0                	test   %eax,%eax
f0122b18:	74 03                	je     f0122b1d <initialize_dynamic_allocator+0x13>
f0122b1a:	ff 45 0c             	incl   0xc(%ebp)
		if (initSizeOfAllocatedSpace == 0)
f0122b1d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0122b21:	0f 84 f8 00 00 00    	je     f0122c1f <initialize_dynamic_allocator+0x115>
			return ;
		is_initialized = 1;
f0122b27:	c7 05 b4 55 74 f0 01 	movl   $0x1,0xf07455b4
f0122b2e:	00 00 00 
	//TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("initialize_dynamic_allocator is not implemented yet");
	//Your Code is Here...

	if(is_initialized){
f0122b31:	a1 b4 55 74 f0       	mov    0xf07455b4,%eax
f0122b36:	85 c0                	test   %eax,%eax
f0122b38:	0f 84 e2 00 00 00    	je     f0122c20 <initialize_dynamic_allocator+0x116>

		// begin block with size 0 and lsb = 1 (allocated)
		uint32* beginBlock = (uint32*)daStart;
f0122b3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0122b41:	89 45 f4             	mov    %eax,-0xc(%ebp)
		*beginBlock = 0 | 1; // size = 0, LSB as a flag = 1
f0122b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122b47:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		// end block with size 0 and lsb = 1 (allocated)
		uint32* endBlock = (uint32*)(daStart + initSizeOfAllocatedSpace - 4);
f0122b4d:	8b 55 08             	mov    0x8(%ebp),%edx
f0122b50:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b53:	01 d0                	add    %edx,%eax
f0122b55:	83 e8 04             	sub    $0x4,%eax
f0122b58:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*endBlock = 0 | 1; // size = 0, LSB as a flag = 1
f0122b5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0122b5e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

		// the block that between begin and end blocks
		struct BlockElement* block = (struct BlockElement*)(daStart + 8);
f0122b64:	8b 45 08             	mov    0x8(%ebp),%eax
f0122b67:	83 c0 08             	add    $0x8,%eax
f0122b6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 blockSize = initSizeOfAllocatedSpace - 8; // subtract size of begin and end blocks
f0122b6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122b70:	83 e8 08             	sub    $0x8,%eax
f0122b73:	89 45 e8             	mov    %eax,-0x18(%ebp)
		set_block_data(block,blockSize,0);
f0122b76:	83 ec 04             	sub    $0x4,%esp
f0122b79:	6a 00                	push   $0x0
f0122b7b:	ff 75 e8             	pushl  -0x18(%ebp)
f0122b7e:	ff 75 ec             	pushl  -0x14(%ebp)
f0122b81:	e8 9c 00 00 00       	call   f0122c22 <set_block_data>
f0122b86:	83 c4 10             	add    $0x10,%esp

		block->prev_next_info.le_next = NULL;
f0122b89:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122b8c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		block->prev_next_info.le_prev = NULL;
f0122b92:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122b95:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

		LIST_INIT(&freeBlocksList);
f0122b9c:	c7 05 30 59 74 f0 00 	movl   $0x0,0xf0745930
f0122ba3:	00 00 00 
f0122ba6:	c7 05 34 59 74 f0 00 	movl   $0x0,0xf0745934
f0122bad:	00 00 00 
f0122bb0:	c7 05 3c 59 74 f0 00 	movl   $0x0,0xf074593c
f0122bb7:	00 00 00 
		LIST_INSERT_HEAD(&freeBlocksList, block);
f0122bba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0122bbe:	75 17                	jne    f0122bd7 <initialize_dynamic_allocator+0xcd>
f0122bc0:	83 ec 04             	sub    $0x4,%esp
f0122bc3:	68 38 3d 13 f0       	push   $0xf0133d38
f0122bc8:	68 80 00 00 00       	push   $0x80
f0122bcd:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122bd2:	e8 62 d7 fd ff       	call   f0100339 <_panic>
f0122bd7:	8b 15 30 59 74 f0    	mov    0xf0745930,%edx
f0122bdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122be0:	89 10                	mov    %edx,(%eax)
f0122be2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122be5:	8b 00                	mov    (%eax),%eax
f0122be7:	85 c0                	test   %eax,%eax
f0122be9:	74 0d                	je     f0122bf8 <initialize_dynamic_allocator+0xee>
f0122beb:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0122bf0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0122bf3:	89 50 04             	mov    %edx,0x4(%eax)
f0122bf6:	eb 08                	jmp    f0122c00 <initialize_dynamic_allocator+0xf6>
f0122bf8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122bfb:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0122c00:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122c03:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0122c08:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122c0b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122c12:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0122c17:	40                   	inc    %eax
f0122c18:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
f0122c1d:	eb 01                	jmp    f0122c20 <initialize_dynamic_allocator+0x116>
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
		if (initSizeOfAllocatedSpace == 0)
			return ;
f0122c1f:	90                   	nop
		block->prev_next_info.le_prev = NULL;

		LIST_INIT(&freeBlocksList);
		LIST_INSERT_HEAD(&freeBlocksList, block);
	}
}
f0122c20:	c9                   	leave  
f0122c21:	c3                   	ret    

f0122c22 <set_block_data>:
//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f0122c22:	55                   	push   %ebp
f0122c23:	89 e5                	mov    %esp,%ebp
f0122c25:	83 ec 10             	sub    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("set_block_data is not implemented yet");
	//Your Code is Here...

	if(totalSize % 2 != 0)
f0122c28:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122c2b:	83 e0 01             	and    $0x1,%eax
f0122c2e:	85 c0                	test   %eax,%eax
f0122c30:	74 03                	je     f0122c35 <set_block_data+0x13>
	{
		totalSize++;
f0122c32:	ff 45 0c             	incl   0xc(%ebp)
	}

	uint32* header = (uint32 *)((uint32*)va-1);
f0122c35:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c38:	83 e8 04             	sub    $0x4,%eax
f0122c3b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	//	size => totalSize with LSB = 0		 set LSB = 1 if isAllocated
	*header = (totalSize & ~1) | (isAllocated & 1);
f0122c3e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122c41:	83 e0 fe             	and    $0xfffffffe,%eax
f0122c44:	89 c2                	mov    %eax,%edx
f0122c46:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c49:	83 e0 01             	and    $0x1,%eax
f0122c4c:	09 c2                	or     %eax,%edx
f0122c4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0122c51:	89 10                	mov    %edx,(%eax)
	uint32* footer = (uint32*) (va + totalSize - 8);
f0122c53:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122c56:	8d 50 f8             	lea    -0x8(%eax),%edx
f0122c59:	8b 45 08             	mov    0x8(%ebp),%eax
f0122c5c:	01 d0                	add    %edx,%eax
f0122c5e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	*footer = (totalSize & ~1) | (isAllocated & 1);
f0122c61:	8b 45 0c             	mov    0xc(%ebp),%eax
f0122c64:	83 e0 fe             	and    $0xfffffffe,%eax
f0122c67:	89 c2                	mov    %eax,%edx
f0122c69:	8b 45 10             	mov    0x10(%ebp),%eax
f0122c6c:	83 e0 01             	and    $0x1,%eax
f0122c6f:	09 c2                	or     %eax,%edx
f0122c71:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0122c74:	89 10                	mov    %edx,(%eax)
}
f0122c76:	90                   	nop
f0122c77:	c9                   	leave  
f0122c78:	c3                   	ret    

f0122c79 <insert_sorted_in_freeList>:
//=========================================
void insert_sorted_in_freeList(struct BlockElement *newBlock)
{
f0122c79:	55                   	push   %ebp
f0122c7a:	89 e5                	mov    %esp,%ebp
f0122c7c:	83 ec 18             	sub    $0x18,%esp
	if(LIST_EMPTY(&freeBlocksList))
f0122c7f:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0122c84:	85 c0                	test   %eax,%eax
f0122c86:	75 68                	jne    f0122cf0 <insert_sorted_in_freeList+0x77>
	{
		LIST_INSERT_HEAD(&freeBlocksList, newBlock);
f0122c88:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122c8c:	75 17                	jne    f0122ca5 <insert_sorted_in_freeList+0x2c>
f0122c8e:	83 ec 04             	sub    $0x4,%esp
f0122c91:	68 38 3d 13 f0       	push   $0xf0133d38
f0122c96:	68 9d 00 00 00       	push   $0x9d
f0122c9b:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122ca0:	e8 94 d6 fd ff       	call   f0100339 <_panic>
f0122ca5:	8b 15 30 59 74 f0    	mov    0xf0745930,%edx
f0122cab:	8b 45 08             	mov    0x8(%ebp),%eax
f0122cae:	89 10                	mov    %edx,(%eax)
f0122cb0:	8b 45 08             	mov    0x8(%ebp),%eax
f0122cb3:	8b 00                	mov    (%eax),%eax
f0122cb5:	85 c0                	test   %eax,%eax
f0122cb7:	74 0d                	je     f0122cc6 <insert_sorted_in_freeList+0x4d>
f0122cb9:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0122cbe:	8b 55 08             	mov    0x8(%ebp),%edx
f0122cc1:	89 50 04             	mov    %edx,0x4(%eax)
f0122cc4:	eb 08                	jmp    f0122cce <insert_sorted_in_freeList+0x55>
f0122cc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0122cc9:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0122cce:	8b 45 08             	mov    0x8(%ebp),%eax
f0122cd1:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0122cd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0122cd9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0122ce0:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0122ce5:	40                   	inc    %eax
f0122ce6:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
		return;
f0122ceb:	e9 1a 01 00 00       	jmp    f0122e0a <insert_sorted_in_freeList+0x191>
	}

	struct BlockElement *blk;
	LIST_FOREACH(blk, &(freeBlocksList))
f0122cf0:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0122cf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122cf8:	eb 7f                	jmp    f0122d79 <insert_sorted_in_freeList+0x100>
	{
		if(blk > newBlock) // if address of blk > address of newBlock => add newBlock before blk
f0122cfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122cfd:	3b 45 08             	cmp    0x8(%ebp),%eax
f0122d00:	76 6f                	jbe    f0122d71 <insert_sorted_in_freeList+0xf8>
		{
			LIST_INSERT_BEFORE(&freeBlocksList,blk,newBlock);
f0122d02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122d06:	74 06                	je     f0122d0e <insert_sorted_in_freeList+0x95>
f0122d08:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122d0c:	75 17                	jne    f0122d25 <insert_sorted_in_freeList+0xac>
f0122d0e:	83 ec 04             	sub    $0x4,%esp
f0122d11:	68 74 3d 13 f0       	push   $0xf0133d74
f0122d16:	68 a6 00 00 00       	push   $0xa6
f0122d1b:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122d20:	e8 14 d6 fd ff       	call   f0100339 <_panic>
f0122d25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d28:	8b 50 04             	mov    0x4(%eax),%edx
f0122d2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0122d2e:	89 50 04             	mov    %edx,0x4(%eax)
f0122d31:	8b 45 08             	mov    0x8(%ebp),%eax
f0122d34:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122d37:	89 10                	mov    %edx,(%eax)
f0122d39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d3c:	8b 40 04             	mov    0x4(%eax),%eax
f0122d3f:	85 c0                	test   %eax,%eax
f0122d41:	74 0d                	je     f0122d50 <insert_sorted_in_freeList+0xd7>
f0122d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d46:	8b 40 04             	mov    0x4(%eax),%eax
f0122d49:	8b 55 08             	mov    0x8(%ebp),%edx
f0122d4c:	89 10                	mov    %edx,(%eax)
f0122d4e:	eb 08                	jmp    f0122d58 <insert_sorted_in_freeList+0xdf>
f0122d50:	8b 45 08             	mov    0x8(%ebp),%eax
f0122d53:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0122d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d5b:	8b 55 08             	mov    0x8(%ebp),%edx
f0122d5e:	89 50 04             	mov    %edx,0x4(%eax)
f0122d61:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0122d66:	40                   	inc    %eax
f0122d67:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
			return;
f0122d6c:	e9 99 00 00 00       	jmp    f0122e0a <insert_sorted_in_freeList+0x191>
		LIST_INSERT_HEAD(&freeBlocksList, newBlock);
		return;
	}

	struct BlockElement *blk;
	LIST_FOREACH(blk, &(freeBlocksList))
f0122d71:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f0122d76:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122d79:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122d7d:	74 07                	je     f0122d86 <insert_sorted_in_freeList+0x10d>
f0122d7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122d82:	8b 00                	mov    (%eax),%eax
f0122d84:	eb 05                	jmp    f0122d8b <insert_sorted_in_freeList+0x112>
f0122d86:	b8 00 00 00 00       	mov    $0x0,%eax
f0122d8b:	a3 38 59 74 f0       	mov    %eax,0xf0745938
f0122d90:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f0122d95:	85 c0                	test   %eax,%eax
f0122d97:	0f 85 5d ff ff ff    	jne    f0122cfa <insert_sorted_in_freeList+0x81>
f0122d9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122da1:	0f 85 53 ff ff ff    	jne    f0122cfa <insert_sorted_in_freeList+0x81>
			LIST_INSERT_BEFORE(&freeBlocksList,blk,newBlock);
			return;
		}
	}
	// if no blk its address > newBlock
	LIST_INSERT_TAIL(&freeBlocksList, newBlock);
f0122da7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122dab:	75 17                	jne    f0122dc4 <insert_sorted_in_freeList+0x14b>
f0122dad:	83 ec 04             	sub    $0x4,%esp
f0122db0:	68 ac 3d 13 f0       	push   $0xf0133dac
f0122db5:	68 ab 00 00 00       	push   $0xab
f0122dba:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122dbf:	e8 75 d5 fd ff       	call   f0100339 <_panic>
f0122dc4:	8b 15 34 59 74 f0    	mov    0xf0745934,%edx
f0122dca:	8b 45 08             	mov    0x8(%ebp),%eax
f0122dcd:	89 50 04             	mov    %edx,0x4(%eax)
f0122dd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0122dd3:	8b 40 04             	mov    0x4(%eax),%eax
f0122dd6:	85 c0                	test   %eax,%eax
f0122dd8:	74 0c                	je     f0122de6 <insert_sorted_in_freeList+0x16d>
f0122dda:	a1 34 59 74 f0       	mov    0xf0745934,%eax
f0122ddf:	8b 55 08             	mov    0x8(%ebp),%edx
f0122de2:	89 10                	mov    %edx,(%eax)
f0122de4:	eb 08                	jmp    f0122dee <insert_sorted_in_freeList+0x175>
f0122de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0122de9:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0122dee:	8b 45 08             	mov    0x8(%ebp),%eax
f0122df1:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0122df6:	8b 45 08             	mov    0x8(%ebp),%eax
f0122df9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122dff:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0122e04:	40                   	inc    %eax
f0122e05:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
}
f0122e0a:	c9                   	leave  
f0122e0b:	c3                   	ret    

f0122e0c <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f0122e0c:	55                   	push   %ebp
f0122e0d:	89 e5                	mov    %esp,%ebp
f0122e0f:	83 ec 78             	sub    $0x78,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f0122e12:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e15:	83 e0 01             	and    $0x1,%eax
f0122e18:	85 c0                	test   %eax,%eax
f0122e1a:	74 03                	je     f0122e1f <alloc_block_FF+0x13>
f0122e1c:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0122e1f:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f0122e23:	77 07                	ja     f0122e2c <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f0122e25:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0122e2c:	a1 b4 55 74 f0       	mov    0xf07455b4,%eax
f0122e31:	85 c0                	test   %eax,%eax
f0122e33:	75 63                	jne    f0122e98 <alloc_block_FF+0x8c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f0122e35:	8b 45 08             	mov    0x8(%ebp),%eax
f0122e38:	83 c0 10             	add    $0x10,%eax
f0122e3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0122e3e:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f0122e45:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0122e48:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0122e4b:	01 d0                	add    %edx,%eax
f0122e4d:	48                   	dec    %eax
f0122e4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0122e51:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0122e54:	ba 00 00 00 00       	mov    $0x0,%edx
f0122e59:	f7 75 ec             	divl   -0x14(%ebp)
f0122e5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0122e5f:	29 d0                	sub    %edx,%eax
f0122e61:	c1 e8 0c             	shr    $0xc,%eax
f0122e64:	83 ec 0c             	sub    $0xc,%esp
f0122e67:	50                   	push   %eax
f0122e68:	e8 0e 6d fe ff       	call   f0109b7b <sbrk>
f0122e6d:	83 c4 10             	add    $0x10,%esp
f0122e70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f0122e73:	83 ec 0c             	sub    $0xc,%esp
f0122e76:	6a 00                	push   $0x0
f0122e78:	e8 fe 6c fe ff       	call   f0109b7b <sbrk>
f0122e7d:	83 c4 10             	add    $0x10,%esp
f0122e80:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f0122e83:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0122e86:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0122e89:	83 ec 08             	sub    $0x8,%esp
f0122e8c:	50                   	push   %eax
f0122e8d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0122e90:	e8 75 fc ff ff       	call   f0122b0a <initialize_dynamic_allocator>
f0122e95:	83 c4 10             	add    $0x10,%esp
	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...

	if(size == 0)
f0122e98:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0122e9c:	75 0a                	jne    f0122ea8 <alloc_block_FF+0x9c>
	{
		return NULL;
f0122e9e:	b8 00 00 00 00       	mov    $0x0,%eax
f0122ea3:	e9 99 03 00 00       	jmp    f0123241 <alloc_block_FF+0x435>
	}
	uint32 totalSize = size + 2*sizeof(uint32); // size + size of header and footer
f0122ea8:	8b 45 08             	mov    0x8(%ebp),%eax
f0122eab:	83 c0 08             	add    $0x8,%eax
f0122eae:	89 45 dc             	mov    %eax,-0x24(%ebp)

	struct BlockElement *block;
	LIST_FOREACH(block, &(freeBlocksList))
f0122eb1:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0122eb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0122eb9:	e9 03 02 00 00       	jmp    f01230c1 <alloc_block_FF+0x2b5>
	{
		uint32 blockSize = get_block_size(block); // Get size without the (LSB) allocation flag
f0122ebe:	83 ec 0c             	sub    $0xc,%esp
f0122ec1:	ff 75 f4             	pushl  -0xc(%ebp)
f0122ec4:	e8 dd fa ff ff       	call   f01229a6 <get_block_size>
f0122ec9:	83 c4 10             	add    $0x10,%esp
f0122ecc:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if(blockSize >= totalSize)
f0122ecf:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0122ed2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0122ed5:	0f 82 de 01 00 00    	jb     f01230b9 <alloc_block_FF+0x2ad>
		{	//if we can put another block with min size 16
			if(blockSize >= totalSize + 4*sizeof(uint32))
f0122edb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122ede:	83 c0 10             	add    $0x10,%eax
f0122ee1:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f0122ee4:	0f 87 32 01 00 00    	ja     f012301c <alloc_block_FF+0x210>
			{
				// the size that will remain from the block that we will allocate a new block in it
				uint32 remainingSize = blockSize - totalSize;
f0122eea:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0122eed:	2b 45 dc             	sub    -0x24(%ebp),%eax
f0122ef0:	89 45 98             	mov    %eax,-0x68(%ebp)

				// the remaining free space from the block that we use to allocate in it
				struct BlockElement *remainingFreeBlock = (struct BlockElement *) ((char *)block + totalSize);
f0122ef3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122ef6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0122ef9:	01 d0                	add    %edx,%eax
f0122efb:	89 45 94             	mov    %eax,-0x6c(%ebp)
				set_block_data(remainingFreeBlock, remainingSize, 0);
f0122efe:	83 ec 04             	sub    $0x4,%esp
f0122f01:	6a 00                	push   $0x0
f0122f03:	ff 75 98             	pushl  -0x68(%ebp)
f0122f06:	ff 75 94             	pushl  -0x6c(%ebp)
f0122f09:	e8 14 fd ff ff       	call   f0122c22 <set_block_data>
f0122f0e:	83 c4 10             	add    $0x10,%esp
				// add it after the block we allocated to be sorted by addresses
				LIST_INSERT_AFTER(&freeBlocksList, block,remainingFreeBlock);
f0122f11:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122f15:	74 06                	je     f0122f1d <alloc_block_FF+0x111>
f0122f17:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0122f1b:	75 17                	jne    f0122f34 <alloc_block_FF+0x128>
f0122f1d:	83 ec 04             	sub    $0x4,%esp
f0122f20:	68 d0 3d 13 f0       	push   $0xf0133dd0
f0122f25:	68 de 00 00 00       	push   $0xde
f0122f2a:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122f2f:	e8 05 d4 fd ff       	call   f0100339 <_panic>
f0122f34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122f37:	8b 10                	mov    (%eax),%edx
f0122f39:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0122f3c:	89 10                	mov    %edx,(%eax)
f0122f3e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0122f41:	8b 00                	mov    (%eax),%eax
f0122f43:	85 c0                	test   %eax,%eax
f0122f45:	74 0b                	je     f0122f52 <alloc_block_FF+0x146>
f0122f47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122f4a:	8b 00                	mov    (%eax),%eax
f0122f4c:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0122f4f:	89 50 04             	mov    %edx,0x4(%eax)
f0122f52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122f55:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0122f58:	89 10                	mov    %edx,(%eax)
f0122f5a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0122f5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122f60:	89 50 04             	mov    %edx,0x4(%eax)
f0122f63:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0122f66:	8b 00                	mov    (%eax),%eax
f0122f68:	85 c0                	test   %eax,%eax
f0122f6a:	75 08                	jne    f0122f74 <alloc_block_FF+0x168>
f0122f6c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0122f6f:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0122f74:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0122f79:	40                   	inc    %eax
f0122f7a:	a3 3c 59 74 f0       	mov    %eax,0xf074593c

				// update the allocated block and remove it from freeBlocksList
				set_block_data(block,totalSize,1);
f0122f7f:	83 ec 04             	sub    $0x4,%esp
f0122f82:	6a 01                	push   $0x1
f0122f84:	ff 75 dc             	pushl  -0x24(%ebp)
f0122f87:	ff 75 f4             	pushl  -0xc(%ebp)
f0122f8a:	e8 93 fc ff ff       	call   f0122c22 <set_block_data>
f0122f8f:	83 c4 10             	add    $0x10,%esp
				// remove the block we allocated from the freeList because it is now allocated.
				LIST_REMOVE(&freeBlocksList, block);
f0122f92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0122f96:	75 17                	jne    f0122faf <alloc_block_FF+0x1a3>
f0122f98:	83 ec 04             	sub    $0x4,%esp
f0122f9b:	68 04 3e 13 f0       	push   $0xf0133e04
f0122fa0:	68 e3 00 00 00       	push   $0xe3
f0122fa5:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0122faa:	e8 8a d3 fd ff       	call   f0100339 <_panic>
f0122faf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fb2:	8b 00                	mov    (%eax),%eax
f0122fb4:	85 c0                	test   %eax,%eax
f0122fb6:	74 10                	je     f0122fc8 <alloc_block_FF+0x1bc>
f0122fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fbb:	8b 00                	mov    (%eax),%eax
f0122fbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122fc0:	8b 52 04             	mov    0x4(%edx),%edx
f0122fc3:	89 50 04             	mov    %edx,0x4(%eax)
f0122fc6:	eb 0b                	jmp    f0122fd3 <alloc_block_FF+0x1c7>
f0122fc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fcb:	8b 40 04             	mov    0x4(%eax),%eax
f0122fce:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0122fd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fd6:	8b 40 04             	mov    0x4(%eax),%eax
f0122fd9:	85 c0                	test   %eax,%eax
f0122fdb:	74 0f                	je     f0122fec <alloc_block_FF+0x1e0>
f0122fdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fe0:	8b 40 04             	mov    0x4(%eax),%eax
f0122fe3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0122fe6:	8b 12                	mov    (%edx),%edx
f0122fe8:	89 10                	mov    %edx,(%eax)
f0122fea:	eb 0a                	jmp    f0122ff6 <alloc_block_FF+0x1ea>
f0122fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122fef:	8b 00                	mov    (%eax),%eax
f0122ff1:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0122ff6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0122ff9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0122fff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123002:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123009:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f012300e:	48                   	dec    %eax
f012300f:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
				return (void*)((uint32*)block);
f0123014:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123017:	e9 25 02 00 00       	jmp    f0123241 <alloc_block_FF+0x435>
			}
			else // if set internal fragmentation
			{
				// add the remaining size to the block we allocate so it will be the same main block size
				set_block_data(block,blockSize,1);
f012301c:	83 ec 04             	sub    $0x4,%esp
f012301f:	6a 01                	push   $0x1
f0123021:	ff 75 9c             	pushl  -0x64(%ebp)
f0123024:	ff 75 f4             	pushl  -0xc(%ebp)
f0123027:	e8 f6 fb ff ff       	call   f0122c22 <set_block_data>
f012302c:	83 c4 10             	add    $0x10,%esp
				// remove the block we allocated from the freeList because it is now allocated.
				LIST_REMOVE(&freeBlocksList, block);
f012302f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123033:	75 17                	jne    f012304c <alloc_block_FF+0x240>
f0123035:	83 ec 04             	sub    $0x4,%esp
f0123038:	68 04 3e 13 f0       	push   $0xf0133e04
f012303d:	68 eb 00 00 00       	push   $0xeb
f0123042:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123047:	e8 ed d2 fd ff       	call   f0100339 <_panic>
f012304c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012304f:	8b 00                	mov    (%eax),%eax
f0123051:	85 c0                	test   %eax,%eax
f0123053:	74 10                	je     f0123065 <alloc_block_FF+0x259>
f0123055:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123058:	8b 00                	mov    (%eax),%eax
f012305a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012305d:	8b 52 04             	mov    0x4(%edx),%edx
f0123060:	89 50 04             	mov    %edx,0x4(%eax)
f0123063:	eb 0b                	jmp    f0123070 <alloc_block_FF+0x264>
f0123065:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123068:	8b 40 04             	mov    0x4(%eax),%eax
f012306b:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0123070:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123073:	8b 40 04             	mov    0x4(%eax),%eax
f0123076:	85 c0                	test   %eax,%eax
f0123078:	74 0f                	je     f0123089 <alloc_block_FF+0x27d>
f012307a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012307d:	8b 40 04             	mov    0x4(%eax),%eax
f0123080:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123083:	8b 12                	mov    (%edx),%edx
f0123085:	89 10                	mov    %edx,(%eax)
f0123087:	eb 0a                	jmp    f0123093 <alloc_block_FF+0x287>
f0123089:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012308c:	8b 00                	mov    (%eax),%eax
f012308e:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0123093:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123096:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012309c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012309f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01230a6:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f01230ab:	48                   	dec    %eax
f01230ac:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
				return (void*)((uint32*)block);
f01230b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01230b4:	e9 88 01 00 00       	jmp    f0123241 <alloc_block_FF+0x435>
		return NULL;
	}
	uint32 totalSize = size + 2*sizeof(uint32); // size + size of header and footer

	struct BlockElement *block;
	LIST_FOREACH(block, &(freeBlocksList))
f01230b9:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f01230be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01230c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01230c5:	74 07                	je     f01230ce <alloc_block_FF+0x2c2>
f01230c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01230ca:	8b 00                	mov    (%eax),%eax
f01230cc:	eb 05                	jmp    f01230d3 <alloc_block_FF+0x2c7>
f01230ce:	b8 00 00 00 00       	mov    $0x0,%eax
f01230d3:	a3 38 59 74 f0       	mov    %eax,0xf0745938
f01230d8:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f01230dd:	85 c0                	test   %eax,%eax
f01230df:	0f 85 d9 fd ff ff    	jne    f0122ebe <alloc_block_FF+0xb2>
f01230e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01230e9:	0f 85 cf fd ff ff    	jne    f0122ebe <alloc_block_FF+0xb2>

//	uint32 *endBlock = &kheapBreak;

	// if we don't find any enough space to allocate the block

	void *oldBreak = sbrk(ROUNDUP(totalSize, PAGE_SIZE) / PAGE_SIZE);
f01230ef:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f01230f6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01230f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01230fc:	01 d0                	add    %edx,%eax
f01230fe:	48                   	dec    %eax
f01230ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0123102:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123105:	ba 00 00 00 00       	mov    $0x0,%edx
f012310a:	f7 75 d8             	divl   -0x28(%ebp)
f012310d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0123110:	29 d0                	sub    %edx,%eax
f0123112:	c1 e8 0c             	shr    $0xc,%eax
f0123115:	83 ec 0c             	sub    $0xc,%esp
f0123118:	50                   	push   %eax
f0123119:	e8 5d 6a fe ff       	call   f0109b7b <sbrk>
f012311e:	83 c4 10             	add    $0x10,%esp
f0123121:	89 45 d0             	mov    %eax,-0x30(%ebp)
	if (oldBreak == (void*)-1) {
f0123124:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%ebp)
f0123128:	75 0a                	jne    f0123134 <alloc_block_FF+0x328>
		return NULL;
f012312a:	b8 00 00 00 00       	mov    $0x0,%eax
f012312f:	e9 0d 01 00 00       	jmp    f0123241 <alloc_block_FF+0x435>
	}
	//uint32* endBlock = (uint32*)(daStart + initSizeOfAllocatedSpace - 4);

	uint32* endBlk = (uint32 *)((char *)oldBreak - 4);
f0123134:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123137:	83 e8 04             	sub    $0x4,%eax
f012313a:	89 45 cc             	mov    %eax,-0x34(%ebp)
	//endBlk = endBlk+(char *) ROUNDUP(totalSize, PAGE_SIZE);

	endBlk = endBlk + (ROUNDUP(totalSize, PAGE_SIZE) / sizeof(uint32));
f012313d:	c7 45 c8 00 10 00 00 	movl   $0x1000,-0x38(%ebp)
f0123144:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123147:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012314a:	01 d0                	add    %edx,%eax
f012314c:	48                   	dec    %eax
f012314d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0123150:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0123153:	ba 00 00 00 00       	mov    $0x0,%edx
f0123158:	f7 75 c8             	divl   -0x38(%ebp)
f012315b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f012315e:	29 d0                	sub    %edx,%eax
f0123160:	c1 e8 02             	shr    $0x2,%eax
f0123163:	c1 e0 02             	shl    $0x2,%eax
f0123166:	01 45 cc             	add    %eax,-0x34(%ebp)
	*endBlk = 0 | 1;
f0123169:	8b 45 cc             	mov    -0x34(%ebp),%eax
f012316c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	uint32 *footerLast = ((uint32*)oldBreak - 2);
f0123172:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123175:	83 e8 08             	sub    $0x8,%eax
f0123178:	89 45 c0             	mov    %eax,-0x40(%ebp)
	uint32 lastSize = (*footerLast) & ~(0x1);
f012317b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012317e:	8b 00                	mov    (%eax),%eax
f0123180:	83 e0 fe             	and    $0xfffffffe,%eax
f0123183:	89 45 bc             	mov    %eax,-0x44(%ebp)
	// the last block for the block that we want to free it
	struct BlockElement *laskBlk = (struct BlockElement *)((char*)oldBreak - lastSize);
f0123186:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0123189:	f7 d8                	neg    %eax
f012318b:	89 c2                	mov    %eax,%edx
f012318d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0123190:	01 d0                	add    %edx,%eax
f0123192:	89 45 b8             	mov    %eax,-0x48(%ebp)
	uint32 isLastFree = is_free_block(laskBlk);
f0123195:	83 ec 0c             	sub    $0xc,%esp
f0123198:	ff 75 b8             	pushl  -0x48(%ebp)
f012319b:	e8 1f f8 ff ff       	call   f01229bf <is_free_block>
f01231a0:	83 c4 10             	add    $0x10,%esp
f01231a3:	0f be c0             	movsbl %al,%eax
f01231a6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if(isLastFree)
f01231a9:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01231ad:	74 42                	je     f01231f1 <alloc_block_FF+0x3e5>
	{
		// merge the block will be free with its prev block
		uint32 newBlkSize = lastSize + ROUNDUP(totalSize, PAGE_SIZE); // size of main block and its prev block
f01231af:	c7 45 b0 00 10 00 00 	movl   $0x1000,-0x50(%ebp)
f01231b6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01231b9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01231bc:	01 d0                	add    %edx,%eax
f01231be:	48                   	dec    %eax
f01231bf:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01231c2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01231c5:	ba 00 00 00 00       	mov    $0x0,%edx
f01231ca:	f7 75 b0             	divl   -0x50(%ebp)
f01231cd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01231d0:	29 d0                	sub    %edx,%eax
f01231d2:	89 c2                	mov    %eax,%edx
f01231d4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01231d7:	01 d0                	add    %edx,%eax
f01231d9:	89 45 a8             	mov    %eax,-0x58(%ebp)
		// extends last block size to contain its size and the size of new space
		set_block_data(laskBlk,newBlkSize,0);
f01231dc:	83 ec 04             	sub    $0x4,%esp
f01231df:	6a 00                	push   $0x0
f01231e1:	ff 75 a8             	pushl  -0x58(%ebp)
f01231e4:	ff 75 b8             	pushl  -0x48(%ebp)
f01231e7:	e8 36 fa ff ff       	call   f0122c22 <set_block_data>
f01231ec:	83 c4 10             	add    $0x10,%esp
f01231ef:	eb 42                	jmp    f0123233 <alloc_block_FF+0x427>
	}
	else
	{
		set_block_data(oldBreak,ROUNDUP(totalSize, PAGE_SIZE),0);
f01231f1:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f01231f8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01231fb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01231fe:	01 d0                	add    %edx,%eax
f0123200:	48                   	dec    %eax
f0123201:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0123204:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0123207:	ba 00 00 00 00       	mov    $0x0,%edx
f012320c:	f7 75 a4             	divl   -0x5c(%ebp)
f012320f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0123212:	29 d0                	sub    %edx,%eax
f0123214:	83 ec 04             	sub    $0x4,%esp
f0123217:	6a 00                	push   $0x0
f0123219:	50                   	push   %eax
f012321a:	ff 75 d0             	pushl  -0x30(%ebp)
f012321d:	e8 00 fa ff ff       	call   f0122c22 <set_block_data>
f0123222:	83 c4 10             	add    $0x10,%esp
		insert_sorted_in_freeList((struct BlockElement *)oldBreak);
f0123225:	83 ec 0c             	sub    $0xc,%esp
f0123228:	ff 75 d0             	pushl  -0x30(%ebp)
f012322b:	e8 49 fa ff ff       	call   f0122c79 <insert_sorted_in_freeList>
f0123230:	83 c4 10             	add    $0x10,%esp
//		LIST_INSERT_TAIL(&freeBlocksList,newBreak);
	}
//	set_block_data((struct BlockElement *)newBreak, totalSize, 1);
	return alloc_block_FF(size);
f0123233:	83 ec 0c             	sub    $0xc,%esp
f0123236:	ff 75 08             	pushl  0x8(%ebp)
f0123239:	e8 ce fb ff ff       	call   f0122e0c <alloc_block_FF>
f012323e:	83 c4 10             	add    $0x10,%esp
}
f0123241:	c9                   	leave  
f0123242:	c3                   	ret    

f0123243 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0123243:	55                   	push   %ebp
f0123244:	89 e5                	mov    %esp,%ebp
f0123246:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS1 - BONUS] [3] DYNAMIC ALLOCATOR - alloc_block_BF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("alloc_block_BF is not implemented yet");
	//Your Code is Here...
	if(size == 0)
f0123249:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012324d:	75 0a                	jne    f0123259 <alloc_block_BF+0x16>
	{
		return NULL;
f012324f:	b8 00 00 00 00       	mov    $0x0,%eax
f0123254:	e9 7a 02 00 00       	jmp    f01234d3 <alloc_block_BF+0x290>
	}
	uint32 totalSize = size + 2*sizeof(uint32); // size + size of header and footer
f0123259:	8b 45 08             	mov    0x8(%ebp),%eax
f012325c:	83 c0 08             	add    $0x8,%eax
f012325f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	struct BlockElement *minBlk= NULL;
f0123262:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 minSize = 0xfffffff; // a large number
f0123269:	c7 45 f0 ff ff ff 0f 	movl   $0xfffffff,-0x10(%ebp)
	struct BlockElement *block;
	LIST_FOREACH(block, &(freeBlocksList))
f0123270:	a1 30 59 74 f0       	mov    0xf0745930,%eax
f0123275:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0123278:	eb 32                	jmp    f01232ac <alloc_block_BF+0x69>
	{
		uint32 blockSize = get_block_size(block);
f012327a:	ff 75 ec             	pushl  -0x14(%ebp)
f012327d:	e8 24 f7 ff ff       	call   f01229a6 <get_block_size>
f0123282:	83 c4 04             	add    $0x4,%esp
f0123285:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// if this block can take the new block and its size < min size of all blocks
		if(blockSize >= totalSize && blockSize < minSize)
f0123288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f012328b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f012328e:	72 14                	jb     f01232a4 <alloc_block_BF+0x61>
f0123290:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0123293:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0123296:	73 0c                	jae    f01232a4 <alloc_block_BF+0x61>
		{
			minBlk = block;
f0123298:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012329b:	89 45 f4             	mov    %eax,-0xc(%ebp)
			minSize = blockSize;
f012329e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01232a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 totalSize = size + 2*sizeof(uint32); // size + size of header and footer

	struct BlockElement *minBlk= NULL;
	uint32 minSize = 0xfffffff; // a large number
	struct BlockElement *block;
	LIST_FOREACH(block, &(freeBlocksList))
f01232a4:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f01232a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01232ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01232b0:	74 07                	je     f01232b9 <alloc_block_BF+0x76>
f01232b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01232b5:	8b 00                	mov    (%eax),%eax
f01232b7:	eb 05                	jmp    f01232be <alloc_block_BF+0x7b>
f01232b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01232be:	a3 38 59 74 f0       	mov    %eax,0xf0745938
f01232c3:	a1 38 59 74 f0       	mov    0xf0745938,%eax
f01232c8:	85 c0                	test   %eax,%eax
f01232ca:	75 ae                	jne    f012327a <alloc_block_BF+0x37>
f01232cc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01232d0:	75 a8                	jne    f012327a <alloc_block_BF+0x37>
			minSize = blockSize;
		}
	}

	// if we don't find any enough space to allocate the block
	if(minBlk == NULL)
f01232d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01232d6:	75 22                	jne    f01232fa <alloc_block_BF+0xb7>
	{
		void *newBlock = sbrk(totalSize);
f01232d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01232db:	83 ec 0c             	sub    $0xc,%esp
f01232de:	50                   	push   %eax
f01232df:	e8 97 68 fe ff       	call   f0109b7b <sbrk>
f01232e4:	83 c4 10             	add    $0x10,%esp
f01232e7:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (newBlock == (void*)-1) {
f01232ea:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01232ee:	75 0a                	jne    f01232fa <alloc_block_BF+0xb7>
			return NULL;
f01232f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01232f5:	e9 d9 01 00 00       	jmp    f01234d3 <alloc_block_BF+0x290>
		}
	}

	//if we can put another block with min size 16
	if(minSize >= totalSize + 4*sizeof(uint32))
f01232fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01232fd:	83 c0 10             	add    $0x10,%eax
f0123300:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0123303:	0f 87 32 01 00 00    	ja     f012343b <alloc_block_BF+0x1f8>
	{
		// the size that will remain from the block that we will allocate a new block in it
		uint32 remainingSize= minSize - totalSize;
f0123309:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012330c:	2b 45 e8             	sub    -0x18(%ebp),%eax
f012330f:	89 45 dc             	mov    %eax,-0x24(%ebp)

		// the remaining free space from the block that we use to allocate in it
		struct BlockElement *remainingFreeBlock = (struct BlockElement *) ((char *)minBlk + totalSize);
f0123312:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123315:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123318:	01 d0                	add    %edx,%eax
f012331a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		set_block_data(remainingFreeBlock, remainingSize, 0);
f012331d:	83 ec 04             	sub    $0x4,%esp
f0123320:	6a 00                	push   $0x0
f0123322:	ff 75 dc             	pushl  -0x24(%ebp)
f0123325:	ff 75 d8             	pushl  -0x28(%ebp)
f0123328:	e8 f5 f8 ff ff       	call   f0122c22 <set_block_data>
f012332d:	83 c4 10             	add    $0x10,%esp
		// add it after the block we allocated to be sorted by addresses
		LIST_INSERT_AFTER(&freeBlocksList, minBlk,remainingFreeBlock);
f0123330:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123334:	74 06                	je     f012333c <alloc_block_BF+0xf9>
f0123336:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f012333a:	75 17                	jne    f0123353 <alloc_block_BF+0x110>
f012333c:	83 ec 04             	sub    $0x4,%esp
f012333f:	68 d0 3d 13 f0       	push   $0xf0133dd0
f0123344:	68 49 01 00 00       	push   $0x149
f0123349:	68 5b 3d 13 f0       	push   $0xf0133d5b
f012334e:	e8 e6 cf fd ff       	call   f0100339 <_panic>
f0123353:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123356:	8b 10                	mov    (%eax),%edx
f0123358:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012335b:	89 10                	mov    %edx,(%eax)
f012335d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123360:	8b 00                	mov    (%eax),%eax
f0123362:	85 c0                	test   %eax,%eax
f0123364:	74 0b                	je     f0123371 <alloc_block_BF+0x12e>
f0123366:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123369:	8b 00                	mov    (%eax),%eax
f012336b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f012336e:	89 50 04             	mov    %edx,0x4(%eax)
f0123371:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123374:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0123377:	89 10                	mov    %edx,(%eax)
f0123379:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012337c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012337f:	89 50 04             	mov    %edx,0x4(%eax)
f0123382:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123385:	8b 00                	mov    (%eax),%eax
f0123387:	85 c0                	test   %eax,%eax
f0123389:	75 08                	jne    f0123393 <alloc_block_BF+0x150>
f012338b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f012338e:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0123393:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0123398:	40                   	inc    %eax
f0123399:	a3 3c 59 74 f0       	mov    %eax,0xf074593c

		// update the allocated block and remove it from freeBlocksList
		set_block_data(minBlk,totalSize,1);
f012339e:	83 ec 04             	sub    $0x4,%esp
f01233a1:	6a 01                	push   $0x1
f01233a3:	ff 75 e8             	pushl  -0x18(%ebp)
f01233a6:	ff 75 f4             	pushl  -0xc(%ebp)
f01233a9:	e8 74 f8 ff ff       	call   f0122c22 <set_block_data>
f01233ae:	83 c4 10             	add    $0x10,%esp
		// remove the block we allocated from the freeList because it is now allocated.
		LIST_REMOVE(&freeBlocksList, minBlk);
f01233b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01233b5:	75 17                	jne    f01233ce <alloc_block_BF+0x18b>
f01233b7:	83 ec 04             	sub    $0x4,%esp
f01233ba:	68 04 3e 13 f0       	push   $0xf0133e04
f01233bf:	68 4e 01 00 00       	push   $0x14e
f01233c4:	68 5b 3d 13 f0       	push   $0xf0133d5b
f01233c9:	e8 6b cf fd ff       	call   f0100339 <_panic>
f01233ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233d1:	8b 00                	mov    (%eax),%eax
f01233d3:	85 c0                	test   %eax,%eax
f01233d5:	74 10                	je     f01233e7 <alloc_block_BF+0x1a4>
f01233d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233da:	8b 00                	mov    (%eax),%eax
f01233dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01233df:	8b 52 04             	mov    0x4(%edx),%edx
f01233e2:	89 50 04             	mov    %edx,0x4(%eax)
f01233e5:	eb 0b                	jmp    f01233f2 <alloc_block_BF+0x1af>
f01233e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233ea:	8b 40 04             	mov    0x4(%eax),%eax
f01233ed:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f01233f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233f5:	8b 40 04             	mov    0x4(%eax),%eax
f01233f8:	85 c0                	test   %eax,%eax
f01233fa:	74 0f                	je     f012340b <alloc_block_BF+0x1c8>
f01233fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01233ff:	8b 40 04             	mov    0x4(%eax),%eax
f0123402:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123405:	8b 12                	mov    (%edx),%edx
f0123407:	89 10                	mov    %edx,(%eax)
f0123409:	eb 0a                	jmp    f0123415 <alloc_block_BF+0x1d2>
f012340b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012340e:	8b 00                	mov    (%eax),%eax
f0123410:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0123415:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123418:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012341e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123421:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123428:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f012342d:	48                   	dec    %eax
f012342e:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
		return (void*)((uint32*)minBlk);
f0123433:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123436:	e9 98 00 00 00       	jmp    f01234d3 <alloc_block_BF+0x290>
	}
	else // if set internal fragmentation
	{
		// add the remaining size to the block we allocate so it will be the same main block size
		set_block_data(minBlk,minSize,1);
f012343b:	83 ec 04             	sub    $0x4,%esp
f012343e:	6a 01                	push   $0x1
f0123440:	ff 75 f0             	pushl  -0x10(%ebp)
f0123443:	ff 75 f4             	pushl  -0xc(%ebp)
f0123446:	e8 d7 f7 ff ff       	call   f0122c22 <set_block_data>
f012344b:	83 c4 10             	add    $0x10,%esp
		// remove the block we allocated from the freeList because it is now allocated.
		LIST_REMOVE(&freeBlocksList, minBlk);
f012344e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0123452:	75 17                	jne    f012346b <alloc_block_BF+0x228>
f0123454:	83 ec 04             	sub    $0x4,%esp
f0123457:	68 04 3e 13 f0       	push   $0xf0133e04
f012345c:	68 56 01 00 00       	push   $0x156
f0123461:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123466:	e8 ce ce fd ff       	call   f0100339 <_panic>
f012346b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012346e:	8b 00                	mov    (%eax),%eax
f0123470:	85 c0                	test   %eax,%eax
f0123472:	74 10                	je     f0123484 <alloc_block_BF+0x241>
f0123474:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123477:	8b 00                	mov    (%eax),%eax
f0123479:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012347c:	8b 52 04             	mov    0x4(%edx),%edx
f012347f:	89 50 04             	mov    %edx,0x4(%eax)
f0123482:	eb 0b                	jmp    f012348f <alloc_block_BF+0x24c>
f0123484:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123487:	8b 40 04             	mov    0x4(%eax),%eax
f012348a:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f012348f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123492:	8b 40 04             	mov    0x4(%eax),%eax
f0123495:	85 c0                	test   %eax,%eax
f0123497:	74 0f                	je     f01234a8 <alloc_block_BF+0x265>
f0123499:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012349c:	8b 40 04             	mov    0x4(%eax),%eax
f012349f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01234a2:	8b 12                	mov    (%edx),%edx
f01234a4:	89 10                	mov    %edx,(%eax)
f01234a6:	eb 0a                	jmp    f01234b2 <alloc_block_BF+0x26f>
f01234a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234ab:	8b 00                	mov    (%eax),%eax
f01234ad:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f01234b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234b5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01234bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01234be:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01234c5:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f01234ca:	48                   	dec    %eax
f01234cb:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
		return (void*)((uint32*)minBlk);
f01234d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
	}
	return NULL;
}
f01234d3:	c9                   	leave  
f01234d4:	c3                   	ret    

f01234d5 <free_block>:
//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f01234d5:	55                   	push   %ebp
f01234d6:	89 e5                	mov    %esp,%ebp
f01234d8:	83 ec 48             	sub    $0x48,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...

	if(va == NULL)
f01234db:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01234df:	0f 84 6a 02 00 00    	je     f012374f <free_block+0x27a>
	{
		return;
	}

	uint32 freeSize = get_block_size(va);
f01234e5:	ff 75 08             	pushl  0x8(%ebp)
f01234e8:	e8 b9 f4 ff ff       	call   f01229a6 <get_block_size>
f01234ed:	83 c4 04             	add    $0x4,%esp
f01234f0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// footer for the prev block for the block that we want to free it
	uint32 *footerPrev = ((uint32*)va - 2 );
f01234f3:	8b 45 08             	mov    0x8(%ebp),%eax
f01234f6:	83 e8 08             	sub    $0x8,%eax
f01234f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 pSize = (*footerPrev) & ~(0x1);
f01234fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01234ff:	8b 00                	mov    (%eax),%eax
f0123501:	83 e0 fe             	and    $0xfffffffe,%eax
f0123504:	89 45 ec             	mov    %eax,-0x14(%ebp)
	// the prev block for the block that we want to free it
	struct BlockElement * prevBlk = (struct BlockElement *)((char*)va - pSize);
f0123507:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012350a:	f7 d8                	neg    %eax
f012350c:	89 c2                	mov    %eax,%edx
f012350e:	8b 45 08             	mov    0x8(%ebp),%eax
f0123511:	01 d0                	add    %edx,%eax
f0123513:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32 isPrevFree = is_free_block(prevBlk);
f0123516:	ff 75 e8             	pushl  -0x18(%ebp)
f0123519:	e8 a1 f4 ff ff       	call   f01229bf <is_free_block>
f012351e:	83 c4 04             	add    $0x4,%esp
f0123521:	0f be c0             	movsbl %al,%eax
f0123524:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// the next block for the block that we want to free it
	struct BlockElement *nextBlk = (struct BlockElement *)((char *)va + freeSize);
f0123527:	8b 55 08             	mov    0x8(%ebp),%edx
f012352a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012352d:	01 d0                	add    %edx,%eax
f012352f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32 isNextFree = is_free_block(nextBlk);
f0123532:	ff 75 e0             	pushl  -0x20(%ebp)
f0123535:	e8 85 f4 ff ff       	call   f01229bf <is_free_block>
f012353a:	83 c4 04             	add    $0x4,%esp
f012353d:	0f be c0             	movsbl %al,%eax
f0123540:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(isPrevFree == 1 && isNextFree == 0)
f0123543:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f0123547:	75 34                	jne    f012357d <free_block+0xa8>
f0123549:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012354d:	75 2e                	jne    f012357d <free_block+0xa8>
	{
		// merge the block will be free with its prev block
		uint32 prevSize = get_block_size(prevBlk);
f012354f:	ff 75 e8             	pushl  -0x18(%ebp)
f0123552:	e8 4f f4 ff ff       	call   f01229a6 <get_block_size>
f0123557:	83 c4 04             	add    $0x4,%esp
f012355a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32 totalSize = freeSize + prevSize; // size of main block and its prev block
f012355d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123560:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123563:	01 d0                	add    %edx,%eax
f0123565:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		// extends prev block size to contain its size and the size of main block
		set_block_data(prevBlk,totalSize,0);
f0123568:	6a 00                	push   $0x0
f012356a:	ff 75 d4             	pushl  -0x2c(%ebp)
f012356d:	ff 75 e8             	pushl  -0x18(%ebp)
f0123570:	e8 ad f6 ff ff       	call   f0122c22 <set_block_data>
f0123575:	83 c4 0c             	add    $0xc,%esp
	// the next block for the block that we want to free it
	struct BlockElement *nextBlk = (struct BlockElement *)((char *)va + freeSize);
	uint32 isNextFree = is_free_block(nextBlk);

	if(isPrevFree == 1 && isNextFree == 0)
	{
f0123578:	e9 d3 01 00 00       	jmp    f0123750 <free_block+0x27b>
		uint32 prevSize = get_block_size(prevBlk);
		uint32 totalSize = freeSize + prevSize; // size of main block and its prev block
		// extends prev block size to contain its size and the size of main block
		set_block_data(prevBlk,totalSize,0);
	}
	else if(isNextFree == 1 && isPrevFree == 0)
f012357d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0123581:	0f 85 c8 00 00 00    	jne    f012364f <free_block+0x17a>
f0123587:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012358b:	0f 85 be 00 00 00    	jne    f012364f <free_block+0x17a>
	{
		// merge the block will be free with its next block
		uint32 nextSize = get_block_size(nextBlk);
f0123591:	ff 75 e0             	pushl  -0x20(%ebp)
f0123594:	e8 0d f4 ff ff       	call   f01229a6 <get_block_size>
f0123599:	83 c4 04             	add    $0x4,%esp
f012359c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 totalSize = freeSize + nextSize; // size of main block and its next block
f012359f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01235a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01235a5:	01 d0                	add    %edx,%eax
f01235a7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		// update the size of block to contain its size and the size of next block
		set_block_data(va,totalSize,0);
f01235aa:	6a 00                	push   $0x0
f01235ac:	ff 75 cc             	pushl  -0x34(%ebp)
f01235af:	ff 75 08             	pushl  0x8(%ebp)
f01235b2:	e8 6b f6 ff ff       	call   f0122c22 <set_block_data>
f01235b7:	83 c4 0c             	add    $0xc,%esp
		// remove next block because we merge it with its prev block
		LIST_REMOVE(&freeBlocksList,nextBlk);
f01235ba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01235be:	75 17                	jne    f01235d7 <free_block+0x102>
f01235c0:	83 ec 04             	sub    $0x4,%esp
f01235c3:	68 04 3e 13 f0       	push   $0xf0133e04
f01235c8:	68 87 01 00 00       	push   $0x187
f01235cd:	68 5b 3d 13 f0       	push   $0xf0133d5b
f01235d2:	e8 62 cd fd ff       	call   f0100339 <_panic>
f01235d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01235da:	8b 00                	mov    (%eax),%eax
f01235dc:	85 c0                	test   %eax,%eax
f01235de:	74 10                	je     f01235f0 <free_block+0x11b>
f01235e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01235e3:	8b 00                	mov    (%eax),%eax
f01235e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01235e8:	8b 52 04             	mov    0x4(%edx),%edx
f01235eb:	89 50 04             	mov    %edx,0x4(%eax)
f01235ee:	eb 0b                	jmp    f01235fb <free_block+0x126>
f01235f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01235f3:	8b 40 04             	mov    0x4(%eax),%eax
f01235f6:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f01235fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01235fe:	8b 40 04             	mov    0x4(%eax),%eax
f0123601:	85 c0                	test   %eax,%eax
f0123603:	74 0f                	je     f0123614 <free_block+0x13f>
f0123605:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123608:	8b 40 04             	mov    0x4(%eax),%eax
f012360b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f012360e:	8b 12                	mov    (%edx),%edx
f0123610:	89 10                	mov    %edx,(%eax)
f0123612:	eb 0a                	jmp    f012361e <free_block+0x149>
f0123614:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123617:	8b 00                	mov    (%eax),%eax
f0123619:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f012361e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123621:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123627:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012362a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123631:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0123636:	48                   	dec    %eax
f0123637:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
		// add main block to the freeList because it is free now
		insert_sorted_in_freeList((struct BlockElement *)va);
f012363c:	83 ec 0c             	sub    $0xc,%esp
f012363f:	ff 75 08             	pushl  0x8(%ebp)
f0123642:	e8 32 f6 ff ff       	call   f0122c79 <insert_sorted_in_freeList>
f0123647:	83 c4 10             	add    $0x10,%esp
		uint32 totalSize = freeSize + prevSize; // size of main block and its prev block
		// extends prev block size to contain its size and the size of main block
		set_block_data(prevBlk,totalSize,0);
	}
	else if(isNextFree == 1 && isPrevFree == 0)
	{
f012364a:	e9 01 01 00 00       	jmp    f0123750 <free_block+0x27b>
		// remove next block because we merge it with its prev block
		LIST_REMOVE(&freeBlocksList,nextBlk);
		// add main block to the freeList because it is free now
		insert_sorted_in_freeList((struct BlockElement *)va);
	}
	else if(isPrevFree == 1 && isNextFree == 1)
f012364f:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f0123653:	0f 85 d3 00 00 00    	jne    f012372c <free_block+0x257>
f0123659:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f012365d:	0f 85 c9 00 00 00    	jne    f012372c <free_block+0x257>
	{
		// merge the block will be free with its prev and next blocks
		uint32 prevSize = get_block_size(prevBlk);
f0123663:	83 ec 0c             	sub    $0xc,%esp
f0123666:	ff 75 e8             	pushl  -0x18(%ebp)
f0123669:	e8 38 f3 ff ff       	call   f01229a6 <get_block_size>
f012366e:	83 c4 10             	add    $0x10,%esp
f0123671:	89 45 c8             	mov    %eax,-0x38(%ebp)
		uint32 nextSize = get_block_size(nextBlk);
f0123674:	83 ec 0c             	sub    $0xc,%esp
f0123677:	ff 75 e0             	pushl  -0x20(%ebp)
f012367a:	e8 27 f3 ff ff       	call   f01229a6 <get_block_size>
f012367f:	83 c4 10             	add    $0x10,%esp
f0123682:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		uint32 totalSize = freeSize + prevSize + nextSize; // size of main block and its prev and next blocks
f0123685:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0123688:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012368b:	01 c2                	add    %eax,%edx
f012368d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0123690:	01 d0                	add    %edx,%eax
f0123692:	89 45 c0             	mov    %eax,-0x40(%ebp)
		// extends prev block size to contain its size and the size of main and next blocks
		set_block_data(prevBlk,totalSize,0);
f0123695:	83 ec 04             	sub    $0x4,%esp
f0123698:	6a 00                	push   $0x0
f012369a:	ff 75 c0             	pushl  -0x40(%ebp)
f012369d:	ff 75 e8             	pushl  -0x18(%ebp)
f01236a0:	e8 7d f5 ff ff       	call   f0122c22 <set_block_data>
f01236a5:	83 c4 10             	add    $0x10,%esp
		// remove next block because we merge it with its prev blocks
		LIST_REMOVE(&freeBlocksList, nextBlk);
f01236a8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01236ac:	75 17                	jne    f01236c5 <free_block+0x1f0>
f01236ae:	83 ec 04             	sub    $0x4,%esp
f01236b1:	68 04 3e 13 f0       	push   $0xf0133e04
f01236b6:	68 94 01 00 00       	push   $0x194
f01236bb:	68 5b 3d 13 f0       	push   $0xf0133d5b
f01236c0:	e8 74 cc fd ff       	call   f0100339 <_panic>
f01236c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01236c8:	8b 00                	mov    (%eax),%eax
f01236ca:	85 c0                	test   %eax,%eax
f01236cc:	74 10                	je     f01236de <free_block+0x209>
f01236ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01236d1:	8b 00                	mov    (%eax),%eax
f01236d3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01236d6:	8b 52 04             	mov    0x4(%edx),%edx
f01236d9:	89 50 04             	mov    %edx,0x4(%eax)
f01236dc:	eb 0b                	jmp    f01236e9 <free_block+0x214>
f01236de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01236e1:	8b 40 04             	mov    0x4(%eax),%eax
f01236e4:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f01236e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01236ec:	8b 40 04             	mov    0x4(%eax),%eax
f01236ef:	85 c0                	test   %eax,%eax
f01236f1:	74 0f                	je     f0123702 <free_block+0x22d>
f01236f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01236f6:	8b 40 04             	mov    0x4(%eax),%eax
f01236f9:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01236fc:	8b 12                	mov    (%edx),%edx
f01236fe:	89 10                	mov    %edx,(%eax)
f0123700:	eb 0a                	jmp    f012370c <free_block+0x237>
f0123702:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123705:	8b 00                	mov    (%eax),%eax
f0123707:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f012370c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f012370f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123715:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0123718:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012371f:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0123724:	48                   	dec    %eax
f0123725:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
		LIST_REMOVE(&freeBlocksList,nextBlk);
		// add main block to the freeList because it is free now
		insert_sorted_in_freeList((struct BlockElement *)va);
	}
	else if(isPrevFree == 1 && isNextFree == 1)
	{
f012372a:	eb 24                	jmp    f0123750 <free_block+0x27b>
	}
	else
	{
		// free it without any merge
		// edit its allocation lsb
		set_block_data(va,freeSize,0);
f012372c:	83 ec 04             	sub    $0x4,%esp
f012372f:	6a 00                	push   $0x0
f0123731:	ff 75 f4             	pushl  -0xc(%ebp)
f0123734:	ff 75 08             	pushl  0x8(%ebp)
f0123737:	e8 e6 f4 ff ff       	call   f0122c22 <set_block_data>
f012373c:	83 c4 10             	add    $0x10,%esp
		// add main block to the freeList because it is free now
		insert_sorted_in_freeList((struct BlockElement *)va);
f012373f:	83 ec 0c             	sub    $0xc,%esp
f0123742:	ff 75 08             	pushl  0x8(%ebp)
f0123745:	e8 2f f5 ff ff       	call   f0122c79 <insert_sorted_in_freeList>
f012374a:	83 c4 10             	add    $0x10,%esp
f012374d:	eb 01                	jmp    f0123750 <free_block+0x27b>
	//panic("free_block is not implemented yet");
	//Your Code is Here...

	if(va == NULL)
	{
		return;
f012374f:	90                   	nop
		// edit its allocation lsb
		set_block_data(va,freeSize,0);
		// add main block to the freeList because it is free now
		insert_sorted_in_freeList((struct BlockElement *)va);
	}
}
f0123750:	c9                   	leave  
f0123751:	c3                   	ret    

f0123752 <realloc_block_FF>:
//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f0123752:	55                   	push   %ebp
f0123753:	89 e5                	mov    %esp,%ebp
f0123755:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...

	if(va == NULL && new_size == 0)
f0123758:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012375c:	75 10                	jne    f012376e <realloc_block_FF+0x1c>
f012375e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123762:	75 0a                	jne    f012376e <realloc_block_FF+0x1c>
	{
		return NULL;
f0123764:	b8 00 00 00 00       	mov    $0x0,%eax
f0123769:	e9 8b 04 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
	}

	if(new_size == 0)
f012376e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0123772:	75 18                	jne    f012378c <realloc_block_FF+0x3a>
	{
		free_block(va);
f0123774:	83 ec 0c             	sub    $0xc,%esp
f0123777:	ff 75 08             	pushl  0x8(%ebp)
f012377a:	e8 56 fd ff ff       	call   f01234d5 <free_block>
f012377f:	83 c4 10             	add    $0x10,%esp
		return NULL;
f0123782:	b8 00 00 00 00       	mov    $0x0,%eax
f0123787:	e9 6d 04 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
	}

	if(va == NULL)
f012378c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0123790:	75 13                	jne    f01237a5 <realloc_block_FF+0x53>
	{
		return alloc_block_FF(new_size);
f0123792:	83 ec 0c             	sub    $0xc,%esp
f0123795:	ff 75 0c             	pushl  0xc(%ebp)
f0123798:	e8 6f f6 ff ff       	call   f0122e0c <alloc_block_FF>
f012379d:	83 c4 10             	add    $0x10,%esp
f01237a0:	e9 54 04 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
	}

	// if size is odd must be increment it by one
	if (new_size % 2 != 0)
f01237a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01237a8:	83 e0 01             	and    $0x1,%eax
f01237ab:	85 c0                	test   %eax,%eax
f01237ad:	74 03                	je     f01237b2 <realloc_block_FF+0x60>
	{
		new_size++;
f01237af:	ff 45 0c             	incl   0xc(%ebp)
	}

	// if size < 8 must be equal it to 8 because min size 8 excluding metadata
	if(new_size < 8)
f01237b2:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
f01237b6:	77 07                	ja     f01237bf <realloc_block_FF+0x6d>
	{
		new_size = 8;
f01237b8:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
	}

	new_size += 8; // adds its footer and header size
f01237bf:	83 45 0c 08          	addl   $0x8,0xc(%ebp)

	uint32 actualSize = get_block_size(va);
f01237c3:	83 ec 0c             	sub    $0xc,%esp
f01237c6:	ff 75 08             	pushl  0x8(%ebp)
f01237c9:	e8 d8 f1 ff ff       	call   f01229a6 <get_block_size>
f01237ce:	83 c4 10             	add    $0x10,%esp
f01237d1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(actualSize == new_size)
f01237d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01237d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01237da:	75 08                	jne    f01237e4 <realloc_block_FF+0x92>
	{
		// don't change any thing
		return va;
f01237dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01237df:	e9 15 04 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
	}

	// next block for the block we want to change its size
	struct BlockElement *nextBlk = (struct BlockElement *)((char *)va + actualSize);
f01237e4:	8b 55 08             	mov    0x8(%ebp),%edx
f01237e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01237ea:	01 d0                	add    %edx,%eax
f01237ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 isNextFree = is_free_block(nextBlk);
f01237ef:	83 ec 0c             	sub    $0xc,%esp
f01237f2:	ff 75 f0             	pushl  -0x10(%ebp)
f01237f5:	e8 c5 f1 ff ff       	call   f01229bf <is_free_block>
f01237fa:	83 c4 10             	add    $0x10,%esp
f01237fd:	0f be c0             	movsbl %al,%eax
f0123800:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 nextSize = get_block_size(nextBlk);
f0123803:	83 ec 0c             	sub    $0xc,%esp
f0123806:	ff 75 f0             	pushl  -0x10(%ebp)
f0123809:	e8 98 f1 ff ff       	call   f01229a6 <get_block_size>
f012380e:	83 c4 10             	add    $0x10,%esp
f0123811:	89 45 e8             	mov    %eax,-0x18(%ebp)
	// increase the size of block
	if(new_size > actualSize)
f0123814:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123817:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f012381a:	0f 86 a7 02 00 00    	jbe    f0123ac7 <realloc_block_FF+0x375>
	{
		if(isNextFree)
f0123820:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0123824:	0f 84 86 02 00 00    	je     f0123ab0 <realloc_block_FF+0x35e>
		{
			if(nextSize + actualSize == new_size) // block and nextblock = newSizeBlock
f012382a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f012382d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123830:	01 d0                	add    %edx,%eax
f0123832:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0123835:	0f 85 b2 00 00 00    	jne    f01238ed <realloc_block_FF+0x19b>
			{
				set_block_data(va,new_size,!(is_free_block(va)));// update size in block
f012383b:	83 ec 0c             	sub    $0xc,%esp
f012383e:	ff 75 08             	pushl  0x8(%ebp)
f0123841:	e8 79 f1 ff ff       	call   f01229bf <is_free_block>
f0123846:	83 c4 10             	add    $0x10,%esp
f0123849:	84 c0                	test   %al,%al
f012384b:	0f 94 c0             	sete   %al
f012384e:	0f b6 c0             	movzbl %al,%eax
f0123851:	83 ec 04             	sub    $0x4,%esp
f0123854:	50                   	push   %eax
f0123855:	ff 75 0c             	pushl  0xc(%ebp)
f0123858:	ff 75 08             	pushl  0x8(%ebp)
f012385b:	e8 c2 f3 ff ff       	call   f0122c22 <set_block_data>
f0123860:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&freeBlocksList,nextBlk);// remove next because it is = zero
f0123863:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0123867:	75 17                	jne    f0123880 <realloc_block_FF+0x12e>
f0123869:	83 ec 04             	sub    $0x4,%esp
f012386c:	68 04 3e 13 f0       	push   $0xf0133e04
f0123871:	68 db 01 00 00       	push   $0x1db
f0123876:	68 5b 3d 13 f0       	push   $0xf0133d5b
f012387b:	e8 b9 ca fd ff       	call   f0100339 <_panic>
f0123880:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123883:	8b 00                	mov    (%eax),%eax
f0123885:	85 c0                	test   %eax,%eax
f0123887:	74 10                	je     f0123899 <realloc_block_FF+0x147>
f0123889:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012388c:	8b 00                	mov    (%eax),%eax
f012388e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123891:	8b 52 04             	mov    0x4(%edx),%edx
f0123894:	89 50 04             	mov    %edx,0x4(%eax)
f0123897:	eb 0b                	jmp    f01238a4 <realloc_block_FF+0x152>
f0123899:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012389c:	8b 40 04             	mov    0x4(%eax),%eax
f012389f:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f01238a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01238a7:	8b 40 04             	mov    0x4(%eax),%eax
f01238aa:	85 c0                	test   %eax,%eax
f01238ac:	74 0f                	je     f01238bd <realloc_block_FF+0x16b>
f01238ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01238b1:	8b 40 04             	mov    0x4(%eax),%eax
f01238b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01238b7:	8b 12                	mov    (%edx),%edx
f01238b9:	89 10                	mov    %edx,(%eax)
f01238bb:	eb 0a                	jmp    f01238c7 <realloc_block_FF+0x175>
f01238bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01238c0:	8b 00                	mov    (%eax),%eax
f01238c2:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f01238c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01238ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01238d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01238d3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01238da:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f01238df:	48                   	dec    %eax
f01238e0:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
				return va;
f01238e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01238e8:	e9 0c 03 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
			}
			else if(nextSize + actualSize > new_size) // new size is less than next and main blocks
f01238ed:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01238f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01238f3:	01 d0                	add    %edx,%eax
f01238f5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01238f8:	0f 86 b2 01 00 00    	jbe    f0123ab0 <realloc_block_FF+0x35e>
			{
				uint32 requiredSize = new_size - actualSize; // size that we need from the next block
f01238fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123901:	2b 45 f4             	sub    -0xc(%ebp),%eax
f0123904:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				uint32 remainingNext = nextSize - requiredSize; // size that will remain from the next block after we split it
f0123907:	8b 45 e8             	mov    -0x18(%ebp),%eax
f012390a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f012390d:	89 45 e0             	mov    %eax,-0x20(%ebp)

				// if next size will not fit another block (internal fragmentation)
				if(remainingNext < 16)
f0123910:	83 7d e0 0f          	cmpl   $0xf,-0x20(%ebp)
f0123914:	0f 87 b8 00 00 00    	ja     f01239d2 <realloc_block_FF+0x280>
				{
					// we will take the main size of the block and its next size also
					set_block_data(va,actualSize + nextSize,!(is_free_block(va)));
f012391a:	83 ec 0c             	sub    $0xc,%esp
f012391d:	ff 75 08             	pushl  0x8(%ebp)
f0123920:	e8 9a f0 ff ff       	call   f01229bf <is_free_block>
f0123925:	83 c4 10             	add    $0x10,%esp
f0123928:	84 c0                	test   %al,%al
f012392a:	0f 94 c0             	sete   %al
f012392d:	0f b6 c0             	movzbl %al,%eax
f0123930:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0123933:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0123936:	01 ca                	add    %ecx,%edx
f0123938:	83 ec 04             	sub    $0x4,%esp
f012393b:	50                   	push   %eax
f012393c:	52                   	push   %edx
f012393d:	ff 75 08             	pushl  0x8(%ebp)
f0123940:	e8 dd f2 ff ff       	call   f0122c22 <set_block_data>
f0123945:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&freeBlocksList,nextBlk);
f0123948:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f012394c:	75 17                	jne    f0123965 <realloc_block_FF+0x213>
f012394e:	83 ec 04             	sub    $0x4,%esp
f0123951:	68 04 3e 13 f0       	push   $0xf0133e04
f0123956:	68 e8 01 00 00       	push   $0x1e8
f012395b:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123960:	e8 d4 c9 fd ff       	call   f0100339 <_panic>
f0123965:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123968:	8b 00                	mov    (%eax),%eax
f012396a:	85 c0                	test   %eax,%eax
f012396c:	74 10                	je     f012397e <realloc_block_FF+0x22c>
f012396e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123971:	8b 00                	mov    (%eax),%eax
f0123973:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123976:	8b 52 04             	mov    0x4(%edx),%edx
f0123979:	89 50 04             	mov    %edx,0x4(%eax)
f012397c:	eb 0b                	jmp    f0123989 <realloc_block_FF+0x237>
f012397e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123981:	8b 40 04             	mov    0x4(%eax),%eax
f0123984:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0123989:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012398c:	8b 40 04             	mov    0x4(%eax),%eax
f012398f:	85 c0                	test   %eax,%eax
f0123991:	74 0f                	je     f01239a2 <realloc_block_FF+0x250>
f0123993:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123996:	8b 40 04             	mov    0x4(%eax),%eax
f0123999:	8b 55 f0             	mov    -0x10(%ebp),%edx
f012399c:	8b 12                	mov    (%edx),%edx
f012399e:	89 10                	mov    %edx,(%eax)
f01239a0:	eb 0a                	jmp    f01239ac <realloc_block_FF+0x25a>
f01239a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01239a5:	8b 00                	mov    (%eax),%eax
f01239a7:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f01239ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01239af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01239b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01239b8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01239bf:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f01239c4:	48                   	dec    %eax
f01239c5:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
					return va;
f01239ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01239cd:	e9 27 02 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
				}
				else // if next size can be fit another block (split)
				{
					LIST_REMOVE(&freeBlocksList,nextBlk);
f01239d2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01239d6:	75 17                	jne    f01239ef <realloc_block_FF+0x29d>
f01239d8:	83 ec 04             	sub    $0x4,%esp
f01239db:	68 04 3e 13 f0       	push   $0xf0133e04
f01239e0:	68 ed 01 00 00       	push   $0x1ed
f01239e5:	68 5b 3d 13 f0       	push   $0xf0133d5b
f01239ea:	e8 4a c9 fd ff       	call   f0100339 <_panic>
f01239ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01239f2:	8b 00                	mov    (%eax),%eax
f01239f4:	85 c0                	test   %eax,%eax
f01239f6:	74 10                	je     f0123a08 <realloc_block_FF+0x2b6>
f01239f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01239fb:	8b 00                	mov    (%eax),%eax
f01239fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123a00:	8b 52 04             	mov    0x4(%edx),%edx
f0123a03:	89 50 04             	mov    %edx,0x4(%eax)
f0123a06:	eb 0b                	jmp    f0123a13 <realloc_block_FF+0x2c1>
f0123a08:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a0b:	8b 40 04             	mov    0x4(%eax),%eax
f0123a0e:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0123a13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a16:	8b 40 04             	mov    0x4(%eax),%eax
f0123a19:	85 c0                	test   %eax,%eax
f0123a1b:	74 0f                	je     f0123a2c <realloc_block_FF+0x2da>
f0123a1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a20:	8b 40 04             	mov    0x4(%eax),%eax
f0123a23:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123a26:	8b 12                	mov    (%edx),%edx
f0123a28:	89 10                	mov    %edx,(%eax)
f0123a2a:	eb 0a                	jmp    f0123a36 <realloc_block_FF+0x2e4>
f0123a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a2f:	8b 00                	mov    (%eax),%eax
f0123a31:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0123a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a39:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123a3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123a42:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123a49:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0123a4e:	48                   	dec    %eax
f0123a4f:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
					nextBlk = (struct BlockElement *)((char *)va + new_size); //update nextBlk address
f0123a54:	8b 55 08             	mov    0x8(%ebp),%edx
f0123a57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123a5a:	01 d0                	add    %edx,%eax
f0123a5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
					set_block_data(nextBlk,remainingNext,0); // update nextBlkSize
f0123a5f:	83 ec 04             	sub    $0x4,%esp
f0123a62:	6a 00                	push   $0x0
f0123a64:	ff 75 e0             	pushl  -0x20(%ebp)
f0123a67:	ff 75 f0             	pushl  -0x10(%ebp)
f0123a6a:	e8 b3 f1 ff ff       	call   f0122c22 <set_block_data>
f0123a6f:	83 c4 10             	add    $0x10,%esp
					set_block_data(va,new_size,!(is_free_block(va))); // update size of newblock
f0123a72:	83 ec 0c             	sub    $0xc,%esp
f0123a75:	ff 75 08             	pushl  0x8(%ebp)
f0123a78:	e8 42 ef ff ff       	call   f01229bf <is_free_block>
f0123a7d:	83 c4 10             	add    $0x10,%esp
f0123a80:	84 c0                	test   %al,%al
f0123a82:	0f 94 c0             	sete   %al
f0123a85:	0f b6 c0             	movzbl %al,%eax
f0123a88:	83 ec 04             	sub    $0x4,%esp
f0123a8b:	50                   	push   %eax
f0123a8c:	ff 75 0c             	pushl  0xc(%ebp)
f0123a8f:	ff 75 08             	pushl  0x8(%ebp)
f0123a92:	e8 8b f1 ff ff       	call   f0122c22 <set_block_data>
f0123a97:	83 c4 10             	add    $0x10,%esp
					insert_sorted_in_freeList(nextBlk);
f0123a9a:	83 ec 0c             	sub    $0xc,%esp
f0123a9d:	ff 75 f0             	pushl  -0x10(%ebp)
f0123aa0:	e8 d4 f1 ff ff       	call   f0122c79 <insert_sorted_in_freeList>
f0123aa5:	83 c4 10             	add    $0x10,%esp
					return va;
f0123aa8:	8b 45 08             	mov    0x8(%ebp),%eax
f0123aab:	e9 49 01 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
				}
			}
		}
		// if next block isn't free or not fit the new size
		return alloc_block_FF(new_size - 8);
f0123ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123ab3:	83 e8 08             	sub    $0x8,%eax
f0123ab6:	83 ec 0c             	sub    $0xc,%esp
f0123ab9:	50                   	push   %eax
f0123aba:	e8 4d f3 ff ff       	call   f0122e0c <alloc_block_FF>
f0123abf:	83 c4 10             	add    $0x10,%esp
f0123ac2:	e9 32 01 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
	}
	else if(new_size < actualSize) // to shrink block
f0123ac7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123aca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0123acd:	0f 83 21 01 00 00    	jae    f0123bf4 <realloc_block_FF+0x4a2>
	{
		uint32 remainingSize = actualSize - new_size; // size that will remain from the main block after we shrink it
f0123ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0123ad6:	2b 45 0c             	sub    0xc(%ebp),%eax
f0123ad9:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if(remainingSize < 16 && isNextFree == 0) // internal fragmentation
f0123adc:	83 7d dc 0f          	cmpl   $0xf,-0x24(%ebp)
f0123ae0:	77 0e                	ja     f0123af0 <realloc_block_FF+0x39e>
f0123ae2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0123ae6:	75 08                	jne    f0123af0 <realloc_block_FF+0x39e>
		{
			// don't change its size
			return va;
f0123ae8:	8b 45 08             	mov    0x8(%ebp),%eax
f0123aeb:	e9 09 01 00 00       	jmp    f0123bf9 <realloc_block_FF+0x4a7>
		}
		else // remainingSize fit in a new block
		{
			struct BlockElement *mainBlk = (struct BlockElement *)va;
f0123af0:	8b 45 08             	mov    0x8(%ebp),%eax
f0123af3:	89 45 d8             	mov    %eax,-0x28(%ebp)
			// update main block with new size
			set_block_data(mainBlk,new_size,!(is_free_block(va)));
f0123af6:	83 ec 0c             	sub    $0xc,%esp
f0123af9:	ff 75 08             	pushl  0x8(%ebp)
f0123afc:	e8 be ee ff ff       	call   f01229bf <is_free_block>
f0123b01:	83 c4 10             	add    $0x10,%esp
f0123b04:	84 c0                	test   %al,%al
f0123b06:	0f 94 c0             	sete   %al
f0123b09:	0f b6 c0             	movzbl %al,%eax
f0123b0c:	83 ec 04             	sub    $0x4,%esp
f0123b0f:	50                   	push   %eax
f0123b10:	ff 75 0c             	pushl  0xc(%ebp)
f0123b13:	ff 75 d8             	pushl  -0x28(%ebp)
f0123b16:	e8 07 f1 ff ff       	call   f0122c22 <set_block_data>
f0123b1b:	83 c4 10             	add    $0x10,%esp

			// the blk with remaining size
			struct BlockElement *remainingBlk=(struct BlockElement *)((char*)mainBlk + new_size);
f0123b1e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0123b21:	8b 45 0c             	mov    0xc(%ebp),%eax
f0123b24:	01 d0                	add    %edx,%eax
f0123b26:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			set_block_data(remainingBlk,remainingSize,0);
f0123b29:	83 ec 04             	sub    $0x4,%esp
f0123b2c:	6a 00                	push   $0x0
f0123b2e:	ff 75 dc             	pushl  -0x24(%ebp)
f0123b31:	ff 75 d4             	pushl  -0x2c(%ebp)
f0123b34:	e8 e9 f0 ff ff       	call   f0122c22 <set_block_data>
f0123b39:	83 c4 10             	add    $0x10,%esp

			if(isNextFree)
f0123b3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0123b40:	0f 84 9b 00 00 00    	je     f0123be1 <realloc_block_FF+0x48f>
			{
				// merge splited block with its next block
				set_block_data(remainingBlk,(remainingSize + nextSize),0);//merge remaining with its next block
f0123b46:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0123b49:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0123b4c:	01 d0                	add    %edx,%eax
f0123b4e:	83 ec 04             	sub    $0x4,%esp
f0123b51:	6a 00                	push   $0x0
f0123b53:	50                   	push   %eax
f0123b54:	ff 75 d4             	pushl  -0x2c(%ebp)
f0123b57:	e8 c6 f0 ff ff       	call   f0122c22 <set_block_data>
f0123b5c:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&freeBlocksList,nextBlk);
f0123b5f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0123b63:	75 17                	jne    f0123b7c <realloc_block_FF+0x42a>
f0123b65:	83 ec 04             	sub    $0x4,%esp
f0123b68:	68 04 3e 13 f0       	push   $0xf0133e04
f0123b6d:	68 10 02 00 00       	push   $0x210
f0123b72:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123b77:	e8 bd c7 fd ff       	call   f0100339 <_panic>
f0123b7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123b7f:	8b 00                	mov    (%eax),%eax
f0123b81:	85 c0                	test   %eax,%eax
f0123b83:	74 10                	je     f0123b95 <realloc_block_FF+0x443>
f0123b85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123b88:	8b 00                	mov    (%eax),%eax
f0123b8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123b8d:	8b 52 04             	mov    0x4(%edx),%edx
f0123b90:	89 50 04             	mov    %edx,0x4(%eax)
f0123b93:	eb 0b                	jmp    f0123ba0 <realloc_block_FF+0x44e>
f0123b95:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123b98:	8b 40 04             	mov    0x4(%eax),%eax
f0123b9b:	a3 34 59 74 f0       	mov    %eax,0xf0745934
f0123ba0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123ba3:	8b 40 04             	mov    0x4(%eax),%eax
f0123ba6:	85 c0                	test   %eax,%eax
f0123ba8:	74 0f                	je     f0123bb9 <realloc_block_FF+0x467>
f0123baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123bad:	8b 40 04             	mov    0x4(%eax),%eax
f0123bb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0123bb3:	8b 12                	mov    (%edx),%edx
f0123bb5:	89 10                	mov    %edx,(%eax)
f0123bb7:	eb 0a                	jmp    f0123bc3 <realloc_block_FF+0x471>
f0123bb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123bbc:	8b 00                	mov    (%eax),%eax
f0123bbe:	a3 30 59 74 f0       	mov    %eax,0xf0745930
f0123bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123bc6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0123bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0123bcf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0123bd6:	a1 3c 59 74 f0       	mov    0xf074593c,%eax
f0123bdb:	48                   	dec    %eax
f0123bdc:	a3 3c 59 74 f0       	mov    %eax,0xf074593c
			}
			insert_sorted_in_freeList(remainingBlk);
f0123be1:	83 ec 0c             	sub    $0xc,%esp
f0123be4:	ff 75 d4             	pushl  -0x2c(%ebp)
f0123be7:	e8 8d f0 ff ff       	call   f0122c79 <insert_sorted_in_freeList>
f0123bec:	83 c4 10             	add    $0x10,%esp
			return mainBlk;
f0123bef:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0123bf2:	eb 05                	jmp    f0123bf9 <realloc_block_FF+0x4a7>
		}
	}
	return NULL;
f0123bf4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0123bf9:	c9                   	leave  
f0123bfa:	c3                   	ret    

f0123bfb <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0123bfb:	55                   	push   %ebp
f0123bfc:	89 e5                	mov    %esp,%ebp
f0123bfe:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0123c01:	83 ec 04             	sub    $0x4,%esp
f0123c04:	68 24 3e 13 f0       	push   $0xf0133e24
f0123c09:	68 20 02 00 00       	push   $0x220
f0123c0e:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123c13:	e8 21 c7 fd ff       	call   f0100339 <_panic>

f0123c18 <alloc_block_NF>:
}
//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0123c18:	55                   	push   %ebp
f0123c19:	89 e5                	mov    %esp,%ebp
f0123c1b:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0123c1e:	83 ec 04             	sub    $0x4,%esp
f0123c21:	68 4c 3e 13 f0       	push   $0xf0133e4c
f0123c26:	68 28 02 00 00       	push   $0x228
f0123c2b:	68 5b 3d 13 f0       	push   $0xf0133d5b
f0123c30:	e8 04 c7 fd ff       	call   f0100339 <_panic>
f0123c35:	66 90                	xchg   %ax,%ax
f0123c37:	90                   	nop

f0123c38 <__moddi3>:
f0123c38:	55                   	push   %ebp
f0123c39:	57                   	push   %edi
f0123c3a:	56                   	push   %esi
f0123c3b:	53                   	push   %ebx
f0123c3c:	83 ec 2c             	sub    $0x2c,%esp
f0123c3f:	8b 74 24 40          	mov    0x40(%esp),%esi
f0123c43:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0123c47:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0123c4b:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0123c4f:	89 d8                	mov    %ebx,%eax
f0123c51:	85 ff                	test   %edi,%edi
f0123c53:	0f 88 d3 00 00 00    	js     f0123d2c <__moddi3+0xf4>
f0123c59:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0123c60:	00 
f0123c61:	85 c0                	test   %eax,%eax
f0123c63:	0f 88 ab 00 00 00    	js     f0123d14 <__moddi3+0xdc>
f0123c69:	89 0c 24             	mov    %ecx,(%esp)
f0123c6c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0123c70:	89 74 24 10          	mov    %esi,0x10(%esp)
f0123c74:	89 fb                	mov    %edi,%ebx
f0123c76:	8b 14 24             	mov    (%esp),%edx
f0123c79:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0123c7d:	89 d0                	mov    %edx,%eax
f0123c7f:	89 54 24 18          	mov    %edx,0x18(%esp)
f0123c83:	89 ca                	mov    %ecx,%edx
f0123c85:	8b 0c 24             	mov    (%esp),%ecx
f0123c88:	89 34 24             	mov    %esi,(%esp)
f0123c8b:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0123c8f:	85 d2                	test   %edx,%edx
f0123c91:	75 15                	jne    f0123ca8 <__moddi3+0x70>
f0123c93:	89 c7                	mov    %eax,%edi
f0123c95:	39 d8                	cmp    %ebx,%eax
f0123c97:	76 5b                	jbe    f0123cf4 <__moddi3+0xbc>
f0123c99:	89 f0                	mov    %esi,%eax
f0123c9b:	89 da                	mov    %ebx,%edx
f0123c9d:	f7 f7                	div    %edi
f0123c9f:	89 d3                	mov    %edx,%ebx
f0123ca1:	89 d8                	mov    %ebx,%eax
f0123ca3:	31 d2                	xor    %edx,%edx
f0123ca5:	eb 09                	jmp    f0123cb0 <__moddi3+0x78>
f0123ca7:	90                   	nop
f0123ca8:	39 fa                	cmp    %edi,%edx
f0123caa:	76 1c                	jbe    f0123cc8 <__moddi3+0x90>
f0123cac:	89 f0                	mov    %esi,%eax
f0123cae:	89 fa                	mov    %edi,%edx
f0123cb0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0123cb4:	85 c9                	test   %ecx,%ecx
f0123cb6:	74 07                	je     f0123cbf <__moddi3+0x87>
f0123cb8:	f7 d8                	neg    %eax
f0123cba:	83 d2 00             	adc    $0x0,%edx
f0123cbd:	f7 da                	neg    %edx
f0123cbf:	83 c4 2c             	add    $0x2c,%esp
f0123cc2:	5b                   	pop    %ebx
f0123cc3:	5e                   	pop    %esi
f0123cc4:	5f                   	pop    %edi
f0123cc5:	5d                   	pop    %ebp
f0123cc6:	c3                   	ret    
f0123cc7:	90                   	nop
f0123cc8:	0f bd c2             	bsr    %edx,%eax
f0123ccb:	83 f0 1f             	xor    $0x1f,%eax
f0123cce:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0123cd2:	75 6c                	jne    f0123d40 <__moddi3+0x108>
f0123cd4:	39 fa                	cmp    %edi,%edx
f0123cd6:	72 05                	jb     f0123cdd <__moddi3+0xa5>
f0123cd8:	3b 0c 24             	cmp    (%esp),%ecx
f0123cdb:	77 0e                	ja     f0123ceb <__moddi3+0xb3>
f0123cdd:	8b 34 24             	mov    (%esp),%esi
f0123ce0:	29 ce                	sub    %ecx,%esi
f0123ce2:	19 d3                	sbb    %edx,%ebx
f0123ce4:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0123ce8:	89 34 24             	mov    %esi,(%esp)
f0123ceb:	8b 04 24             	mov    (%esp),%eax
f0123cee:	8b 54 24 14          	mov    0x14(%esp),%edx
f0123cf2:	eb bc                	jmp    f0123cb0 <__moddi3+0x78>
f0123cf4:	85 c9                	test   %ecx,%ecx
f0123cf6:	75 0b                	jne    f0123d03 <__moddi3+0xcb>
f0123cf8:	b8 01 00 00 00       	mov    $0x1,%eax
f0123cfd:	31 d2                	xor    %edx,%edx
f0123cff:	f7 f1                	div    %ecx
f0123d01:	89 c1                	mov    %eax,%ecx
f0123d03:	89 d8                	mov    %ebx,%eax
f0123d05:	31 d2                	xor    %edx,%edx
f0123d07:	f7 f1                	div    %ecx
f0123d09:	8b 04 24             	mov    (%esp),%eax
f0123d0c:	f7 f1                	div    %ecx
f0123d0e:	89 d3                	mov    %edx,%ebx
f0123d10:	eb 8f                	jmp    f0123ca1 <__moddi3+0x69>
f0123d12:	66 90                	xchg   %ax,%ax
f0123d14:	89 c8                	mov    %ecx,%eax
f0123d16:	89 da                	mov    %ebx,%edx
f0123d18:	f7 d8                	neg    %eax
f0123d1a:	83 d2 00             	adc    $0x0,%edx
f0123d1d:	f7 da                	neg    %edx
f0123d1f:	89 04 24             	mov    %eax,(%esp)
f0123d22:	89 54 24 04          	mov    %edx,0x4(%esp)
f0123d26:	e9 45 ff ff ff       	jmp    f0123c70 <__moddi3+0x38>
f0123d2b:	90                   	nop
f0123d2c:	f7 de                	neg    %esi
f0123d2e:	83 d7 00             	adc    $0x0,%edi
f0123d31:	f7 df                	neg    %edi
f0123d33:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0123d3a:	ff 
f0123d3b:	e9 21 ff ff ff       	jmp    f0123c61 <__moddi3+0x29>
f0123d40:	b8 20 00 00 00       	mov    $0x20,%eax
f0123d45:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0123d49:	29 f8                	sub    %edi,%eax
f0123d4b:	89 c6                	mov    %eax,%esi
f0123d4d:	89 44 24 14          	mov    %eax,0x14(%esp)
f0123d51:	89 f9                	mov    %edi,%ecx
f0123d53:	d3 e2                	shl    %cl,%edx
f0123d55:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0123d59:	89 e8                	mov    %ebp,%eax
f0123d5b:	89 f1                	mov    %esi,%ecx
f0123d5d:	d3 e8                	shr    %cl,%eax
f0123d5f:	09 d0                	or     %edx,%eax
f0123d61:	89 04 24             	mov    %eax,(%esp)
f0123d64:	89 ea                	mov    %ebp,%edx
f0123d66:	89 f9                	mov    %edi,%ecx
f0123d68:	d3 e2                	shl    %cl,%edx
f0123d6a:	89 d7                	mov    %edx,%edi
f0123d6c:	89 da                	mov    %ebx,%edx
f0123d6e:	d3 e2                	shl    %cl,%edx
f0123d70:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0123d74:	d3 e5                	shl    %cl,%ebp
f0123d76:	8b 44 24 10          	mov    0x10(%esp),%eax
f0123d7a:	89 f1                	mov    %esi,%ecx
f0123d7c:	d3 e8                	shr    %cl,%eax
f0123d7e:	09 d0                	or     %edx,%eax
f0123d80:	d3 eb                	shr    %cl,%ebx
f0123d82:	89 da                	mov    %ebx,%edx
f0123d84:	f7 34 24             	divl   (%esp)
f0123d87:	89 d3                	mov    %edx,%ebx
f0123d89:	f7 e7                	mul    %edi
f0123d8b:	89 c6                	mov    %eax,%esi
f0123d8d:	89 d1                	mov    %edx,%ecx
f0123d8f:	39 d3                	cmp    %edx,%ebx
f0123d91:	72 29                	jb     f0123dbc <__moddi3+0x184>
f0123d93:	74 33                	je     f0123dc8 <__moddi3+0x190>
f0123d95:	89 e8                	mov    %ebp,%eax
f0123d97:	29 f0                	sub    %esi,%eax
f0123d99:	19 cb                	sbb    %ecx,%ebx
f0123d9b:	89 de                	mov    %ebx,%esi
f0123d9d:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0123da1:	d3 e6                	shl    %cl,%esi
f0123da3:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0123da7:	89 f9                	mov    %edi,%ecx
f0123da9:	d3 e8                	shr    %cl,%eax
f0123dab:	09 c6                	or     %eax,%esi
f0123dad:	89 f0                	mov    %esi,%eax
f0123daf:	89 f9                	mov    %edi,%ecx
f0123db1:	d3 eb                	shr    %cl,%ebx
f0123db3:	89 da                	mov    %ebx,%edx
f0123db5:	e9 f6 fe ff ff       	jmp    f0123cb0 <__moddi3+0x78>
f0123dba:	66 90                	xchg   %ax,%ax
f0123dbc:	29 f8                	sub    %edi,%eax
f0123dbe:	1b 14 24             	sbb    (%esp),%edx
f0123dc1:	89 d1                	mov    %edx,%ecx
f0123dc3:	89 c6                	mov    %eax,%esi
f0123dc5:	eb ce                	jmp    f0123d95 <__moddi3+0x15d>
f0123dc7:	90                   	nop
f0123dc8:	39 c5                	cmp    %eax,%ebp
f0123dca:	72 f0                	jb     f0123dbc <__moddi3+0x184>
f0123dcc:	89 d9                	mov    %ebx,%ecx
f0123dce:	eb c5                	jmp    f0123d95 <__moddi3+0x15d>

f0123dd0 <__udivdi3>:
f0123dd0:	55                   	push   %ebp
f0123dd1:	57                   	push   %edi
f0123dd2:	56                   	push   %esi
f0123dd3:	53                   	push   %ebx
f0123dd4:	83 ec 1c             	sub    $0x1c,%esp
f0123dd7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0123ddb:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0123ddf:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0123de3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0123de7:	89 ca                	mov    %ecx,%edx
f0123de9:	89 f8                	mov    %edi,%eax
f0123deb:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0123def:	85 f6                	test   %esi,%esi
f0123df1:	75 2d                	jne    f0123e20 <__udivdi3+0x50>
f0123df3:	39 cf                	cmp    %ecx,%edi
f0123df5:	77 65                	ja     f0123e5c <__udivdi3+0x8c>
f0123df7:	89 fd                	mov    %edi,%ebp
f0123df9:	85 ff                	test   %edi,%edi
f0123dfb:	75 0b                	jne    f0123e08 <__udivdi3+0x38>
f0123dfd:	b8 01 00 00 00       	mov    $0x1,%eax
f0123e02:	31 d2                	xor    %edx,%edx
f0123e04:	f7 f7                	div    %edi
f0123e06:	89 c5                	mov    %eax,%ebp
f0123e08:	31 d2                	xor    %edx,%edx
f0123e0a:	89 c8                	mov    %ecx,%eax
f0123e0c:	f7 f5                	div    %ebp
f0123e0e:	89 c1                	mov    %eax,%ecx
f0123e10:	89 d8                	mov    %ebx,%eax
f0123e12:	f7 f5                	div    %ebp
f0123e14:	89 cf                	mov    %ecx,%edi
f0123e16:	89 fa                	mov    %edi,%edx
f0123e18:	83 c4 1c             	add    $0x1c,%esp
f0123e1b:	5b                   	pop    %ebx
f0123e1c:	5e                   	pop    %esi
f0123e1d:	5f                   	pop    %edi
f0123e1e:	5d                   	pop    %ebp
f0123e1f:	c3                   	ret    
f0123e20:	39 ce                	cmp    %ecx,%esi
f0123e22:	77 28                	ja     f0123e4c <__udivdi3+0x7c>
f0123e24:	0f bd fe             	bsr    %esi,%edi
f0123e27:	83 f7 1f             	xor    $0x1f,%edi
f0123e2a:	75 40                	jne    f0123e6c <__udivdi3+0x9c>
f0123e2c:	39 ce                	cmp    %ecx,%esi
f0123e2e:	72 0a                	jb     f0123e3a <__udivdi3+0x6a>
f0123e30:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0123e34:	0f 87 9e 00 00 00    	ja     f0123ed8 <__udivdi3+0x108>
f0123e3a:	b8 01 00 00 00       	mov    $0x1,%eax
f0123e3f:	89 fa                	mov    %edi,%edx
f0123e41:	83 c4 1c             	add    $0x1c,%esp
f0123e44:	5b                   	pop    %ebx
f0123e45:	5e                   	pop    %esi
f0123e46:	5f                   	pop    %edi
f0123e47:	5d                   	pop    %ebp
f0123e48:	c3                   	ret    
f0123e49:	8d 76 00             	lea    0x0(%esi),%esi
f0123e4c:	31 ff                	xor    %edi,%edi
f0123e4e:	31 c0                	xor    %eax,%eax
f0123e50:	89 fa                	mov    %edi,%edx
f0123e52:	83 c4 1c             	add    $0x1c,%esp
f0123e55:	5b                   	pop    %ebx
f0123e56:	5e                   	pop    %esi
f0123e57:	5f                   	pop    %edi
f0123e58:	5d                   	pop    %ebp
f0123e59:	c3                   	ret    
f0123e5a:	66 90                	xchg   %ax,%ax
f0123e5c:	89 d8                	mov    %ebx,%eax
f0123e5e:	f7 f7                	div    %edi
f0123e60:	31 ff                	xor    %edi,%edi
f0123e62:	89 fa                	mov    %edi,%edx
f0123e64:	83 c4 1c             	add    $0x1c,%esp
f0123e67:	5b                   	pop    %ebx
f0123e68:	5e                   	pop    %esi
f0123e69:	5f                   	pop    %edi
f0123e6a:	5d                   	pop    %ebp
f0123e6b:	c3                   	ret    
f0123e6c:	bd 20 00 00 00       	mov    $0x20,%ebp
f0123e71:	89 eb                	mov    %ebp,%ebx
f0123e73:	29 fb                	sub    %edi,%ebx
f0123e75:	89 f9                	mov    %edi,%ecx
f0123e77:	d3 e6                	shl    %cl,%esi
f0123e79:	89 c5                	mov    %eax,%ebp
f0123e7b:	88 d9                	mov    %bl,%cl
f0123e7d:	d3 ed                	shr    %cl,%ebp
f0123e7f:	89 e9                	mov    %ebp,%ecx
f0123e81:	09 f1                	or     %esi,%ecx
f0123e83:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0123e87:	89 f9                	mov    %edi,%ecx
f0123e89:	d3 e0                	shl    %cl,%eax
f0123e8b:	89 c5                	mov    %eax,%ebp
f0123e8d:	89 d6                	mov    %edx,%esi
f0123e8f:	88 d9                	mov    %bl,%cl
f0123e91:	d3 ee                	shr    %cl,%esi
f0123e93:	89 f9                	mov    %edi,%ecx
f0123e95:	d3 e2                	shl    %cl,%edx
f0123e97:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123e9b:	88 d9                	mov    %bl,%cl
f0123e9d:	d3 e8                	shr    %cl,%eax
f0123e9f:	09 c2                	or     %eax,%edx
f0123ea1:	89 d0                	mov    %edx,%eax
f0123ea3:	89 f2                	mov    %esi,%edx
f0123ea5:	f7 74 24 0c          	divl   0xc(%esp)
f0123ea9:	89 d6                	mov    %edx,%esi
f0123eab:	89 c3                	mov    %eax,%ebx
f0123ead:	f7 e5                	mul    %ebp
f0123eaf:	39 d6                	cmp    %edx,%esi
f0123eb1:	72 19                	jb     f0123ecc <__udivdi3+0xfc>
f0123eb3:	74 0b                	je     f0123ec0 <__udivdi3+0xf0>
f0123eb5:	89 d8                	mov    %ebx,%eax
f0123eb7:	31 ff                	xor    %edi,%edi
f0123eb9:	e9 58 ff ff ff       	jmp    f0123e16 <__udivdi3+0x46>
f0123ebe:	66 90                	xchg   %ax,%ax
f0123ec0:	8b 54 24 08          	mov    0x8(%esp),%edx
f0123ec4:	89 f9                	mov    %edi,%ecx
f0123ec6:	d3 e2                	shl    %cl,%edx
f0123ec8:	39 c2                	cmp    %eax,%edx
f0123eca:	73 e9                	jae    f0123eb5 <__udivdi3+0xe5>
f0123ecc:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0123ecf:	31 ff                	xor    %edi,%edi
f0123ed1:	e9 40 ff ff ff       	jmp    f0123e16 <__udivdi3+0x46>
f0123ed6:	66 90                	xchg   %ax,%ax
f0123ed8:	31 c0                	xor    %eax,%eax
f0123eda:	e9 37 ff ff ff       	jmp    f0123e16 <__udivdi3+0x46>
f0123edf:	90                   	nop

f0123ee0 <__umoddi3>:
f0123ee0:	55                   	push   %ebp
f0123ee1:	57                   	push   %edi
f0123ee2:	56                   	push   %esi
f0123ee3:	53                   	push   %ebx
f0123ee4:	83 ec 1c             	sub    $0x1c,%esp
f0123ee7:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0123eeb:	8b 74 24 34          	mov    0x34(%esp),%esi
f0123eef:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0123ef3:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0123ef7:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0123efb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0123eff:	89 f3                	mov    %esi,%ebx
f0123f01:	89 fa                	mov    %edi,%edx
f0123f03:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0123f07:	89 34 24             	mov    %esi,(%esp)
f0123f0a:	85 c0                	test   %eax,%eax
f0123f0c:	75 1a                	jne    f0123f28 <__umoddi3+0x48>
f0123f0e:	39 f7                	cmp    %esi,%edi
f0123f10:	0f 86 a2 00 00 00    	jbe    f0123fb8 <__umoddi3+0xd8>
f0123f16:	89 c8                	mov    %ecx,%eax
f0123f18:	89 f2                	mov    %esi,%edx
f0123f1a:	f7 f7                	div    %edi
f0123f1c:	89 d0                	mov    %edx,%eax
f0123f1e:	31 d2                	xor    %edx,%edx
f0123f20:	83 c4 1c             	add    $0x1c,%esp
f0123f23:	5b                   	pop    %ebx
f0123f24:	5e                   	pop    %esi
f0123f25:	5f                   	pop    %edi
f0123f26:	5d                   	pop    %ebp
f0123f27:	c3                   	ret    
f0123f28:	39 f0                	cmp    %esi,%eax
f0123f2a:	0f 87 ac 00 00 00    	ja     f0123fdc <__umoddi3+0xfc>
f0123f30:	0f bd e8             	bsr    %eax,%ebp
f0123f33:	83 f5 1f             	xor    $0x1f,%ebp
f0123f36:	0f 84 ac 00 00 00    	je     f0123fe8 <__umoddi3+0x108>
f0123f3c:	bf 20 00 00 00       	mov    $0x20,%edi
f0123f41:	29 ef                	sub    %ebp,%edi
f0123f43:	89 fe                	mov    %edi,%esi
f0123f45:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0123f49:	89 e9                	mov    %ebp,%ecx
f0123f4b:	d3 e0                	shl    %cl,%eax
f0123f4d:	89 d7                	mov    %edx,%edi
f0123f4f:	89 f1                	mov    %esi,%ecx
f0123f51:	d3 ef                	shr    %cl,%edi
f0123f53:	09 c7                	or     %eax,%edi
f0123f55:	89 e9                	mov    %ebp,%ecx
f0123f57:	d3 e2                	shl    %cl,%edx
f0123f59:	89 14 24             	mov    %edx,(%esp)
f0123f5c:	89 d8                	mov    %ebx,%eax
f0123f5e:	d3 e0                	shl    %cl,%eax
f0123f60:	89 c2                	mov    %eax,%edx
f0123f62:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123f66:	d3 e0                	shl    %cl,%eax
f0123f68:	89 44 24 04          	mov    %eax,0x4(%esp)
f0123f6c:	8b 44 24 08          	mov    0x8(%esp),%eax
f0123f70:	89 f1                	mov    %esi,%ecx
f0123f72:	d3 e8                	shr    %cl,%eax
f0123f74:	09 d0                	or     %edx,%eax
f0123f76:	d3 eb                	shr    %cl,%ebx
f0123f78:	89 da                	mov    %ebx,%edx
f0123f7a:	f7 f7                	div    %edi
f0123f7c:	89 d3                	mov    %edx,%ebx
f0123f7e:	f7 24 24             	mull   (%esp)
f0123f81:	89 c6                	mov    %eax,%esi
f0123f83:	89 d1                	mov    %edx,%ecx
f0123f85:	39 d3                	cmp    %edx,%ebx
f0123f87:	0f 82 87 00 00 00    	jb     f0124014 <__umoddi3+0x134>
f0123f8d:	0f 84 91 00 00 00    	je     f0124024 <__umoddi3+0x144>
f0123f93:	8b 54 24 04          	mov    0x4(%esp),%edx
f0123f97:	29 f2                	sub    %esi,%edx
f0123f99:	19 cb                	sbb    %ecx,%ebx
f0123f9b:	89 d8                	mov    %ebx,%eax
f0123f9d:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0123fa1:	d3 e0                	shl    %cl,%eax
f0123fa3:	89 e9                	mov    %ebp,%ecx
f0123fa5:	d3 ea                	shr    %cl,%edx
f0123fa7:	09 d0                	or     %edx,%eax
f0123fa9:	89 e9                	mov    %ebp,%ecx
f0123fab:	d3 eb                	shr    %cl,%ebx
f0123fad:	89 da                	mov    %ebx,%edx
f0123faf:	83 c4 1c             	add    $0x1c,%esp
f0123fb2:	5b                   	pop    %ebx
f0123fb3:	5e                   	pop    %esi
f0123fb4:	5f                   	pop    %edi
f0123fb5:	5d                   	pop    %ebp
f0123fb6:	c3                   	ret    
f0123fb7:	90                   	nop
f0123fb8:	89 fd                	mov    %edi,%ebp
f0123fba:	85 ff                	test   %edi,%edi
f0123fbc:	75 0b                	jne    f0123fc9 <__umoddi3+0xe9>
f0123fbe:	b8 01 00 00 00       	mov    $0x1,%eax
f0123fc3:	31 d2                	xor    %edx,%edx
f0123fc5:	f7 f7                	div    %edi
f0123fc7:	89 c5                	mov    %eax,%ebp
f0123fc9:	89 f0                	mov    %esi,%eax
f0123fcb:	31 d2                	xor    %edx,%edx
f0123fcd:	f7 f5                	div    %ebp
f0123fcf:	89 c8                	mov    %ecx,%eax
f0123fd1:	f7 f5                	div    %ebp
f0123fd3:	89 d0                	mov    %edx,%eax
f0123fd5:	e9 44 ff ff ff       	jmp    f0123f1e <__umoddi3+0x3e>
f0123fda:	66 90                	xchg   %ax,%ax
f0123fdc:	89 c8                	mov    %ecx,%eax
f0123fde:	89 f2                	mov    %esi,%edx
f0123fe0:	83 c4 1c             	add    $0x1c,%esp
f0123fe3:	5b                   	pop    %ebx
f0123fe4:	5e                   	pop    %esi
f0123fe5:	5f                   	pop    %edi
f0123fe6:	5d                   	pop    %ebp
f0123fe7:	c3                   	ret    
f0123fe8:	3b 04 24             	cmp    (%esp),%eax
f0123feb:	72 06                	jb     f0123ff3 <__umoddi3+0x113>
f0123fed:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0123ff1:	77 0f                	ja     f0124002 <__umoddi3+0x122>
f0123ff3:	89 f2                	mov    %esi,%edx
f0123ff5:	29 f9                	sub    %edi,%ecx
f0123ff7:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0123ffb:	89 14 24             	mov    %edx,(%esp)
f0123ffe:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0124002:	8b 44 24 04          	mov    0x4(%esp),%eax
f0124006:	8b 14 24             	mov    (%esp),%edx
f0124009:	83 c4 1c             	add    $0x1c,%esp
f012400c:	5b                   	pop    %ebx
f012400d:	5e                   	pop    %esi
f012400e:	5f                   	pop    %edi
f012400f:	5d                   	pop    %ebp
f0124010:	c3                   	ret    
f0124011:	8d 76 00             	lea    0x0(%esi),%esi
f0124014:	2b 04 24             	sub    (%esp),%eax
f0124017:	19 fa                	sbb    %edi,%edx
f0124019:	89 d1                	mov    %edx,%ecx
f012401b:	89 c6                	mov    %eax,%esi
f012401d:	e9 71 ff ff ff       	jmp    f0123f93 <__umoddi3+0xb3>
f0124022:	66 90                	xchg   %ax,%ax
f0124024:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0124028:	72 ea                	jb     f0124014 <__umoddi3+0x134>
f012402a:	89 d9                	mov    %ebx,%ecx
f012402c:	e9 62 ff ff ff       	jmp    f0123f93 <__umoddi3+0xb3>
